From 694ee5d446ee51f4930fb1f3c3374e11de6972f3 Mon Sep 17 00:00:00 2001
From: Arjan van de Ven <arjan@linux.intel.com>
Date: Sat, 9 Apr 2016 22:41:37 +0000
Subject: [PATCH 112/124] fs: ext4: fsync: optimize double-fsync() a bunch

There are cases where EXT4 is a bit too conservative sending barriers down to the disk;
there are cases where the transaction in progress is not the one that sent the barrier
(in other words: the fsync is for a file for which the IO happened more time ago
and all data was already sent to the disk). For that case, a more performing tradeoff
can be made on SSD devices (which have the ability to flush their dram caches in a hurry
on a power fail event) where the barrier gets sent to the disk, but we don't need to wait
for the barrier to complete. Any consecutive IO will block on the barrier correctly.
---
 block/bio.c            | 20 ++++++++++++++++++++
 block/blk-flush.c      | 41 +++++++++++++++++++++++++++++++++++++++++
 fs/ext4/fsync.c        |  6 +++++-
 include/linux/bio.h    |  1 +
 include/linux/blkdev.h |  5 +++++
 5 files changed, 72 insertions(+), 1 deletion(-)

diff --git a/block/bio.c b/block/bio.c
index db85c5753a76..80f5ab6b536a 100644
--- a/block/bio.c
+++ b/block/bio.c
@@ -882,6 +882,26 @@ int submit_bio_wait(struct bio *bio)
 }
 EXPORT_SYMBOL(submit_bio_wait);
 
+static void submit_bio_nowait_endio(struct bio *bio)
+{
+	bio_put(bio);
+}
+
+/**
+ * submit_bio_nowait - submit a bio for fire-and-forget
+ * @rw: whether to %READ or %WRITE, or maybe to %READA (read ahead)
+ * @bio: The &struct bio which describes the I/O
+ *
+ * Simple wrapper around submit_bio() that takes care of bio_put() on completion
+ */
+void submit_bio_nowait(struct bio *bio)
+{
+	bio->bi_end_io = submit_bio_nowait_endio;
+	bio->bi_opf |= REQ_SYNC;
+	submit_bio(bio);
+}
+EXPORT_SYMBOL(submit_bio_nowait);
+
 /**
  * bio_advance - increment/complete a bio by some number of bytes
  * @bio:	bio to advance
diff --git a/block/blk-flush.c b/block/blk-flush.c
index 3c882cbc7541..b2dfcfe01ed7 100644
--- a/block/blk-flush.c
+++ b/block/blk-flush.c
@@ -530,6 +530,47 @@ int blkdev_issue_flush(struct block_device *bdev, gfp_t gfp_mask,
 }
 EXPORT_SYMBOL(blkdev_issue_flush);
 
+/**
+ * blkdev_issue_flush_nowait - queue a flush
+ * @bdev:	blockdev to issue flush for
+ * @gfp_mask:	memory allocation flags (for bio_alloc)
+ * @error_sector:	error sector
+ *
+ * Description:
+ *    Issue a flush for the block device in question. Caller can supply
+ *    room for storing the error offset in case of a flush error, if they
+ *    wish to. If WAIT flag is not passed then caller may check only what
+ *    request was pushed in some internal queue for later handling.
+ */
+void blkdev_issue_flush_nowait(struct block_device *bdev, gfp_t gfp_mask)
+{
+	struct request_queue *q;
+	struct bio *bio;
+
+	if (bdev->bd_disk == NULL)
+		return;
+
+	q = bdev_get_queue(bdev);
+	if (!q)
+		return;
+
+	/*
+	 * some block devices may not have their queue correctly set up here
+	 * (e.g. loop device without a backing file) and so issuing a flush
+	 * here will panic. Ensure there is a request function before issuing
+	 * the flush.
+	 */
+	if (!q->make_request_fn)
+		return;
+
+	bio = bio_alloc(gfp_mask, 0);
+	bio->bi_bdev = bdev;
+	bio_set_op_attrs(bio, REQ_OP_WRITE, WRITE_FLUSH);
+
+	submit_bio_nowait(bio);
+}
+EXPORT_SYMBOL(blkdev_issue_flush_nowait);
+
 struct blk_flush_queue *blk_alloc_flush_queue(struct request_queue *q,
 		int node, int cmd_size)
 {
diff --git a/fs/ext4/fsync.c b/fs/ext4/fsync.c
index 88effb1053c7..a58966c18172 100644
--- a/fs/ext4/fsync.c
+++ b/fs/ext4/fsync.c
@@ -150,7 +150,11 @@ int ext4_sync_file(struct file *file, loff_t start, loff_t end, int datasync)
 	ret = jbd2_complete_transaction(journal, commit_tid);
 	if (needs_barrier) {
 	issue_flush:
-		err = blkdev_issue_flush(inode->i_sb->s_bdev, GFP_KERNEL, NULL);
+		err = 0;
+		if (!blk_queue_nonrot(bdev_get_queue(inode->i_sb->s_bdev)))
+			err = blkdev_issue_flush(inode->i_sb->s_bdev, GFP_KERNEL, NULL);
+		else
+			blkdev_issue_flush_nowait(inode->i_sb->s_bdev, GFP_KERNEL);
 		if (!ret)
 			ret = err;
 	}
diff --git a/include/linux/bio.h b/include/linux/bio.h
index 97cb48f03dc7..3f055e6541e0 100644
--- a/include/linux/bio.h
+++ b/include/linux/bio.h
@@ -421,6 +421,7 @@ struct request_queue;
 extern int bio_phys_segments(struct request_queue *, struct bio *);
 
 extern int submit_bio_wait(struct bio *bio);
+extern void submit_bio_nowait(struct bio *bio);
 extern void bio_advance(struct bio *, unsigned);
 
 extern void bio_init(struct bio *);
diff --git a/include/linux/blkdev.h b/include/linux/blkdev.h
index f6a816129856..727684abf21e 100644
--- a/include/linux/blkdev.h
+++ b/include/linux/blkdev.h
@@ -1144,6 +1144,7 @@ static inline struct request *blk_map_queue_find_tag(struct blk_queue_tag *bqt,
 #define BLKDEV_DISCARD_ZERO	(1 << 1)	/* must reliably zero data */
 
 extern int blkdev_issue_flush(struct block_device *, gfp_t, sector_t *);
+extern void blkdev_issue_flush_nowait(struct block_device *, gfp_t);
 extern int blkdev_issue_discard(struct block_device *bdev, sector_t sector,
 		sector_t nr_sects, gfp_t gfp_mask, unsigned long flags);
 extern int __blkdev_issue_discard(struct block_device *bdev, sector_t sector,
@@ -1745,6 +1746,10 @@ static inline int blkdev_issue_flush(struct block_device *bdev, gfp_t gfp_mask,
 	return 0;
 }
 
+static inline void blkdev_issue_flush_nowait(struct block_device *bdev, gfp_t gfp_mask)
+{
+}
+
 #endif /* CONFIG_BLOCK */
 
 #endif
-- 
2.11.0

