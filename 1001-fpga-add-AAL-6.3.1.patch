From 99bac4203cde03a490bec34cf7271feeef8741cc Mon Sep 17 00:00:00 2001
From: Miguel Bernal Marin <miguel.bernal.marin@linux.intel.com>
Date: Tue, 28 Mar 2017 17:15:42 -0600
Subject: [PATCH 1001/1002] fpga: add AAL 6.3.1

Signed-off-by: Miguel Bernal Marin <miguel.bernal.marin@linux.intel.com>
---
 drivers/fpga/aal/Kconfig                           |   47 +
 drivers/fpga/aal/Makefile                          |    6 +
 drivers/fpga/aal/bus/Makefile                      |   21 +
 drivers/fpga/aal/bus/aalbus-device.c               |  803 ++++++
 drivers/fpga/aal/bus/aalbus-int.h                  |  148 ++
 drivers/fpga/aal/bus/aalbus-main.c                 | 2287 +++++++++++++++++
 drivers/fpga/aal/bus/kOSAL.c                       |  692 +++++
 drivers/fpga/aal/cci/Makefile                      |   40 +
 drivers/fpga/aal/cci/cci_pcie_common.c             |  582 +++++
 drivers/fpga/aal/cci/cci_pcie_driver_PIPsession.c  |  286 +++
 drivers/fpga/aal/cci/cci_pcie_driver_PIPsession.h  |  110 +
 drivers/fpga/aal/cci/cci_pcie_driver_internal.h    |  404 +++
 drivers/fpga/aal/cci/cci_pcie_driver_main_linux.c  | 1474 +++++++++++
 drivers/fpga/aal/cci/cci_pcie_driver_simulator.c   |  423 ++++
 drivers/fpga/aal/cci/cci_pcie_driver_simulator.h   |  102 +
 drivers/fpga/aal/cci/cci_pcie_driver_umapi.h       |  140 ++
 .../fpga/aal/cci/cci_pcie_driver_umapi_common.c    | 1138 +++++++++
 drivers/fpga/aal/cci/cci_pcie_driver_umapi_linux.c |  605 +++++
 drivers/fpga/aal/cci/cci_pcie_driver_umapi_linux.h |  105 +
 drivers/fpga/aal/cci/ccip_afu.c                    |  698 ++++++
 drivers/fpga/aal/cci/ccip_fme.c                    |  890 +++++++
 drivers/fpga/aal/cci/ccip_fme.h                    |  251 ++
 drivers/fpga/aal/cci/ccip_fme_mmap_linux.c         |  307 +++
 drivers/fpga/aal/cci/ccip_logging.c                | 1173 +++++++++
 drivers/fpga/aal/cci/ccip_logging.h                |  357 +++
 drivers/fpga/aal/cci/ccip_logging_linux.c          |  181 ++
 drivers/fpga/aal/cci/ccip_logging_linux.h          |   94 +
 drivers/fpga/aal/cci/ccip_perfmon.c                |  625 +++++
 drivers/fpga/aal/cci/ccip_perfmon.h                |  161 ++
 drivers/fpga/aal/cci/ccip_perfmon_linux.c          |  294 +++
 drivers/fpga/aal/cci/ccip_perfmon_linux.h          |   95 +
 drivers/fpga/aal/cci/ccip_port.c                   | 1022 ++++++++
 drivers/fpga/aal/cci/ccip_port.h                   |  218 ++
 drivers/fpga/aal/cci/ccip_pr.c                     | 2639 ++++++++++++++++++++
 drivers/fpga/aal/cci/ccip_pr.h                     |  309 +++
 drivers/fpga/aal/cci/ccip_pwr.c                    |  445 ++++
 drivers/fpga/aal/cci/ccip_pwr.h                    |   92 +
 drivers/fpga/aal/cci/ccip_sim_mmio.c               | 1420 +++++++++++
 drivers/fpga/aal/cci/ccip_stap.c                   |  347 +++
 drivers/fpga/aal/cci/ccipdrv-events.h              |  702 ++++++
 drivers/fpga/aal/cci/kOSAL.c                       |  692 +++++
 .../aal/include/aalsdk/kernel/AALTransactionID_s.h |  115 +
 .../fpga/aal/include/aalsdk/kernel/AALWorkspace.h  |  120 +
 .../fpga/aal/include/aalsdk/kernel/KernelStructs.h |  166 ++
 .../fpga/aal/include/aalsdk/kernel/aalbus-device.h |  419 ++++
 .../fpga/aal/include/aalsdk/kernel/aalbus-ipip.h   |  181 ++
 drivers/fpga/aal/include/aalsdk/kernel/aalbus.h    |  832 ++++++
 .../fpga/aal/include/aalsdk/kernel/aalbus_Defs.h   |  134 +
 .../include/aalsdk/kernel/aalbus_iconfigmonitor.h  |  141 ++
 .../include/aalsdk/kernel/aalbus_iupdate_config.h  |  260 ++
 drivers/fpga/aal/include/aalsdk/kernel/aaldefs.h   |  915 +++++++
 drivers/fpga/aal/include/aalsdk/kernel/aaldevice.h |  352 +++
 drivers/fpga/aal/include/aalsdk/kernel/aalids.h    |  169 ++
 .../fpga/aal/include/aalsdk/kernel/aalinterface.h  |  212 ++
 .../aal/include/aalsdk/kernel/aalmafu-events.h     |  286 +++
 drivers/fpga/aal/include/aalsdk/kernel/aalmafu.h   |  194 ++
 drivers/fpga/aal/include/aalsdk/kernel/aalqueue.h  |  429 ++++
 .../aal/include/aalsdk/kernel/aalrm-services.h     |  100 +
 drivers/fpga/aal/include/aalsdk/kernel/aalrm.h     |  215 ++
 .../fpga/aal/include/aalsdk/kernel/aalrm_client.h  |  158 ++
 .../include/aalsdk/kernel/aalrm_server-services.h  |  193 ++
 .../fpga/aal/include/aalsdk/kernel/aalrm_server.h  |  224 ++
 drivers/fpga/aal/include/aalsdk/kernel/aaltypes.h  |  675 +++++
 .../fpga/aal/include/aalsdk/kernel/aalui-events.h  |  671 +++++
 drivers/fpga/aal/include/aalsdk/kernel/aalui.h     |  475 ++++
 .../fpga/aal/include/aalsdk/kernel/aalwsservice.h  |  236 ++
 drivers/fpga/aal/include/aalsdk/kernel/ahmpip.h    |  844 +++++++
 .../fpga/aal/include/aalsdk/kernel/ahmpipdefs.h    |  634 +++++
 drivers/fpga/aal/include/aalsdk/kernel/ccidefs.h   |  165 ++
 drivers/fpga/aal/include/aalsdk/kernel/ccip_defs.h | 1738 +++++++++++++
 .../fpga/aal/include/aalsdk/kernel/ccipdriver.h    |  632 +++++
 drivers/fpga/aal/include/aalsdk/kernel/fappip.h    |  231 ++
 .../fpga/aal/include/aalsdk/kernel/iaaldevice.h    |  444 ++++
 drivers/fpga/aal/include/aalsdk/kernel/kosal.h     | 1079 ++++++++
 drivers/fpga/aal/include/aalsdk/kernel/spl2defs.h  |  303 +++
 drivers/fpga/aal/include/aalsdk/kernel/vafu2defs.h |  180 ++
 drivers/fpga/aal/rmc/Makefile                      |   22 +
 drivers/fpga/aal/rmc/aalrm-events-int.h            |  241 ++
 drivers/fpga/aal/rmc/aalrm-file.c                  |  241 ++
 drivers/fpga/aal/rmc/aalrm-int.h                   |  211 ++
 drivers/fpga/aal/rmc/aalrm-ioctl.c                 |  769 ++++++
 drivers/fpga/aal/rmc/aalrm-main.c                  |  611 +++++
 drivers/fpga/aal/rmc/kOSAL.c                       |  692 +++++
 drivers/fpga/aal/rms/Makefile                      |   23 +
 drivers/fpga/aal/rms/aalrm_server-file.c           |  212 ++
 drivers/fpga/aal/rms/aalrm_server-int.h            |  753 ++++++
 drivers/fpga/aal/rms/aalrm_server-ioctl.c          |  900 +++++++
 drivers/fpga/aal/rms/aalrm_server-main.c           |  709 ++++++
 drivers/fpga/aal/rms/aalrm_server-services.c       |  254 ++
 drivers/fpga/aal/rms/aalrms-events-int.h           |  136 +
 drivers/fpga/aal/rms/kOSAL.c                       |  692 +++++
 91 files changed, 43013 insertions(+)
 create mode 100644 drivers/fpga/aal/Kconfig
 create mode 100644 drivers/fpga/aal/Makefile
 create mode 100644 drivers/fpga/aal/bus/Makefile
 create mode 100644 drivers/fpga/aal/bus/aalbus-device.c
 create mode 100644 drivers/fpga/aal/bus/aalbus-int.h
 create mode 100644 drivers/fpga/aal/bus/aalbus-main.c
 create mode 100644 drivers/fpga/aal/bus/kOSAL.c
 create mode 100644 drivers/fpga/aal/cci/Makefile
 create mode 100644 drivers/fpga/aal/cci/cci_pcie_common.c
 create mode 100644 drivers/fpga/aal/cci/cci_pcie_driver_PIPsession.c
 create mode 100644 drivers/fpga/aal/cci/cci_pcie_driver_PIPsession.h
 create mode 100644 drivers/fpga/aal/cci/cci_pcie_driver_internal.h
 create mode 100644 drivers/fpga/aal/cci/cci_pcie_driver_main_linux.c
 create mode 100644 drivers/fpga/aal/cci/cci_pcie_driver_simulator.c
 create mode 100644 drivers/fpga/aal/cci/cci_pcie_driver_simulator.h
 create mode 100644 drivers/fpga/aal/cci/cci_pcie_driver_umapi.h
 create mode 100644 drivers/fpga/aal/cci/cci_pcie_driver_umapi_common.c
 create mode 100644 drivers/fpga/aal/cci/cci_pcie_driver_umapi_linux.c
 create mode 100644 drivers/fpga/aal/cci/cci_pcie_driver_umapi_linux.h
 create mode 100644 drivers/fpga/aal/cci/ccip_afu.c
 create mode 100644 drivers/fpga/aal/cci/ccip_fme.c
 create mode 100644 drivers/fpga/aal/cci/ccip_fme.h
 create mode 100644 drivers/fpga/aal/cci/ccip_fme_mmap_linux.c
 create mode 100644 drivers/fpga/aal/cci/ccip_logging.c
 create mode 100644 drivers/fpga/aal/cci/ccip_logging.h
 create mode 100644 drivers/fpga/aal/cci/ccip_logging_linux.c
 create mode 100644 drivers/fpga/aal/cci/ccip_logging_linux.h
 create mode 100644 drivers/fpga/aal/cci/ccip_perfmon.c
 create mode 100644 drivers/fpga/aal/cci/ccip_perfmon.h
 create mode 100644 drivers/fpga/aal/cci/ccip_perfmon_linux.c
 create mode 100644 drivers/fpga/aal/cci/ccip_perfmon_linux.h
 create mode 100644 drivers/fpga/aal/cci/ccip_port.c
 create mode 100644 drivers/fpga/aal/cci/ccip_port.h
 create mode 100644 drivers/fpga/aal/cci/ccip_pr.c
 create mode 100644 drivers/fpga/aal/cci/ccip_pr.h
 create mode 100644 drivers/fpga/aal/cci/ccip_pwr.c
 create mode 100644 drivers/fpga/aal/cci/ccip_pwr.h
 create mode 100644 drivers/fpga/aal/cci/ccip_sim_mmio.c
 create mode 100644 drivers/fpga/aal/cci/ccip_stap.c
 create mode 100644 drivers/fpga/aal/cci/ccipdrv-events.h
 create mode 100644 drivers/fpga/aal/cci/kOSAL.c
 create mode 100644 drivers/fpga/aal/include/aalsdk/kernel/AALTransactionID_s.h
 create mode 100644 drivers/fpga/aal/include/aalsdk/kernel/AALWorkspace.h
 create mode 100644 drivers/fpga/aal/include/aalsdk/kernel/KernelStructs.h
 create mode 100644 drivers/fpga/aal/include/aalsdk/kernel/aalbus-device.h
 create mode 100644 drivers/fpga/aal/include/aalsdk/kernel/aalbus-ipip.h
 create mode 100644 drivers/fpga/aal/include/aalsdk/kernel/aalbus.h
 create mode 100644 drivers/fpga/aal/include/aalsdk/kernel/aalbus_Defs.h
 create mode 100644 drivers/fpga/aal/include/aalsdk/kernel/aalbus_iconfigmonitor.h
 create mode 100644 drivers/fpga/aal/include/aalsdk/kernel/aalbus_iupdate_config.h
 create mode 100644 drivers/fpga/aal/include/aalsdk/kernel/aaldefs.h
 create mode 100644 drivers/fpga/aal/include/aalsdk/kernel/aaldevice.h
 create mode 100644 drivers/fpga/aal/include/aalsdk/kernel/aalids.h
 create mode 100644 drivers/fpga/aal/include/aalsdk/kernel/aalinterface.h
 create mode 100644 drivers/fpga/aal/include/aalsdk/kernel/aalmafu-events.h
 create mode 100644 drivers/fpga/aal/include/aalsdk/kernel/aalmafu.h
 create mode 100644 drivers/fpga/aal/include/aalsdk/kernel/aalqueue.h
 create mode 100644 drivers/fpga/aal/include/aalsdk/kernel/aalrm-services.h
 create mode 100644 drivers/fpga/aal/include/aalsdk/kernel/aalrm.h
 create mode 100644 drivers/fpga/aal/include/aalsdk/kernel/aalrm_client.h
 create mode 100644 drivers/fpga/aal/include/aalsdk/kernel/aalrm_server-services.h
 create mode 100644 drivers/fpga/aal/include/aalsdk/kernel/aalrm_server.h
 create mode 100644 drivers/fpga/aal/include/aalsdk/kernel/aaltypes.h
 create mode 100644 drivers/fpga/aal/include/aalsdk/kernel/aalui-events.h
 create mode 100644 drivers/fpga/aal/include/aalsdk/kernel/aalui.h
 create mode 100644 drivers/fpga/aal/include/aalsdk/kernel/aalwsservice.h
 create mode 100644 drivers/fpga/aal/include/aalsdk/kernel/ahmpip.h
 create mode 100644 drivers/fpga/aal/include/aalsdk/kernel/ahmpipdefs.h
 create mode 100644 drivers/fpga/aal/include/aalsdk/kernel/ccidefs.h
 create mode 100644 drivers/fpga/aal/include/aalsdk/kernel/ccip_defs.h
 create mode 100644 drivers/fpga/aal/include/aalsdk/kernel/ccipdriver.h
 create mode 100644 drivers/fpga/aal/include/aalsdk/kernel/fappip.h
 create mode 100644 drivers/fpga/aal/include/aalsdk/kernel/iaaldevice.h
 create mode 100644 drivers/fpga/aal/include/aalsdk/kernel/kosal.h
 create mode 100644 drivers/fpga/aal/include/aalsdk/kernel/spl2defs.h
 create mode 100644 drivers/fpga/aal/include/aalsdk/kernel/vafu2defs.h
 create mode 100644 drivers/fpga/aal/rmc/Makefile
 create mode 100644 drivers/fpga/aal/rmc/aalrm-events-int.h
 create mode 100644 drivers/fpga/aal/rmc/aalrm-file.c
 create mode 100644 drivers/fpga/aal/rmc/aalrm-int.h
 create mode 100644 drivers/fpga/aal/rmc/aalrm-ioctl.c
 create mode 100644 drivers/fpga/aal/rmc/aalrm-main.c
 create mode 100644 drivers/fpga/aal/rmc/kOSAL.c
 create mode 100644 drivers/fpga/aal/rms/Makefile
 create mode 100644 drivers/fpga/aal/rms/aalrm_server-file.c
 create mode 100644 drivers/fpga/aal/rms/aalrm_server-int.h
 create mode 100644 drivers/fpga/aal/rms/aalrm_server-ioctl.c
 create mode 100644 drivers/fpga/aal/rms/aalrm_server-main.c
 create mode 100644 drivers/fpga/aal/rms/aalrm_server-services.c
 create mode 100644 drivers/fpga/aal/rms/aalrms-events-int.h
 create mode 100644 drivers/fpga/aal/rms/kOSAL.c

diff --git a/drivers/fpga/aal/Kconfig b/drivers/fpga/aal/Kconfig
new file mode 100644
index 000000000000..0adaef853d50
--- /dev/null
+++ b/drivers/fpga/aal/Kconfig
@@ -0,0 +1,47 @@
+#
+# Accelerator Abstraction Layer kernel driver
+#
+
+config AAL
+	bool "Enabling Accelerator Abstraction Layer (AAL)"
+	help
+	  Enable the Accelerator Abstraction Layer driver.
+
+if AAL
+
+config AAL_BUS
+	tristate "AAL Bus"
+	default m
+	help
+	  Enable the Accelerator Abstraction Layer BUS driver.
+
+config AAL_RMS
+	tristate "AAL Resource Management Server"
+	default m
+	help
+	  Enable the Accelerator Abstraction Layer Resource management
+	  server driver.
+
+config AAL_RMC
+	tristate "AAL Resource Management Client"
+	default m
+	help
+	  Enable the Accelerator Abstraction Layer Resource management
+	  client driver.
+
+config AAL_CCI
+	tristate "AAL PCIe driver for CCI FPGA devices"
+	default m
+	help
+	  Enable the Accelerator Abstraction Layer PCIe driver for
+	  CCI FPGA devices.
+
+config AAL_DEBUG
+	bool "Enable debug on AAL"
+	default y
+
+config AAL_ASSERT
+	bool "Enable assert on AAL"
+	default y
+
+endif # AAL
diff --git a/drivers/fpga/aal/Makefile b/drivers/fpga/aal/Makefile
new file mode 100644
index 000000000000..e9b4b1e5c24c
--- /dev/null
+++ b/drivers/fpga/aal/Makefile
@@ -0,0 +1,6 @@
+
+obj-$(CONFIG_AAL_BUS)       += bus/
+obj-$(CONFIG_AAL_RMS)       += rms/
+obj-$(CONFIG_AAL_RMC)       += rmc/
+obj-$(CONFIG_AAL_CCI)       += cci/
+
diff --git a/drivers/fpga/aal/bus/Makefile b/drivers/fpga/aal/bus/Makefile
new file mode 100644
index 000000000000..10f85206c328
--- /dev/null
+++ b/drivers/fpga/aal/bus/Makefile
@@ -0,0 +1,21 @@
+ccflags-y := -I$(src)/../include -D__KERNEL__=1
+ccflags-y += -DDRV_NAME=\"aalbus\"
+ccflags-y += -DDRV_VERSION=\"6.3.1\"
+
+ifdef CONFIG_AAL_DEBUG
+	ccflags-y += -DENABLE_DEBUG=1
+else
+	ccflags-y += -DENABLE_DEBUG=0
+endif
+
+ifdef CONFIG_AAL_ASSERT
+	ccflags-y += -DENABLE_ASSERT=1
+else
+	ccflags-y += -DENABLE_ASSERT=0
+endif
+
+obj-$(CONFIG_AAL_BUS)	+= aalbus.o
+
+aalbus-y	:=	aalbus-device.o \
+			aalbus-main.o   \
+			kOSAL.o
diff --git a/drivers/fpga/aal/bus/aalbus-device.c b/drivers/fpga/aal/bus/aalbus-device.c
new file mode 100644
index 000000000000..226b54f4fbf5
--- /dev/null
+++ b/drivers/fpga/aal/bus/aalbus-device.c
@@ -0,0 +1,803 @@
+//******************************************************************************
+// This  file  is  provided  under  a  dual BSD/GPLv2  license.  When using or
+//         redistributing this file, you may do so under either license.
+//
+//                            GPL LICENSE SUMMARY
+//
+//  Copyright(c) 2008-2017, Intel Corporation.
+//
+//  This program  is  free software;  you  can redistribute it  and/or  modify
+//  it  under  the  terms of  version 2 of  the GNU General Public License  as
+//  published by the Free Software Foundation.
+//
+//  This  program  is distributed  in the  hope that it  will  be useful,  but
+//  WITHOUT   ANY   WARRANTY;   without   even  the   implied   warranty    of
+//  MERCHANTABILITY  or  FITNESS  FOR  A  PARTICULAR  PURPOSE.  See  the   GNU
+//  General Public License for more details.
+//
+//  The  full  GNU  General Public License is  included in  this  distribution
+//  in the file called README.GPLV2-LICENSE.TXT.
+//
+//  Contact Information:
+//  Henry Mitchel, henry.mitchel at intel.com
+//  77 Reed Rd., Hudson, MA  01749
+//
+//                                BSD LICENSE
+//
+//  Copyright(c) 2008-2017, Intel Corporation.
+//
+//  Redistribution and  use  in source  and  binary  forms,  with  or  without
+//  modification,  are   permitted  provided  that  the  following  conditions
+//  are met:
+//
+//    * Redistributions  of  source  code  must  retain  the  above  copyright
+//      notice, this list of conditions and the following disclaimer.
+//    * Redistributions in  binary form  must  reproduce  the  above copyright
+//      notice,  this  list of  conditions  and  the  following disclaimer  in
+//      the   documentation   and/or   other   materials   provided  with  the
+//      distribution.
+//    * Neither   the  name   of  Intel  Corporation  nor  the  names  of  its
+//      contributors  may  be  used  to  endorse  or promote  products derived
+//      from this software without specific prior written permission.
+//
+//  THIS  SOFTWARE  IS  PROVIDED  BY  THE  COPYRIGHT HOLDERS  AND CONTRIBUTORS
+//  "AS IS"  AND  ANY  EXPRESS  OR  IMPLIED  WARRANTIES,  INCLUDING,  BUT  NOT
+//  LIMITED  TO, THE  IMPLIED WARRANTIES OF  MERCHANTABILITY  AND FITNESS  FOR
+//  A  PARTICULAR  PURPOSE  ARE  DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT
+//  OWNER OR CONTRIBUTORS BE LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,
+//  SPECIAL,  EXEMPLARY,  OR  CONSEQUENTIAL   DAMAGES  (INCLUDING,   BUT   NOT
+//  LIMITED  TO,  PROCUREMENT  OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF USE,
+//  DATA,  OR PROFITS;  OR BUSINESS INTERRUPTION)  HOWEVER  CAUSED  AND ON ANY
+//  THEORY  OF  LIABILITY,  WHETHER  IN  CONTRACT,  STRICT LIABILITY,  OR TORT
+//  (INCLUDING  NEGLIGENCE  OR OTHERWISE) ARISING  IN ANY WAY  OUT  OF THE USE
+//  OF  THIS  SOFTWARE, EVEN IF ADVISED  OF  THE  POSSIBILITY  OF SUCH DAMAGE.
+//******************************************************************************
+//****************************************************************************
+//        FILE: aalbus-device.c
+//     CREATED: 09/15/2008
+//      AUTHOR: Joseph Grecco
+//
+// PURPOSE:  This file contains the implementation for AAL device generic
+//           behavior.
+//           Accelerator Abstraction Layer (AAL)
+//           Accelerator Hardware Module bus driver module
+// HISTORY:
+// COMMENTS:
+// WHEN:          WHO:     WHAT:
+// 09/15/2008     JG       Initial version started
+// 11/11/2008     JG       Added legal header
+// 12/16/2008     JG       Began support for abort and shutdown
+//                            Added Support for WSID object
+//                            Major interface changes.
+// 12/18/2008     JG       Added use of owner Session initializer
+//                            and copier to ensure pointers are initialized
+// 12/23/2008     JG       Modified UpdateOWner to support passing
+//                            pack same owner session as already set
+// 01/04/2009     HM       Updated Copyright
+// 10/01/2009     JG       Added remove method to the device
+// 10/22/2009     JG       Added aaldev_AddOwner_e in support of modified
+//                         device methods
+// 04/28/2010     HM       Added return value checks to down_interruptible()
+//****************************************************************************
+#include "aalsdk/kernel/kosal.h"
+
+#define MODULE_FLAGS AALBUS_DBG_MOD
+
+#include "aalbus-int.h"
+#include "aalsdk/kernel/aalinterface.h"
+#include "aalsdk/kernel/aalbus-device.h"
+#include "aalsdk/kernel/aaldevice.h"
+
+kosal_semaphore g_listlock;
+
+//=============================================================================
+// Name:  aalbus_destroy_device
+// Description: Destroys an AAL device type
+// Interface: public
+// Inputs: devp - Device to destroy.
+// Outputs: 1 - success.
+// Comments:
+//=============================================================================
+int
+aaldev_destroy_device(struct aal_device *devp)
+{
+   int status;
+   int retval = -EINVAL;
+   struct aal_bus *aal_bus_p;
+   struct aal_bus_type *aal_bus_type_p;
+
+   /* get a reference to the public aal_bus as well as the "private"
+    * aal_bus_type.  aal_bus_type_p will always point to something if
+    * aal_bus_p is non-null, so there's no reason to check it for validity.
+    * (although if we're way off into the weeds, it may point further off into
+    * the weeds...) */
+   aal_bus_p = aalbus_get_bus();
+   if (NULL == aal_bus_p) {
+      DPRINTF(AALBUS_DBG_MOD, " aalbus_get_bus failed\n");
+      return -1;
+   }
+   aal_bus_type_p = kosal_container_of(aal_bus_p, struct aal_bus_type, m_bus);
+
+   /* check device validity before proceeding.  if devp isn't valid, it isn't
+    * a device that is known to us, and is likely a bug. */
+   status = aal_bus_p->dev_is_valid(devp);
+   if (0 != status) {
+      status = kosal_sem_get_user_alertable(&aal_bus_type_p->alloc_list_sem);
+      if (0 != status) {
+         DPRINTF(AALBUS_DBG_MOD, " interrupted while acquiring lock for allocation list\n");
+         return status;
+      }
+      list_del(&devp->m_alloc_list);
+      kosal_sem_put(&aal_bus_type_p->alloc_list_sem);
+      kosal_kfree(devp, sizeof(struct aal_device));
+      retval = 1;
+      DPRINTF(AALBUS_DBG_MOD, "device %p destroyed\n", devp);
+   } else {
+      DPRINTF(AALBUS_DBG_MOD, "device %p not a valid aal_device!\n", devp);
+      /* not a valid device, so we don't touch it.  error will be propagated
+       * back to the caller. */
+   }
+
+   return retval;
+}
+
+//=============================================================================
+// Name: aaldev_release_device
+// Description: Called by Linux as a result of the unregister call. This
+//              function removes the device from memory by calling the  AAL Bus
+//              destroy()
+// Interface: private
+// Inputs: pdev - generic device structure
+// Outputs: none
+// Returns:void
+// Comments:
+//=============================================================================
+void
+aaldev_release_device(struct device *pdev)
+{
+   struct aal_bus    *AALbusp = aalbus_get_bus();
+   struct aal_device *paaldev = basedev_to_aaldev(pdev);
+
+   // If a user release method is installed call it.
+   if ( dev_hasRelease(paaldev) ) {
+      dev_release(paaldev, pdev);
+   }
+
+   // Destroy the device
+   DPRINTF(AALBUS_DBG_MOD, "Destroying AFU Device.\n");
+   aaldev_factp(AALbusp).destroy(paaldev);
+}
+
+//=============================================================================
+// Name: aaldev_create_device
+// Description: Creates the device and registers with AAL Bus.
+// Interface: public
+// Returns 0 - success
+// Inputs: devIDp - pointer to aal_device ID to create
+//         basename - basename to use. /0 - uses default
+//         relfcnp - pointer to driver release function. NULL - uses default
+//         ipipp - pointer to PIP for this device.
+// Outputs: none.
+// Comments: Once this device has been created this DKSM must be ready to
+//           accept requests as the MAFU will be exposed to the AAL user
+//           subsystem.
+// TODO - Add manifest and uevent
+//=============================================================================
+struct aal_device *
+aaldev_create_device(struct mafu_CreateAFU *pRequest,
+                     void (*relfcnp)(struct device*),
+                     struct aal_ipip       *ipipp)
+{
+   struct aal_device_id *devID      = &pRequest->device_id;
+   struct aal_device    *paaldevice = NULL;
+   struct aal_bus 		*aal_bus_p;
+   struct aal_bus_type 	*aal_bus_type_p;
+   int status;
+
+
+   ASSERT(devID);
+
+   paaldevice = (struct aal_device    *)kosal_kmalloc(sizeof(struct aal_device));
+   if ( NULL == paaldevice ) {
+      DPRINTF(AALBUS_DBG_MOD, ": Error allocating device memory for bus type %d busID[%d:%d]\n",
+                                 (unsigned) devID->m_devaddr.m_bustype,
+                                 devID->m_devaddr.m_devicenum,
+                                 devID->m_devaddr.m_subdevnum);
+      return NULL;
+   }
+
+   DPRINTF(AALBUS_DBG_MOD," Preping AAL device %p\n", paaldevice);
+
+   //aaldev_prep(paaldevice);
+   {
+      // Prepare the new device
+      memset(paaldevice, 0, sizeof(struct aal_device));
+
+      kosal_list_init(&paaldevice->m_ownerlist);
+      kosal_list_init(&paaldevice->m_alloc_list);
+      kosal_mutex_init(&paaldevice->m_sem);
+      kosal_mutex_init(&paaldevice->m_listsem);
+
+      // Version of the structure
+      paaldevice->m_version     = AAL_DEVICE_VERSION;
+
+      // Used as part of the handle validation
+      paaldevice->m_validator   = (__u64)virt_to_phys(paaldevice);
+
+      paaldevice->m_dev.release = aaldev_release_device; // System method
+
+   }
+
+   /*
+    * add to list of allocated devices
+    */
+
+   /* get handle to aalbus and outer aalBus */
+   aal_bus_p = aalbus_get_bus();
+   if (NULL == aal_bus_p) {
+      DPRINTF(AALBUS_DBG_MOD, " aalbus_get_bus failed\n");
+      kosal_kfree(paaldevice, sizeof(struct aal_device));
+      return NULL;
+   }
+   aal_bus_type_p = kosal_container_of(aal_bus_p, struct aal_bus_type, m_bus);
+   DPRINTF(AALBUS_DBG_MOD, " aal_bus at %p has bus_type at %p, with flags "
+      "%x\n", aal_bus_p, aal_bus_type_p, aal_bus_type_p->m_flags);
+
+   status = kosal_sem_get_user_alertable(&aal_bus_type_p->alloc_list_sem);
+   if (0 != status) {
+      DPRINTF(AALBUS_DBG_MOD, " Failed to acquire allocate list semaphore\n");
+      kosal_kfree(paaldevice, sizeof(struct aal_device));
+      return NULL;
+   } else {
+      list_add(&paaldevice->m_alloc_list, &aal_bus_type_p->alloc_list_head);
+      kosal_sem_put(&aal_bus_type_p->alloc_list_sem);
+   }
+
+   // Initialize the device ID info
+   DPRINTF(AALBUS_DBG_MOD," Initializing AAL device %p\n", paaldevice);
+   paaldevice->m_devid = *devID;
+
+   // Method called when the device is released (i.e., its destructor)
+   //  The canonical release device calls the user's release method.
+   //  If NULL is provided then only the canonical behavior is done
+   dev_setrelease(paaldevice, relfcnp);                  // User method
+
+
+   // The Context is a PIP defined data value
+   //   The standard AAL PIP pointer is stored as well
+   paaldevice->m_pipContext = NULL;
+   aaldev_pipp(paaldevice)  = ipipp;
+
+   // Set the maximum number of shares
+   paaldevice->m_maxowners = pRequest->maxshares;
+
+   // Is direct access to PIP enabled for this device?
+   paaldevice->m_mappableAPI = pRequest->enableDirectAPI;
+
+   // Store the base name
+   if ( 0 == strlen(pRequest->basename) ) {
+      // Default
+      strncpy(aaldev_basename(paaldevice), AAL_AFU_DEVICE_BASENAME, BUS_ID_SIZE-1);
+   } else {
+      strncpy(aaldev_basename(paaldevice), pRequest->basename,      BUS_ID_SIZE-1);
+   }
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,29)
+   dev_set_name(&aaldev_to_basedev(paaldevice),
+                "%s[%d:%d:%d]",
+                (char*)aaldev_basename(paaldevice),
+                aaldev_devaddr_busnum(paaldevice),
+                aaldev_devaddr_devnum(paaldevice),
+                aaldev_devaddr_subdevnum(paaldevice));
+#else
+   // Construct the device name from the base name and the device ID
+   snprintf((char*)aaldev_devname(paaldevice), BUS_ID_SIZE,
+            "%s[%d:%d:%d]",
+            (char*)aaldev_basename(paaldevice),
+            aaldev_devaddr_busnum(paaldevice),
+            aaldev_devaddr_devnum(paaldevice),
+            aaldev_devaddr_subdevnum(paaldevice));
+#endif
+
+   //---------------------------------------------------------
+   // Register the device
+   //  This will cause the bus's match function to be called.
+   //  That call will be forwarded to this driver as it is
+   //  registered with the aalBus.  The rest of initialization
+   //  occurs there.
+   //---------------------------------------------------------
+   if ( pRequest->actionflags & AAL_DEV_CREATE_UNREGISTERED ) {
+
+      // Stop here
+      DPRINTF(AALBUS_DBG_MOD, ": AFU device created but not registered.  Action flags = %x\n",pRequest->actionflags);
+      return paaldevice;
+
+   } else if( 0 != aal_bus_p->register_device(paaldevice) ) {
+      DPRINTF(AALBUS_DBG_MOD, ": AFU device failed to register!.\n");
+      status = kosal_sem_get_user_alertable(&aal_bus_type_p->alloc_list_sem);
+      if (0 != status) {
+         DPRINTF(AALBUS_DBG_MOD, " interrupted while acquiring lock for"
+            " allocation list, leaking memory as a result\n");
+      } else {
+         list_del(&paaldevice->m_alloc_list);
+         kosal_sem_put(&aal_bus_type_p->alloc_list_sem);
+         kosal_kfree(paaldevice, sizeof(struct aal_device));
+      }
+      return NULL;
+   }
+
+   return paaldevice;
+}
+
+
+//=============================================================================
+// Name: aaldev_find_pid_owner
+// Description: Finds the device owner that has this pid
+// Interface: private
+// Inputs: pid - Process ID to search for
+//         pdev - pointer to device
+// Returns: aal_devowner * of owner or else NULL
+// Comments: This routine is not protected but uses the safe version of the
+//           list_for_each making it safe for removals.
+//=============================================================================
+static inline
+struct aaldev_owner *
+aaldev_find_pid_owner(struct aal_device *pdev,
+                      btPID              pid)
+{
+   kosal_list_head     *pitr;
+   kosal_list_head     *temp;
+   struct aaldev_owner *result = NULL;
+
+   if ( unlikely( !aaldev_valid(pdev) ) ) {
+      DPRINTF (AALBUS_DBG_MOD, ": Invalid device\n");
+      return 0;
+   }
+
+   // Loop through the list looking for a match
+   kosal_list_for_each_safe(pitr, temp, &pdev->m_ownerlist) {
+
+      // If the pid matches
+      result = kosal_container_of(pitr, struct aaldev_owner, m_ownerlist);
+      DPRINTF (AALBUS_DBG_MOD, ": Owner pid %d  Requesting pid %d\n", result->m_pid, pid);
+
+      if ( result->m_pid == pid ) {
+         return result;
+      }
+
+   }
+
+   return NULL;
+}
+
+//=============================================================================
+// Name: aaldev_addOwner
+// Description: Add a new owner to the ownership list
+// Interface: public
+// Inputs: pdev - pointer to the device
+//         pid - ID of owning process
+//         manifest - opaque block associated with owner
+//         psessionlist - pointer to the new owning sessions owner list
+// Returns: aaldev_addowner_OK - success
+// Comments: Owner must be unique.  The psessionlist is used to enable a
+//          session object to maintain a list of devices it owns
+//=============================================================================
+aaldev_AddOwner_e
+aaldev_addOwner(struct aal_device *pdev,
+                btPID              pid,
+                void              *manifest,
+                btAny              ownerContext,
+                kosal_list_head   *psessionlist)
+{
+   aaldev_AddOwner_e    ret  = aaldev_addowner_OK;
+   struct aaldev_owner *pown = NULL;
+
+   DPRINTF (AALBUS_DBG_MOD, ": Adding Owner\n");
+
+   if ( unlikely( !aaldev_valid(pdev) ) ) {
+      DPRINTF (AALBUS_DBG_MOD, ": Invalid device\n");
+      return aaldev_addowner_NotOwner;
+   }
+
+   // Lock the list from any updates
+   if ( unlikely( kosal_sem_get_user_alertable(&pdev->m_sem) ) ) {
+      DPRINTF (AALBUS_DBG_MOD, ": kosal_sem_get_user_alertable interrupted\n");
+      return aaldev_addowner_Interrupted;
+   }
+
+   // Make sure the device owner count has not been exceeded
+   // TODO support multiple owners (sharing)
+   if( ( MAFU_CONFIGURE_UNLIMTEDSHARES != pdev->m_numowners ) &&
+       ( pdev->m_numowners >= pdev->m_maxowners ) ) {
+      DPRINTF (AALBUS_DBG_MOD, ": Failed - Maximum Owners assigned %d exceeds %d\n",
+                                                   pdev->m_numowners,
+                                                   pdev->m_maxowners);
+      ret = aaldev_addowner_MaxOwners;
+      goto out;
+   }
+
+   // Make sure this pid is unique
+   if ( aaldev_find_pid_owner(pdev,pid) ) {
+      DPRINTF (AALBUS_DBG_MOD, ": Owner already assigned!%d\n",pid);
+      ret = aaldev_addowner_DupOwner;
+      goto out;
+   }
+
+   // Allocate the new owner struct
+   pown = (struct aaldev_owner *)kosal_kmalloc(sizeof(struct aaldev_owner));
+   if ( unlikely( NULL == pown ) ) {
+      DPRINTF (AALBUS_DBG_MOD, ": failed to allocate owner structure\n");
+      ret = aaldev_addowner_SysErr;
+      goto out;
+   }
+
+   // Create the owner
+   aaldev_owner_init(pown, pid, manifest,ownerContext);
+
+   // Record the device
+   pown->m_device = pdev;
+
+   // protect list operations
+   if ( unlikely( kosal_sem_get_user_alertable(&g_listlock) ) ) {
+      DPRINTF (AALBUS_DBG_MOD, ": kosal_sem_get_user_alertable interrupted\n");
+      kosal_kfree(pown, sizeof(struct aaldev_owner));
+      return aaldev_addowner_Interrupted;
+   }
+
+   // Add the owner to the device's owner list.
+   // This is the list of owners for this device
+   list_add(&pown->m_ownerlist, &pdev->m_ownerlist);
+
+   // Add this owner object to the session's list
+   // This is a list of devices owned by this session
+   list_add(&pown->m_devicelist, psessionlist);
+
+   kosal_sem_put(&g_listlock);
+
+   // Increment number of owners
+   if ( MAFU_CONFIGURE_UNLIMTEDSHARES != pdev->m_numowners ) {
+      pdev->m_numowners++;
+   }
+
+   // Send the configuration update event
+   aalbus_get_bus()->send_config_update_event(pdev,
+                                              krms_ccfgUpdate_DevOwnerAdded,
+                                              pid);
+
+out:
+   kosal_sem_put(&pdev->m_sem);
+   return ret;
+}
+
+
+//=============================================================================
+// Name: aaldev_isOwner
+// Description: Returns whether the PID is an owner of the device
+// Interface: public
+// Inputs: pdev - pointer to the device
+//         pid - ID of owning process
+// Returns: aaldev_addowner_OK - An Owner
+// Comments:
+//=============================================================================
+aaldev_AddOwner_e
+aaldev_isOwner(struct aal_device *pdev,
+               btPID              pid)
+{
+   aaldev_AddOwner_e ret = aaldev_addowner_OK;
+
+   if( unlikely( !aaldev_valid(pdev) ) ) {
+      DPRINTF (AALBUS_DBG_MOD, ": Invalid device\n");
+      return aaldev_addowner_InvalidDevice;
+   }
+
+   // Lock the list from any updates
+   if ( unlikely( kosal_sem_get_user_alertable(&pdev->m_sem) ) ) {
+      DPRINTF (AALBUS_DBG_MOD, ": kosal_sem_get_user_alertable interrupted\n");
+      return aaldev_addowner_Interrupted;
+   }
+
+   // Use find owner
+   ret = (NULL == aaldev_find_pid_owner(pdev, pid) ? aaldev_addowner_NotOwner : aaldev_addowner_OK);
+
+   kosal_sem_put(&pdev->m_sem);
+
+   return ret;
+}
+
+//=============================================================================
+// Name: aaldev_removeOwner
+// Description: Remove an owner from the ownership list
+// Interface: public
+// Inputs: pdev - pointer to the device. NULL indicates remove all.
+//         pid - ID of owner to remove from the list
+// Returns: aaldev_addowner_OK - success
+// Comments:
+//=============================================================================
+int
+aaldev_removeOwner(struct aal_device *pdev, btPID pid)
+{
+   int                  ret  = 1;
+   struct aaldev_owner *pown = NULL;
+
+   DPRINTF (AALBUS_DBG_MOD, ": Removing Owner\n");
+
+   if ( unlikely( !aaldev_valid(pdev) ) ) {
+      DPRINTF (AALBUS_DBG_MOD, ": Invalid device\n");
+      return  aaldev_addowner_InvalidDevice;
+   }
+
+   // Lock the list from any updates
+   if ( unlikely( kosal_sem_get_user_alertable(&pdev->m_sem) ) ) {
+      DPRINTF (AALBUS_DBG_MOD, ": kosal_sem_get_user_alertable interrupted\n");
+      return aaldev_addowner_Interrupted;
+   }
+
+   pown = aaldev_find_pid_owner(pdev, pid);
+
+   // Make sure this pid is unique
+   if ( unlikely(NULL == pown) ) {
+      DPRINTF (AALBUS_DBG_MOD, ": Not Owner\n");
+      ret = aaldev_addowner_NotOwner;
+      goto out;
+   }
+
+   // protect list operations
+   if ( unlikely( kosal_sem_get_user_alertable(&g_listlock) ) ) {
+      DPRINTF (AALBUS_DBG_MOD, ": kosal_sem_get_user_alertable interrupted\n");
+      return aaldev_addowner_Interrupted;
+   }
+
+   list_del_init(&pown->m_devicelist);
+   list_del_init(&pown->m_ownerlist);
+
+   kosal_sem_put(&g_listlock);
+
+   // done list update
+   kosal_kfree(pown, sizeof(struct aaldev_owner));
+
+   // Decrement number of owners
+   pdev->m_numowners--;
+
+   // Send the configuration update event
+   aalbus_get_bus()->send_config_update_event(pdev,
+                                              krms_ccfgUpdate_DevOwnerRemoved,
+                                              pid);
+out:
+   kosal_sem_put(&pdev->m_sem);
+   return ret;
+}
+
+//=============================================================================
+// Name: aaldev_updateOwner
+// Description: Update an existing owner record
+// Interface: public
+// Inputs: pdev - pointer to the device
+//         pid - ID of owner to find
+//         ownerSessionp  - pointer to owner session
+//         psessionlist - session list to replace with
+// Returns: aaldev_addowner_OK - success
+// Comments:
+//=============================================================================
+aaldev_AddOwner_e
+aaldev_updateOwner(struct aal_device          *pdev,
+                   btPID                       pid,
+                   struct aaldev_ownerSession *ownerSessionp,
+                   kosal_list_head            *psessionlist)
+{
+   aaldev_AddOwner_e    ret  = aaldev_addowner_OK;
+   struct aaldev_owner *pown = NULL;
+
+   DPRINTF (AALBUS_DBG_MOD, ": Updating Owner for device %p on list %p\n", pdev, psessionlist);
+
+   if ( unlikely( !aaldev_valid(pdev) ) ) {
+      DPRINTF (AALBUS_DBG_MOD, ": Invalid device\n");
+      return aaldev_addowner_InvalidDevice;
+   }
+
+   if ( unlikely( kosal_sem_get_user_alertable(&pdev->m_sem) ) ) {
+      DPRINTF (AALBUS_DBG_MOD, ": kosal_sem_get_user_alertable interrupted\n");
+      return aaldev_addowner_Interrupted;
+   }
+
+   pown = aaldev_find_pid_owner(pdev, pid);
+   if ( unlikely(NULL == pown) ) {
+      DPRINTF (AALBUS_DBG_MOD, ": Not Owner\n");
+      ret = aaldev_addowner_NotOwner;
+      goto out;
+   }
+
+   // protect list operations
+   if ( unlikely( kosal_sem_get_user_alertable(&g_listlock) ) ) {
+      DPRINTF (AALBUS_DBG_MOD, ": kosal_sem_get_user_alertable interrupted\n");
+      return aaldev_addowner_Interrupted;
+   }
+
+   // Remove this entry from the previous session list
+   list_del(&pown->m_devicelist);
+
+   // If the session info is being updated
+   if( ( NULL != ownerSessionp ) &&
+       ( ownerSessionp != &pown->m_sess) ) {
+      ownerSess_Copy(&pown->m_sess, ownerSessionp);
+   }
+
+   // Add it to the new session owners list
+   list_add(&pown->m_devicelist, psessionlist);
+
+   kosal_sem_put( &g_listlock );
+
+   DPRINTF (AALBUS_DBG_MOD, ": Done Updating Owner\n");
+
+   // Send the configuration update event
+   // TODO RIGHT NOW AFUs DON'T HAVE NECESSARILY HAVE A BUS SET.
+   aalbus_get_bus()->send_config_update_event(pdev,
+                                              krms_ccfgUpdate_DevOwnerUpdated,
+                                              pid);
+
+out:
+   kosal_sem_put(&pdev->m_sem);
+   return ret;
+}
+
+//=============================================================================
+// Name: aaldev_getOwnerSession
+// Description: Return the owner session
+// Interface: public
+// Inputs: pdev - pointer to the device
+//         pid - owner ID
+// Returns: pointer to owner session or NULL is not owner
+// Comments:
+//=============================================================================
+struct aaldev_ownerSession *
+aaldev_getOwnerSession(struct aal_device *pdev,
+                       btPID              pid)
+{
+   struct aaldev_ownerSession *ret  = NULL;
+   struct aaldev_owner        *pown = NULL;
+
+   DPRINTF (AALBUS_DBG_MOD, ": Getting Owner of device %p\n", pdev);
+
+   if ( unlikely( !aaldev_valid(pdev) ) ) {
+      DPRINTF (AALBUS_DBG_MOD, ": Invalid device\n");
+      return NULL;
+   }
+
+   if ( unlikely( kosal_sem_get_user_alertable(&pdev->m_sem) ) ) {
+      DPRINTF (AALBUS_DBG_MOD, ": kosal_sem_get_user_alertable interrupted\n");
+      return NULL;
+   }
+
+   pown = aaldev_find_pid_owner(pdev, pid);
+   if ( likely( NULL != pown ) ) {
+      ret = &pown->m_sess;
+      DPRINTF (AALBUS_DBG_MOD, ": Returning session %p\n", ret);
+   }
+
+   kosal_sem_put(&pdev->m_sem);
+   return ret;
+}
+
+
+//=============================================================================
+// Name: aaldev_doForeachOwner
+// Description: Calls a function on each owner on the list until complete or
+//              until the callback return non-zero.
+// Interface: public
+// Inputs: pdev - pointer to the device
+// Returns: pointer to owner stopped on or NULL if list completed
+// Comments:
+//=============================================================================
+struct aaldev_owner *
+aaldev_doForeachOwner(struct aal_device      *pdev,
+                      aaldev_OwnerProcessor_t fcn)
+{
+   kosal_list_head *pitr;
+   kosal_list_head *temp;
+
+   // Loop through the list looking for a match
+   kosal_list_for_each_safe(pitr, temp, &pdev->m_ownerlist) {
+
+      // If the function returns non-zero return current iterator
+      if ( 0 != fcn(pdev, kosal_container_of(pitr, struct aaldev_owner, m_ownerlist)) ) {
+         return kosal_container_of(pitr, struct aaldev_owner, m_ownerlist);
+      }
+
+   }
+
+   return NULL;
+}
+
+//=============================================================================
+// Name: aaldev_quiesce
+// Description: Update an existing owner record
+// Interface: public
+// Inputs: pdev - pointer to the device
+// Returns: 0 - success
+// Comments:
+//=============================================================================
+int
+aaldev_quiesce(struct aal_device *pdev, struct aaldev_owner *pown)
+{
+   return 0;
+}
+
+//=============================================================================
+// Name: aaldev_remove
+// Description: Remove the device
+// Interface: public
+// Inputs: pdev - pointer to the device
+// Returns: 1 - success
+// Comments:
+//=============================================================================
+int
+aaldev_remove(struct aal_device *pdev)
+{
+   int ret = 1;
+
+   DPRINTF(AALBUS_DBG_MOD, "Removing device %p\n", pdev);
+
+   if ( unlikely( !aaldev_valid(pdev) ) ) {
+	   DPRINTF(AALBUS_DBG_MOD, "Invalid device %p\n", pdev);
+      return 0;
+   }
+
+   if ( unlikely( kosal_sem_get_user_alertable(&pdev->m_sem) ) ) {
+	   DPRINTF(AALBUS_DBG_MOD, "kosal_sem_get_user_alertable interrupted\n");
+      return 0;
+   }
+
+   // For now disallow destruction with non-zero owners.
+   //  Eventually this should be changed to notify owners
+   //  via a status update event to remove
+   if ( unlikely( 0 != pdev->m_numowners ) ) {
+	   DPRINTF(AALBUS_DBG_MOD, "Non-zero owner count : %u\n", pdev->m_numowners);
+      ret = 0;
+      goto out;
+   }
+
+   // Send an update configuration event
+   aalbus_get_bus()->send_config_update_event(pdev,
+                                              krms_ccfgUpdate_DevRemoved,
+                                              0);
+
+   DPRINTF(AALBUS_DBG_MOD, "Done removing %p\n", pdev);
+
+out:
+   kosal_sem_put(&pdev->m_sem);
+   return ret;
+}
+
+//=============================================================================
+// Name: aaldev_init
+// Description: Initialized the device structure
+// Interface: public
+// Inputs: pdev - pointer to the device
+// Returns: 1 - success
+// Comments:
+//=============================================================================
+int
+aaldev_init(struct aal_device *pdev)
+{
+
+#if 0
+   if( unlikely( !aaldev_valid(pdev) ) ) {
+      kosal_printk_level(KERN_ERR, "aaldev_initFailed\n");
+      return 0;
+   }
+#endif
+   //  Initialize interface
+   pdev->i.addOwner        = aaldev_addOwner;
+   pdev->i.isOwner         = aaldev_isOwner;
+   pdev->i.removeOwner     = aaldev_removeOwner;
+   pdev->i.updateOwner     = aaldev_updateOwner;
+   pdev->i.getOwnerSession = aaldev_getOwnerSession;
+   pdev->i.doForeachOwner  = aaldev_doForeachOwner;
+   pdev->i.quiesce         = aaldev_quiesce;
+   pdev->i.remove          = aaldev_remove;
+
+   kosal_list_init(&pdev->m_ownerlist);
+   kosal_mutex_init(&pdev->m_sem);
+   kosal_mutex_init(&pdev->m_listsem);
+
+   return 1;
+}
+
diff --git a/drivers/fpga/aal/bus/aalbus-int.h b/drivers/fpga/aal/bus/aalbus-int.h
new file mode 100644
index 000000000000..5958c99cf2c4
--- /dev/null
+++ b/drivers/fpga/aal/bus/aalbus-int.h
@@ -0,0 +1,148 @@
+//******************************************************************************
+// This  file  is  provided  under  a  dual BSD/GPLv2  license.  When using or
+//         redistributing this file, you may do so under either license.
+//
+//                            GPL LICENSE SUMMARY
+//
+//  Copyright(c) 2008-2017, Intel Corporation.
+//
+//  This program  is  free software;  you  can redistribute it  and/or  modify
+//  it  under  the  terms of  version 2 of  the GNU General Public License  as
+//  published by the Free Software Foundation.
+//
+//  This  program  is distributed  in the  hope that it  will  be useful,  but
+//  WITHOUT   ANY   WARRANTY;   without   even  the   implied   warranty    of
+//  MERCHANTABILITY  or  FITNESS  FOR  A  PARTICULAR  PURPOSE.  See  the   GNU
+//  General Public License for more details.
+//
+//  The  full  GNU  General Public License is  included in  this  distribution
+//  in the file called README.GPLV2-LICENSE.TXT.
+//
+//  Contact Information:
+//  Henry Mitchel, henry.mitchel at intel.com
+//  77 Reed Rd., Hudson, MA  01749
+//
+//                                BSD LICENSE
+//
+//  Copyright(c) 2008-2017, Intel Corporation.
+//
+//  Redistribution and  use  in source  and  binary  forms,  with  or  without
+//  modification,  are   permitted  provided  that  the  following  conditions
+//  are met:
+//
+//    * Redistributions  of  source  code  must  retain  the  above  copyright
+//      notice, this list of conditions and the following disclaimer.
+//    * Redistributions in  binary form  must  reproduce  the  above copyright
+//      notice,  this  list of  conditions  and  the  following disclaimer  in
+//      the   documentation   and/or   other   materials   provided  with  the
+//      distribution.
+//    * Neither   the  name   of  Intel  Corporation  nor  the  names  of  its
+//      contributors  may  be  used  to  endorse  or promote  products derived
+//      from this software without specific prior written permission.
+//
+//  THIS  SOFTWARE  IS  PROVIDED  BY  THE  COPYRIGHT HOLDERS  AND CONTRIBUTORS
+//  "AS IS"  AND  ANY  EXPRESS  OR  IMPLIED  WARRANTIES,  INCLUDING,  BUT  NOT
+//  LIMITED  TO, THE  IMPLIED WARRANTIES OF  MERCHANTABILITY  AND FITNESS  FOR
+//  A  PARTICULAR  PURPOSE  ARE  DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT
+//  OWNER OR CONTRIBUTORS BE LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,
+//  SPECIAL,  EXEMPLARY,  OR  CONSEQUENTIAL   DAMAGES  (INCLUDING,   BUT   NOT
+//  LIMITED  TO,  PROCUREMENT  OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF USE,
+//  DATA,  OR PROFITS;  OR BUSINESS INTERRUPTION)  HOWEVER  CAUSED  AND ON ANY
+//  THEORY  OF  LIABILITY,  WHETHER  IN  CONTRACT,  STRICT LIABILITY,  OR TORT
+//  (INCLUDING  NEGLIGENCE  OR OTHERWISE) ARISING  IN ANY WAY  OUT  OF THE USE
+//  OF  THIS  SOFTWARE, EVEN IF ADVISED  OF  THE  POSSIBILITY  OF SUCH DAMAGE.
+//******************************************************************************
+//****************************************************************************
+//        FILE: aalbus-int.h
+//     CREATED: 02/15/2008
+//      AUTHOR: Joseph Grecco
+//
+// PURPOSE:  Internal definitions for the AAL Logical Bus driver module
+// HISTORY:
+// COMMENTS:
+// WHEN:          WHO:     WHAT:
+// 02-15-08       JG       Initial version created
+// 11/11/2008     JG       Added legal header
+// 01/04/2009     HM       Updated Copyright
+// 04/19/2012     TSW      Deprecate __func__ in favor of platform-agnostic
+//                          __AAL_FUNC__.
+//****************************************************************************
+#ifndef __AALKERNEL_AALBUS_AALBUS_INT_H__
+#define __AALKERNEL_AALBUS_AALBUS_INT_H__
+#include <aalsdk/kernel/kosal.h>
+#include <aalsdk/kernel/aalbus.h>
+
+
+#ifndef DRV_VERSION
+   #define DRV_VERSION    "EXPERIMENTAL VERSION"
+#endif
+
+#define DRV_DESCRIPTION   "AAL Logical Bus Module"
+#define DRV_AUTHOR        "Joseph Grecco <joe.grecco@intel.com>"
+#define DRV_LICENSE       "GPL"
+#define DRV_COPYRIGHT     "Copyright(c) 2008-2016, Intel Corporation"
+
+
+//
+// Attribute defaults
+//
+
+// Debug attributes
+//#define AALBUS_DBG_MOD    (1 << 0)
+//#define AALBUS_DBG_FILE   (1 << 1)
+//#define AALBUS_DBG_MMAP   (1 << 2)
+//#define AALBUS_DBG_IOCTL  (1 << 3)
+
+#define AALBUS_DBG_ALL        (AALBUS_DBG_MOD | AALBUS_DBG_FILE | AALBUS_DBG_MMAP | AALBUS_DBG_IOCTL)
+#define AALBUS_DBG_INVLID    ~(AALBUS_DBG_ALL)
+#define AALBUS_DBG_DEFAULT    AALBUS_DBG_ALL
+
+//========================
+// Typedefs and constants
+//========================
+
+//=============================================================================
+// Name: update_config_parms
+// Description: Used in aalbus_config_update_event
+//=============================================================================
+struct update_config_parms
+{
+   krms_cfgUpDate_e             updateType;
+   btPID                        pid;
+   aalbus_event_config_update_t Handler;
+};
+
+//=============================================================================
+// Name: aal_bus_type
+// Description: AAL bus class
+//=============================================================================
+struct aal_bus_type
+{
+   struct aal_bus     m_bus;        // AAL Bus public interface
+
+   struct {
+      aalbus_event_config_update_t EventHandler;
+      btObjectType                 context;
+   } config_update_event_handler;
+#if   defined( __AAL_LINUX__ )
+   struct bus_type    m_bustype;    // Generic bus base
+#endif
+   kosal_list_head    m_servicelist;
+   kosal_mutex        m_sem;        // Private mutex
+
+#define AAL_BUS_TYPE_FLAG_REGISTERED 0x00000001
+   btUnsigned16bitInt m_flags;
+
+   // Head of all aal_device structs created by aalbus, with semaphore.
+   // List items are in aal_device.alloc_list.
+   kosal_list_head alloc_list_head;
+   kosal_mutex     alloc_list_sem;
+};
+
+#define aal_bus_type_aal_busp(pbt) (&(pbt)->m_bus)
+
+#define aal_bus_type_is_registered(pbt)  flag_is_set((pbt)->m_flags, AAL_BUS_TYPE_FLAG_REGISTERED)
+#define aal_bus_type_set_registered(pbt) flag_setf((pbt)->m_flags,   AAL_BUS_TYPE_FLAG_REGISTERED)
+#define aal_bus_type_clr_registered(pbt) flag_clrf((pbt)->m_flags,   AAL_BUS_TYPE_FLAG_REGISTERED)
+
+#endif // __AALKERNEL_AALBUS_AALBUS_INT_H__
diff --git a/drivers/fpga/aal/bus/aalbus-main.c b/drivers/fpga/aal/bus/aalbus-main.c
new file mode 100644
index 000000000000..a27709e38eab
--- /dev/null
+++ b/drivers/fpga/aal/bus/aalbus-main.c
@@ -0,0 +1,2287 @@
+//******************************************************************************
+// This  file  is  provided  under  a  dual BSD/GPLv2  license.  When using or
+//         redistributing this file, you may do so under either license.
+//
+//                            GPL LICENSE SUMMARY
+//
+//  Copyright(c) 2008-2017, Intel Corporation.
+//
+//  This program  is  free software;  you  can redistribute it  and/or  modify
+//  it  under  the  terms of  version 2 of  the GNU General Public License  as
+//  published by the Free Software Foundation.
+//
+//  This  program  is distributed  in the  hope that it  will  be useful,  but
+//  WITHOUT   ANY   WARRANTY;   without   even  the   implied   warranty    of
+//  MERCHANTABILITY  or  FITNESS  FOR  A  PARTICULAR  PURPOSE.  See  the   GNU
+//  General Public License for more details.
+//
+//  The  full  GNU  General Public License is  included in  this  distribution
+//  in the file called README.GPLV2-LICENSE.TXT.
+//
+//  Contact Information:
+//  Henry Mitchel, henry.mitchel at intel.com
+//  77 Reed Rd., Hudson, MA  01749
+//
+//                                BSD LICENSE
+//
+//  Copyright(c) 2008-2017, Intel Corporation.
+//
+//  Redistribution and  use  in source  and  binary  forms,  with  or  without
+//  modification,  are   permitted  provided  that  the  following  conditions
+//  are met:
+//
+//    * Redistributions  of  source  code  must  retain  the  above  copyright
+//      notice, this list of conditions and the following disclaimer.
+//    * Redistributions in  binary form  must  reproduce  the  above copyright
+//      notice,  this  list of  conditions  and  the  following disclaimer  in
+//      the   documentation   and/or   other   materials   provided  with  the
+//      distribution.
+//    * Neither   the  name   of  Intel  Corporation  nor  the  names  of  its
+//      contributors  may  be  used  to  endorse  or promote  products derived
+//      from this software without specific prior written permission.
+//
+//  THIS  SOFTWARE  IS  PROVIDED  BY  THE  COPYRIGHT HOLDERS  AND CONTRIBUTORS
+//  "AS IS"  AND  ANY  EXPRESS  OR  IMPLIED  WARRANTIES,  INCLUDING,  BUT  NOT
+//  LIMITED  TO, THE  IMPLIED WARRANTIES OF  MERCHANTABILITY  AND FITNESS  FOR
+//  A  PARTICULAR  PURPOSE  ARE  DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT
+//  OWNER OR CONTRIBUTORS BE LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,
+//  SPECIAL,  EXEMPLARY,  OR  CONSEQUENTIAL   DAMAGES  (INCLUDING,   BUT   NOT
+//  LIMITED  TO,  PROCUREMENT  OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF USE,
+//  DATA,  OR PROFITS;  OR BUSINESS INTERRUPTION)  HOWEVER  CAUSED  AND ON ANY
+//  THEORY  OF  LIABILITY,  WHETHER  IN  CONTRACT,  STRICT LIABILITY,  OR TORT
+//  (INCLUDING  NEGLIGENCE  OR OTHERWISE) ARISING  IN ANY WAY  OUT  OF THE USE
+//  OF  THIS  SOFTWARE, EVEN IF ADVISED  OF  THE  POSSIBILITY  OF SUCH DAMAGE.
+//******************************************************************************
+//***************************************************************************
+//        FILE: aalbus-main.c
+//     CREATED: 02/15/2008
+//      AUTHOR: Joseph Grecco
+//              Alvin Chen
+//
+// PURPOSE:  This file contains the main startup and shutdown code for the
+//           Accelerator Abstraction Layer (AAL)
+//           Accelerator Hardware Module bus driver module
+// HISTORY:
+// COMMENTS:
+// WHEN:          WHO:     WHAT:
+// 02/15/2008     JG       Initial version started
+// 11/11/2008     JG       Added legal header
+// 11/25/2008     HM       Large merge
+// 01/04/2009     HM       Updated Copyright
+// 02/26/2009     JG       Support for NULL match() Implemented probe
+//                JG       Began dynamic config implementation
+//                         Eliminated Bridge device
+//                         Changed how register device works
+//                         Began supporting more get_device flags
+// 04/13/2009     JG       Added support for version kernel 2.6.27
+// 10/01/2009     HM       Fixed deactivate hang found by XDI and Joe
+// 10/01/2009     JG       Fixed a bug in unregister_device that caused
+//                         a segfault due to acessing the device after
+//                         destruction
+// 10/09/2009     AC       Added active uevent sending feature.
+// 02/11/2010     JG       Support for kernel 2.6.31
+// 04/28/2010     HM       Added return value checks to kosal_sem_get_krnl_alertable()
+//****************************************************************************
+#include "aalsdk/kernel/kosal.h"
+#include "aalbus-int.h"
+#include "aalsdk/kernel/aalinterface.h"
+#include "aalsdk/kernel/aalbus-device.h"
+
+#define MODULE_FLAGS AALBUS_DBG_MOD
+
+MODULE_VERSION    (DRV_VERSION);
+MODULE_DESCRIPTION(DRV_DESCRIPTION);
+MODULE_AUTHOR     (DRV_AUTHOR);
+MODULE_LICENSE    (DRV_LICENSE);
+
+//=============================================================================
+// Driver Parameters
+//=============================================================================
+
+
+//
+//  Declarations for module parameters - Enables parameter value passing from
+//                                       insmod and permissions as seen from /sys
+//
+
+// debug flag with default values
+
+btUnsignedInt debug = 0
+#if 0
+  | AALBUS_DBG_MOD
+  | AALBUS_DBG_FILE
+  | AALBUS_DBG_MMAP
+  | AALBUS_DBG_IOCTL
+#endif
+;
+
+#if   defined( __AAL_LINUX__ )
+MODULE_PARM_DESC(debug, "debug level");
+module_param    (debug, int, 0644);
+#endif // __AAL_LINUX__
+
+extern void aaldev_release_device(struct device *pdev);
+
+// Declare standard entry points
+static int
+aalbus_init(void);
+
+static
+void
+aalbus_exit(void);
+
+module_init(aalbus_init);
+module_exit(aalbus_exit);
+
+//=============================================================================
+// Prototypes
+//=============================================================================
+int
+aalbus_register_class_device(struct aal_classdevice *classdevice);
+void
+aalbus_unregister_class_device(struct aal_classdevice *classdevice);
+
+int
+aalbus_register_device(struct aal_device *dev);
+void
+aalbus_unregister_device(struct aal_device *dev);
+
+#if 0
+int
+aalbus_destroy_device(struct aal_device *devp);
+struct aal_device *
+aalbus_create_device(struct aal_device_id *devID,
+                     void * manifest);
+#endif
+
+btInt
+aalbus_init_driver(kosal_ownermodule      * ,
+                   struct aal_driver      * ,
+                   struct aal_classdevice * ,
+                   const char             * ,
+                   btInt );
+int
+aalbus_release_driver(struct aal_driver      * ,
+                      struct aal_classdevice * );
+int
+aalbus_register_driver(struct aal_driver *driver);
+void
+aalbus_unregister_driver(struct aal_driver *driver);
+
+int
+aalbus_register_service_interface(struct aal_interface *pinterface);
+int
+aalbus_unregister_service_interface(struct aal_interface *pinterface);
+
+int
+aalbus_send_uevent(struct aal_device *dev, enum kobject_action act, char *env[]);
+
+int
+aalbus_validate_device(struct aal_device *);
+
+//////////////////////////////////////////////////////////////////////////////////////////////
+struct aal_interface *
+aalbus_get_service_interface(btIID iid);
+void
+aalbus_release_service_interface(struct aal_interface *pinterface);
+int
+aalbus_has_interface(btIID iid);
+
+int
+aalbus_match(struct device* dev, struct device_driver *drv);
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,23)
+int
+aalbus_uevent(struct device *dev, struct kobj_uevent_env *env);
+#else
+int
+aalbus_uevent(struct device *dev,
+              char **envp,
+              int num_envp,
+              char *buffer,
+              int buffer_size);
+#endif
+
+int
+aalbus_probe(struct device * dev);
+int
+aalbus_remove(struct device * dev);
+void
+aalbus_shutdown(struct device * dev);
+int
+aalbus_suspend(struct device * dev, pm_message_t state);
+int
+aalbus_resume(struct device * dev);
+
+// Class methods
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,27)
+   #if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,23)
+   static
+   int
+   aalbus_class_uevent(struct class_device *dev,
+                       struct kobj_uevent_env *env);
+   #else
+   static
+   int
+   aalbus_class_uevent(struct class_device *dev,
+                       char **env,
+                       int num_envp,
+                       char *buffer,
+                       int buffer_size);
+   #endif
+#endif
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,26)
+void
+aalbus_class_device_release(struct device *);
+#else
+void
+aalbus_class_device_release(struct class_device *);
+#endif
+
+
+void
+aalbus_class_release(struct class *class);
+void
+aalbus_class_devrelease(struct device *dev);
+
+struct aal_device *
+aalbus_get_device(struct aal_device_id *devID, __u32 mask);
+struct aal_device *
+aalbus_handle_to_device(void *handle);
+
+int
+aalbus_register_config_update_handler(aalbus_event_config_update_t EventHandler,
+                                      void * context);
+int
+aalbus_config_update_event(struct device *pdev, void *data);
+int
+aalbus_send_config_update_event(struct aal_device *pdev,
+                                krms_cfgUpDate_e updatetype,
+                                btPID pid);
+
+//=============================================================================
+//=============================================================================
+
+static
+ssize_t
+aalbus_attrib_show_version(struct bus_type *bus, char *buf);
+
+static
+ssize_t
+aalbus_attrib_show_debug(struct bus_type *bus, char *buf);
+static
+ssize_t
+aalbus_attrib_store_debug(struct bus_type *bus, const char *buf, size_t size);
+
+//----------------------
+// Static bus attributes
+//----------------------
+BUS_ATTR(version,S_IRUGO,aalbus_attrib_show_version,NULL);
+BUS_ATTR(debug,S_IRUGO|S_IWUSR|S_IWGRP,aalbus_attrib_show_debug,aalbus_attrib_store_debug);
+
+//---------------
+// Bus Attributes
+//---------------
+
+//=============================================================================
+// Name: aalbus_attrib_show_version
+//=============================================================================
+static
+ssize_t
+aalbus_attrib_show_version(struct bus_type *bus, char *buf)
+{
+   return (snprintf(buf,PAGE_SIZE,"%s\n",DRV_VERSION));
+}
+
+//=============================================================================
+// Name: aalbus_attrib_show_debug
+//=============================================================================
+static
+ssize_t
+aalbus_attrib_show_debug(struct bus_type *bus, char *buf)
+{
+   return (snprintf(buf,PAGE_SIZE,"%d\n",debug));
+}
+
+//=============================================================================
+// Name: aalbus_attrib_store_debug
+//=============================================================================
+static
+ssize_t
+aalbus_attrib_store_debug(struct bus_type *bus,
+                          const char *buf,
+                          size_t size)
+{
+   int temp = 0;
+   sscanf(buf,"%d", &temp);
+   // Check for valid setting
+   if(temp & AALBUS_DBG_INVLID) {
+      // Invalid debug flag
+      printk (KERN_INFO DRV_NAME ": Ignoring invalid value (%d) for attribute [debug] \n", temp);
+      return -1;
+   }
+   debug = temp;
+   printk (KERN_INFO DRV_NAME ": Attribute change - Debug = %d\n", temp);
+   return size;
+}
+
+
+//-----------------------------------------------------------------------------
+//-----------------------------------------------------------------------------
+//                        Bus Module Public Interface
+//-----------------------------------------------------------------------------
+//-----------------------------------------------------------------------------
+
+//=============================================================================
+// Name: amhe_bus_type
+// Description: Static object presenting the Bus driver
+//=============================================================================
+static struct aal_bus_type aalBus =
+{
+   // Bus public interface
+   .m_bus =
+   {
+      .m_version                       = AAL_BUS_VERSION,
+      .INIT_FACT_CREATE_DEVICE         = aaldev_create_device,
+      .INIT_FACT_DESTROY_DEVICE        = aaldev_destroy_device,
+      .register_device                 = aalbus_register_device,
+      .unregister_device               = aalbus_unregister_device,
+      .get_device                      = aalbus_get_device,
+      .handle_to_device                = aalbus_handle_to_device,
+      .init_driver                     = aalbus_init_driver,
+      .release_driver                  = aalbus_release_driver,
+      .register_driver                 = aalbus_register_driver,
+      .unregister_driver               = aalbus_unregister_driver,
+      .register_class_device           = aalbus_register_class_device,
+      .unregister_class_device         = aalbus_unregister_class_device,
+      .register_service_interface      = aalbus_register_service_interface,
+      .unregister_service_interface    = aalbus_unregister_service_interface,
+      .get_service_interface           = aalbus_get_service_interface,
+      .release_service_interface       = aalbus_release_service_interface,
+      .has_interface                   = aalbus_has_interface,
+      .register_config_update_handler  = aalbus_register_config_update_handler,
+#if 0
+      .walk_device_chain               = aalbus_walk_device_chain,
+#endif
+      .send_config_update_event        = aalbus_send_config_update_event,
+//      .send_uevent                     = aalbus_send_uevent,
+      .dev_is_valid                    = aalbus_validate_device,
+   },
+
+   .config_update_event_handler = {
+      .EventHandler = NULL,
+      .context      = NULL,
+   },
+
+   .m_bustype = {
+      .name     = "aal",
+      .match    = aalbus_match,
+      .uevent   = aalbus_uevent,
+      .probe    = aalbus_probe,
+      .remove   = aalbus_remove,
+      .shutdown = aalbus_shutdown,
+      .suspend  = aalbus_suspend,
+      .resume   = aalbus_resume,
+   },
+
+   .m_flags = 0,
+};
+
+
+//=============================================================================
+// Name: aal_class
+// Description: Class object for all AAL real and  virtual devices
+//=============================================================================
+struct class_info
+{
+   struct class m_class;
+   btBool       m_isregistered;
+};
+static struct class_info aal_class =
+{
+   .m_class = {
+      .name             = "aal",
+      .owner            = THIS_MODULE,
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,27)
+      .uevent           = aalbus_class_uevent,
+      .release          = aalbus_class_device_release,
+#endif
+      .class_release    = aalbus_class_release,
+   },
+   .m_isregistered = false,
+};
+
+//=============================================================================
+// Name: aalbus_init
+// Description: Initialization routine for the module
+// Interface: public
+// Inputs: none.
+// Outputs: none.
+// Comments:
+//=============================================================================
+static
+int 
+aalbus_init(void)
+{
+   int ret;
+
+   kosal_printk_level(KERN_INFO, "Accelerator Abstraction Layer\n");
+   kosal_printk_level(KERN_INFO, "-> %s\n", DRV_DESCRIPTION);
+   kosal_printk_level(KERN_INFO, "-> Version %s\n",DRV_VERSION);
+   kosal_printk_level(KERN_INFO, "-> %s\n", DRV_COPYRIGHT);
+
+   /* initialize list heads and associated semaphores */
+   kosal_list_init(&aalBus.m_servicelist);
+   kosal_mutex_init(&aalBus.m_sem);
+   kosal_list_init(&aalBus.alloc_list_head);
+   kosal_mutex_init(&aalBus.alloc_list_sem);
+   kosal_mutex_init(&g_listlock);
+
+   //
+   // Register our bus subsystem with the kernel
+   //
+   ret = bus_register( &aalBus.m_bustype );
+   if ( ret < 0 ) {
+      kosal_printk_level(KERN_ERR, "Failed to register ret = %d\n", ret);
+      goto ERROR;
+   }
+   aal_bus_type_set_registered(&aalBus);
+
+   //----------------------------------
+   // Create the class container object
+   //----------------------------------
+   ret = class_register(&aal_class.m_class);
+   if ( 0 != ret ) {
+      kosal_printk_level(KERN_ERR, "Failed to register Class ret = %d\n", ret);
+      goto ERROR;
+   }
+   aal_class.m_isregistered = true;
+
+   //------------------
+   // Create attributes
+   //------------------
+   if ( bus_create_file(&aalBus.m_bustype, &bus_attr_version) ) {
+      kosal_printk_level(KERN_ERR, "Failed to create version attribute - Unloading module\n");
+      ret = -ENOMEM;
+      goto ERROR;
+   }
+
+   if ( bus_create_file(&aalBus.m_bustype, &bus_attr_debug) ) {
+      kosal_printk_level(KERN_ERR, "Failed to create debug attribute - Unloading module\n");
+      ret = -ENOMEM;
+      goto ERROR;
+   }
+
+   return 0;
+
+ERROR:
+
+   if ( aal_class.m_isregistered ) {
+      class_unregister(&aal_class.m_class);
+      aal_class.m_isregistered = false;
+   }
+
+   if ( aal_bus_type_is_registered(&aalBus) ) {
+      bus_unregister(&aalBus.m_bustype);
+      aal_bus_type_clr_registered(&aalBus);
+   }
+
+   return ret;
+}
+//=============================================================================
+// Name: aalbus_exit
+// Description: Removes device from filesystem and acpm registration
+// Interface: public
+// Inputs: none.
+// Outputs: none.
+// Comments:
+//=============================================================================
+static
+void
+aalbus_exit(void)
+{
+   kosal_printk_level(KERN_INFO, "<- AAL Bus exiting\n");
+
+   if ( aal_class.m_isregistered ) {
+      class_unregister(&aal_class.m_class);
+      aal_class.m_isregistered = false;
+   }
+
+   if ( aal_bus_type_is_registered(&aalBus) ) {
+      bus_unregister(&aalBus.m_bustype);
+      aal_bus_type_clr_registered(&aalBus);
+   }
+
+   kosal_printk_level(KERN_INFO, "<- %s removed.\n", DRV_DESCRIPTION);
+}
+
+
+//=============================================================================
+// Name: aalbus_get_bus
+// Description: Returns a pointer to the bus object
+// Interface: public export
+// Inputs: none.
+// Returns: Pointer to aalbus object
+// Comments: Used by clients of the bus to get access to the bus interface
+//=============================================================================
+struct aal_bus *
+aalbus_get_bus(void)
+{
+   return aal_bus_type_aal_busp(&aalBus);
+}
+//=============================================================================
+// Name:  aalbus_match
+// Description: Queries a driver to determine if it supports a device
+// Interface: public
+// Inputs: dev - device to examine
+//         drv - driver to query
+// Outputs: 1 - match.
+// Comments:
+//=============================================================================
+int
+aalbus_match(struct device *dev, struct device_driver *drv)
+{
+#if (1 == ENABLE_CANARIES)
+   btBool valid;
+   struct aal_driver *paal_driver = base_to_aaldrv(drv);
+
+   ASSERT(dev);
+   ASSERT(drv);
+   if ( (NULL == dev) || (NULL == drv) ) {
+      return 0;
+   }
+
+   canaries_are_valid(struct_aal_driver, paal_driver, valid);
+   ASSERT(valid);
+   if ( !valid ) {
+      return 0;
+   }
+#endif // ENABLE_CANARIES
+
+   if ( NULL != base_to_aaldrv(drv)->m_match ) {
+      return base_to_aaldrv(drv)->m_match(base_to_aaldrv(drv),
+                                          basedev_to_aaldev(dev));
+   }
+   return 0;
+}
+
+//=============================================================================
+// Name:  aalbus_uevent
+// Description:
+// Interface:
+// Inputs: none.
+// Outputs: none.
+// Comments:
+//=============================================================================
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,23)
+int
+aalbus_uevent(struct device          *dev,
+              struct kobj_uevent_env *env)
+{
+   PTRACEIN;
+#if 0
+   if ( NULL != basedev_to_aaldev(dev)->m_uevent ) {
+      return basedev_to_aaldev(dev)->m_uevent(basedev_to_aaldev(dev), env);
+   }
+#endif
+   return 0;
+}
+#else
+int
+aalbus_uevent(struct device *dev,
+              char         **envp,
+              int            num_envp,
+              char          *buffer,
+              int            buffer_size)
+{
+   kosal_printk_level(KERN_INFO, "Entered.\n");
+   if ( NULL != basedev_to_aaldev(dev)->m_uevent ) {
+      return basedev_to_aaldev(dev)->m_uevent(basedev_to_aaldev(dev), envp, num_envp, buffer, buffer_size);
+   }
+   return 0;
+}
+#endif
+
+//=============================================================================
+// Name:  aalbus_probe
+// Description:
+// Interface:
+// Inputs: none.
+// Outputs: none.
+// Comments:
+//=============================================================================
+int
+aalbus_probe(struct device *dev)
+{
+#if (1 == ENABLE_CANARIES)
+   btBool valid;
+   struct aal_driver *paal_driver = base_to_aaldrv(dev->driver);
+
+   ASSERT(dev);
+   if ( NULL == dev ) {
+      return 0;
+   }
+
+   canaries_are_valid(struct_aal_driver, paal_driver, valid);
+   ASSERT(valid);
+   if ( !valid ) {
+      return 0;
+   }
+#endif // ENABLE_CANARIES
+
+   kosal_printk_level(KERN_INFO, "Entered.\n");
+   if ( NULL != base_to_aaldrv(dev->driver)->m_probe ) {
+      return base_to_aaldrv(dev->driver)->m_probe(basedev_to_aaldev(dev));
+   } else {
+      kosal_printk_level(KERN_INFO, "No probe function for matched driver.\n");
+   }
+   return 0;
+}
+
+
+//=============================================================================
+// Name:  aalbus_remove
+// Description:
+// Interface:
+// Inputs: none.
+// Outputs: none.
+// Comments:
+//=============================================================================
+int
+aalbus_remove(struct device *dev)
+{
+   kosal_printk_level(KERN_INFO, "Entered.\n");
+   return 0;
+}
+
+//=============================================================================
+// Name:  aalbus_shutdown
+// Description:
+// Interface:
+// Inputs: none.
+// Outputs: none.
+// Comments:
+//=============================================================================
+void
+aalbus_shutdown(struct device *dev)
+{
+   PTRACEIN;
+   return;
+}
+
+//=============================================================================
+// Name:  aalbus_suspend
+// Description:
+// Interface:
+// Inputs: none.
+// Outputs: none.
+// Comments:
+//=============================================================================
+int
+aalbus_suspend(struct device *dev, pm_message_t state)
+{
+   PTRACEIN;
+   return 0;
+}
+
+
+//=============================================================================
+// Name:  aalbus_resume
+// Description:
+// Interface:
+// Inputs: none.
+// Outputs: none.
+// Comments:
+//=============================================================================
+int
+aalbus_resume(struct device *dev)
+{
+   PTRACEIN;
+   return 0;
+}
+
+//=============================================================================
+// Name:  aalbus_register_device
+// Description:  This function registers a device with the core. It is
+//               called by the bus level driver whenever a new device is
+//               detected. This includes AHMs and AFUs in the case of a
+//               reconfigure request. If there are drivers installed they will
+//               be probed to determine if any support this device.
+// Interface:
+// Inputs: paaldev - device to register
+// Outputs: none.
+// Comments:
+//=============================================================================
+int
+aalbus_register_device(struct aal_device *paaldev)
+{
+   struct update_config_parms parms;
+
+   DPRINTF(AALBUS_DBG_MOD, "Registering device %s\n", aaldev_devname(paaldev));
+
+   if ( unlikely( !aaldev_init(paaldev) ) ) {
+      kosal_printk_level(KERN_ERR, "Device registration failed\n");
+      return -1;
+   }
+
+   // Do not permit multiple registrations
+   ASSERT(!aaldev_is_registered(paaldev));
+   if ( aaldev_is_registered(paaldev) ) {
+	   DPRINTF(AALBUS_DBG_MOD, "Device already registered with AAL Bus\n");
+      return -1;
+   }
+
+   // kosal_sem_get_user_alertable(&aalBus.m_sem);
+   if ( unlikely( kosal_sem_get_user_alertable(&aalBus.m_sem) ) ) {
+      kosal_printk_level(KERN_ERR, "kosal_sem_get_user_alertable interrupted\n");
+      return -1;
+   }
+
+   aaldev_to_basedev(paaldev).bus = &aalBus.m_bustype;
+
+   // Add this device to the bus' list of devices
+   if (0 !=  kosal_sem_get_user_alertable(&aalBus.alloc_list_sem)) {
+      DPRINTF(AALBUS_DBG_MOD, " Failed to acquire allocate list semaphore\n");
+      return -1;
+   } else {
+      list_add(&paaldev->m_alloc_list, &aalBus.alloc_list_head);
+      kosal_sem_put(&aalBus.alloc_list_sem);
+   }
+
+   paaldev->m_dev.release = aaldev_release_device; // System method
+
+   // device_register(&AALDEVBASE(dev));
+   if ( device_register(&aaldev_to_basedev(paaldev)) ) {
+      PERR("device_register() failed; could not register device %s\n", paaldev->m_basename);
+      kosal_sem_put(&aalBus.m_sem);
+      return -1;
+   }
+
+
+   // Generate a config update event TODO - This should move to Device
+   if ( aalBus.config_update_event_handler.EventHandler ) {
+      parms.Handler    = aalBus.config_update_event_handler.EventHandler;
+      parms.updateType = krms_ccfgUpdate_DevAdded;
+      parms.pid        = 0;
+      aalbus_config_update_event(&aaldev_to_basedev(paaldev), &parms);
+   }
+
+   aaldev_set_registered(paaldev);
+   kosal_sem_put(&aalBus.m_sem);
+
+   DPRINTF(AALBUS_DBG_MOD,  "Done registering device %s\n",aaldev_devname(paaldev));
+
+   return 0;
+}
+
+//=============================================================================
+// Name:  aalbus_unregister_device
+// Description: Unregisters a device from the core.  Issued by the bus driver
+//              when an AHM or AFU are taken off line or removed.
+// Interface:
+// Inputs: none.
+// Outputs: none.
+// Comments:
+//=============================================================================
+void
+aalbus_unregister_device(struct aal_device *dev)
+{
+#if (1 == ENABLE_DEBUG)
+   if( &aalBus.m_bustype == aaldev_to_basedev(dev).bus ){
+      kosal_printk_level(KERN_INFO, "Unregistering AAL device \"%s\"\n", aaldev_devname(dev));
+   }
+#endif // ENABLE_DEBUG
+
+   // Do not unregister devices not registered
+   ASSERT(aaldev_is_registered(dev));
+   if ( !aaldev_is_registered(dev) ) {
+      kosal_printk_level(KERN_WARNING, "Device not registered with AAL Bus\n");
+      return;
+   }
+
+   // Remove the device. This causes the device to signal its
+   //  removal from the system
+   dev_removedevice(dev);
+
+   // Begin the process of unplugging the device from the framework
+   //  the device_unregister() causes the Linux DD framework to generate
+   //  the device::release() callback to be invoked. This is where the device
+   //  specifc clean-up will occur.  Once the device_register() returns assume
+   //  dev is deleted.
+   device_unregister(&aaldev_to_basedev(dev));
+   aaldev_clr_registered(dev);
+
+   kosal_printk_level(KERN_INFO, "Done unregistering device\n");
+   return;
+}
+
+
+#if (0 && (1 == ENABLE_DEBUG))
+
+static
+struct aal_interface *
+debug_hook_get_interface(struct aal_driver *drv, btIID iid)
+{
+   DPRINTF(AALBUS_DBG_MOD, "FAILED %s(drv=0x%p, iid=0x%llx)\n",
+              __AAL_FUNC__, drv, iid);
+   return NULL;
+}
+static
+int
+debug_hook_has_interface(struct aal_driver *drv, btIID iid)
+{
+   DPRINTF(AALBUS_DBG_MOD, "FAILED %s(drv=0x%p, iid=0x%llx)\n",
+              __AAL_FUNC__, drv, iid);
+   return 0;
+}
+static
+int
+debug_hook_supports_interface(struct aal_driver *drv, btIID iid)
+{
+   DPRINTF(AALBUS_DBG_MOD, "FAILED %s(drv=0x%p, iid=0x%llx)\n",
+              __AAL_FUNC__, drv, iid);
+   return 0;
+}
+static
+int
+debug_hook_match(struct aal_driver *drv, struct aal_device *dev)
+{
+   DPRINTF(AALBUS_DBG_MOD, "FAILED %s(drv=0x%p, dev=0x%p)\n",
+              __AAL_FUNC__, drv, dev);
+   return 0;
+}
+static
+int
+debug_hook_probe(struct aal_device *dev)
+{
+   DPRINTF(AALBUS_DBG_MOD, "FAILED %s(dev=0x%p)\n",
+              __AAL_FUNC__, dev);
+   return 0;
+}
+static
+unsigned int
+debug_hook_fops_poll(struct file *f, struct poll_table_struct *pt)
+{
+   DPRINTF(AALBUS_DBG_MOD, "FAILED %s(struct file *=0x%p, struct poll_table_struct *=0x%p)\n",
+              __AAL_FUNC__, f, pt);
+   return 0;
+}
+static
+long
+debug_hook_fops_unlocked_ioctl(struct file *f, unsigned int a, unsigned long b)
+{
+   DPRINTF(AALBUS_DBG_MOD, "FAILED %s(struct file *=0x%p, unsigned int=%u, unsigned long=%lu)\n",
+              __AAL_FUNC__, f, a, b);
+   return 0;
+}
+static
+int
+debug_hook_fops_mmap(struct file *f, struct vm_area_struct *vma)
+{
+   DPRINTF(AALBUS_DBG_MOD, "FAILED %s(struct file *=0x%p, struct vm_area_struct *=0x%p)\n",
+              __AAL_FUNC__, f, vma);
+   return 0;
+}
+static
+int
+debug_hook_fops_open(struct inode *inod, struct file *f)
+{
+   DPRINTF(AALBUS_DBG_MOD, "FAILED %s(struct inode *=0x%p, struct file *=0x%p)\n",
+              __AAL_FUNC__, inod, f);
+   return 0;
+}
+static
+int
+debug_hook_fops_release(struct inode *inod, struct file *f)
+{
+   DPRINTF(AALBUS_DBG_MOD, "FAILED %s(struct inode *=0x%p, struct file *=0x%p)\n",
+              __AAL_FUNC__, inod, f);
+   return 0;
+}
+
+static
+void
+aalbus_driver_debug_hook_fops(struct file_operations *fops)
+{
+   if ( NULL == fops->poll ) {
+      fops->poll = debug_hook_fops_poll;
+      DPRINTF(AALBUS_DBG_MOD, " hooked fops->poll\n");
+   }
+   if ( NULL == fops->unlocked_ioctl ) {
+      fops->unlocked_ioctl = debug_hook_fops_unlocked_ioctl;
+      DPRINTF(AALBUS_DBG_MOD, " hooked fops->unlocked_ioctl\n");
+   }
+   if ( NULL == fops->mmap ) {
+      fops->mmap = debug_hook_fops_mmap;
+      DPRINTF(AALBUS_DBG_MOD, " hooked fops->mmap\n");
+   }
+   if ( NULL == fops->open ) {
+      fops->open = debug_hook_fops_open;
+      DPRINTF(AALBUS_DBG_MOD, " hooked fops->open\n");
+   }
+   if ( NULL == fops->release ) {
+      fops->release = debug_hook_fops_release;
+      DPRINTF(AALBUS_DBG_MOD, " hooked fops->release\n");
+   }
+}
+
+static
+int
+debug_hook_dd_probe(struct device *dev)
+{
+   DPRINTF(AALBUS_DBG_MOD, "FAILED %s(struct device *=0x%p)\n",
+              __AAL_FUNC__, dev);
+   return 0;
+}
+static
+int
+debug_hook_dd_remove(struct device *dev)
+{
+   DPRINTF(AALBUS_DBG_MOD, "FAILED %s(struct device *=0x%p)\n",
+              __AAL_FUNC__, dev);
+   return 0;
+}
+static
+void
+debug_hook_dd_shutdown(struct device *dev)
+{
+   DPRINTF(AALBUS_DBG_MOD, "FAILED %s(struct device *=0x%p)\n",
+              __AAL_FUNC__, dev);
+}
+static
+int
+debug_hook_dd_suspend(struct device *dev, pm_message_t state)
+{
+   DPRINTF(AALBUS_DBG_MOD, "FAILED %s(struct device *=0x%p, pm_message_t)\n",
+              __AAL_FUNC__, dev);
+   return 0;
+}
+static
+int
+debug_hook_dd_resume(struct device *dev)
+{
+   DPRINTF(AALBUS_DBG_MOD, "FAILED %s(struct device *=0x%p)\n",
+              __AAL_FUNC__, dev);
+   return 0;
+}
+
+static
+void
+aalbus_driver_debug_hook_device_driver(struct device_driver *dd)
+{
+   if ( NULL == dd->probe ) {
+      dd->probe = debug_hook_dd_probe;
+      DPRINTF(AALBUS_DBG_MOD, " hooked dd->probe\n");
+   }
+   if ( NULL == dd->remove ) {
+      dd->remove = debug_hook_dd_remove;
+      DPRINTF(AALBUS_DBG_MOD, " hooked dd->remove\n");
+   }
+   if ( NULL == dd->shutdown ) {
+      dd->shutdown = debug_hook_dd_shutdown;
+      DPRINTF(AALBUS_DBG_MOD, " hooked dd->shutdown\n");
+   }
+   if ( NULL == dd->suspend ) {
+      dd->suspend = debug_hook_dd_suspend;
+      DPRINTF(AALBUS_DBG_MOD, " hooked dd->suspend\n");
+   }
+   if ( NULL == dd->resume ) {
+      dd->resume = debug_hook_dd_resume;
+      DPRINTF(AALBUS_DBG_MOD, " hooked dd->resume\n");
+   }
+}
+
+static
+void
+aalbus_driver_debug_hook_class_device_release(struct device *dev)
+{
+   DPRINTF(AALBUS_DBG_MOD, "FAILED %s(struct device *=0x%p)\n",
+              __AAL_FUNC__, dev);
+}
+
+static
+void
+aalbus_driver_debug_hook_class_device(struct aal_driver      *pdrv,
+                                      struct aal_classdevice *pclassdev)
+{
+   int    i;
+   btIID *devid;
+
+   if ( NULL == pclassdev ) {
+      return;
+   }
+
+   DPRINTF(AALBUS_DBG_MOD, " pclassdev->m_flags=0x%x\n", pclassdev->m_flags);
+   DPRINTF(AALBUS_DBG_MOD, " pclassdev->m_classid.m_majorversion=0x%x\n", pclassdev->m_classid.m_majorversion);
+   DPRINTF(AALBUS_DBG_MOD, " pclassdev->m_classid.m_minorversion=0x%x\n", pclassdev->m_classid.m_minorversion);
+   DPRINTF(AALBUS_DBG_MOD, " pclassdev->m_classid.m_releaseversion=0x%llx\n", pclassdev->m_classid.m_releaseversion);
+   DPRINTF(AALBUS_DBG_MOD, " pclassdev->m_classid.m_classGUID=0x%llx\n", pclassdev->m_classid.m_classGUID);
+
+   DPRINTF(AALBUS_DBG_MOD, " pclassdev->m_devIIDlist=0x%p\n", pclassdev->m_devIIDlist);
+   if ( NULL != pclassdev->m_devIIDlist ) {
+      i = 0;
+      devid = pclassdev->m_devIIDlist;
+      while ( *devid ) {
+         DPRINTF(AALBUS_DBG_MOD, " pclassdev->m_devIIDlist[%d]=%llx\n", i, *devid);
+         ++i;
+         ++devid;
+      }
+   }
+
+
+   DPRINTF(AALBUS_DBG_MOD, " pclassdev->m_bus=0x%p\n", pclassdev->m_bus);
+/*
+   if ( NULL == pclassdev->m_bus ) {
+      pclassdev->m_bus = &aalBus.m_bus;
+      //pclassdev->m_bus = aaldrv_aalbusp(pdrv);
+      DPRINTF(AALBUS_DBG_MOD, " patched NULL pclassdev->m_bus (0x%p)\n", pclassdev->m_bus);
+   }
+*/
+
+   DPRINTF(AALBUS_DBG_MOD, " pclassdev->m_classdev.bus=0x%p\n", pclassdev->m_classdev.bus);
+/*
+   if ( NULL == pclassdev->m_classdev.bus ) {
+      pclassdev->m_classdev.bus = &aalBus.m_bustype;
+      //pclassdev->m_classdev.bus = aaldrv_to_base_busp(pdrv);
+      DPRINTF(AALBUS_DBG_MOD, " patched NULL pclassdev->m_classdev.bus (0x%p)\n", pclassdev->m_classdev.bus);
+   }
+*/
+
+   DPRINTF(AALBUS_DBG_MOD, " pclassdev->m_classdev.driver=0x%p\n", pclassdev->m_classdev.driver);
+/*
+   if ( NULL == pclassdev->m_classdev.driver ) {
+      pclassdev->m_classdev.driver = aaldrv_to_basep(pdrv);
+      DPRINTF(AALBUS_DBG_MOD, " patched NULL pclassdev->m_classdev.driver (0x%p)\n", pclassdev->m_classdev.driver);
+   }
+*/
+
+   DPRINTF(AALBUS_DBG_MOD, " pclassdev->m_classdev.driver=0x%p\n", pclassdev->m_classdev.driver);
+/*
+   if ( NULL == pclassdev->m_classdev.init_name ) {
+      pclassdev->m_classdev.init_name = "patched";
+      DPRINTF(AALBUS_DBG_MOD, " patched NULL pclassdev->m_classdev.init_name (\"%s\")\n", pclassdev->m_classdev.init_name);
+   }
+*/
+//   pclassdev->m_classdev.release = aalbus_driver_debug_hook_class_device_release;
+}
+
+static
+void
+aalbus_driver_debug_hook(struct module          *powner,
+                         struct aal_driver      *pdrv,
+                         struct aal_classdevice *pclassdev,
+                         const char             *devname,
+                         int                     devmajor)
+{
+   const struct aal_device_id *devid;
+   int                         i;
+
+   DPRINTF(AALBUS_DBG_MOD, " Entering %s(powner=0x%p, pdrv=0x%p, pclassdev=0x%p, devname=\"%s\", devmajor=%d)\n",
+              __AAL_FUNC__,
+              powner,
+              pdrv,
+              pclassdev,
+              (NULL == devname) ? "<null>" : devname,
+              devmajor
+              );
+
+   ASSERT(powner);
+   if ( NULL == powner ) {
+      return;
+   }
+
+   ASSERT(pdrv);
+   if ( NULL == pdrv ) {
+      return;
+   }
+
+   DPRINTF(AALBUS_DBG_MOD, " pdrv->m_flags=0x%x\n", pdrv->m_flags);
+
+   if ( NULL == pdrv->get_interface ) {
+      pdrv->get_interface = debug_hook_get_interface;
+      DPRINTF(AALBUS_DBG_MOD, " hooked get_interface\n");
+   }
+   if ( NULL == pdrv->has_interface ) {
+      pdrv->has_interface = debug_hook_has_interface;
+      DPRINTF(AALBUS_DBG_MOD, " hooked has_interface\n");
+   }
+   if ( NULL == pdrv->supports_interface ) {
+      pdrv->supports_interface = debug_hook_supports_interface;
+      DPRINTF(AALBUS_DBG_MOD, " hooked supports_interface\n");
+   }
+
+   aalbus_driver_debug_hook_fops(&pdrv->m_fops);
+
+   //struct cdev                 m_cdev;  // character device
+
+   DPRINTF(AALBUS_DBG_MOD, " pdrv->m_major=%d\n", pdrv->m_major);
+   DPRINTF(AALBUS_DBG_MOD, " pdrv->m_iids=0x%p\n", pdrv->m_iids);
+
+   DPRINTF(AALBUS_DBG_MOD, " pdrv->m_idtable=0x%p\n", pdrv->m_idtable);
+   if ( NULL != pdrv->m_idtable ) {
+      devid = pdrv->m_idtable;
+      i = 0;
+      while ( devid->m_devaddr.m_bustype ) {
+         DPRINTF(AALBUS_DBG_MOD, " devid[%d].m_vendor=0x%x\n", i, devid->m_vendor);
+         ++i;
+         ++devid;
+      }
+   }
+
+   if ( NULL == pdrv->m_match ) {
+      pdrv->m_match = debug_hook_match;
+      DPRINTF(AALBUS_DBG_MOD, " hooked m_match\n");
+   }
+   if ( NULL == pdrv->m_probe ) {
+      pdrv->m_probe = debug_hook_probe;
+      DPRINTF(AALBUS_DBG_MOD, " hooked m_probe\n");
+   }
+
+   DPRINTF(AALBUS_DBG_MOD, " pdrv->m_bus=0x%p\n", pdrv->m_bus);
+
+   aalbus_driver_debug_hook_device_driver(&pdrv->m_driver);
+
+   aalbus_driver_debug_hook_class_device(pdrv, pclassdev);
+
+   DPRINTF(AALBUS_DBG_MOD, " Leaving %s()\n", __AAL_FUNC__);
+}
+
+#endif // ENABLE_DEBUG
+
+
+//=============================================================================
+// Name:  aalbus_init_driver
+// Description:
+//
+//
+// Interface: public
+// Inputs: none.
+// Outputs: none.
+// Comments: Initializes all of the driver structures
+//=============================================================================
+btInt
+aalbus_init_driver(kosal_ownermodule      *powner,
+                   struct aal_driver      *pdrv,
+                   struct aal_classdevice *pclassdev,
+                   const char             *devname,
+                   btInt                   devmajor)
+{
+   int             res     = 0;
+   dev_t           devtype = 0;
+   struct aal_bus *pbus;
+
+   ASSERT(powner);
+   if ( NULL == powner ) {
+      PERR("Got NULL struct module *\n");
+      return -EINVAL;
+   }
+
+   ASSERT(pdrv);
+   if ( NULL == pdrv ) {
+      PERR("Got NULL struct aal_driver *\n");
+      return -EINVAL;
+   }
+
+   if ( NULL == aaldrv_to_base(pdrv).name ) {
+      ASSERT(devname);
+      if ( NULL == devname ) {
+         PERR("No name in struct device_driver and NULL devname.\n");
+         return -EINVAL;
+      }
+
+      aaldrv_to_base(pdrv).name = devname;
+   }
+
+   if ( NULL != pclassdev ) {
+      ASSERT(devname);
+      if ( NULL == devname ) {
+         PERR("Class device 0x%p requested, but devname is NULL.\n", pclassdev);
+         return -EINVAL;
+      }
+   }
+
+   pbus = aalbus_get_bus();
+   ASSERT(pbus);
+   if ( NULL == pbus ) {
+      return -EFAULT;
+   }
+
+   kosal_list_init(&pdrv->m_sesslist);
+
+   if ( NULL != devname ) {
+      // char device node requested - get a major device number
+
+      //  use the value passed at load time or allocate dynamically
+      if ( 0 != devmajor ) {
+         // major number requested at load time
+         PDEBUG("Registering static major number %d for \"%s\"\n",
+                   devmajor, devname);
+
+         devtype = MKDEV(devmajor, 0);
+         res = register_chrdev_region(devtype, 1, devname);
+
+         if ( res < 0 ) {
+            PERR("Failed to register major device number %d for \"%s\"\n",
+                    devmajor, devname);
+            return res;
+         }
+      } else {
+         // Dynamically allocate the major number
+         PDEBUG("Allocating major number for \"%s\"\n", devname);
+
+         res = alloc_chrdev_region(&devtype, 0, 1, devname);
+
+         if ( res < 0 ) {
+            PERR("Failed to allocate major device number for \"%s\"\n", devname);
+            return res;
+         }
+
+         aaldrv_dev_major(pdrv) = MAJOR(devtype);
+         PDEBUG("Using major number %d for \"%s\"\n", aaldrv_dev_major(pdrv), devname);
+      }
+
+      aaldrv_set_chrdev_region_obtained(pdrv);
+   }
+
+
+   // Register the driver with the AALbus
+   aaldrv_fops(pdrv).owner    = (struct module *)powner;
+   aaldrv_to_base(pdrv).owner = (struct module *)powner;
+
+   res = pbus->register_driver(pdrv);
+   if ( res < 0 ) {
+      goto ERROR;
+   }
+
+   if ( NULL != devname ) {
+      // Add the char device
+
+      cdev_init(aaldrv_cdevp(pdrv), aaldrv_fopsp(pdrv));
+      aaldrv_cdevp(pdrv)->ops   = aaldrv_fopsp(pdrv);
+      aaldrv_cdevp(pdrv)->owner = (struct module *)powner;
+
+      res = cdev_add(aaldrv_cdevp(pdrv), devtype, 1);
+      if ( res ) {
+         PERR("Failed to register character device : ret = %d\n", res);
+         goto ERROR;
+      }
+
+      aaldrv_set_chrdev_added(pdrv);
+   }
+
+
+   // Register the class device, if any.
+   if ( NULL != pclassdev ) {
+
+      aal_classdev_set_name(pclassdev, devname);
+      aal_classdev_devtype(pclassdev) = devtype;
+
+      PDEBUG("Registering class \"%s\"\n", aal_classdev_get_name(pclassdev));
+
+      res = pbus->register_class_device(pclassdev);
+      if ( res < 0 ) {
+         goto ERROR;
+      }
+   }
+
+#if (0 && (1 == ENABLE_DEBUG))
+   aalbus_driver_debug_hook(powner, pdrv, pclassdev, devname, devmajor);
+#endif
+
+   return res;
+
+ERROR:
+
+   if ( NULL != pclassdev ) {
+      if ( aal_classdev_is_registered(pclassdev) ) {
+         pbus->unregister_class_device(pclassdev);
+      }
+   }
+
+   if ( aaldrv_is_chrdev_added(pdrv) ) {
+      cdev_del(aaldrv_cdevp(pdrv));
+      aaldrv_clr_chrdev_added(pdrv);
+   }
+
+   if ( aaldrv_is_registered(pdrv) ) {
+      pbus->unregister_driver(pdrv);
+   }
+
+   if ( aaldrv_is_chrdev_region_obtained(pdrv) ) {
+      unregister_chrdev_region(devtype, 1);
+      aaldrv_clr_chrdev_region_obtained(pdrv);
+   }
+
+   return res;
+}
+
+//=============================================================================
+// Name:  aalbus_release_driver
+// Description:
+//
+//
+// Interface: public
+// Inputs: none.
+// Outputs: none.
+// Comments: Initializes all of the driver structures
+//=============================================================================
+int
+aalbus_release_driver(struct aal_driver      *pdrv,
+                      struct aal_classdevice *pclassdev)
+{
+   int             devmajor;
+   dev_t           devtype;
+   struct aal_bus *pbus;
+
+   ASSERT(pdrv);
+   if ( NULL == pdrv ) {
+      PERR("Got NULL struct aal_driver *\n");
+      return -EINVAL;
+   }
+
+   pbus = aalbus_get_bus();
+   ASSERT(pbus);
+   if ( NULL == pbus ) {
+      return -EFAULT;
+   }
+
+   if ( NULL != pclassdev ) {
+      if ( aal_classdev_is_registered(pclassdev) ) {
+         pbus->unregister_class_device(pclassdev);
+      }
+   }
+
+   if ( aaldrv_is_chrdev_added(pdrv) ) {
+      cdev_del(aaldrv_cdevp(pdrv));
+      aaldrv_clr_chrdev_added(pdrv);
+   }
+
+   if ( aaldrv_is_registered(pdrv) ) {
+      pbus->unregister_driver(pdrv);
+   }
+
+   if ( aaldrv_is_chrdev_region_obtained(pdrv) ) {
+      devmajor = aaldrv_dev_major(pdrv);
+      devtype  = MKDEV(devmajor, 0);
+      unregister_chrdev_region(devtype, 1);
+      aaldrv_clr_chrdev_region_obtained(pdrv);
+   }
+
+   return 0;
+}
+
+//=============================================================================
+// Name:  aalbus_register_driver
+// Description:  Called by a device driver to register with the bus.  If there
+//               are any devices installed they will be probed to determine if
+//               the driver supports them.
+// Interface: public
+// Inputs: none.
+// Outputs: none.
+// Comments: Initializes all of the driver structures
+//=============================================================================
+int
+aalbus_register_driver(struct aal_driver *driver)
+{
+   int ret = 0;
+#if (1 == ENABLE_CANARIES)
+   btBool valid;
+   canaries_are_valid(struct_aal_driver, driver, valid);
+   ASSERT(!valid);
+   canaries_init(struct_aal_driver, driver);
+#endif // ENABLE_CANARIES
+
+   DPRINTF(AALBUS_DBG_MOD, ": Registering device driver\n");
+
+   ASSERT(!aaldrv_is_registered(driver));
+   if ( aaldrv_is_registered(driver) ) {
+      return -EINVAL;
+   }
+
+   if ( NULL == driver->m_match ) {
+	   DPRINTF(AALBUS_DBG_MOD, ": No match method\n");
+   }
+   // Point driver at bus. Bus performs canonical methods for driver
+   aaldrv_to_base_busp(driver) = &aalBus.m_bustype;
+   aaldrv_aalbusp(driver)      = &aalBus.m_bus;
+
+   // Register driver with system.  Will cause devices to be probed
+   ret = driver_register(aaldrv_to_basep(driver));
+   if ( ret < 0 )   {
+	   DPRINTF(AALBUS_DBG_MOD, ": Driver_registration failed!\n");
+      return ret;
+   }
+
+   aaldrv_set_is_registered(driver);
+   return 0;
+}
+
+//=============================================================================
+// Name:  aalbus_unregister_driver
+// Description: Called by a device driver to unregister
+// Interface:
+// Inputs: none.
+// Outputs: none.
+// Comments:
+//=============================================================================
+void
+aalbus_unregister_driver(struct aal_driver *driver)
+{
+#if (1 == ENABLE_CANARIES)
+   btBool valid;
+   canaries_are_valid(struct_aal_driver, driver, valid);
+   ASSERT(valid);
+#endif // ENABLE_CANARIES
+
+   DPRINTF(AALBUS_DBG_MOD, ": Unregistering device driver\n");
+
+   ASSERT(aaldrv_is_registered(driver));
+   if ( aaldrv_is_registered(driver) ) {
+      driver_unregister(aaldrv_to_basep(driver));
+      aaldrv_clr_is_registered(driver);
+   }
+
+   DPRINTF(AALBUS_DBG_MOD,  "Done Unregistering device driver\n");
+
+#if (1 == ENABLE_CANARIES)
+   canaries_clear(struct_aal_driver, driver);
+#endif
+}
+
+//=============================================================================
+// Name:  aalbus_register_class_device
+// Description: Called by drivers such as interface drivers to create class
+//              devices
+// Interface: public
+// Inputs: none.
+// Outputs: none.
+// Comments: Initializes all of the driver structures
+//=============================================================================
+int
+aalbus_register_class_device(struct aal_classdevice *pclassdevice)
+{
+   int ret = 0;
+
+   ASSERT(!aal_classdev_is_registered(pclassdevice));
+   if ( aal_classdev_is_registered(pclassdevice) ) {
+      return -EINVAL;
+   }
+
+   // Point class device at AAL class.
+   pclassdevice->m_classdev.class = &aal_class.m_class;
+
+   // Register driver with system.  Will cause devices to be probed
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,26)
+
+   //Install the default release handler if one has not been specified
+   if ( NULL == aal_classdevp_to_dev(pclassdevice).release ) {
+      aal_classdevp_to_dev(pclassdevice).release = aalbus_class_device_release;
+   }
+   ret = device_register(&pclassdevice->m_classdev);
+#else
+   DPRINTF(AALBUS_DBG_MOD, ": Registering class device %s.\n",pclassdevice->m_classdev.class_id);
+   ret = class_device_register(&pclassdevice->m_classdev);
+#endif
+   if( ret < 0 )   {
+      DPRINTF(AALBUS_DBG_MOD, ": Class device registration failed!\n");
+      return ret;
+   }
+
+   aal_classdev_set_registered(pclassdevice);
+   return 0;
+}
+
+//=============================================================================
+// Name:  aalbus_unregister_class_device
+// Description: Called by a drivers to unregister class devices
+// Interface:
+// Inputs: none.
+// Outputs: none.
+// Comments:
+//=============================================================================
+void
+aalbus_unregister_class_device(struct aal_classdevice *pclassdevice)
+{
+   DPRINTF(AALBUS_DBG_MOD,  "Unregistering class device driver\n");
+
+   ASSERT(aal_classdev_is_registered(pclassdevice));
+   if ( aal_classdev_is_registered(pclassdevice) ) {
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,26)
+      device_unregister(&pclassdevice->m_classdev);
+#else
+      class_device_unregister(&pclassdevice->m_classdev);
+#endif
+
+      aal_classdev_clr_registered(pclassdevice);
+   }
+   return;
+}
+
+//=============================================================================
+// Name:  aalbus_send_uevent
+// Description: 
+// Interface:
+// Inputs: none.
+// Outputs: none.
+// Comments:
+//=============================================================================
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,23)
+int
+aalbus_send_uevent(struct aal_device *dev, enum kobject_action act, char *env[])
+{
+   DPRINTF(AALBUS_DBG_MOD, "in.\n");
+
+   return kobject_uevent_env(&dev->m_dev.kobj, act, env);
+}
+#else
+int
+aalbus_send_uevent(struct aal_device *dev, enum kobject_action act, char *env[])
+{
+   DPRINTF(AALBUS_DBG_MOD, "Not implemented in.\n");
+
+   return 0;
+}
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,26)
+//=============================================================================
+// Name:  aalbus_class_uevent
+// Description:
+// Interface:
+// Inputs: none.
+// Outputs: none.
+// Comments:
+//=============================================================================
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,23)
+int aalbus_class_uevent(struct class_device    *dev,
+                        struct kobj_uevent_env *env)
+#else
+int aalbus_class_uevent(struct class_device *dev,
+                        char               **env,
+                        int                  num_envp,
+                        char                *buffer,
+                        int                  buffer_size)
+
+#endif
+
+{
+   DPRINTF(AALBUS_DBG_MOD, ": Entered\n");
+   return 0;
+}
+
+#endif
+
+//=============================================================================
+// Name:  aalbus_class_device_release
+// Description:
+// Interface:
+// Inputs: none.
+// Outputs: none.
+// Comments:
+//=============================================================================
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,26)
+void
+aalbus_class_device_release(struct device *dev)
+#else
+void
+aalbus_class_device_release(struct class_device *dev)
+#endif
+{
+   DPRINTF(AALBUS_DBG_MOD,  "Default class device release handler\n");
+   return;
+}
+
+//=============================================================================
+// Name:  aalbus_class_release
+// Description:
+// Interface:
+// Inputs: none.
+// Outputs: none.
+// Comments:
+//=============================================================================
+void
+aalbus_class_release(struct class *class)
+{
+   DPRINTF(AALBUS_DBG_MOD,  "Entered\n");
+   return;
+}
+
+//=============================================================================
+// Name: aalbus_class_devrelease
+// Description:
+// Interface:
+// Inputs: none.
+// Outputs: none.
+// Comments:
+//=============================================================================
+void
+aalbus_class_devrelease(struct device *dev)
+{
+   DPRINTF(AALBUS_DBG_MOD,  "Entered\n");
+   return;
+}
+
+//=============================================================================
+// Name: aalbus_register_service_interface
+// Description: Registers a service interface with the bus
+// Interface: public
+// Inputs: pinterface - interface to register
+//         iid - interface ID.
+// Outputs: 0 - successful
+// Comments: This function does not increment the ownind modufes refcnt. The
+//           interface ID must be unique to the service list.
+//=============================================================================
+int
+aalbus_register_service_interface(struct aal_interface *pinterface)
+{
+   int res;
+
+   DPRINTF(AALBUS_DBG_MOD,  "Registering service interface 0x%" PRIx64 "\n", pinterface->m_iid);
+
+   ASSERT(!aalinterface_is_registered(pinterface));
+
+   // aal_interface_add() determines whether it has already been added.
+   res = aal_interface_add(&aalBus.m_servicelist, &aalBus.m_sem, pinterface);
+   if ( 0 == res ) {
+      aalinterface_set_registered(pinterface);
+   }
+   return res;
+}
+
+//=============================================================================
+// Name: aalbus_unregister_service_interface
+// Description: Unregisters a service interface with the bus
+// Interface: public
+// Inputs: pinterface - interface to register
+//         iid - interface ID.
+// Outputs: 0 - successful
+// Comments: This function does not increment the ownind modufes refcnt. The
+//           interface ID must be unique to the service list.
+//=============================================================================
+int
+aalbus_unregister_service_interface(struct aal_interface *pinterface)
+{
+   int res;
+
+   DPRINTF(AALBUS_DBG_MOD,  "Unregistering service interface 0x%Lx\n", pinterface->m_iid);
+
+   ASSERT(aalinterface_is_registered(pinterface));
+
+   // aal_interface_del() determines whether it has already been added.
+   res = aal_interface_del(&aalBus.m_servicelist, &aalBus.m_sem, pinterface);
+   if ( 0 == res ) {
+      aalinterface_clr_registered(pinterface);
+   }
+   return res;
+}
+
+
+//=============================================================================
+// Name: aalbus_get_service_interface
+// Description: Aquires a service interface and increments the modules refcnt
+// Interface: public
+// Inputs: iid - ID of the interface to get
+// Outputs: NULL - if failure
+// Comments: This function increments the refcn of the module that owns the
+//           interface. This will prevent the module from being released while
+//           another module may be using the interface. It is important that
+//           the interface be released using aalbus_release_service_interface()
+//           to allow the service module to eventually be unloaded.
+//=============================================================================
+struct aal_interface *
+aalbus_get_service_interface(btIID iid)
+{
+   struct aal_interface *pinterface =
+         aal_interface_find(&aalBus.m_servicelist, iid);
+
+   if ( NULL == pinterface ) {
+      return NULL; // Interface not found.
+   }
+
+   // Try the module to make sure it is not getting released
+   if ( !try_module_get(pinterface->m_owner) ) {
+      return NULL;
+   }
+
+   if ( unlikely( kosal_sem_get_user_alertable(&aalBus.m_sem) ) ) {
+      ASSERT(false);
+      return pinterface;
+   }
+   aalinterface_get(pinterface);
+   kosal_sem_put(&aalBus.m_sem);
+
+   return pinterface;
+}
+
+//=============================================================================
+// Name: aalbus_release_service_interface
+// Description: Releases a service interface and decrements the owning module's
+//              refcnt.
+// Interface: public
+// Inputs:  pinterface - interface to release.
+// Outputs: none.
+// Comments:
+//=============================================================================
+void
+aalbus_release_service_interface(struct aal_interface *pinterface)
+{
+   DPRINTF(AALBUS_DBG_MOD,  "Releasing service interface 0x%Lx\n", pinterface->m_iid);
+
+   if ( unlikely( kosal_sem_get_user_alertable(&aalBus.m_sem) ) ) {
+      ASSERT(false);
+      module_put(pinterface->m_owner);
+      return;
+   }
+
+   ASSERT(aalinterface_count(pinterface) > 0);
+   if ( aalinterface_count(pinterface) > 0 ) {
+      aalinterface_put(pinterface);
+   }
+   kosal_sem_put(&aalBus.m_sem);
+
+   module_put(pinterface->m_owner);
+}
+
+//=============================================================================
+// Name: aalbus_has_interface
+// Description: Checks to see if an interface has been registered
+// Interface: public
+// Inputs: iid - ID of interface.
+// Outputs: 1 if interface is available.
+// Comments:
+//=============================================================================
+int
+aalbus_has_interface(btIID iid)
+{
+   return (NULL != aal_interface_find(&aalBus.m_servicelist, iid));
+}
+
+
+//=============================================================================
+// Name: device_find_param
+// Description: Parameter used in get_device search functions
+//=============================================================================
+struct device_find_param {
+   __u32                  m_mask;      // Input
+   struct aal_device_id  *m_devID;     // Input
+   struct device         *m_dev;       // Output
+};
+
+//=============================================================================
+// Name: aalbus_itr_get_device
+// Description: Returns next found device
+// Interface: public
+// Inputs: pdev       - generic device structure
+//         data       - pointer to the device find param
+//         mask       - fields in the id to examine
+// Outputs: 1 - if present
+// Comments:
+//=============================================================================
+static
+int
+aalbus_itr_get_device(struct device *pdev, void *data)
+{
+   struct device_find_param *param = (struct device_find_param *)data;
+   struct aal_device        *paal  = basedev_to_aaldev(pdev);
+   __u32 mask = param->m_mask;
+
+   // Determine if this is the device being looked for
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,26)
+   DPRINTF(AALBUS_DBG_MOD, ": Checking device %s  mask %x paal %p\n", (char*)dev_name(pdev),param->m_mask, paal);
+#else
+   DPRINTF(AALBUS_DBG_MOD, ": Checking device %s  mask %x paal %p\n", pdev->bus_id,param->m_mask, paal);
+#endif
+
+   //---------------------------------------------------
+   // Loop examine device and all of its children
+   //  If a mask was set then see if the device matches
+   //  all of the attributes specified. If any fail then
+   //  no match. Null mask means exact match.
+   //---------------------------------------------------
+   if ( mask ) {
+      // Optimization for common case
+      DPRINTF(AALBUS_DBG_MOD, ": check AAL_DEV_ID_MASK_ADDR\n");
+      if( mask & AAL_DEV_ID_MASK_ADDR){
+         if( memcmp( &param->m_devID->m_devaddr, &aaldev_devaddr(paal), sizeof( struct aal_device_addr ) ) != 0 ){
+            DPRINTF(AALBUS_DBG_MOD, ": No match on AAL_DEV_ID_MASK_ADDR\n");
+            return 0;
+         }
+      } // if( mask & AAL_DEV_ID_MASK_ADDR)
+
+      // Match AHM GUID
+      DPRINTF(AALBUS_DBG_MOD, ": check AHMGUID\n");
+      if( mask & AAL_DEV_ID_MASK_AHMGUID){
+        if(param->m_devID->m_ahmGUID != aaldev_devid(paal).m_ahmGUID){
+            DPRINTF(AALBUS_DBG_MOD, ": No match on AHMGUID\n");
+            return 0;
+         }
+      }
+
+      // Match the Board number
+      DPRINTF(AALBUS_DBG_MOD, ": check AAL_DEV_ID_MASK_SOCKETNUM\n");
+      if( (mask & AAL_DEV_ID_MASK_SOCKETNUM)){
+          if(param->m_devID->m_devaddr.m_socketnum != aaldev_devaddr_socketnum(paal)){
+             DPRINTF(AALBUS_DBG_MOD, ": No match on AAL_DEV_ID_MASK_SOCKETNUM\n");
+             return 0;
+           }
+      }
+
+      // Match the Board number
+      DPRINTF(AALBUS_DBG_MOD, ": check AAL_DEV_ID_MASK_BUSNUM\n");
+      if( (mask & AAL_DEV_ID_MASK_BUSNUM)){
+          if(param->m_devID->m_devaddr.m_busnum != aaldev_devaddr_busnum(paal)){
+             DPRINTF(AALBUS_DBG_MOD, ": No match on AAL_DEV_ID_MASK_BUSNUM\n");
+             return 0;
+           }
+      }
+
+      // Match the Board number
+      DPRINTF(AALBUS_DBG_MOD, ": check AAL_DEV_ID_MASK_DEVNUM\n");
+      if( (mask & AAL_DEV_ID_MASK_DEVNUM)){
+          if(param->m_devID->m_devaddr.m_devicenum != aaldev_devaddr_devnum(paal)){
+             DPRINTF(AALBUS_DBG_MOD, ": No match on AAL_DEV_ID_MASK_DEVNUM\n");
+             return 0;
+           }
+      }
+      DPRINTF(AALBUS_DBG_MOD, ": check AHMGUID\n");
+      if( mask & AAL_DEV_ID_MASK_SUBDEVNUM){
+            if(param->m_devID->m_devaddr.m_subdevnum != aaldev_devaddr_subdevnum(paal)){
+               DPRINTF(AALBUS_DBG_MOD, ": No match on AHMGUID\n");
+               return 0;
+             }
+      }
+      DPRINTF(AALBUS_DBG_MOD, ": check AAL_DEV_ID_MASK_BUSTYPE\n");
+      if( (mask & AAL_DEV_ID_MASK_BUSTYPE)){
+          if(param->m_devID->m_devaddr.m_bustype != aaldev_devaddr_bustype(paal)){
+             DPRINTF(AALBUS_DBG_MOD, ": No match on AAL_DEV_ID_MASK_BUSTYPE\n");
+             return 0;
+          }
+      }
+      DPRINTF(AALBUS_DBG_MOD, ": check AHMGUID\n");
+      if( (mask & AAL_DEV_ID_MASK_DEVTYPE)){
+          if(param->m_devID->m_devicetype != aaldev_devid_devtype(paal)){
+             DPRINTF(AALBUS_DBG_MOD, ": No match on AHMGUID\n");
+             return 0;
+          }
+      }
+      DPRINTF(AALBUS_DBG_MOD, ": check AAL_DEV_ID_MASK_AHMGUID\n");
+      if( mask & AAL_DEV_ID_MASK_AHMGUID){
+        if(param->m_devID->m_ahmGUID != aaldev_devid_ahmguid(paal)){
+           DPRINTF(AALBUS_DBG_MOD, ": No match on AAL_DEV_ID_MASK_AHMGUID\n");
+           return 0;
+         }
+      }
+      DPRINTF(AALBUS_DBG_MOD, ": check AAL_DEV_ID_MASK_AFUGUID\n");
+      if( mask & AAL_DEV_ID_MASK_AFUGUID){
+        if(param->m_devID->m_afuGUID != aaldev_devid_afuguid(paal)){
+           DPRINTF(AALBUS_DBG_MOD, ": No match on AAL_DEV_ID_MASK_AFUGUID\n");
+            return 0;
+         }
+      }
+      DPRINTF(AALBUS_DBG_MOD, ": check AAL_DEV_ID_MASK_PIPGUID\n");
+      if( mask & AAL_DEV_ID_MASK_PIPGUID){
+        if(param->m_devID->m_pipGUID != aaldev_devid_pipguid(paal)){
+            DPRINTF(AALBUS_DBG_MOD, ": No match on AAL_DEV_ID_MASK_PIPGUID\n");
+            return 0;
+         }
+      }
+      DPRINTF(AALBUS_DBG_MOD, ": check AAL_DEV_ID_MASK_DEVID\n");
+      if( mask & AAL_DEV_ID_MASK_DEVID){
+          if(memcmp(param->m_devID, &aaldev_devid(paal), sizeof(struct aal_device_id) ) !=0){
+            DPRINTF(AALBUS_DBG_MOD, ": No match on AAL_DEV_ID_MASK_DEVID\n");
+            return 0;
+          }
+      }
+      DPRINTF(AALBUS_DBG_MOD, ": check AAL_DEV_ID_MASK_VENDOR\n");
+      // Check for match of unmasked fields
+      if( mask & AAL_DEV_ID_MASK_VENDOR){
+        if(param->m_devID->m_vendor != aaldev_devid_vendorid(paal)){
+            DPRINTF(AALBUS_DBG_MOD, ": No match on AAL_DEV_ID_MASK_VENDOR\n");
+            return 0;
+        }
+      }
+
+      // Passed all of the criteria
+      param->m_dev = pdev;
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,26)
+      DPRINTF(AALBUS_DBG_MOD, ": Found device %s.  Passed all criteria\n", dev_name(pdev));
+#else
+      DPRINTF(AALBUS_DBG_MOD, ": Found device %s.  Passed all criteria\n",  pdev->bus_id);
+#endif
+      return 1;
+   } // if(mask)
+   else{
+      // Check for exact match
+      if( memcmp( param->m_devID, &paal->m_devid, sizeof( struct aal_device_id ) ) == 0 ){
+         param->m_dev = pdev;
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,26)
+         DPRINTF(AALBUS_DBG_MOD, ": Found device %s\n", dev_name(pdev));
+#else
+         DPRINTF(AALBUS_DBG_MOD, ": Found device %s\n", pdev->bus_id);
+#endif
+         return 1;
+      }
+   }
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,26)
+   DPRINTF(AALBUS_DBG_MOD, ": Checking children of %s\n", dev_name(pdev));
+#else
+   DPRINTF(AALBUS_DBG_MOD, ": Checking children of %s\n", pdev->bus_id);
+#endif
+
+   // If the above did not match check the child devices if any
+   device_for_each_child(pdev, param, aalbus_itr_get_device);
+   if ( NULL != param->m_dev ) {
+      // Device found
+      return 1;
+   }
+   return 0;
+}
+
+
+//=============================================================================
+// Name: aalbus_get_device
+// Description: Get device by device ID.
+// Interface: public
+// Inputs: devID - generic device structure
+// Outputs: none
+// Returns: the device object pointer - if successful otherwise NULL
+// Comments:
+//=============================================================================
+struct aal_device *
+aalbus_get_device(struct aal_device_id *devID, __u32 mask)
+{
+   struct device_find_param param =
+   {
+      .m_mask     = mask,
+      .m_devID    = devID,
+      .m_dev      = NULL,
+   };
+   DPRINTF( AALBUS_DBG_MOD, ": in\n");
+   // kosal_sem_get_user_alertable(&aalBus.m_sem);
+   if ( unlikely( kosal_sem_get_user_alertable(&aalBus.m_sem) ) ) {
+      DPRINTF (AALBUS_DBG_MOD, ": kosal_sem_get_user_alertable interrupted\n");
+      return NULL;
+   }
+
+   DPRINTF( AALBUS_DBG_MOD, ": searching device tree\n");
+   bus_for_each_dev(&aalBus.m_bustype, NULL, &param, aalbus_itr_get_device);
+   kosal_sem_put(&aalBus.m_sem);
+
+   DPRINTF( AALBUS_DBG_MOD, ": detected %p\n",param.m_dev != NULL ? basedev_to_aaldev(param.m_dev) : NULL);
+   return (NULL != param.m_dev) ? basedev_to_aaldev(param.m_dev) : NULL;
+}
+
+//=============================================================================
+// Name: aalbus_handle_to_device
+// Description: Get device by handle.
+// Interface: public
+// Inputs: handle - device handle
+// Outputs: none
+// Returns: the device object pointer - if successful
+// Comments:
+//=============================================================================
+struct aal_device *
+aalbus_handle_to_device(void *handle)
+{
+   // Handle is really the dev pointer
+   struct aal_device *devp = (struct aal_device *)handle;
+
+   // Sanity check the handle
+   if ( likely( devp &&
+                ( (struct aal_bus *)aaldev_busp(devp) == (struct aal_bus *)&aalBus) ) ) {
+      return devp;
+   }
+
+   return NULL;
+}
+
+
+//=============================================================================
+// Name: aalbus_send_config_update_event
+// Description: send a device update event for a single device
+// Interface: private
+// Inputs:  dev - Device
+//          EventHandler - Event Handler
+//
+// Outputs: none
+// Returns: none
+// Comments: TODO - Only supports one handler. May need to extend
+//=============================================================================
+int
+aalbus_send_config_update_event(struct aal_device *pdev,
+                                krms_cfgUpDate_e   updateType,
+                                btPID              pid)
+{
+   struct update_config_parms parms;
+
+   DPRINTF(AALBUS_DBG_MOD,  "Sending Update Event dev = %p\n", pdev);
+
+   ////////////////////////////////////////////////////////////////////////
+   if ( aalBus.config_update_event_handler.EventHandler ) {
+      if ( !pdev ) {
+         kosal_printk_level(KERN_WARNING, "NULL pdev\n");
+         return 0;
+      }
+
+      parms.Handler    = aalBus.config_update_event_handler.EventHandler;
+      parms.updateType = updateType;
+      parms.pid        = pid;
+
+      if ( NULL != parms.Handler ) {
+         parms.Handler(pdev, parms.updateType, parms.pid,
+                          aalBus.config_update_event_handler.context);
+      }
+   } // if (aalBus.config_update_event_handler.EventHandler)
+   return 0;
+}
+
+//=============================================================================
+// Name: aalbus_config_update_event
+// Description: generate a device update event for all devices in chain
+// Interface: private
+// Inputs:  dev - Device
+// Outputs: none
+// Returns: none
+// Comments: TODO - Only supports one handler. May need to extend
+//=============================================================================
+int
+aalbus_config_update_event(struct device *pbasedev, void *data)
+{
+   struct aal_device          *pdev   = basedev_to_aaldev(pbasedev);
+   struct update_config_parms *pparms = data;
+
+   if ( !pdev ) {
+	   DPRINTF( AALBUS_DBG_MOD, "NULL pdev\n");
+      return 0;
+   }
+
+   DPRINTF( AALBUS_DBG_MOD, "\n===============================\n");
+
+   DPRINTF(AALBUS_DBG_MOD,"Type: ");
+   switch ( pparms->updateType ) {
+      case krms_ccfgUpdate_DevAdded:
+         DPRINTF( AALBUS_DBG_MOD," Device Added\n");
+      break;
+      case krms_ccfgUpdate_DevRemoved:
+         DPRINTF( AALBUS_DBG_MOD," Device Removed\n");
+      break;
+      case krms_ccfgUpdate_DevOwnerAdded:
+         DPRINTF( AALBUS_DBG_MOD," Owner Added\n");
+      break;
+      case krms_ccfgUpdate_DevOwnerUpdated:
+         DPRINTF( AALBUS_DBG_MOD," Owner Updated\n");
+      break;
+
+      case krms_ccfgUpdate_DevOwnerRemoved:
+         DPRINTF( AALBUS_DBG_MOD," Owner Removed\n");
+      break;
+      case krms_ccfgUpdate_DevActivated:
+         DPRINTF( AALBUS_DBG_MOD," Device Activated\n");
+      break;
+      case krms_ccfgUpdate_DevQuiesced:
+         DPRINTF( AALBUS_DBG_MOD," Device Quiecsed\n");
+      break;
+
+      default:
+         DPRINTF( AALBUS_DBG_MOD," Unknown\n");
+      break;
+   }
+   DPRINTF( AALBUS_DBG_MOD, "On Device \"%s\" channel %d.\n",
+              aaldev_devname(pdev),
+              aaldev_devaddr_subdevnum(pdev));
+
+   //////////////////////////////////////////////////////////////////////////////////////////
+   if ( NULL != pparms->Handler ) {
+      DPRINTF( AALBUS_DBG_MOD, ": Sending Update Event\n");
+      pparms->Handler(pdev,
+                      pparms->updateType,
+                      pparms->pid,
+                      aalBus.config_update_event_handler.context);
+   }
+   DPRINTF( AALBUS_DBG_MOD, "\n===============================\n");
+
+   // Walk the chain down through all children
+   device_for_each_child(pbasedev, data, aalbus_config_update_event);
+   return 0;
+}
+
+
+//=============================================================================
+// Name: aalbus_register_config_update_handler
+// Description: Registers an event handler to accept config update events
+// Interface: public
+// Inputs: EventHandler - Event Handler (NULL means unistall)
+//         context -
+// Outputs: none
+// Returns: 0 - if successful
+// Comments: TODO - Only supports one handler. May need to extend
+//=============================================================================
+int
+aalbus_register_config_update_handler(aalbus_event_config_update_t EventHandler,
+                                      void                        *context)
+
+{
+   // Create a device added event - Generated to send the initial update
+   struct update_config_parms parms = {
+      .updateType = krms_ccfgUpdate_DevAdded,
+      .pid        = 0,
+      .Handler    = EventHandler,
+   };
+
+   // Only support one handler now
+   if( (NULL != EventHandler) &&
+       (NULL != aalBus.config_update_event_handler.EventHandler) ) {
+      return -EINVAL;
+   }
+
+   // kosal_sem_get_user_alertable(&aalBus.m_sem);
+   if ( unlikely( kosal_sem_get_user_alertable(&aalBus.m_sem) ) ) {
+      DPRINTF (AALBUS_DBG_MOD, ": kosal_sem_get_user_alertable interrupted\n");
+      return -EINTR;
+   }
+
+   aalBus.config_update_event_handler.EventHandler = EventHandler;
+   aalBus.config_update_event_handler.context      = context;
+
+   kosal_sem_put(&aalBus.m_sem);
+
+   // If the handler was disabled then done.
+   if ( NULL == aalBus.config_update_event_handler.EventHandler ) {
+      return 0;
+   }
+
+   //  If a new handler was enabled then generate the whole configuration state
+   DPRINTF( AALBUS_DBG_MOD, ": Sending Config Updates\n");
+
+   // Generate a config update for every device in the system
+   // kosal_sem_get_user_alertable(&aalBus.m_sem);
+   if ( unlikely( kosal_sem_get_user_alertable(&aalBus.m_sem) ) ) {
+      DPRINTF (AALBUS_DBG_MOD, ": kosal_sem_get_user_alertable interrupted\n");
+      return -EINTR;
+   }
+   DPRINTF( AALBUS_DBG_MOD," \n\n\n\n\n************************************************\n");
+   bus_for_each_dev(&aalBus.m_bustype,
+                    NULL,
+                    &parms,
+                    aalbus_config_update_event);
+   DPRINTF( AALBUS_DBG_MOD,"************************************************\n\n\n");
+   kosal_sem_put(&aalBus.m_sem);
+   return 0;
+}
+
+#if 0
+// #if 0 - aalbus_walk_device_chain() is unused.
+//=============================================================================
+// Name: aalbus_walk_device_chain
+// Description: Walks the device chain fro debug purposes
+// Interface: public
+// Inputs:
+//         context -
+// Outputs: none
+// Returns: 0 - if successful
+// Comments: TODO - Only supports one handler. May need to extend
+//=============================================================================
+int aalbus_walk_device_chain(void)
+
+{
+   // Create a device added event - Generated to send the initial update
+   struct update_config_parms  parms={
+      .updateType = krms_ccfgUpdate_DevAdded,
+      .pid        = 0,
+      .Handler    = NULL,
+   };
+
+   DPRINTF( AALBUS_DBG_MOD, ": WALKING BUS DEVICE CHAIN\n");
+
+   // Generate a config update for every device in the system
+   // kosal_sem_get_user_alertable(&aalBus.m_sem);
+   if (unlikely (kosal_sem_get_user_alertable(&aalBus.m_sem))) {
+      DPRINTF (AALBUS_DBG_MOD, ": kosal_sem_get_user_alertable interrupted\n");
+      return -EINTR;
+   }
+   DPRINTF( AALBUS_DBG_MOD," \n********** DEVICE CHAIN **************\n");
+   bus_for_each_dev( &aalBus.m_bustype,
+                     NULL,
+                     &parms,
+                     aalbus_config_update_event );
+   DPRINTF( AALBUS_DBG_MOD,"************* END DEVICE CHAIN **********\n\n\n");
+   kosal_sem_put(&aalBus.m_sem);
+   return 0;
+}
+#endif // #if 0
+
+/** @brief validate the passed device
+ * @return non-zero if device is a valid AAL device */
+int aalbus_validate_device(struct aal_device *pdev)
+{
+   struct aal_bus *aal_bus_p;
+   struct aal_bus_type *aal_bus_type_p;
+   int status;
+   bool found = false;
+   struct aal_device *curdev_p;
+
+
+   /* simple check before proceeding */
+   if ( NULL == pdev ) {
+      DPRINTF(AALBUS_DBG_MOD, " Failed NULL pointer\n");
+      return false;
+   }
+
+   /* get handle to aalbus and outer aalBus */
+   aal_bus_p = aalbus_get_bus();
+   if (NULL == aal_bus_p) {
+      DPRINTF(AALBUS_DBG_MOD, " aalbus_get_bus failed\n");
+      return false;
+   }
+   aal_bus_type_p = container_of(aal_bus_p, struct aal_bus_type, m_bus);
+
+   /* grab the allocation list mutex and search the allocation list for
+    * our device */
+   status = kosal_sem_get_user_alertable(&aal_bus_type_p->alloc_list_sem);
+   if (0 != status) {
+      DPRINTF(AALBUS_DBG_MOD,
+          " Failed to acquire allocate list semaphore\n");
+      return false;
+   } else {
+      kosal_list_for_each_entry(curdev_p,
+          &aal_bus_type_p->alloc_list_head,
+          m_alloc_list, struct aal_device)
+      {
+         DPRINTF(AALBUS_DBG_MOD, "%p on list\n", curdev_p);
+         if (curdev_p == pdev) {
+            found = true;
+            break;
+         }
+      }
+      kosal_sem_put(&aal_bus_type_p->alloc_list_sem);
+   }
+
+   /* if we've verified pdev is a known aal_device, do some additional
+    * sanity checks on its members */
+   if (true == found) {
+      status = ( ( (__u64)virt_to_phys(pdev) == pdev->m_validator )
+          && ( AAL_DEVICE_VERSION == pdev->m_version   ) );
+   } else {
+      DPRINTF(AALBUS_DBG_MOD,
+          " couldn't find device %p on allocated list\n",
+          pdev);
+      status = false;
+   }
+
+   DPRINTF(AALBUS_DBG_MOD, " device %p was %sfound\n", pdev,
+       (status ? "" : "NOT "));
+
+   return status;
+}
+
+
+//
+// Export the public interfaces
+//
+EXPORT_SYMBOL( aalbus_get_bus );
+EXPORT_SYMBOL( aalbus_get_device );  //TODO get rid
+
diff --git a/drivers/fpga/aal/bus/kOSAL.c b/drivers/fpga/aal/bus/kOSAL.c
new file mode 100644
index 000000000000..6335f93fba8a
--- /dev/null
+++ b/drivers/fpga/aal/bus/kOSAL.c
@@ -0,0 +1,692 @@
+//******************************************************************************
+// This  file  is  provided  under  a  dual BSD/GPLv2  license.  When using or
+//         redistributing this file, you may do so under either license.
+//
+//                            GPL LICENSE SUMMARY
+//
+//  Copyright(c) 2012-2017, Intel Corporation.
+//
+//  This program  is  free software;  you  can redistribute it  and/or  modify
+//  it  under  the  terms of  version 2 of  the GNU General Public License  as
+//  published by the Free Software Foundation.
+//
+//  This  program  is distributed  in the  hope that it  will  be useful,  but
+//  WITHOUT   ANY   WARRANTY;   without   even  the   implied   warranty    of
+//  MERCHANTABILITY  or  FITNESS  FOR  A  PARTICULAR  PURPOSE.  See  the   GNU
+//  General Public License for more details.
+//
+//  The  full  GNU  General Public License is  included in  this  distribution
+//  in the file called README.GPLV2-LICENSE.TXT.
+//
+//  Contact Information:
+//  Henry Mitchel, henry.mitchel at intel.com
+//  77 Reed Rd., Hudson, MA  01749
+//
+//                                BSD LICENSE
+//
+//  Copyright(c) 2012-2017, Intel Corporation.
+//
+//  Redistribution and  use  in source  and  binary  forms,  with  or  without
+//  modification,  are   permitted  provided  that  the  following  conditions
+//  are met:
+//
+//    * Redistributions  of  source  code  must  retain  the  above  copyright
+//      notice, this list of conditions and the following disclaimer.
+//    * Redistributions in  binary form  must  reproduce  the  above copyright
+//      notice,  this  list of  conditions  and  the  following disclaimer  in
+//      the   documentation   and/or   other   materials   provided  with  the
+//      distribution.
+//    * Neither   the  name   of  Intel  Corporation  nor  the  names  of  its
+//      contributors  may  be  used  to  endorse  or promote  products derived
+//      from this software without specific prior written permission.
+//
+//  THIS  SOFTWARE  IS  PROVIDED  BY  THE  COPYRIGHT HOLDERS  AND CONTRIBUTORS
+//  "AS IS"  AND  ANY  EXPRESS  OR  IMPLIED  WARRANTIES,  INCLUDING,  BUT  NOT
+//  LIMITED  TO, THE  IMPLIED WARRANTIES OF  MERCHANTABILITY  AND FITNESS  FOR
+//  A  PARTICULAR  PURPOSE  ARE  DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT
+//  OWNER OR CONTRIBUTORS BE LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,
+//  SPECIAL,  EXEMPLARY,  OR  CONSEQUENTIAL   DAMAGES  (INCLUDING,   BUT   NOT
+//  LIMITED  TO,  PROCUREMENT  OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF USE,
+//  DATA,  OR PROFITS;  OR BUSINESS INTERRUPTION)  HOWEVER  CAUSED  AND ON ANY
+//  THEORY  OF  LIABILITY,  WHETHER  IN  CONTRACT,  STRICT LIABILITY,  OR TORT
+//  (INCLUDING  NEGLIGENCE  OR OTHERWISE) ARISING  IN ANY WAY  OUT  OF THE USE
+//  OF  THIS  SOFTWARE, EVEN IF ADVISED  OF  THE  POSSIBILITY  OF SUCH DAMAGE.
+//******************************************************************************
+//****************************************************************************
+/// @file kOSAL.c
+/// @brief Implementation of the Kernel abstraction functions.
+/// @ingroup kOSAL
+/// @verbatim
+/// Accelerator Abstraction Layer
+///
+/// AUTHORS:  Joseph Grecco, Intel Corporation
+///           Tim Whisonant, Intel Corporation
+///
+/// HISTORY:
+/// WHEN:          WHO:     WHAT:
+/// 12/27/2012     JG       Initial version
+//****************************************************************************
+#include "aalsdk/kernel/kosal.h"
+#define MODULE_FLAGS KOSAL_DBG_MOD
+
+#if defined( __AAL_LINUX__ )
+#include <linux/vmalloc.h>
+# include <linux/delay.h>
+#include <linux/dma-mapping.h>
+#include <linux/rtc.h>
+#endif // __AAL_LINUX__
+
+#if defined( __AAL_UNKNOWN_OS__ )
+# error Implement kOSAL for unknown OS.
+#endif // __AAL_UNKNOWN_OS__
+
+//=============================================================================
+/// kosal_pci_read_config_dword
+/// @brief     Read a dword from PCIe device Config space
+/// @param[in] dev - PCI device handle
+///            offset - offset into Config space starting from beginning of 
+//                      header.
+//             
+/// @return    0 failed
+///
+/// @note   Windows intrinsic numbers bits 0 to 63, ffsll numbers
+///         them 1 to 64. Using ffsll variation.
+/// @note   Windows intrinsic must be set outside function
+//
+//=============================================================================
+btInt _kosal_pci_read_config_dword(__ASSERT_HERE_PROTO
+                                   pkosal_pci_dev      pdev,
+                                   btUnsigned32bitInt  offset,
+                                   btUnsigned32bitInt *pval)
+{
+   btInt res;
+#if   defined( __AAL_WINDOWS__ )
+   ULONG bytesRead = 0;
+#endif // __AAL_WINDOWS__
+
+   __ASSERT_HERE_IN_FN(NULL != pdev);
+   __ASSERT_HERE_IN_FN(NULL != pval);
+   if((NULL ==  pdev) || (NULL == pval)) {
+      res = -EINVAL;
+      return res ;
+   }
+
+#if   defined( __AAL_LINUX__ )
+
+   res = ( pci_read_config_dword(pdev, offset, pval) ? 0 : 1 );
+
+#elif defined( __AAL_WINDOWS__ )
+
+   bytesRead = pdev->GetBusData(pdev->Context,             // Context of bus interface
+                                PCI_WHICHSPACE_CONFIG,     // Config space
+                                pval,                      // Where to return it
+                                offset,                    // From the beginning
+                                sizeof(btUnsigned32bitInt));
+
+   res = ( sizeof(btUnsigned32bitInt) == bytesRead ? 1 : 0 );
+
+#endif // OS
+
+   PPCI_HERE("kosal_pci_read_config_dword(pdev=0x%" PRIxUINTPTR_T ", offset=%u [0x%x], pval=0x%" PRIxUINTPTR_T ") : *pval=0x%x [%u]\n",
+                __UINTPTR_T_CAST(pdev),
+                offset, offset,
+                __UINTPTR_T_CAST(pval),
+                *pval, *pval);
+
+   return res;
+}
+
+//=============================================================================
+/// kosal_virt_to_phys
+/// @brief     Convert a kernel virtual address to physical
+/// @param[in] vaddr - kernel virtual
+/// @return    physica address or NULLif  failed
+//=============================================================================
+btPhysAddr
+kosal_virt_to_phys(btAny vaddr)
+{
+#if   defined( __AAL_LINUX__ )
+
+   return (btPhysAddr)virt_to_phys(vaddr);
+
+#elif defined( __AAL_WINDOWS__ )
+
+   PHYSICAL_ADDRESS physaddr = { 0 };
+     
+   physaddr = MmGetPhysicalAddress(vaddr);
+
+   return (btPhysAddr)physaddr.QuadPart;
+
+#endif // OS
+}
+
+//=============================================================================
+/// kosal_mdelay
+/// @brief     Delay in milliseconds
+/// @param[in] time in millisecs
+/// @return    1 if success
+/// @note      This function may only be called when IRQL <= APC_LEVEL
+//=============================================================================
+btInt _kosal_mdelay(__ASSERT_HERE_PROTO btTime delay)
+{
+   btInt res;
+#if   defined( __AAL_WINDOWS__ )
+   NTSTATUS      status;
+   LARGE_INTEGER rel_timout_in_100ns;
+# if ENABLE_ASSERT
+   UNREFERENCED_PARAMETER(__file);
+   UNREFERENCED_PARAMETER(__line);
+   UNREFERENCED_PARAMETER(__fn);
+# endif // ENABLE_ASSERT
+#endif // __AAL_WINDOWS__
+
+   PPOLLING_HERE("kosal_mdelay(delay=%llu [0x%llx]) sleeping\n", delay, delay);
+
+#if   defined( __AAL_LINUX__ )
+
+   mdelay(delay);
+   res = 1;
+
+#elif defined( __AAL_WINDOWS__ )
+
+   // Relative time is specified as a negative value.
+   // Timeout is specified in 100 ns.
+   rel_timout_in_100ns.QuadPart = -((LONGLONG)delay * 10000);
+
+   status = KeDelayExecutionThread(KernelMode, FALSE, &rel_timout_in_100ns);
+
+   res = ( NT_SUCCESS(status) ? 1 : 0 );
+
+#endif // OS
+
+   PPOLLING_HERE("kosal_mdelay(delay=%llu [0x%llx]) waking\n", delay, delay);
+   return res;
+}
+
+//=============================================================================
+/// kosal_udelay
+/// @brief     Delay in microseconds
+/// @param[in] time in micro seconds
+/// @return    1 if success
+/// @note      This function may only be called when IRQL <= APC_LEVEL
+//=============================================================================
+btInt _kosal_udelay(__ASSERT_HERE_PROTO btTime delay)
+{
+   btInt res;
+#if   defined( __AAL_WINDOWS__ )
+   NTSTATUS      status;
+   LARGE_INTEGER rel_timout_in_100ns;
+# if ENABLE_ASSERT
+   UNREFERENCED_PARAMETER(__file);
+   UNREFERENCED_PARAMETER(__line);
+   UNREFERENCED_PARAMETER(__fn);
+# endif // ENABLE_ASSERT
+#endif // __AAL_WINDOWS__
+
+   PPOLLING_HERE("kosal_udelay(delay=%llu [0x%llx]) sleeping\n", delay, delay);
+
+#if   defined( __AAL_LINUX__ )
+
+   udelay(delay);
+   res = 1;
+
+#elif defined( __AAL_WINDOWS__ )
+   
+   // Relative time is specified as a negative value.
+   // Timeout is specified in 100 ns.
+   rel_timout_in_100ns.QuadPart = -((LONGLONG)delay * 10);
+
+   status = KeDelayExecutionThread(KernelMode, FALSE, &rel_timout_in_100ns);
+   res = ( NT_SUCCESS(status) ? 1 : 0 );
+
+#endif // OS
+
+   PPOLLING_HERE("kosal_udelay(delay=%llu [0x%llx]) waking\n", delay, delay);
+   return res;
+}
+
+btVirtAddr _kosal_kmalloc(__ASSERT_HERE_PROTO btWSSize size_in_bytes)
+{
+   btVirtAddr krnl_virt = NULL;
+
+   __ASSERT_HERE_IN_FN(size_in_bytes > 0);
+
+#if   defined( __AAL_LINUX__ )
+# ifdef __i386__
+   krnl_virt = __get_free_pages(GFP_KERNEL, get_order(kosal_round_up_to_page_size(size_in_bytes)));
+# else
+   krnl_virt = kmalloc((size_t)size_in_bytes, GFP_KERNEL);
+# endif // __i386__
+#elif defined( __AAL_WINDOWS__ )
+
+   krnl_virt = (btVirtAddr)MmAllocateNonCachedMemory((SIZE_T)size_in_bytes);
+
+#endif // OS
+
+   __ASSERT_HERE_IN_FN(NULL != krnl_virt);
+
+   PMEMORY_HERE("kosal_kmalloc(size=%llu [0x%llx]) = 0x%" PRIxUINTPTR_T " [phys=0x%" PRIxPHYS_ADDR "]\n",
+                   size_in_bytes, size_in_bytes,
+                   __UINTPTR_T_CAST(krnl_virt),
+                   kosal_virt_to_phys(krnl_virt));
+
+   return krnl_virt;
+}
+
+btVirtAddr _kosal_kzmalloc(__ASSERT_HERE_PROTO btWSSize size_in_bytes)
+{
+   btVirtAddr krnl_virt = NULL;
+
+   __ASSERT_HERE_IN_FN(size_in_bytes > 0);
+
+#if   defined( __AAL_LINUX__ )
+# ifdef __i386__
+   krnl_virt = __get_free_pages(GFP_KERNEL, get_order(kosal_round_up_to_page_size(size_in_bytes)));
+   if(krnl_virt){
+      memset(krnl_virt, 0 , (size_t)size_in_bytes);
+   }
+# else
+   krnl_virt = kmalloc((size_t)size_in_bytes, GFP_KERNEL);
+   if(krnl_virt){
+      memset(krnl_virt, 0 , (size_t)size_in_bytes);
+   }
+# endif // __i386__
+#elif defined( __AAL_WINDOWS__ )
+
+   krnl_virt = (btVirtAddr)MmAllocateNonCachedMemory((SIZE_T)size_in_bytes);
+   if(krnl_virt){
+      RtlZeroMemory(krnl_virt, (SIZE_T)size_in_bytes);
+   }
+#endif // OS
+
+   __ASSERT_HERE_IN_FN(NULL != krnl_virt);
+
+   PMEMORY_HERE("kosal_kzmalloc(size=%llu [0x%llx]) = 0x%" PRIxUINTPTR_T " [phys=0x%" PRIxPHYS_ADDR "]\n",
+                   size_in_bytes, size_in_bytes,
+                   __UINTPTR_T_CAST(krnl_virt),
+                   kosal_virt_to_phys(krnl_virt));
+
+   return krnl_virt;
+}
+
+void _kosal_kfree(__ASSERT_HERE_PROTO btAny krnl_virt, btWSSize size_in_bytes)
+{
+   __ASSERT_HERE_IN_FN(NULL != krnl_virt);
+   __ASSERT_HERE_IN_FN(size_in_bytes > 0);
+
+   PMEMORY_HERE("kosal_kfree(0x%" PRIxUINTPTR_T " [phys=0x%" PRIxPHYS_ADDR "], size=%llu [0x%llx])\n",
+                   __UINTPTR_T_CAST(krnl_virt),
+                   kosal_virt_to_phys(krnl_virt),
+                   size_in_bytes, size_in_bytes);
+
+   if ( NULL != krnl_virt ) {
+
+#if   defined( __AAL_LINUX__ )
+# ifdef __i386__
+      free_pages(krnl_virt, get_order(kosal_round_up_to_page_size(size_in_bytes)));
+# else
+      UNREFERENCED_PARAMETER(size_in_bytes);
+      kfree(krnl_virt);
+# endif // __i386__
+#elif defined( __AAL_WINDOWS__ )
+
+      MmFreeNonCachedMemory(krnl_virt, (SIZE_T)size_in_bytes);
+
+#endif // OS
+
+   }
+
+}
+
+//=============================================================================
+/// kosal_alloc_contiguous_mem_nocache
+/// @brief     Allocate a buffer of contiguous physical pages
+/// @param[in] size in bytes
+/// @return    pointer to memory. NULL if failure.
+/// @note      
+//=============================================================================
+btVirtAddr _kosal_alloc_contiguous_mem_nocache(__ASSERT_HERE_PROTO btWSSize size_in_bytes)
+{
+#if   defined( __AAL_LINUX__ )
+   btVirtAddr pg;
+   btVirtAddr buffer_end;
+#elif defined( __AAL_WINDOWS__ )
+   PHYSICAL_ADDRESS minaddr = { 0ULL };
+   PHYSICAL_ADDRESS maxaddr = { 0xFFFFFFFFFFFFFFFFULL };
+   PHYSICAL_ADDRESS alignment;
+   maxaddr.LowPart= 0xffffffff;
+   maxaddr.HighPart= 0xffffffff;
+#endif // __AAL_WINDOWS__
+
+   btVirtAddr krnl_virt = NULL;
+
+   __ASSERT_HERE_IN_FN(size_in_bytes > 0);
+   
+
+
+#if   defined( __AAL_LINUX__ )
+
+   krnl_virt = (btVirtAddr)__get_free_pages(GFP_KERNEL, get_order(size_in_bytes));
+   __ASSERT_HERE_IN_FN(NULL != krnl_virt);
+   if ( NULL == krnl_virt ) {
+      return NULL;
+   }
+   
+   // Set each page as reserved so that the swapper will not page them out.
+   buffer_end = krnl_virt + size_in_bytes;
+   for ( pg = krnl_virt ; pg < buffer_end ; pg += PAGE_SIZE ) {
+      SetPageReserved( virt_to_page((unsigned long)pg) );
+   }
+
+#elif defined( __AAL_WINDOWS__ )
+   // MmAllocateContiguousMemorySpecifyCache allocates a block of nonpaged memory that is contiguous
+   //  in physical address space. The routine maps this block to a contiguous block of virtual memory
+   //  in the system address space and returns the virtual address of the base of this block.
+   //  The routine aligns the starting address of a contiguous memory allocation to a memory page boundary.
+   
+   alignment.QuadPart = kosal_round_up_to_page_size(size_in_bytes);
+   krnl_virt = (btVirtAddr)MmAllocateContiguousMemorySpecifyCache((SIZE_T)size_in_bytes,
+                                                                  minaddr,
+                                                                  maxaddr,
+                                                                  alignment,
+                                                                  MmNonCached);
+   __ASSERT_HERE_IN_FN(NULL != krnl_virt);
+   if ( NULL == krnl_virt ) {
+      return NULL;
+   }
+
+#endif // OS
+
+   // Recommended security practice..
+   memset(krnl_virt, 0, (size_t)size_in_bytes);
+
+   PMEMORY_HERE("kosal_alloc_contiguous_mem_nocache(size=%llu [0x%llx]) = 0x%" PRIxUINTPTR_T " [phys=0x%" PRIxPHYS_ADDR "]\n",
+                   size_in_bytes, size_in_bytes,
+                   __UINTPTR_T_CAST(krnl_virt),
+                   kosal_virt_to_phys(krnl_virt));
+
+   return krnl_virt;
+}
+
+//=============================================================================
+/// kosal_free_contiguous_mem
+/// @brief     Free buffer of contiguous physical pages allocated through
+///            kosal_alloc_contiguous_mem_nocache
+/// @param[in] size in bytes
+/// @return    pointer to memory. NULL if failure.
+/// @note      
+//=============================================================================
+void _kosal_free_contiguous_mem(__ASSERT_HERE_PROTO btAny krnl_virt, btWSSize size_in_bytes)
+{
+#if   defined( __AAL_WINDOWS__ )
+   UNREFERENCED_PARAMETER(size_in_bytes);
+#endif // __AAL_WINDOWS__
+
+   __ASSERT_HERE_IN_FN(NULL != krnl_virt);
+   __ASSERT_HERE_IN_FN(size_in_bytes > 0);
+
+   PMEMORY_HERE("kosal_free_contiguous_mem(ptr=0x%" PRIxUINTPTR_T " [phys=0x%" PRIxPHYS_ADDR "], bytes=%llu [0x%llx])\n",
+                   __UINTPTR_T_CAST(krnl_virt),
+                   kosal_virt_to_phys(krnl_virt),
+                   size_in_bytes, size_in_bytes);
+
+   // Recommended security practice..
+   if ( NULL != krnl_virt ) {
+      memset(krnl_virt, 0, (size_t)size_in_bytes);
+   }
+
+#if   defined( __AAL_LINUX__ )
+
+   if ( NULL != krnl_virt ) {
+      // Clear the reserved bit.
+      btVirtAddr pg;
+      btVirtAddr buffer_end = krnl_virt + size_in_bytes;
+
+      for ( pg = krnl_virt ; pg < buffer_end ; pg += PAGE_SIZE ) {
+         ClearPageReserved( virt_to_page((unsigned long)pg) );
+      }
+
+      free_pages((unsigned long)krnl_virt, get_order(size_in_bytes));
+   }
+
+#elif defined( __AAL_WINDOWS__ )
+
+   if ( NULL != krnl_virt ) {
+      MmFreeContiguousMemory(krnl_virt);
+   }
+
+#endif // OS
+}
+
+//=============================================================================
+/// _kosal_alloc_dma_coherent
+/// @brief     Allocate a buffer of DMA-able coherent contiguous memory
+/// @param[in] devhandle OS specific
+///            size in bytes
+///            pdma_handle Address to return DMA address for device
+/// @return    pointer to memory. NULL if failure.
+/// @note
+//=============================================================================
+btVirtAddr _kosal_alloc_dma_coherent( __ASSERT_HERE_PROTO btHANDLE devhandle,
+                                       btWSSize size_in_bytes,
+                                      btHANDLE *pdma_handle)
+{
+#if defined( __AAL_WINDOWS__ )
+   PHYSICAL_ADDRESS minaddr = { 0ULL };
+   PHYSICAL_ADDRESS maxaddr = { 0xFFFFFFFFFFFFFFFFULL };
+   PHYSICAL_ADDRESS alignment;
+   maxaddr.LowPart= 0xffffffff;
+   maxaddr.HighPart= 0xffffffff;
+#endif // __AAL_WINDOWS__
+
+   btVirtAddr krnl_virt = NULL;
+
+   __ASSERT_HERE_IN_FN(size_in_bytes > 0);
+
+
+
+#if   defined( __AAL_LINUX__ )
+
+   krnl_virt = (btVirtAddr)dma_alloc_coherent(&((struct pci_dev*)devhandle)->dev, size_in_bytes, (dma_addr_t*)pdma_handle, GFP_KERNEL);
+   __ASSERT_HERE_IN_FN(NULL != krnl_virt);
+   if ( NULL == krnl_virt ) {
+      return NULL;
+   }
+
+
+#elif defined( __AAL_WINDOWS__ )
+   // MmAllocateContiguousMemorySpecifyCache allocates a block of nonpaged memory that is contiguous
+   //  in physical address space. The routine maps this block to a contiguous block of virtual memory
+   //  in the system address space and returns the virtual address of the base of this block.
+   //  The routine aligns the starting address of a contiguous memory allocation to a memory page boundary.
+
+   alignment.QuadPart = kosal_round_up_to_page_size(size_in_bytes);
+   krnl_virt = (btVirtAddr)MmAllocateContiguousMemorySpecifyCache((SIZE_T)size_in_bytes,
+                                                                  minaddr,
+                                                                  maxaddr,
+                                                                  alignment,
+                                                                  MmNonCached);
+   __ASSERT_HERE_IN_FN(NULL != krnl_virt);
+   if ( NULL == krnl_virt ) {
+      return NULL;
+   }
+
+#endif // OS
+
+   // Recommended security practice..
+   memset(krnl_virt, 0, (size_t)size_in_bytes);
+
+   PMEMORY_HERE("_kosal_alloc_dma_coherent(size=%llu [0x%llx]) = 0x%" PRIxUINTPTR_T " [phys=0x%" PRIxPHYS_ADDR "]\n",
+                   size_in_bytes, size_in_bytes,
+                   __UINTPTR_T_CAST(krnl_virt),
+                 (long unsigned int)*pdma_handle);
+
+   return krnl_virt;
+}
+
+//=============================================================================
+/// kosal_free_contiguous_mem
+/// @brief     Free buffer of contiguous physical pages allocated through
+///            kosal_alloc_contiguous_mem_nocache
+/// @param[in] size in bytes
+/// @return    pointer to memory. NULL if failure.
+/// @note
+//=============================================================================
+void _kosal_free_dma_coherent( __ASSERT_HERE_PROTO btHANDLE devhandle,
+                               btVirtAddr krnl_virt,
+                               btWSSize size_in_bytes,
+                               btHANDLE dma_handle)
+{
+#if   defined( __AAL_WINDOWS__ )
+   UNREFERENCED_PARAMETER(size_in_bytes);
+#endif // __AAL_WINDOWS__
+
+   __ASSERT_HERE_IN_FN(NULL != krnl_virt);
+   __ASSERT_HERE_IN_FN(size_in_bytes > 0);
+
+   PMEMORY_HERE("_kosal_free_dma_coherent(ptr=0x%" PRIxUINTPTR_T " [phys=0x%" PRIxPHYS_ADDR "], bytes=%llu [0x%llx])\n",
+                   __UINTPTR_T_CAST(krnl_virt),
+                   kosal_virt_to_phys(krnl_virt),
+                   size_in_bytes, size_in_bytes);
+
+   // Recommended security practice..
+   if ( NULL != krnl_virt ) {
+      memset(krnl_virt, 0, (size_t)size_in_bytes);
+   }
+
+#if   defined( __AAL_LINUX__ )
+
+
+      dma_free_coherent(&((struct pci_dev*)devhandle)->dev, size_in_bytes, krnl_virt, (dma_addr_t)dma_handle);
+
+#elif defined( __AAL_WINDOWS__ )
+
+   if ( NULL != krnl_virt ) {
+      MmFreeContiguousMemory(krnl_virt);
+   }
+
+#endif // OS
+}
+
+#if   defined( __AAL_LINUX__ )
+
+void task_poller(struct work_struct *work)
+{
+   struct delayed_work *delayedWork = container_of(work, struct delayed_work, work);
+   struct kosal_work_object *pwork  = container_of(delayedWork, struct kosal_work_object, workobj);
+
+   pwork->fnct(pwork->context);
+
+}
+void kosal_queue_delayed_work(kosal_work_queue wq, struct kosal_work_object *pwo, KOSAL_TIME msec) {
+
+   queue_delayed_work(wq,&(pwo->workobj),msecs_to_jiffies(msec));
+}
+
+
+#elif defined( __AAL_WINDOWS__ )
+
+void WorkItemCallback(IN PDEVICE_OBJECT pdevObject, IN PVOID Context) {
+   struct kosal_work_object *pwork = ( struct kosal_work_object * )Context;
+   UNREFERENCED_PARAMETER(pdevObject);
+   kosal_mdelay(pwork->msec_delay);
+   pwork->fnct(pwork->context);
+   return;
+}
+
+void kosal_queue_delayed_work(kosal_work_queue wq, struct kosal_work_object *pwo, btTime msec)
+{
+   pwo->msec_delay = msec;
+   IoQueueWorkItem(wq, WorkItemCallback, DelayedWorkQueue, pwo);
+}
+
+void kosal_wake_up_interruptible(kosal_poll_object *pwaitq)
+{
+   NTSTATUS Status;
+   if ( NULL != *pwaitq ) {
+      // Check to see if the IRP was canceled already   
+      Status = WdfRequestUnmarkCancelable(*pwaitq);
+      if ( Status != STATUS_CANCELLED ) {
+         // Complete normally
+         WdfRequestComplete(*pwaitq, STATUS_SUCCESS);
+      }
+   }
+   kosal_poll_object_consume(pwaitq);
+}
+
+#endif // __AAL_WINDOWS__
+
+btVirtAddr _kosal_get_user_buffer( __ASSERT_HERE_PROTO btVirtAddr user_prt, btWSSize size_in_bytes)
+{
+
+
+#if   defined( __AAL_LINUX__ )
+   unsigned long ret;
+   btVirtAddr pkbuffer = vmalloc(size_in_bytes);
+   if(NULL== pkbuffer){
+      return NULL;
+   }
+
+   memset(pkbuffer,0,size_in_bytes);
+   ret = copy_from_user(pkbuffer, user_prt, size_in_bytes);
+   if(ret != 0){
+      vfree(pkbuffer);
+      return NULL;
+   }
+   return pkbuffer;
+#elif defined( __AAL_WINDOWS__ )  //TODO
+   UNREFERENCED_PARAMETER(user_prt);
+   UNREFERENCED_PARAMETER(size_in_bytes);
+
+   __ASSERT_HERE_IN_FN( NULL != user_prt );
+   __ASSERT_HERE_IN_FN( 0 != size_in_bytes );
+   return NULL;
+#endif
+}
+
+void _kosal_free_user_buffer(__ASSERT_HERE_PROTO btVirtAddr user_prt,  btWSSize size_in_bytes)
+{
+
+#if   defined( __AAL_LINUX__ )
+   vfree(user_prt);
+#elif defined( __AAL_WINDOWS__ )  // TODO
+   UNREFERENCED_PARAMETER( user_prt );
+   UNREFERENCED_PARAMETER( size_in_bytes );
+
+   __ASSERT_HERE_IN_FN( NULL != user_prt );
+   __ASSERT_HERE_IN_FN( 0 != size_in_bytes );
+
+#endif
+}
+
+
+char* kosal_gettimestamp(void) 
+{
+
+#if defined( __AAL_LINUX__ )
+
+   static char timestamp[200];
+   struct rtc_time tm;
+   struct timeval time;
+   unsigned long local_time;
+
+   do_gettimeofday(&time);
+   local_time = (u32)(time.tv_sec - (sys_tz.tz_minuteswest * 60));
+   rtc_time_to_tm(local_time, &tm);
+
+   sprintf(timestamp," Time Stamp: %04d-%02d-%02d %02d:%02d:%02d ",
+                                                                   tm.tm_year + 1900,
+                                                                   tm.tm_mon + 1,
+                                                                   tm.tm_mday,
+                                                                   tm.tm_hour,
+                                                                   tm.tm_min,
+                                                                   tm.tm_sec);
+
+   return timestamp;
+#elif defined( __AAL_WINDOWS__ )
+
+#endif
+}
+
+
+
diff --git a/drivers/fpga/aal/cci/Makefile b/drivers/fpga/aal/cci/Makefile
new file mode 100644
index 000000000000..6e8c1e3abc92
--- /dev/null
+++ b/drivers/fpga/aal/cci/Makefile
@@ -0,0 +1,40 @@
+ccflags-y := -I$(src)/../include -D__KERNEL__=1
+ccflags-y += -DDRV_NAME=\"ccipciedrv\"
+ccflags-y += -DDRV_VERSION=\"6.3.1\"
+ccflags-y += -I$(src)
+
+ifdef CONFIG_AAL_DEBUG
+	ccflags-y += -DENABLE_DEBUG=1
+else
+	ccflags-y += -DENABLE_DEBUG=0
+endif
+
+ifdef CONFIG_AAL_ASSERT
+	ccflags-y += -DENABLE_ASSERT=1
+else
+	ccflags-y += -DENABLE_ASSERT=0
+endif
+
+obj-$(CONFIG_AAL_CCI)	+= ccipciedrv.o
+
+ccipciedrv-y	:=	cci_pcie_driver_main_linux.o	\
+			cci_pcie_driver_simulator.o	\
+			ccip_sim_mmio.o			\
+			cci_pcie_common.o 		\
+			cci_pcie_driver_PIPsession.o	\
+			cci_pcie_driver_umapi_linux.o	\
+			cci_pcie_driver_umapi_common.o	\
+			ccip_fme.o			\
+			ccip_port.o			\
+			ccip_afu.o			\
+			ccip_stap.o			\
+			ccip_pr.o			\
+			ccip_perfmon.o			\
+			ccip_perfmon_linux.o		\
+			ccip_fme_mmap_linux.o		\
+			ccip_logging.o			\
+			ccip_logging_linux.o		\
+			ccip_pwr.o 			\
+			kOSAL.o
+
+
diff --git a/drivers/fpga/aal/cci/cci_pcie_common.c b/drivers/fpga/aal/cci/cci_pcie_common.c
new file mode 100644
index 000000000000..78c95283f182
--- /dev/null
+++ b/drivers/fpga/aal/cci/cci_pcie_common.c
@@ -0,0 +1,582 @@
+//******************************************************************************
+// This  file  is  provided  under  a  dual BSD/GPLv2  license.  When using or
+//         redistributing this file, you may do so under either license.
+//
+//                            GPL LICENSE SUMMARY
+//
+//  Copyright(c) 2015-2017, Intel Corporation.
+//
+//  This program  is  free software;  you  can redistribute it  and/or  modify
+//  it  under  the  terms of  version 2 of  the GNU General Public License  as
+//  published by the Free Software Foundation.
+//
+//  This  program  is distributed  in the  hope that it  will  be useful,  but
+//  WITHOUT   ANY   WARRANTY;   without   even  the   implied   warranty    of
+//  MERCHANTABILITY  or  FITNESS  FOR  A  PARTICULAR  PURPOSE.  See  the   GNU
+//  General Public License for more details.
+//
+//  The  full  GNU  General Public License is  included in  this  distribution
+//  in the file called README.GPLV2-LICENSE.TXT.
+//
+//  Contact Information:
+//  Henry Mitchel, henry.mitchel at intel.com
+//  77 Reed Rd., Hudson, MA  01749
+//
+//                                BSD LICENSE
+//
+//  Copyright(c) 2015-2017, Intel Corporation.
+//
+//  Redistribution and  use  in source  and  binary  forms,  with  or  without
+//  modification,  are   permitted  provided  that  the  following  conditions
+//  are met:
+//
+//    * Redistributions  of  source  code  must  retain  the  above  copyright
+//      notice, this list of conditions and the following disclaimer.
+//    * Redistributions in  binary form  must  reproduce  the  above copyright
+//      notice,  this  list of  conditions  and  the  following disclaimer  in
+//      the   documentation   and/or   other   materials   provided  with  the
+//      distribution.
+//    * Neither   the  name   of  Intel  Corporation  nor  the  names  of  its
+//      contributors  may  be  used  to  endorse  or promote  products derived
+//      from this software without specific prior written permission.
+//
+//  THIS  SOFTWARE  IS  PROVIDED  BY  THE  COPYRIGHT HOLDERS  AND CONTRIBUTORS
+//  "AS IS"  AND  ANY  EXPRESS  OR  IMPLIED  WARRANTIES,  INCLUDING,  BUT  NOT
+//  LIMITED  TO, THE  IMPLIED WARRANTIES OF  MERCHANTABILITY  AND FITNESS  FOR
+//  A  PARTICULAR  PURPOSE  ARE  DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT
+//  OWNER OR CONTRIBUTORS BE LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,
+//  SPECIAL,  EXEMPLARY,  OR  CONSEQUENTIAL   DAMAGES  (INCLUDING,   BUT   NOT
+//  LIMITED  TO,  PROCUREMENT  OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF USE,
+//  DATA,  OR PROFITS;  OR BUSINESS INTERRUPTION)  HOWEVER  CAUSED  AND ON ANY
+//  THEORY  OF  LIABILITY,  WHETHER  IN  CONTRACT,  STRICT LIABILITY,  OR TORT
+//  (INCLUDING  NEGLIGENCE  OR OTHERWISE) ARISING  IN ANY WAY  OUT  OF THE USE
+//  OF  THIS  SOFTWARE, EVEN IF ADVISED  OF  THE  POSSIBILITY  OF SUCH DAMAGE.
+//******************************************************************************
+//****************************************************************************
+//        FILE: cci_common.c
+//     CREATED: Jul 28, 2015
+//      AUTHOR: Joseph Grecco <joe.grecco@intel.com>
+//
+// PURPOSE:   This file holds OS independent AAL specific implementation
+//            common to this driver.
+// HISTORY:
+// COMMENTS:
+// WHEN:          WHO:     WHAT:
+//****************************************************************************///
+#include "aalsdk/kernel/kosal.h"
+#define MODULE_FLAGS CCIPCIE_DBG_MOD // Prints all
+
+#include "aalsdk/kernel/aalbus.h"
+#include "aalsdk/kernel/ccipdriver.h"
+#include "aalsdk/kernel/iaaldevice.h"
+#include "aalsdk/kernel/ccip_defs.h"
+
+#include "cci_pcie_driver_internal.h"
+
+
+#include "ccip_port.h"
+#include "ccip_fme.h"
+
+extern struct cci_aal_device   *
+               cci_create_AAL_SignalTap_Device( struct port_device  *,
+                                                struct aal_device_id *);
+extern struct cci_aal_device   *
+                      cci_create_AAL_PR_Device( struct fme_device  *,
+                                                struct aal_device_id *);
+
+extern struct cci_aal_device   *
+                       cci_create_AAL_UAFU_Device( struct port_device  *,
+                                                   btPhysAddr,
+                                                   struct CCIP_AFU_Header *,
+                                                   struct aal_device_id *);
+
+struct cci_aal_device   *
+               cci_create_AAL_Port_Device( struct port_device  *,
+                                           btUnsigned32bitInt devnum,
+                                           struct aal_device_id *);
+
+///============================================================================
+/// Name: create_ccidevice
+/// @brief Creates the CCI Board device object
+/// @return ccip_device
+///============================================================================
+struct ccip_device * create_ccidevice()
+{
+   // Allocate the board object
+   struct ccip_device * pccipdev = (struct ccip_device * ) kosal_kzmalloc(sizeof(struct ccip_device));
+   if ( NULL ==  pccipdev ) {
+      PERR("Could not allocate CCI device object\n");
+      return NULL;
+   }
+
+   // Initialize object
+   kosal_list_init(&cci_aaldev_list_head(pccipdev));
+   kosal_list_init(&cci_aaldev_list_head(pccipdev));
+   kosal_list_init(&ccip_aal_dev_list(pccipdev));
+   kosal_list_init(&ccip_port_dev_list(pccipdev));
+
+   kosal_mutex_init(cci_aaldev_psem(pccipdev));
+
+   return pccipdev;
+}
+
+///============================================================================
+/// Name: destroy_ccidevice
+/// @brief Destroys the CCI Board device object
+/// @return ccip_device
+///============================================================================
+void  destroy_ccidevice(struct ccip_device *pccidev)
+{
+   kosal_list_head *paaldev_list = &ccip_aal_dev_list(pccidev);
+   kosal_list_head *port_list = &ccip_port_dev_list( pccidev );
+
+   PVERBOSE("Destroying CCI devices\n");
+
+   // Check the aaldevice list for any registered objects
+   if( !kosal_list_is_empty( paaldev_list ) ){
+      struct cci_aal_device *pcci_aaldev   = NULL;
+      kosal_list_head       *This          = NULL;
+      kosal_list_head       *tmp           = NULL;
+
+      // Run through list of devices.  Use safe variant
+      //  as we will be deleting entries
+      kosal_list_for_each_safe(This, tmp, paaldev_list) {
+
+         pcci_aaldev = cci_list_to_cci_aal_device(This);
+
+         cci_unpublish_aaldevice(pcci_aaldev);
+         cci_destroy_aal_device(pcci_aaldev);
+      }
+
+   }else{
+      PVERBOSE("No published objects to remove\n");
+   }
+
+   // If Lists not empty do it TODO
+   // Check the aaldevice list for any registered objects
+   if( !kosal_list_is_empty( port_list ) ){
+      struct port_device    *pportdev     = NULL;
+      kosal_list_head       *This         = NULL;
+      kosal_list_head       *tmp          = NULL;
+
+      // Run through list of devices.  Use safe variant
+      //  as we will be deleting entries
+      kosal_list_for_each_safe(This, tmp, port_list) {
+
+         pportdev = cci_list_to_cci_port_device(This);
+         destroy_port_device(pportdev);
+      }
+
+   }else{
+      PVERBOSE("No port objects to remove\n");
+   }
+
+   // Destroy the FME device
+   if(NULL != ccip_dev_to_fme_dev(pccidev)) {
+      PVERBOSE("Freeing FME Memory\n");
+      kosal_kfree(ccip_dev_to_fme_dev(pccidev),sizeof(struct fme_device ) );
+   }
+
+   // Remove ourselves from any lists
+   kosal_sem_get_krnl( &pccidev->m_sem );
+   kosal_list_del(&cci_aaldev_list_head(pccidev));
+   kosal_sem_put( &pccidev->m_sem );
+
+   kosal_kfree(pccidev, sizeof(struct ccip_device));
+}
+
+///============================================================================
+/// Name: cci_fme_dev_create_AAL_allocatable_objects
+/// @brief Creates and registers FME objects (resources) we want to expose
+///        Through AAL.
+///
+/// @param[in] pccipdev - CCI Board object .
+/// @return    error code
+///============================================================================
+btBool cci_fme_dev_create_AAL_allocatable_objects(struct ccip_device * pccipdev)
+{
+   struct cci_aal_device   *pcci_aaldev = NULL;
+   struct aal_device_id     aalid;
+   int                      ret        = 0;
+
+   //=====================================================================
+   // Create the FME AAL device. The FME AAL device is the class
+   //   is registered with AAL Bus to enable it to be allocated by an
+   //   application. AAL device objects represent the application usable
+   //   devices. AAL device objects have their own low level communication
+   //   function called the Physical Interface Protocol (PIP). This enables
+   //   us to easily create object specific interfaces in a single driver.
+
+   // Construct the cci_aal_device object
+   pcci_aaldev = cci_create_aal_device();
+   ASSERT(NULL != pcci_aaldev);
+   if(NULL == pcci_aaldev) {
+      return false;
+   }
+
+   // Make it an FME by setting the type field and giving a pointer to the
+   //  FME device object of the CCIP board device
+   cci_aaldev_type(pcci_aaldev) = cci_dev_FME;
+   cci_aaldev_pfme(pcci_aaldev) = ccip_dev_to_fme_dev(pccipdev);
+   cci_aaldev_pci_dev(pcci_aaldev) = ccip_dev_to_pci_dev(pccipdev);
+
+   // Setup the AAL device's ID. This is the collection of attributes
+   //  that uniquely identifies the AAL device, usually for the purpose
+   //  of allocation through Resource Management
+   //------------------------------------------------------------------
+   aaldevid_devaddr_bustype(aalid)     =  ccip_dev_pcie_bustype(pccipdev);
+
+   // The AAL address maps to the PCIe address. The Subdevice number is
+   //  vendor defined and in this case the FME object has the value CCIP_DEV_FME_SUBDEV
+   //
+   // Device addressing follows the convention of B:D:F is the PCIe address.
+   //  The B:D:F uniquely identifies a physical board which is the root of the
+   //  device hierarchy. All AAL devices under this board will have the same B:D:F
+   //  The subdevice number is used to identify the Port number in the hierarchy. For
+   //  the FME object it is 0xFFFF.
+   //  Because every AAL device exposed through the AAL kernel framework must have a unique
+   //  address, the instance number is used to uniquely identify Objects under the subdevice.
+   //  The instance number simply increments within an adress space and should not be assumed
+   //  to relate to a particular object type.
+   //  Example:  For B:D:F  		00010001:0:0
+   //       FME address: 			00010001:0:0:FFFF:0
+   //       Port 0 address:			00010001:0:0:0:0
+   //       PR Port 0 address:  	00010001:0:0:0:1   (the instance number is not have a define value other than to create a unique address)
+   //       UAFU Port 0 address:	00010001:0:0:0:2
+   //       Port 1 address:			00010001:0:0:1:0
+   //       PR Port 1 address:  	00010001:0:0:1:1   (the instance number is not have a define value other than to create a unique address)
+   //       UAFU Port 1 address:	00010001:0:0:1:2
+
+   aaldevid_devaddr_busnum(aalid)      = ccip_dev_pcie_busnum(pccipdev);
+   aaldevid_devaddr_devnum(aalid)      = ccip_dev_pcie_devnum(pccipdev);
+   aaldevid_devaddr_fcnnum(aalid)      = ccip_dev_pcie_fcnnum(pccipdev);
+   aaldevid_devaddr_subdevnum(aalid)   = CCIP_DEV_FME_SUBDEV;	// FME subdevice number is constant
+   aaldevid_devaddr_socketnum(aalid)   = ccip_dev_pcie_socketnum(pccipdev);  
+   aaldevid_devaddr_instanceNum(aalid) = 0;						// FME is always instance 0
+
+   // The following attributes describe the interfaces supported by the device
+   aaldevid_afuguidl(aalid)            = CCIP_FME_GUIDL;
+   aaldevid_afuguidh(aalid)            = CCIP_FME_GUIDH;
+   aaldevid_devtype(aalid)             = aal_devtypeAFU;
+   aaldevid_pipguid(aalid)             = CCIP_FME_PIPIID;
+   aaldevid_vendorid(aalid)            = AAL_vendINTC;
+
+   // Set the interface permissions
+   // Enable MMIO-R
+   cci_aaldev_set_allow_map_mmior_space(pcci_aaldev);
+
+
+   // Setup the MMIO region parameters
+   cci_aaldev_kvp_afu_mmio(pcci_aaldev)   = ccip_fmedev_kvp_afu_mmio(pccipdev);
+   cci_aaldev_len_afu_mmio(pcci_aaldev)   = ccip_fmedev_len_afu_mmio(pccipdev);
+   cci_aaldev_phys_afu_mmio(pcci_aaldev)  = ccip_fmedev_phys_afu_mmio(pccipdev);
+
+   // Create the AAL device and attach it to the CCI device object
+   cci_aaldev_to_aaldev(pcci_aaldev) =  aaldev_create( "CCIPFME",           // AAL device base name
+                                                       &aalid,             // AAL ID
+                                                       &cci_FMEpip);
+
+   //CCI device object create fails, delete FME AAL device
+   if(NULL == cci_aaldev_to_aaldev(pcci_aaldev) ){
+      cci_destroy_aal_device(pcci_aaldev);
+      return false;
+   }
+
+   //===========================================================
+   // Set up the optional aal_device attributes
+   //
+
+   // Set how many owners are allowed access to this device simultaneously
+   pcci_aaldev->m_aaldev->m_maxowners = 1;
+
+   // Set the config space mapping permissions
+   cci_aaldev_to_aaldev(pcci_aaldev)->m_mappableAPI = AAL_DEV_APIMAP_NONE;
+   if( cci_aaldev_allow_map_csr_read_space(pcci_aaldev) ){
+      cci_aaldev_to_aaldev(pcci_aaldev)->m_mappableAPI |= AAL_DEV_APIMAP_CSRWRITE;
+   }
+
+   if( cci_aaldev_allow_map_csr_write_space(pcci_aaldev) ){
+      cci_aaldev_to_aaldev(pcci_aaldev)->m_mappableAPI |= AAL_DEV_APIMAP_CSRREAD;
+   }
+
+   if( cci_aaldev_allow_map_mmior_space(pcci_aaldev) ){
+      cci_aaldev_to_aaldev(pcci_aaldev)->m_mappableAPI |= AAL_DEV_APIMAP_MMIOR;
+   }
+
+   if( cci_aaldev_allow_map_umsg_space(pcci_aaldev) ){
+      cci_aaldev_to_aaldev(pcci_aaldev)->m_mappableAPI |= AAL_DEV_APIMAP_UMSG;
+   }
+
+   // The PIP uses the PIP context to get a handle to the CCI Device from the generic device.
+   aaldev_pip_context(cci_aaldev_to_aaldev(pcci_aaldev)) = (void*)pcci_aaldev;
+
+   // Method called when the device is released (i.e., its destructor)
+   //  The canonical release device calls the user's release method.
+   //  If NULL is provided then only the canonical behavior is done
+   dev_setrelease(cci_aaldev_to_aaldev(pcci_aaldev), cci_release_device);
+
+      // Device is ready for use.  Publish it with the Configuration Management Subsystem
+   ret = cci_publish_aaldevice(pcci_aaldev);
+   ASSERT(ret == 0);
+   if(0> ret){
+      PERR("Failed to initialize AAL Device for FME[%d:%d:%d:%x:%d]",aaldevid_devaddr_busnum(aalid),
+                                                                     aaldevid_devaddr_devnum(aalid),
+                                                                     aaldevid_devaddr_fcnnum(aalid),
+                                                                     aaldevid_devaddr_subdevnum(aalid),
+																	 aaldevid_devaddr_instanceNum(aalid));
+      kosal_kfree(cci_aaldev_kvp_afu_mmio(pcci_aaldev), cci_aaldev_len_afu_mmio(pcci_aaldev));
+      kosal_kfree(cci_aaldev_kvp_afu_umsg(pcci_aaldev),cci_aaldev_len_afu_umsg(pcci_aaldev));
+      cci_destroy_aal_device(pcci_aaldev);
+      return false;
+   }
+
+   // Add the device to the CCI Board device's device list
+   kosal_list_add(&cci_aaldev_list_head(pcci_aaldev), &ccip_aal_dev_list(pccipdev));
+
+   return true;
+}
+
+///============================================================================
+/// Name: cci_create_AAL_PR_allocatable_objects
+/// @brief Creates and registers PR objects (resources) we want to expose
+///        through AAL.
+///
+/// @param[in] pccipdev - CCI Board object .
+/// @return    error code
+///============================================================================
+btBool cci_create_AAL_PR_allocatable_objects(struct ccip_device * pccipdev)
+{
+   struct cci_aal_device   *pcci_aaldev = NULL;
+   struct aal_device_id     aalid;
+
+   //========================
+   // Instantiate a PR Device
+
+   aaldevid_devaddr_bustype(aalid)     = ccip_dev_pcie_bustype(pccipdev);
+   aaldevid_devaddr_busnum(aalid)      = ccip_dev_pcie_busnum(pccipdev);
+   aaldevid_devaddr_devnum(aalid)      = ccip_dev_pcie_devnum(pccipdev);
+   aaldevid_devaddr_fcnnum(aalid)      = ccip_dev_pcie_fcnnum(pccipdev);
+   aaldevid_devaddr_subdevnum(aalid)   = 0x0;    // PR subdevice number is constant
+   aaldevid_devaddr_instanceNum(aalid) = 0x5;    // PR is always instance 06
+   aaldevid_devaddr_socketnum(aalid)   = ccip_dev_pcie_socketnum(pccipdev);
+   aaldevid_devtype(aalid)             = aal_devtypeAFU;
+
+   pcci_aaldev = cci_create_AAL_PR_Device(ccip_dev_to_fme_dev(pccipdev), &aalid);
+   ASSERT(NULL != pcci_aaldev);
+
+   if(NULL == pcci_aaldev){
+      PDEBUG("ERROR: Creating PR device\n");
+      return false;     // TODO This is a BUG if we get here but should cleanup correctly.
+   }
+
+   // Add the device to the CCI Board device's device list
+   kosal_list_add(&cci_aaldev_list_head(pcci_aaldev), &ccip_aal_dev_list(pccipdev));
+
+   return true;
+}
+
+///============================================================================
+/// Name: cci_port_dev_create_AAL_allocatable_objects
+/// @brief Creates and registers Port objects (resources) we want to expose
+///        through AAL.
+///
+/// @param[in] pportdev - CCI Port object
+/// @param[in] devnum - Port number
+/// @return    error code
+///============================================================================
+btBool cci_port_dev_create_AAL_allocatable_objects(struct port_device  *pportdev,
+                                                   btUnsigned32bitInt devnum)
+{
+   struct cci_aal_device   *pcci_aaldev = NULL;
+   struct aal_device_id     aalid;
+
+
+   //==================================================
+   // Instantiate a Port device
+   //  Creates the Port AAL devuce. Initializes
+   //  the aalid used for all of the child devices to
+   //  be created later.
+   pcci_aaldev = cci_create_AAL_Port_Device(pportdev, devnum, &aalid);
+   ASSERT(NULL != pcci_aaldev);
+
+   if(NULL == pcci_aaldev){
+      PDEBUG("ERROR: Creating port device\n");
+      return false;     // TODO This is a BUG if we get here but should cleanup correctly.
+   }
+
+   // Add the device to the CCI Board device's device list
+   kosal_list_add( &cci_aaldev_list_head(pcci_aaldev), &ccip_aal_dev_list( ccip_port_to_ccidev(pportdev) ));
+
+   //=======================================
+   // Instantiate a Signal Tap device
+   aaldevid_devaddr_instanceNum(aalid)++;
+   pcci_aaldev = cci_create_AAL_SignalTap_Device(pportdev, &aalid);
+   ASSERT(NULL != pcci_aaldev);
+
+   if(NULL == pcci_aaldev){
+      PDEBUG("ERROR: Creating Signal Tap device\n");
+      return false;     // TODO This is a BUG if we get here but should cleanup correctly.
+   }
+
+   ccip_port_stap_dev(pportdev)  = pcci_aaldev;
+   // Add the device to the CCI Board device's device list
+   kosal_list_add( &cci_aaldev_list_head(pcci_aaldev), &ccip_aal_dev_list( ccip_port_to_ccidev(pportdev) ));
+
+   
+   //=========================================
+   // Instantiate a User AFU if one is present
+   {
+      // Get the AFU header pointer by adding the offset to the port header address
+      struct CCIP_AFU_Header        *pafu_hdr = (struct CCIP_AFU_Header *)(((btVirtAddr)ccip_port_hdr(pportdev) ) + ccip_port_hdr(pportdev)->ccip_port_next_afu.afu_id_offset);
+      btPhysAddr                     pafu_phys = ccip_port_phys_mmio(pportdev) + ccip_port_hdr(pportdev)->ccip_port_next_afu.afu_id_offset;
+
+      // If the device is present
+      if(~0ULL != pafu_hdr->ccip_dfh.csr){
+
+         // Instantiate it
+         aaldevid_devaddr_instanceNum(aalid)++;
+         pcci_aaldev = cci_create_AAL_UAFU_Device(  pportdev,
+                                                    pafu_phys,
+                                                    pafu_hdr,
+                                                   &aalid);
+         ASSERT(NULL != pcci_aaldev);
+
+         if(NULL == pcci_aaldev){
+            PDEBUG("ERROR: Creating User AFU device\n");
+            return false;     // TODO This is a BUG if we get here but should cleanup correctly.
+         }
+
+         // Add the device to the CCI Board device's device list
+         kosal_list_add( &cci_aaldev_list_head(pcci_aaldev), &ccip_aal_dev_list( ccip_port_to_ccidev(pportdev) ));
+
+      } // End if(~0ULL == pafu_hdr->ccip_dfh.csr){
+   } //End block
+
+   return true;
+}
+
+///============================================================================
+/// Name: cci_create_aal_device
+/// @brief Constructor for a cci_aal_device object.
+/// @return    pointer to object
+///============================================================================
+ struct cci_aal_device* cci_create_aal_device()
+{
+   struct cci_aal_device* pcci_aaldev = NULL;
+
+   // Allocate the cci_aal_device object
+   pcci_aaldev = (struct cci_aal_device*) kosal_kzmalloc(sizeof(struct cci_aal_device));
+   if ( NULL == pcci_aaldev ) {
+      PERR("Unable to allocate system memory for cci_aal_device object\n");
+      return NULL;
+   }
+
+   // Initialize object
+   kosal_list_init(&cci_aaldev_list_head(pcci_aaldev));
+   kosal_mutex_init(cci_aaldev_psem(pcci_aaldev));
+   kosal_mutex_init(cci_dev_pr_sem(pcci_aaldev));
+
+   return pcci_aaldev;
+}
+
+//=============================================================================
+// Name: cci_destroy_aal_device
+// Description: Destructor for a cci_aal_device object
+// Inputs: pointer to object.
+// Outputs: 0 - success
+// Comments: none.
+//=============================================================================
+int cci_destroy_aal_device( struct cci_aal_device* pcci_aaldev)
+{
+   ASSERT(NULL != pcci_aaldev);
+   if(NULL == pcci_aaldev){
+      PERR("Attempting to destroy NULL pointer to cci_aal_device object\n");
+      return -EINVAL;
+   }
+
+   // Destroy Work Queue
+   if(NULL != pcci_aaldev->m_workq_reconf) {
+       kosal_destroy_workqueue(pcci_aaldev->m_workq_reconf);
+    }
+
+   kosal_list_del( &cci_aaldev_list_head(pcci_aaldev));
+
+   kosal_kfree(pcci_aaldev, sizeof(struct cci_aal_device));
+   return 0;
+}
+
+//=============================================================================
+// Name: cci_release_device
+// Description: callback for notification that an AAL Device is being destroyed.
+// Interface: public
+// Inputs: pdev: kernel-provided generic device structure.
+// Outputs: none.
+// Comments:
+//=============================================================================
+void
+cci_release_device(pkosal_os_dev pdev)
+{
+
+   struct aal_device *paaldev = basedev_to_aaldev(pdev);
+//   struct cci_aal_device *pcci_aaldev = aaldev_to_cci_aal_device(paaldev);
+
+   PTRACEIN;
+
+   PDEBUG("Called with struct aal_device * 0x%p\n", paaldev);
+//   kosal_list_del( &cci_aaldev_list_head(pcci_aaldev));
+
+   // DO NOT call factory release here. It will be done by the framework.
+   PTRACEOUT;
+}
+
+//=============================================================================
+// Name: cci_publish_aaldevice
+// Description: Publishes an AAL Device with the Configuration Management
+//              subsystem.
+// Inputs: pCCIdev - Device Object .
+// Outputs: 0 - success.
+// Comments: none.
+//=============================================================================
+int cci_publish_aaldevice(struct cci_aal_device * pcci_aaldev)
+{
+   btInt ret = 0;
+#if defined( __AAL_WINDOWS__ )
+   UNREFERENCED_PARAMETER(pcci_aaldev);
+#else
+   // Pointer to the AAL Bus interface
+   struct aal_bus       *pAALbus = aalbus_get_bus();
+
+   ASSERT(pcci_aaldev);
+
+   ret = pAALbus->register_device(cci_aaldev_to_aaldev(pcci_aaldev));
+   if ( 0 != ret ) {
+      return -ENODEV;
+   }
+   PVERBOSE("Published CCI device\n");
+#endif
+   return ret;
+} //cci_publish_aaldevice
+
+//=============================================================================
+// Name: cci_unpublish_aaldevice
+// Description: Removes AAL Device from Configuration
+// Input: pCCIdev - device to remove
+// Comment:
+// Returns: none
+// Comments:
+//=============================================================================
+void
+cci_unpublish_aaldevice(struct cci_aal_device *pcci_aaldev)
+{
+   PVERBOSE("Removing CCI device from configuration\n");
+
+   if ( NULL!= cci_aaldev_to_aaldev(pcci_aaldev) ) {
+      PINFO("Removing AAL device\n");
+      aalbus_get_bus()->unregister_device(cci_aaldev_to_aaldev(pcci_aaldev));
+      cci_aaldev_to_aaldev(pcci_aaldev) = NULL;
+   }
+
+} // cci_unpublish_aaldevice
+
+
+
diff --git a/drivers/fpga/aal/cci/cci_pcie_driver_PIPsession.c b/drivers/fpga/aal/cci/cci_pcie_driver_PIPsession.c
new file mode 100644
index 000000000000..1ed7aec2b569
--- /dev/null
+++ b/drivers/fpga/aal/cci/cci_pcie_driver_PIPsession.c
@@ -0,0 +1,286 @@
+//******************************************************************************
+// This  file  is  provided  under  a  dual BSD/GPLv2  license.  When using or
+//         redistributing this file, you may do so under either license.
+//
+//                            GPL LICENSE SUMMARY
+//
+//  Copyright(c) 2015-2017, Intel Corporation.
+//
+//  This program  is  free software;  you  can redistribute it  and/or  modify
+//  it  under  the  terms of  version 2 of  the GNU General Public License  as
+//  published by the Free Software Foundation.
+//
+//  This  program  is distributed  in the  hope that it  will  be useful,  but
+//  WITHOUT   ANY   WARRANTY;   without   even  the   implied   warranty    of
+//  MERCHANTABILITY  or  FITNESS  FOR  A  PARTICULAR  PURPOSE.  See  the   GNU
+//  General Public License for more details.
+//
+//  The  full  GNU  General Public License is  included in  this  distribution
+//  in the file called README.GPLV2-LICENSE.TXT.
+//
+//  Contact Information:
+//  Henry Mitchel, henry.mitchel at intel.com
+//  77 Reed Rd., Hudson, MA  01749
+//
+//                                BSD LICENSE
+//
+//  Copyright(c) 2012-2017, Intel Corporation.
+//
+//  Redistribution and  use  in source  and  binary  forms,  with  or  without
+//  modification,  are   permitted  provided  that  the  following  conditions
+//  are met:
+//
+//    * Redistributions  of  source  code  must  retain  the  above  copyright
+//      notice, this list of conditions and the following disclaimer.
+//    * Redistributions in  binary form  must  reproduce  the  above copyright
+//      notice,  this  list of  conditions  and  the  following disclaimer  in
+//      the   documentation   and/or   other   materials   provided  with  the
+//      distribution.
+//    * Neither   the  name   of  Intel  Corporation  nor  the  names  of  its
+//      contributors  may  be  used  to  endorse  or promote  products derived
+//      from this software without specific prior written permission.
+//
+//  THIS  SOFTWARE  IS  PROVIDED  BY  THE  COPYRIGHT HOLDERS  AND CONTRIBUTORS
+//  "AS IS"  AND  ANY  EXPRESS  OR  IMPLIED  WARRANTIES,  INCLUDING,  BUT  NOT
+//  LIMITED  TO, THE  IMPLIED WARRANTIES OF  MERCHANTABILITY  AND FITNESS  FOR
+//  A  PARTICULAR  PURPOSE  ARE  DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT
+//  OWNER OR CONTRIBUTORS BE LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,
+//  SPECIAL,  EXEMPLARY,  OR  CONSEQUENTIAL   DAMAGES  (INCLUDING,   BUT   NOT
+//  LIMITED  TO,  PROCUREMENT  OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF USE,
+//  DATA,  OR PROFITS;  OR BUSINESS INTERRUPTION)  HOWEVER  CAUSED  AND ON ANY
+//  THEORY  OF  LIABILITY,  WHETHER  IN  CONTRACT,  STRICT LIABILITY,  OR TORT
+//  (INCLUDING  NEGLIGENCE  OR OTHERWISE) ARISING  IN ANY WAY  OUT  OF THE USE
+//  OF  THIS  SOFTWARE, EVEN IF ADVISED  OF  THE  POSSIBILITY  OF SUCH DAMAGE.
+//******************************************************************************
+//****************************************************************************
+//        FILE: cci_PIPsession.c
+//     CREATED: 07/28/2015
+//      AUTHOR: Joseph Grecco, Intel
+// PURPOSE: This file implements the AAL CCIv4 PIP Session.
+// HISTORY:
+// COMMENTS: The CCIv4 PIP Session is an an object which maintains state and
+//           context between an CCIv4 AAL Device and a user mode application
+//           that has been bound to it.
+// WHEN:          WHO:     WHAT:
+//****************************************************************************
+#include "aalsdk/kernel/kosal.h"
+
+#define MODULE_FLAGS CCIPCIE_DBG_MOD
+
+#include "aalsdk/kernel/aalbus.h"              // for AAL_vendINTC
+#include "aalsdk/kernel/aalui-events.h"
+#include "aalsdk/kernel/aalids.h"
+//#include "aalsdk/kernel/aalbus-device.h"
+#include "aalsdk/kernel/spl2defs.h"
+
+#include "cci_pcie_driver_PIPsession.h"
+#include "cci_pcie_driver_internal.h"
+#include "ccip_port.h"
+#include "aalsdk/kernel/aalmafu-events.h"
+
+
+//=============================================================================
+// Name: session_create
+// Description: Creates a private session object
+//              The session holds PIP context specific to the device and its
+//              owner.
+// Inputs: pownerSession - AAL Object used to maintain context between the PIP
+//                        and its owning process.
+// Outputs: encoder_session
+// Comments:
+//=============================================================================
+struct cci_PIPsession *
+session_create(struct aaldev_ownerSession *pownerSess)
+{
+   struct cci_PIPsession *pSess;
+
+   // Allocate the session object
+   pSess = (struct cci_PIPsession *)kosal_kzmalloc(sizeof(struct cci_PIPsession));
+   ASSERT(NULL != pSess);
+   if( NULL == pSess ){
+      return NULL;
+   }
+
+   // Initialize the session
+   cci_PIPsessionp_to_ownerSession(pSess)  = pownerSess;
+   cci_PIPsessionp_to_aal_afup(pSess)      = aalsess_aaldevicep(pownerSess);
+
+   kosal_mutex_init(cci_PIPsessionp_semaphore(pSess));
+
+   // Save the device for this AFU. (Saved when the AFU was created)
+   cci_PIPsessionp_to_ccidev(pSess) = aaldev_pip_context_to_obj(struct cci_aal_device *, pSess->paaldev);
+
+   PDEBUG("CCI PIP Session Created.\n");
+
+   return pSess;
+}
+
+//=============================================================================
+// Name: BindSession
+// Description: Bind the application session to the PIP
+// Inputs: powerSession - AAL Object used to maintain context between the PIP
+//                        and its owning process.
+// Returns: success = 1
+//=============================================================================
+int
+BindSession(struct aaldev_ownerSession *pownerSess)
+{
+   struct aal_device     *paaldev = NULL;
+   struct cci_aal_device     *pdev    = NULL;
+   struct cci_PIPsession *pSess   = NULL;
+
+   PVERBOSE("Binding UI Session with CCIv4 Device\n");
+
+   // Get the AAL device
+   paaldev = aalsess_aaldevicep(pownerSess);
+
+   // Make sure there is a device to bind to
+   if ( unlikely( NULL == paaldev ) ) {
+      PDEBUG( "No device!\n" );
+      return -ENODEV;
+   }
+
+   // Get the device from the AAL device's PIP context (setup when device was created)
+   pdev = aaldev_pip_context_to_obj(struct cci_aal_device*, paaldev);
+
+   // Create a PIP session and save it.
+   pSess = session_create( pownerSess );
+   if( unlikely( NULL == pSess ) ){
+      PDEBUG( "Create session failed.\n" );
+      return -ENODEV;
+   }
+
+   // Return the session as a handle. This is used later in PIP Command Handler
+   pownerSess->m_PIPHandle = pSess;
+
+   // Save the session in the device
+   cci_aaldev_to_PIPsessionp(pdev) = pSess;
+
+   return 1;
+}
+
+//=============================================================================
+// Name: session_destroy
+// Description: Destroy the private session
+// Interface: public
+// Inputs: .
+// Outputs: none.
+// Comments:
+//=============================================================================
+int session_destroy(struct cci_PIPsession *pSess)
+{
+   PDEBUG( "Destroying CCIv4 PIP Session.\n");
+
+   // Final free
+   kosal_kfree(pSess, sizeof(struct cci_PIPsession) );
+   return 0;
+}
+
+//=============================================================================
+// Name: UnbindSession
+// Description:Called when the user process unbinds from the device
+// Interface: public
+// Inputs: Pointer to the ownerSession attributes
+// Returns: success = 1
+// Comments:  Host AFU need  not do anything
+//=============================================================================
+int UnbindSession(struct aaldev_ownerSession *pownerSess)
+{
+   struct cci_PIPsession      *pSess         = (struct cci_PIPsession *)pownerSess->m_PIPHandle;
+   struct cci_aal_device      *pdev          = cci_PIPsessionp_to_ccidev(pSess);
+   struct CCIP_PORT_DFL_UMSG  *puMsgvirt     = NULL;
+
+   PDEBUG("UnBinding UI Session\n");
+
+   // Stop all on-going processing
+   kosal_sem_get_krnl( cci_aaldev_psem(pdev) );
+
+   // If this is a uAFU make sure it is stopped
+   if( cci_dev_UAFU ==  cci_aaldev_type(pdev) ){
+      PDEBUG("Quiescing User AFU\n");
+      if(true == get_port_feature( cci_aaldev_pport(pdev),
+                                   CCIP_PORT_DFLID_USMG,
+                                   NULL,
+                                   (btVirtAddr*)&puMsgvirt)){
+         btTime delay = 10;
+         btTime totaldelay = 0;
+
+         // Disable uMSGis running
+         puMsgvirt->ccip_umsg_capability.status_umsg_engine = 0;
+         while(1 == puMsgvirt->ccip_umsg_capability.umsg_init_status){
+            // Sleep
+            kosal_udelay(delay);
+
+            totaldelay = totaldelay + delay;
+            if (totaldelay > 100)   {
+               PDEBUG("Timed out waiting for uMSG engine to stop\n");
+               break;
+            }
+         }
+         // Force the address to zero
+         puMsgvirt->ccip_umsg_base_address.umsg_base_address = 0;
+      }
+
+      // Reset the AFU
+      port_afu_quiesce_and_halt( cci_aaldev_pport(pdev));
+      port_afu_Enable( cci_aaldev_pport(pdev));
+   }
+
+   kosal_sem_put( cci_aaldev_psem(pdev) );
+
+   // Free all allocated workspaces not yet freed
+   cci_flush_all_wsids(pSess);
+
+   session_destroy(pSess);
+
+   return 1;
+}
+
+//=============================================================================
+// Name: cci_flush_all_wsids
+// Description: Frees all workspaces allocated for this session
+// Interface: private
+// Inputs: sessp - session
+// Comments: This function should be called during cleanup.  It does not
+//           protect session queue access
+//=============================================================================
+void
+cci_flush_all_wsids(struct cci_PIPsession *psess)
+{
+   struct aaldev_ownerSession *pownerSess;
+   struct cci_aal_device        *pdev;
+
+   struct aal_wsid            *wsidp;
+   struct aal_wsid            *tmp;
+
+   PTRACEIN;
+
+   ASSERT(psess);
+
+   pownerSess = cci_PIPsessionp_to_ownerSession(psess);
+   ASSERT(pownerSess);
+
+   pdev = cci_PIPsessionp_to_ccidev(psess);
+   ASSERT(pdev);
+
+   PVERBOSE("Freeing allocated workspaces.\n");
+
+   kosal_list_for_each_entry_safe( wsidp, tmp, &pownerSess->m_wshead, m_list, struct aal_wsid) {
+      if( WSM_TYPE_VIRTUAL == wsidp->m_type){
+         if( NULL== cci_aaldev_pci_dev(pdev) ) {
+            kosal_free_contiguous_mem((btAny)wsidp->m_id, wsidp->m_size);
+         }else{
+            kosal_free_dma_coherent( ccip_dev_pci_dev(pdev), (btAny)wsidp->m_id, wsidp->m_size, wsidp->m_dmahandle);
+         }
+
+         // remove the wsid from the device and destroy
+         PVERBOSE("Done Freeing PWS with id 0x%llx.\n",pwsid_to_wsidHandle(wsidp));
+      }
+
+      kosal_list_del_init(&wsidp->m_list);
+
+      ccidrv_freewsid(wsidp);
+   } // end list_for_each_entry
+   PTRACEOUT;
+}
+
diff --git a/drivers/fpga/aal/cci/cci_pcie_driver_PIPsession.h b/drivers/fpga/aal/cci/cci_pcie_driver_PIPsession.h
new file mode 100644
index 000000000000..a5594572ee64
--- /dev/null
+++ b/drivers/fpga/aal/cci/cci_pcie_driver_PIPsession.h
@@ -0,0 +1,110 @@
+//******************************************************************************
+// This  file  is  provided  under  a  dual BSD/GPLv2  license.  When using or
+//         redistributing this file, you may do so under either license.
+//
+//                            GPL LICENSE SUMMARY
+//
+//  Copyright(c) 2012-2017, Intel Corporation.
+//
+//  This program  is  free software;  you  can redistribute it  and/or  modify
+//  it  under  the  terms of  version 2 of  the GNU General Public License  as
+//  published by the Free Software Foundation.
+//
+//  This  program  is distributed  in the  hope that it  will  be useful,  but
+//  WITHOUT   ANY   WARRANTY;   without   even  the   implied   warranty    of
+//  MERCHANTABILITY  or  FITNESS  FOR  A  PARTICULAR  PURPOSE.  See  the   GNU
+//  General Public License for more details.
+//
+//  The  full  GNU  General Public License is  included in  this  distribution
+//  in the file called README.GPLV2-LICENSE.TXT.
+//
+//  Contact Information:
+//  Henry Mitchel, henry.mitchel at intel.com
+//  77 Reed Rd., Hudson, MA  01749
+//
+//                                BSD LICENSE
+//
+//  Copyright(c) 2012-2017, Intel Corporation.
+//
+//  Redistribution and  use  in source  and  binary  forms,  with  or  without
+//  modification,  are   permitted  provided  that  the  following  conditions
+//  are met:
+//
+//    * Redistributions  of  source  code  must  retain  the  above  copyright
+//      notice, this list of conditions and the following disclaimer.
+//    * Redistributions in  binary form  must  reproduce  the  above copyright
+//      notice,  this  list of  conditions  and  the  following disclaimer  in
+//      the   documentation   and/or   other   materials   provided  with  the
+//      distribution.
+//    * Neither   the  name   of  Intel  Corporation  nor  the  names  of  its
+//      contributors  may  be  used  to  endorse  or promote  products derived
+//      from this software without specific prior written permission.
+//
+//  THIS  SOFTWARE  IS  PROVIDED  BY  THE  COPYRIGHT HOLDERS  AND CONTRIBUTORS
+//  "AS IS"  AND  ANY  EXPRESS  OR  IMPLIED  WARRANTIES,  INCLUDING,  BUT  NOT
+//  LIMITED  TO, THE  IMPLIED WARRANTIES OF  MERCHANTABILITY  AND FITNESS  FOR
+//  A  PARTICULAR  PURPOSE  ARE  DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT
+//  OWNER OR CONTRIBUTORS BE LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,
+//  SPECIAL,  EXEMPLARY,  OR  CONSEQUENTIAL   DAMAGES  (INCLUDING,   BUT   NOT
+//  LIMITED  TO,  PROCUREMENT  OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF USE,
+//  DATA,  OR PROFITS;  OR BUSINESS INTERRUPTION)  HOWEVER  CAUSED  AND ON ANY
+//  THEORY  OF  LIABILITY,  WHETHER  IN  CONTRACT,  STRICT LIABILITY,  OR TORT
+//  (INCLUDING  NEGLIGENCE  OR OTHERWISE) ARISING  IN ANY WAY  OUT  OF THE USE
+//  OF  THIS  SOFTWARE, EVEN IF ADVISED  OF  THE  POSSIBILITY  OF SUCH DAMAGE.
+//******************************************************************************
+//****************************************************************************
+//        FILE: cci_PIPsession.h
+//     CREATED: 07/28/2015
+//      AUTHOR: Joseph Grecco, Intel <joe.grecco@intel.com>
+//
+// PURPOSE: Internal private definitions and constants for the CCCIV4 PIP Session.
+// HISTORY:
+// COMMENTS:
+// WHEN:          WHO:     WHAT:
+//****************************************************************************
+#ifndef __AALKERNEL_CCI_PIP_SESSION_H__
+#define __AALKERNEL_CCI_PIP_SESSION_H__
+#include "cci_pcie_driver_internal.h"
+
+//=============================================================================
+// Name: cci_PIPsession
+// Description: Object that represents an instance of a session between an
+//              owner of a device and the device itself. It holds state such
+//              as the task list and PIP interface. The PIP interface
+//              holds the owner session context and the PIP function interfaces.
+// Comments: This object is specific to the PIP. The ownerSession contains
+//           the generic session context shared between the PIP and the
+//           AAL kernel services.
+//=============================================================================
+struct cci_PIPsession {
+
+   // PIP contains all of the interfaces we use for communications
+   struct aal_device               *paaldev;
+   struct cci_aal_device           *pCCIdev;
+
+   // Current transaction
+   stTransactionID_t              currTranID;
+
+   // Owner Session hold shared session instance information
+   struct aaldev_ownerSession    *pownerSess;
+   kosal_semaphore                session_sem;
+
+};
+#define cci_PIPsessionp_to_ccidev(s)              ( (s)->pCCIdev )
+#define cci_PIPsessionp_to_aal_afup(s)            ((s)->paaldev)
+#define cci_PIPsessionp_to_ownerSession(s)        ((s)->pownerSess)
+#define cci_PIPsessionp_semaphore(s)              (&(s)->session_sem)
+
+//=============================================================================
+//=============================================================================
+//                                PROTOTYPES
+//=============================================================================
+//=============================================================================
+struct cci_PIPsession *session_create(struct aaldev_ownerSession *pownerSess);
+int BindSession(struct aaldev_ownerSession *pownerSess);
+int session_destroy(struct cci_PIPsession *sess);
+int UnbindSession(struct aaldev_ownerSession *pownerSess);
+void cci_flush_all_wsids( struct cci_PIPsession *);
+
+#endif // __AALKERNEL_CCIV4_PIP_SESSION_H__
+
diff --git a/drivers/fpga/aal/cci/cci_pcie_driver_internal.h b/drivers/fpga/aal/cci/cci_pcie_driver_internal.h
new file mode 100644
index 000000000000..d0775c8747e9
--- /dev/null
+++ b/drivers/fpga/aal/cci/cci_pcie_driver_internal.h
@@ -0,0 +1,404 @@
+//******************************************************************************
+// This  file  is  provided  under  a  dual BSD/GPLv2  license.  When using or
+//         redistributing this file, you may do so under either license.
+//
+//                            GPL LICENSE SUMMARY
+//
+//  Copyright(c) 2015-2017, Intel Corporation.
+//
+//  This program  is  free software;  you  can redistribute it  and/or  modify
+//  it  under  the  terms of  version 2 of  the GNU General Public License  as
+//  published by the Free Software Foundation.
+//
+//  This  program  is distributed  in the  hope that it  will  be useful,  but
+//  WITHOUT   ANY   WARRANTY;   without   even  the   implied   warranty    of
+//  MERCHANTABILITY  or  FITNESS  FOR  A  PARTICULAR  PURPOSE.  See  the   GNU
+//  General Public License for more details.
+//
+//  The  full  GNU  General Public License is  included in  this  distribution
+//  in the file called README.GPLV2-LICENSE.TXT.
+//
+//  Contact Information:
+//  Henry Mitchel, henry.mitchel at intel.com
+//  77 Reed Rd., Hudson, MA  01749
+//
+//                                BSD LICENSE
+//
+//  Copyright(c) 2012-2017, Intel Corporation.
+//
+//  Redistribution and  use  in source  and  binary  forms,  with  or  without
+//  modification,  are   permitted  provided  that  the  following  conditions
+//  are met:
+//
+//    * Redistributions  of  source  code  must  retain  the  above  copyright
+//      notice, this list of conditions and the following disclaimer.
+//    * Redistributions in  binary form  must  reproduce  the  above copyright
+//      notice,  this  list of  conditions  and  the  following disclaimer  in
+//      the   documentation   and/or   other   materials   provided  with  the
+//      distribution.
+//    * Neither   the  name   of  Intel  Corporation  nor  the  names  of  its
+//      contributors  may  be  used  to  endorse  or promote  products derived
+//      from this software without specific prior written permission.
+//
+//  THIS  SOFTWARE  IS  PROVIDED  BY  THE  COPYRIGHT HOLDERS  AND CONTRIBUTORS
+//  "AS IS"  AND  ANY  EXPRESS  OR  IMPLIED  WARRANTIES,  INCLUDING,  BUT  NOT
+//  LIMITED  TO, THE  IMPLIED WARRANTIES OF  MERCHANTABILITY  AND FITNESS  FOR
+//  A  PARTICULAR  PURPOSE  ARE  DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT
+//  OWNER OR CONTRIBUTORS BE LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,
+//  SPECIAL,  EXEMPLARY,  OR  CONSEQUENTIAL   DAMAGES  (INCLUDING,   BUT   NOT
+//  LIMITED  TO,  PROCUREMENT  OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF USE,
+//  DATA,  OR PROFITS;  OR BUSINESS INTERRUPTION)  HOWEVER  CAUSED  AND ON ANY
+//  THEORY  OF  LIABILITY,  WHETHER  IN  CONTRACT,  STRICT LIABILITY,  OR TORT
+//  (INCLUDING  NEGLIGENCE  OR OTHERWISE) ARISING  IN ANY WAY  OUT  OF THE USE
+//  OF  THIS  SOFTWARE, EVEN IF ADVISED  OF  THE  POSSIBILITY  OF SUCH DAMAGE.
+//******************************************************************************
+//****************************************************************************
+//        FILE: cci_pcie_driver_internal.h
+//     CREATED: 10/14/2015
+//      AUTHOR: Joseph Grecco, Intel <joe.grecco@intel.com>
+//
+// PURPOSE: Internal private definitions and constants for the
+//          CCI PCIe Device Driver.
+// HISTORY:
+// COMMENTS:
+// WHEN:          WHO:     WHAT:
+//****************************************************************************
+#ifndef __AALKERNEL_CCI_PCIE_DRIVER_INTERNAL_H__
+#define __AALKERNEL_CCI_PCIE_DRIVER_INTERNAL_H__
+#include "aalsdk/kernel/kosal.h"
+
+#include <aalsdk/kernel/aalqueue.h>
+#include <aalsdk/kernel/iaaldevice.h>
+#include <aalsdk/kernel/aalwsservice.h>
+
+/////////////////////////////////////////////////////////////////////////////
+#ifndef DRV_VERSION
+# define DRV_VERSION          "EXPERIMENTAL VERSION"
+#endif
+#define DRV_DESCRIPTION       "AAL FPGA PCIe Device driver and CCI Physical Interface Protocol (PIP)"
+#define DRV_AUTHOR            "Joseph Grecco <joe.grecco@intel.com>"
+#define DRV_LICENSE           "Dual BSD/GPL"
+#define DRV_COPYRIGHT         "Copyright(c) 2015-2016, Intel Corporation"
+
+#define DEVICE_BASENAME       "cci"
+
+#define CCI_PCI_DRIVER_NAME   "ccidrv"
+
+////////////////////////////////////////////////////////////////////////////////
+#define CCI_MMIO_SIZE       ( 0x40000 )                   /// Size of AFU MMIO space
+#define CCI_UMSG_SIZE       ( 0x5000 )                    /// Size of uMsg space
+
+// PCI device IDs
+#define PCIe_DEVICE_ID_RCiEP0        0xBCBD ///< Primary port with FIU
+#define PCIe_DEVICE_ID_RCiEP1        0xBCBE ///< Null device for data transport
+#define PCIe_DEVICE_ID_RCiEP2        0xBCBC ///< QPI or UPI EPt
+#define PCIe_DEVICE_ID_RCiEP0_SKX_P  0xBCC0 ///< Primary PF device on SKX-P
+#define PCIe_DEVICE_ID_VF_SKX_P      0xBCC1 ///< VF device on SKX-P
+#define PCIe_DEVICE_ID_RCiEP0_DCP    0x09C4 ///< Primary PF device on DCP
+#define PCIe_DEVICE_ID_VF_DCP        0x09C5 ///< VF device for DCP
+
+//=============================================================================
+// Prototypes
+//=============================================================================
+
+enum   cci_devtype{
+   cci_dev_FME,
+   cci_dev_Port,
+   cci_dev_UAFU,
+   cci_dev_STAP,
+   cci_dev_PR,
+   cci_dev_PWR
+};
+
+//=============================================================================
+// Name: cci_aal_device
+// Description: Structure describing a CCI AAL device. This object is used to
+//              expose an allocatable object to the host via the aalbus.
+//=============================================================================
+struct cci_aal_device {
+#define CCI_DEV_FLAG_PCI_DEV_ENABLED           0x00000001
+#define CCI_DEV_FLAG_PCI_REGION_REQUESTED      0x00000002
+#define CCI_DEV_FLAG_ALLOW_MAP_CSR_READ_SPACE  0x00000004
+#define CCI_DEV_FLAG_ALLOW_MAP_CSR_WRITE_SPACE 0x00000008
+#define CCI_DEV_FLAG_SIMULATED_DEV             0x00000010
+#define CCI_DEV_FLAG_ALLOW_MAP_MMIOR_SPACE     0x00000020
+#define CCI_DEV_FLAG_ALLOW_MAP_UMSG_SPACE      0x00000040
+
+   struct aal_device         *m_aaldev;         // AAL Device from which this is derived
+   kosal_pci_dev            *m_pcidev;         // Linux pci_dev pointer (or NULL if manual)
+
+   btUnsignedInt              m_flags;
+
+   // Used for being added to the global list of devices.
+   kosal_list_head            m_list;           // List itself
+
+   // Private semaphore
+   kosal_semaphore            m_sem;
+
+   enum aal_bus_types_e       m_boardtype;
+
+   int                        m_simulated;
+
+   int                        m_protocolID;
+
+   // For background tasks handling
+   kosal_work_queue           m_workq_reconf;
+
+   // AFU MMIO Space
+   btVirtAddr                 m_kvp_afu_mmio;   // kv address of MMIO space
+   btPhysAddr                 m_phys_afu_mmio;  // Physical address of MMIO space
+   btUnsigned64bitInt         m_len_afu_mmio;   // Bytes
+
+   // AFU uMSG Space
+   btVirtAddr                 m_kvp_afu_umsg;    // kv address of CSR space
+   btPhysAddr                 m_phys_afu_umsg;   // Physical address of CSR space
+   btUnsigned64bitInt         m_len_afu_umsg;    // Bytes
+
+   struct cci_PIPsession     *m_pPIPSession;     // PIP session object
+
+   enum   cci_devtype         m_devtype;        // Type of the subclass (e.g., FME, PORT, AFU)
+   struct fme_device         *m_pfme;
+   struct port_device        *m_pport;
+
+   // PR command Handler semaphore
+   kosal_semaphore            m_pr_sem;
+
+};
+
+
+#define pci_dev_to_cci_dev(ptr)              kosal_container_of(ptr, struct cci_aal_device. m_pcidev )
+#define aaldev_to_cci_aal_device(ptr)        aaldev_to_any(struct cci_aal_device, ptr)
+
+#define cci_aaldev_pfme(pdev)                  ( pdev->m_pfme )
+#define cci_aaldev_pport(pdev)                 ( pdev->m_pport )
+#define cci_aaldev_pafu(pdev)                  ( pdev->m_pafu )
+
+#define cci_aaldev_pci_dev(pdev)               ((pdev)->m_pcidev)
+   #define cci_aaldev_pci_dev_is_enabled(pdev)  ((pdev)->m_flags & CCI_DEV_FLAG_PCI_DEV_ENABLED)
+   #define cci_aaldev_pci_dev_set_enabled(pdev) ((pdev)->m_flags |= CCI_DEV_FLAG_PCI_DEV_ENABLED)
+   #define cci_aaldev_pci_dev_clr_enabled(pdev) ((pdev)->m_flags &= ~CCI_DEV_FLAG_PCI_DEV_ENABLED)
+
+   #define cci_aaldev_pci_dev_is_region_requested(pdev)  ((pdev)->m_flags & CCI_DEV_FLAG_PCI_REGION_REQUESTED)
+   #define cci_aaldev_pci_dev_set_region_requested(pdev) ((pdev)->m_flags |= CCI_DEV_FLAG_PCI_REGION_REQUESTED)
+   #define cci_aaldev_pci_dev_clr_region_requested(pdev) ((pdev)->m_flags &= ~CCI_DEV_FLAG_PCI_REGION_REQUESTED)
+
+   #define cci_aaldev_allow_map_csr_read_space(pdev)     ((pdev)->m_flags & CCI_DEV_FLAG_ALLOW_MAP_CSR_READ_SPACE)
+   #define cci_aaldev_set_allow_map_csr_read_space(pdev) ((pdev)->m_flags |= CCI_DEV_FLAG_ALLOW_MAP_CSR_READ_SPACE)
+   #define cci_aaldev_clr_allow_map_csr_read_space(pdev) ((pdev)->m_flags &= ~CCI_DEV_FLAG_ALLOW_MAP_CSR_READ_SPACE)
+
+   #define cci_aaldev_allow_map_csr_write_space(pdev)     ((pdev)->m_flags & CCI_DEV_FLAG_ALLOW_MAP_CSR_WRITE_SPACE)
+   #define cci_aaldev_set_allow_map_csr_write_space(pdev) ((pdev)->m_flags |= CCI_DEV_FLAG_ALLOW_MAP_CSR_WRITE_SPACE)
+   #define cci_aaldev_clr_allow_map_csr_write_space(pdev) ((pdev)->m_flags &= ~CCI_DEV_FLAG_ALLOW_MAP_CSR_WRITE_SPACE)
+
+   #define cci_aaldev_allow_map_csr_space(pdev) ( cci_aaldev_allow_map_csr_read_space(pdev) || cci_aaldev_allow_map_csr_write_space(pdev) )
+
+   #define cci_aaldev_allow_map_mmior_space(pdev)     ((pdev)->m_flags & CCI_DEV_FLAG_ALLOW_MAP_MMIOR_SPACE)
+   #define cci_aaldev_set_allow_map_mmior_space(pdev) ((pdev)->m_flags |= CCI_DEV_FLAG_ALLOW_MAP_MMIOR_SPACE)
+   #define cci_aaldev_clr_allow_map_mmior_space(pdev) ((pdev)->m_flags &= ~CCI_DEV_FLAG_ALLOW_MAP_MMIOR_SPACE)
+
+   #define cci_aaldev_allow_map_umsg_space(pdev)     ((pdev)->m_flags & CCI_DEV_FLAG_ALLOW_MAP_UMSG_SPACE)
+   #define cci_aaldev_set_allow_map_umsg_space(pdev) ((pdev)->m_flags |= CCI_DEV_FLAG_ALLOW_MAP_UMSG_SPACE)
+   #define cci_aaldev_clr_allow_map_umsg_space(pdev) ((pdev)->m_flags &= ~CCI_DEV_FLAG_ALLOW_MAP_UMSG_SPACE)
+
+   #define cci_aaldev_is_simulated(pdev)  ((pdev)->m_flags & CCI_DEV_FLAG_SIMULATED_DEV)
+   #define cci_aaldev_set_simulated(pdev) ((pdev)->m_flags |= CCI_DEV_FLAG_SIMULATED_DEV)
+   #define cci_aaldev_clr_simulated(pdev) ((pdev)->m_flags &= ~CCI_DEV_FLAG_SIMULATED_DEV)
+
+#define cci_aaldev_type(pdev)                  ((pdev)->m_devtype)
+
+#define cci_aaldev_board_type(pdev)            ((pdev)->m_boardtype)
+
+#define cci_set_simulated(pdev)             ((pdev)->m_simulated = 1)
+#define cci_clr_simulated(pdev)             ((pdev)->m_simulated = 0)
+#define cci_is_simulated(pdev)             ((pdev)->m_simulated == 1)
+
+#define cci_aaldev_protocol(pdev)              ((pdev)->m_protocolID)
+
+#define cci_aaldev_phys_afu_mmio(pdev)         ((pdev)->m_phys_afu_mmio)
+#define cci_aaldev_kvp_afu_mmio(pdev)          ((pdev)->m_kvp_afu_mmio)
+#define cci_aaldev_len_afu_mmio(pdev)          ((pdev)->m_len_afu_mmio)
+
+#define cci_aaldev_phys_afu_umsg(pdev)         ((pdev)->m_phys_afu_umsg)
+#define cci_aaldev_kvp_afu_umsg(pdev)          ((pdev)->m_kvp_afu_umsg)
+#define cci_aaldev_len_afu_umsg(pdev)          ((pdev)->m_len_afu_umsg)
+
+
+#define cci_aaldev_to_pci_dev(pdev)            ((pdev)->m_pcidev)
+#define cci_aaldev_to_aaldev(pdev)          ( (pdev)->m_aaldev )
+
+
+#define cci_aaldev_list_head(pdev)             ((pdev)->m_list)
+#define cci_list_to_cci_aal_device(plist)    kosal_list_entry(plist, struct cci_aal_device, m_list)
+
+#define cci_aaldev_to_PIPsessionp(pdev)        ((pdev)->m_pPIPSession)
+#define cci_aaldev_psem(pdev)                  (&(pdev)->m_sem)
+#define cci_dev_pr_sem(pdev)                (&(pdev)->m_pr_sem)
+
+#define cci_aaldev_workq_reconf(pdev)            ((pdev)->m_workq_reconf )
+
+
+///============================================================================
+/// Name: ccip_device
+/// @brief  CCIP board device
+///============================================================================
+struct ccip_device
+{
+   // Used for being added to the global list of devices.
+   kosal_list_head            m_list;
+
+   // Head of the list of AAL devices created
+   kosal_list_head            m_devlisthead;
+
+   // Head of the list of ports devices
+   kosal_list_head            m_portlisthead;
+
+   int                        m_isVF;
+   int                        m_numVFs;
+   int                        m_maxVFs;
+
+   struct fme_device         *m_pfme_dev;       // FME Device
+   struct port_device        *m_pport_dev[4];   // Port Device array
+
+   kosal_pci_dev            *m_pcidev;         // Linux pci_dev pointer
+
+   btUnsignedInt              m_flags;
+
+   // Private semaphore
+   kosal_semaphore            m_sem;
+
+   int                        m_simulated;
+
+   enum aal_bus_types_e       m_bustype;
+   btUnsigned16bitInt         m_socketnum;       // Socket number
+   btUnsigned32bitInt         m_busNum;
+   btUnsigned16bitInt         m_devicenum;      // device number
+   btUnsigned16bitInt         m_functnum;       // function number
+
+   btInt                      m_resources;      // Bit mask indicating bars that have been reserved
+
+   // FME MMIO Space
+   btVirtAddr                 m_kvp_fme_mmio;   // kv address of MMIO space
+   btPhysAddr                 m_phys_fme_mmio;  // Physical address of MMIO space
+   size_t                     m_len_fme_mmio;   // Bytes
+
+   btUnsigned64bitInt         m_num_ports;
+   btVirtAddr                 m_kvp_port_mmio[5];   // kv address of MMIO space
+   btPhysAddr                 m_phys_port_mmio[5];  // Physical address of MMIO space
+   size_t                     m_len_port_mmio[5];
+
+   // AFU MMIO Space
+   btVirtAddr                 m_kvp_afu_mmio;   // kv address of MMIO space
+   btPhysAddr                 m_phys_afu_mmio;  // Physical address of MMIO space
+   size_t                     m_len_afu_mmio;   // Bytes
+
+
+}; // end struct ccip_afu_device
+
+#define pci_dev_to_ccip_dev(ptr)             ccip_container_of(ptr, kosal_pci_dev, m_pcidev, struct ccip_device)
+#define ccip_dev_to_pci_dev(pdev)            ((pdev)->m_pcidev)
+#define ccip_dev_to_aaldev(pdev)             ((pdev)->m_aaldev)
+#define ccip_dev_to_fme_dev(pdev)            ((pdev)->m_pfme_dev)
+#define ccip_dev_to_port_dev(pdev,i)         ((pdev)->m_pport_dev[i])
+
+#define ccip_dev_pci_dev(pdev)               ((pdev)->m_pcidev)
+
+#define cci_aaldev_board_type(pdev)             ((pdev)->m_boardtype)
+
+#define ccip_set_simulated(pdev)             ((pdev)->m_simulated = 1)
+#define ccip_clr_simulated(pdev)             ((pdev)->m_simulated = 0)
+#define ccip_is_simulated(pdev)              ((pdev)->m_simulated == 1)
+
+#define ccip_set_VFdev(pdev)                 ((pdev)->m_isVF = 1)
+#define ccip_is_VFdev(pdev)                  ((pdev)->m_isVF == 1)
+
+#define ccip_set_resource(pdev,r)            ((pdev)->m_resources |= (1<<(r+1)))
+#define ccip_has_resource(pdev,r)            ((pdev)->m_resources & (1<<(r+1)))
+#define ccip_clr_resource(pdev,r)            ((pdev)->m_resources &= ~(1<<(r+1)))
+
+#define ccip_list_to_ccip_device(plist)      kosal_list_entry(plist, struct ccip_device, m_list)
+#define aaldev_to_ccip_device(plist)         kosal_list_entry(plist, struct ccip_device, m_list)
+#define ccip_dev_to_PIPsessionp(pdev)        ((pdev)->m_pPIPSession)
+#define ccip_dev_psem(pdev)                  (&(pdev)->m_sem)
+
+#define ccip_dev_list_head(pdev)             ((pdev)->m_list)
+#define ccip_aal_dev_list(pdev)              ((pdev)->m_devlisthead)
+#define ccip_port_dev_list(pdev)             ((pdev)->m_portlisthead)
+
+#define ccip_fmedev_phys_afu_mmio(pdev)      ((pdev)->m_phys_fme_mmio)
+#define ccip_fmedev_kvp_afu_mmio(pdev)       ((pdev)->m_kvp_fme_mmio)
+#define ccip_fmedev_len_afu_mmio(pdev)       ((pdev)->m_len_fme_mmio)
+
+#define ccip_portdev_numports(pdev)          ((pdev)->m_num_ports)
+#define ccip_portdev_phys_afu_mmio(pdev,n)   ((pdev)->m_phys_port_mmio[n])
+#define ccip_portdev_kvp_afu_mmio(pdev,n)    ((pdev)->m_kvp_port_mmio[n])
+#define ccip_portdev_len_afu_mmio(pdev,n)    ((pdev)->m_len_port_mmio[n])
+
+#define ccip_portdev_maxVFs(pdev)            ((pdev)->m_maxVFs)
+#define ccip_portdev_numVFs(pdev)            ((pdev)->m_numVFs)
+
+#define ccip_dev_pcie_bustype(pdev)          ((pdev)->m_bustype)
+#define ccip_dev_pcie_busnum(pdev)           ((pdev)->m_busNum)
+#define ccip_dev_pcie_devnum(pdev)           ((pdev)->m_devicenum)
+#define ccip_dev_pcie_fcnnum(pdev)           ((pdev)->m_functnum)
+#define ccip_dev_pcie_socketnum(pdev)        ((pdev)->m_socketnum)
+
+
+/// @brief   Writes 64 bit control and status registers.
+///
+/// @param[in]  baseAddress   base CSR address.
+/// @param[in]  offset        offset of CSR  .
+/// @param[in]  value    value  going to be write in CSR.
+/// @return   void
+int write_ccip_csr64(btVirtAddr baseAddress, btUnsigned64bitInt offset,bt64bitCSR value);
+
+/// @brief   read 64 bit control and status registers.
+///
+/// @param[in]  baseAddress   base CSR address.
+/// @param[in]  offset        offset of CSR  .
+/// @return    64 bit  CSR value
+bt64bitCSR read_ccip_csr64( btVirtAddr baseAddress, btUnsigned64bitInt offset );
+
+
+//=============================================================================
+//=============================================================================
+//                                PROTOTYPES
+//=============================================================================
+//=============================================================================
+struct ccip_device;   // forward reference
+struct port_device;
+
+struct ccip_device * create_ccidevice(void);
+void  destroy_ccidevice(struct ccip_device *pccidev);
+extern btBool cci_fme_dev_create_AAL_allocatable_objects(struct ccip_device *);
+extern btBool cci_create_AAL_PR_allocatable_objects(struct ccip_device * pccipdev);
+extern  btBool cci_create_AAL_power_Device(struct ccip_device *);
+btBool cci_port_dev_create_AAL_allocatable_objects(struct port_device  *,
+                                                   btUnsigned32bitInt);
+extern struct cci_aal_device* cci_create_aal_device(void);
+extern int cci_destroy_aal_device( struct cci_aal_device*);
+extern int cci_publish_aaldevice(struct cci_aal_device *);
+extern void cci_unpublish_aaldevice(struct cci_aal_device *pcci_aaldev);
+extern void cci_remove_device(struct ccip_device *);
+extern void cci_release_device(pkosal_os_dev pdev);
+extern void ccidrv_exitDriver(void);
+
+extern struct ccidrv_session * ccidrv_session_create(btPID );
+extern btInt ccidrv_session_destroy(struct ccidrv_session * );
+extern struct aal_wsid *find_wsid( const struct ccidrv_session *,
+                                   btWSID);
+extern struct aal_wsid * ccidrv_valwsid(btWSID);
+extern btInt ccidrv_freewsid(struct aal_wsid *pwsid);
+extern struct aal_wsid* ccidrv_getwsid( struct aal_device *pdev,
+                                        unsigned long long id);
+extern btInt
+ccidrv_sendevent( struct aaldev_ownerSession *,
+                  struct aal_q_item *);
+
+extern inline void GetCSR(btUnsigned64bitInt *ptr, bt32bitCSR *pcsrval);
+extern inline void SetCSR(btUnsigned64bitInt *ptr, bt32bitCSR *csrval);
+extern        void Get64CSR(btUnsigned64bitInt *ptr, bt64bitCSR *pcsrval);
+extern        void Set64CSR(btUnsigned64bitInt *ptr, bt64bitCSR *csrval);
+
+
+#endif // __AALKERNEL_CCI_PCIE_DRIVER_INTERNAL_H__
+
diff --git a/drivers/fpga/aal/cci/cci_pcie_driver_main_linux.c b/drivers/fpga/aal/cci/cci_pcie_driver_main_linux.c
new file mode 100644
index 000000000000..4504c425aecd
--- /dev/null
+++ b/drivers/fpga/aal/cci/cci_pcie_driver_main_linux.c
@@ -0,0 +1,1474 @@
+//******************************************************************************
+// This  file  is  provided  under  a  dual BSD/GPLv2  license.  When using or
+//         redistributing this file, you may do so under either license.
+//
+//                            GPL LICENSE SUMMARY
+//
+//  Copyright(c) 2015-2017, Intel Corporation.
+//
+//  This program  is  free software;  you  can redistribute it  and/or  modify
+//  it  under  the  terms of  version 2 of  the GNU General Public License  as
+//  published by the Free Software Foundation.
+//
+//  This  program  is distributed  in the  hope that it  will  be useful,  but
+//  WITHOUT   ANY   WARRANTY;   without   even  the   implied   warranty    of
+//  MERCHANTABILITY  or  FITNESS  FOR  A  PARTICULAR  PURPOSE.  See  the   GNU
+//  General Public License for more details.
+//
+//  The  full  GNU  General Public License is  included in  this  distribution
+//  in the file called README.GPLV2-LICENSE.TXT.
+//
+//  Contact Information:
+//  Henry Mitchel, henry.mitchel at intel.com
+//  77 Reed Rd., Hudson, MA  01749
+//
+//                                BSD LICENSE
+//
+//  Copyright(c) 2015-2017, Intel Corporation.
+//
+//  Redistribution and  use  in source  and  binary  forms,  with  or  without
+//  modification,  are   permitted  provided  that  the  following  conditions
+//  are met:
+//
+//    * Redistributions  of  source  code  must  retain  the  above  copyright
+//      notice, this list of conditions and the following disclaimer.
+//    * Redistributions in  binary form  must  reproduce  the  above copyright
+//      notice,  this  list of  conditions  and  the  following disclaimer  in
+//      the   documentation   and/or   other   materials   provided  with  the
+//      distribution.
+//    * Neither   the  name   of  Intel  Corporation  nor  the  names  of  its
+//      contributors  may  be  used  to  endorse  or promote  products derived
+//      from this software without specific prior written permission.
+//
+//  THIS  SOFTWARE  IS  PROVIDED  BY  THE  COPYRIGHT HOLDERS  AND CONTRIBUTORS
+//  "AS IS"  AND  ANY  EXPRESS  OR  IMPLIED  WARRANTIES,  INCLUDING,  BUT  NOT
+//  LIMITED  TO, THE  IMPLIED WARRANTIES OF  MERCHANTABILITY  AND FITNESS  FOR
+//  A  PARTICULAR  PURPOSE  ARE  DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT
+//  OWNER OR CONTRIBUTORS BE LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,
+//  SPECIAL,  EXEMPLARY,  OR  CONSEQUENTIAL   DAMAGES  (INCLUDING,   BUT   NOT
+//  LIMITED  TO,  PROCUREMENT  OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF USE,
+//  DATA,  OR PROFITS;  OR BUSINESS INTERRUPTION)  HOWEVER  CAUSED  AND ON ANY
+//  THEORY  OF  LIABILITY,  WHETHER  IN  CONTRACT,  STRICT LIABILITY,  OR TORT
+//  (INCLUDING  NEGLIGENCE  OR OTHERWISE) ARISING  IN ANY WAY  OUT  OF THE USE
+//  OF  THIS  SOFTWARE, EVEN IF ADVISED  OF  THE  POSSIBILITY  OF SUCH DAMAGE.
+//******************************************************************************
+//****************************************************************************
+//        FILE: cci_pcie_driver_main.c
+//     CREATED: 10/14/2015
+//      AUTHOR: Joseph Grecco, Intel <joe.grecco@intel.com>
+// PURPOSE: This file implements init/exit entry points for the
+//          AAL FPGA device driver for
+//          functionality of the AAL FPGA device driver.
+// HISTORY:
+// COMMENTS: Linux specific
+// WHEN:          WHO:     WHAT:
+// 10/14/2015     JG       Initial version started
+//****************************************************************************
+#include "aalsdk/kernel/kosal.h"
+
+#define MODULE_FLAGS CCIPCIE_DBG_MOD // Prints all
+
+#include "aalsdk/kernel/aalbus.h"
+#include "aalsdk/kernel/aalinterface.h"
+#include "aalsdk/kernel/ccip_defs.h"
+
+#include "cci_pcie_driver_internal.h"
+
+#include "cci_pcie_driver_simulator.h"
+
+#include "ccip_fme.h"
+#include "ccip_port.h"
+#include "ccip_perfmon_linux.h"
+#include "ccip_logging.h"
+#include "ccip_logging_linux.h"
+
+extern int print_sim_fme_device(struct fme_device *);
+extern int print_sim_port_device(struct port_device *pport_dev);
+
+/// g_device_list - Global device list for this module.
+kosal_list_head g_device_list;
+
+/// g_dev_list_sem - Global device list semaphore.
+kosal_semaphore g_dev_list_sem;
+
+
+//////////////////////////////////////////////////////////////////////////////////////
+
+MODULE_VERSION    (DRV_VERSION);
+MODULE_DESCRIPTION(DRV_DESCRIPTION);
+MODULE_AUTHOR     (DRV_AUTHOR);
+MODULE_LICENSE    (DRV_LICENSE);
+
+//=============================================================================
+// Driver Parameters
+//=============================================================================
+// Set up configuration parameter for insmod command-line:
+// Argument:
+//      sim: Instantiate simualted AFUs
+//       Value: Number of AFUs to instantiate
+//      sriov: Activate SR-IOV
+//       Value: Number of VFs to enable (can't exceed number of PORTs)
+//      sriov_vf: Ignore VF driver binding (to enable VF enumeration on VM)
+//       Value: 1 to ignore VF, 0 to bind VF device to driver(default)
+//
+// Typical usage:
+//    sudo insmod ccidrv           # Normal load. PCIe enumeration enabled
+//    sudo insmod ccidrv sim=4     # Instantiate 4 simulated AFUs
+//    sudo insmod ccidrv sriov=1   # Activate SR-IOV with 1 VF
+//    sudo insmod ccidrv sriov_vf=1   # bind VF driver in sriov mode
+
+unsigned long  sim = 0;
+MODULE_PARM_DESC(sim, "Simulation: #=Number of simulated AFUs to instantiate");
+module_param    (sim, ulong, S_IRUGO);
+
+unsigned long  sriov = 0;
+MODULE_PARM_DESC(sriov, "SR-IOV: #=Number of VFs to activate");
+module_param    (sriov, ulong, S_IRUGO);
+
+int            sriov_vf = 0;
+MODULE_PARM_DESC(sriov_vf, "SR-IOV with VF driver binding: 1 to enable VF driver with PF");
+module_param    (sriov_vf, int, S_IRUGO);
+
+////////////////////////////////////////////////////////////////////////////////
+
+//=============================================================================
+//             D E B U G   F L A G S
+//
+// kern-utils.h macros expects DRV_NAME and debug declarations
+// DRV_NAME is defined in mem-int.h
+//=============================================================================
+
+btUnsignedInt debug = 0
+#if 0
+/* Type and Level selection flags */
+   | PTRACE_FLAG
+   | PVERBOSE_FLAG
+   | PDEBUG_FLAG
+   | PINFO_FLAG
+   | PNOTICE_FLAG
+/* Module selection flags */
+   | CCIPCIE_DBG_MOD
+   | CCIPCIE_DBG_DEV
+   | CCIPCIE_DBG_AFU
+   | CCIPCIE_DBG_MAFU
+   | CCIPCIE_DBG_MMAP
+   | CCIPCIE_DBG_CMD
+   | CCIPCIE_DBG_CFG
+#endif
+;
+
+/******************************************************************************
+ * Debug parameter global definition
+ */
+MODULE_PARM_DESC(debug, "module debug level");
+module_param    (debug, int, 0644);
+
+
+//=============================================================================
+// Name: aalbus_attrib_show_debug
+// Decription: Accessor for the debug parameter. Called when the sys fs
+//             parameter is read.
+//=============================================================================
+static ssize_t ahmpip_attrib_show_debug(struct device_driver *drv, char *buf)
+{
+   return (snprintf(buf,PAGE_SIZE,"%x\n",debug));
+}
+
+//=============================================================================
+// Name: aalbus_attrib_store_debug
+// Decription: Mutator for the debug parameter. Called when the sys fs
+//             parameter is written.
+//=============================================================================
+static ssize_t ahmpip_attrib_store_debug(struct device_driver *drv,
+                                         const char *buf,
+                                         size_t size)
+{
+   unsigned temp = 0;
+   sscanf(buf,"%x", &temp);
+
+   debug = temp;
+
+   printk(KERN_INFO DRV_NAME ": Attribute change - debug = %d\n", temp);
+   return size;
+}
+
+// Attributes for debug
+DRIVER_ATTR(debug,S_IRUGO|S_IWUSR|S_IWGRP, ahmpip_attrib_show_debug,ahmpip_attrib_store_debug);
+
+//////////////////////////////////////////////////////////////////////////////
+///////////////////////////////////////////////////////////////////////////////
+////////////////////                                     //////////////////////
+/////////////////              PCIE INTERFACES             ////////////////////
+////////////////////                                     //////////////////////
+///////////////////////////////////////////////////////////////////////////////
+///////////////////////////////////////////////////////////////////////////////
+
+//=============================================================================
+// Prototypes
+//=============================================================================
+static int cci_pci_probe(struct pci_dev * , const struct pci_device_id * );
+static void cci_pci_remove(struct pci_dev * );
+#if 0
+static
+struct ccip_device *
+cci_pcie_stub_probe( struct pci_dev             *pcidev,
+                     const struct pci_device_id *pcidevid);
+#endif
+static
+struct ccip_device *
+cci_enumerate_device( struct pci_dev             *pcidev,
+                     const struct pci_device_id *pcidevid);
+
+static
+struct ccip_device *
+cci_enumerate_vf_device( struct pci_dev             *pcidev,
+                         const struct pci_device_id *pcidevid);
+static int cci_pci_sriov_configure(struct pci_dev *, int);
+
+static int  ccidrv_init(void);
+static void ccidrv_exit(void);
+
+module_init(ccidrv_init);
+module_exit(ccidrv_exit);
+
+extern int ccidrv_initDriver(void/*callback*/);
+extern int ccidrv_initUMAPI(void);
+void ccidrv_exitUMAPI(void);
+
+enum cci_config_afu_access_type {
+   cci_config_afu_access_PF,
+   cci_config_afu_access_VF
+};
+static void cci_config_afu_access_control(struct ccip_device * pccipdev,
+                                          unsigned long num_ports,
+                                          enum cci_config_afu_access_type mode);
+
+
+///////////////////////////////////////////////////////////////////////////////
+///////////////////////////////////////////////////////////////////////////////
+////////////////////                                     //////////////////////
+/////////////////            PCIE INTEGRATION               ///////////////////
+////////////////////                                     //////////////////////
+///////////////////////////////////////////////////////////////////////////////
+///////////////////////////////////////////////////////////////////////////////
+//=============================================================================
+//=============================================================================
+
+///=================================================================
+/// cci_pci_id_tbl - identify PCI devices supported by this driver
+///=================================================================
+static struct pci_device_id cci_pcie_id_tbl[] = {
+   { PCI_DEVICE(PCI_VENDOR_ID_INTEL, PCIe_DEVICE_ID_RCiEP0),          .driver_data = (kernel_ulong_t)cci_enumerate_device },
+   { PCI_DEVICE(PCI_VENDOR_ID_INTEL, PCIe_DEVICE_ID_VF),              .driver_data = (kernel_ulong_t)cci_enumerate_vf_device },
+   { PCI_DEVICE(PCI_VENDOR_ID_INTEL, PCIe_DEVICE_ID_RCiEP1),          .driver_data = (kernel_ulong_t)0 },
+   { PCI_DEVICE(PCI_VENDOR_ID_INTEL, PCIe_DEVICE_ID_RCiEP2),          .driver_data = (kernel_ulong_t)0 },
+   { PCI_DEVICE(PCI_VENDOR_ID_INTEL, PCIe_DEVICE_ID_RCiEP0_SKX_P),    .driver_data = (kernel_ulong_t)cci_enumerate_device },
+   { PCI_DEVICE(PCI_VENDOR_ID_INTEL, PCIe_DEVICE_ID_VF_SKX_P),        .driver_data = (kernel_ulong_t)cci_enumerate_vf_device },
+   { PCI_DEVICE(PCI_VENDOR_ID_INTEL, PCIe_DEVICE_ID_RCiEP0_DCP),      .driver_data = (kernel_ulong_t)cci_enumerate_device },
+   { PCI_DEVICE(PCI_VENDOR_ID_INTEL, PCIe_DEVICE_ID_VF_DCP),          .driver_data = (kernel_ulong_t)cci_enumerate_vf_device },
+   { 0, }
+};
+CASSERT(sizeof(void *) == sizeof(kernel_ulong_t));
+
+MODULE_DEVICE_TABLE(pci, cci_pcie_id_tbl);
+
+//=============================================================================
+// Name: cci_pcie_driver_info
+// Description: This struct represents the PCIe driver instance.
+//              The Driver object is registered with the Linux PCI
+//              subsystem.
+//=============================================================================
+struct cci_pcie_driver_info
+{
+   int                        isregistered;  // boolean : did we register with PCIe subsystem?
+   struct pci_driver          pcidrv;        //  Linux PCIe driver structure
+};
+
+// Instantiate the structure
+static struct cci_pcie_driver_info driver_info = {
+   .isregistered = 0,
+   .pcidrv = {
+      .name             = CCI_PCI_DRIVER_NAME,
+      .id_table         = cci_pcie_id_tbl,
+      .probe            = cci_pci_probe,
+      .remove           = cci_pci_remove,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,8,0)
+      .sriov_configure  = cci_pci_sriov_configure
+#endif /* LINUX_VERSION_CODE >= KERNEL_VERSION(3,8,0) */
+   },
+};
+
+/// Signature of CCI device specific probe function
+typedef struct ccip_device * (*cci_probe_fn)( struct pci_dev                * ,
+                                              const struct pci_device_id    * );
+
+//=============================================================================
+//=============================================================================
+//                                INLINE PRIMITIVES
+//=============================================================================
+//=============================================================================
+
+//=============================================================================
+// Name: cci_getBARAddress
+// Description: Called during the device probe by cci_pci_probe
+//                  when the device id matches PCI_DEVICE_ID_PCIFPGA.
+// Interface: public
+// Inputs:  ppcidev - Pointer to PICe device
+//          pphysaddr - Pointer to where to return the physical address
+//          pvirtaddr - Pointer to where to return the mapped virtual address
+//          psize - BAR region size
+// Outputs: 1 = success.
+// Comments:
+//=============================================================================
+static inline int cci_getBARAddress( struct pci_dev   *ppcidev,
+                                     int               barnum,
+                                     btPhysAddr       *pphysaddr,
+                                     btVirtAddr       *pvirtaddr,
+                                     size_t           *psize)
+{
+   if ( 0 == pci_request_region(ppcidev, barnum, CCI_PCI_DRIVER_NAME) ) {
+      // get the low base address register.
+      *pphysaddr = pci_resource_start(ppcidev, barnum);
+      *psize  = (size_t)pci_resource_len(ppcidev, barnum);
+
+      PVERBOSE("BAR=%d phy Address : %" PRIxPHYS_ADDR "\n",barnum, *pphysaddr);
+      PVERBOSE("BAR=%d size : %zd\n",barnum, *psize);
+
+   }else{
+      PERR("Failed to obtian PCI BAR=%d \"%s\". Using Bar 0.\n", barnum, CCI_PCI_DRIVER_NAME);
+      return 0;
+   }
+
+   // Only non-zero regions make sense
+   if((0 == *pphysaddr) || (0 == *psize)){
+      pci_release_region(ppcidev, barnum);
+      return 0;
+   }
+   // Get the KVP for the region
+   *pvirtaddr = ioremap_nocache(*pphysaddr, *psize);
+   return 1;
+}
+#if 0
+//=============================================================================
+// Name: cci_pcie_stub_probe
+// Description: Called if either the PCIe_DEVICE_ID_RCiEP1 or PCIe_DEVICE_ID_RCiEP2
+//              devices are detected. These devices have no visible host interface.
+// Interface: public
+// Inputs: pcidev - kernel-provided device pointer.
+//         pcidevid - kernel-provided device id pointer.
+// Outputs: Pointer to populated CCI device or NULL if failure
+// Comments:
+//=============================================================================
+static
+struct ccip_device * cci_pcie_stub_probe( struct pci_dev             *pcidev,
+                                          const struct pci_device_id *pcidevid)
+{
+
+   ASSERT(pcidev);
+   if ( NULL == pcidev ) {
+      PTRACEOUT_INT(-EINVAL);
+      return NULL;
+   }
+
+   ASSERT(pcidevid);
+   if ( NULL == pcidevid ) {
+      PTRACEOUT_INT(-EINVAL);
+      return NULL;
+   }
+   switch(pcidevid->device)
+   {
+      case PCIe_DEVICE_ID_RCiEP1:
+         PVERBOSE("PCIe RCiEP 1 ignored\n");
+         break;
+      case PCIe_DEVICE_ID_RCiEP2:
+         PVERBOSE("PCIe RCiEP 2 ignored\n");
+         break;
+      default:
+         PVERBOSE("Unknown device ID ignored\n");
+         break;
+   }
+   return (struct ccip_device *) (-1);
+}
+#endif
+//=============================================================================
+// Name: cci_pci_probe
+// Description: Called during the device probe by PCIe subsystem.
+// Interface: public
+// Inputs: pcidev - kernel-provided device pointer.
+//         pcidevid - kernel-provided device id pointer.
+// Outputs: 0 = success.
+// Comments:
+//=============================================================================
+static
+int
+cci_pci_probe( struct pci_dev             *pcidev,
+               const struct pci_device_id *pcidevid)
+{
+
+   int res = -EINVAL;
+   cci_probe_fn  probe_fn;
+   struct ccip_device      *pccidev = NULL;
+
+   PTRACEIN;
+
+   // Validate parameters
+   ASSERT(pcidev);
+   if ( NULL == pcidev ) {
+      res = -EINVAL;
+      PTRACEOUT_INT(res);
+      return res;
+   }
+
+   ASSERT(pcidevid);
+   if ( NULL == pcidevid ) {
+      res = -EINVAL;
+      PTRACEOUT_INT(res);
+      return res;
+   }
+
+   // Display device information
+   PVERBOSE("Discovered FPGA Device:");
+   PVERBOSE("-VenderID %x  \n",pcidevid->vendor );
+   PVERBOSE("-DeviceID  %x  \n",pcidevid->device );
+   PVERBOSE("-B:D.F = %x:%x.%x  \n",pcidev->bus->number,PCI_SLOT(pcidev->devfn),PCI_FUNC(pcidev->devfn) );
+
+   // Get the device specific probe function
+   probe_fn = (cci_probe_fn)pcidevid->driver_data;
+   if ( NULL == probe_fn ) {
+       PVERBOSE("Ignoring hidden PCIe devcies\n");
+       return 0;
+   }
+
+   // Call the probe function.  This is where the real work occurs
+   //  If probe_fn returns NULL, it should print a verbose message in the log
+   //  as to why (e.g. skipped PF because VF is present).
+   pccidev = probe_fn( pcidev, pcidevid );
+
+   // If all went well record this device on our
+   //  list of devices owned by the driver
+   if(NULL != pccidev){
+      kosal_list_add(&(pccidev->m_list), &g_device_list);
+      res = 0;
+   }
+   PTRACEOUT_INT(res);
+   return res;
+}
+
+///////////////////////////////////////////////////////////////////////////////
+///////////////////////////////////////////////////////////////////////////////
+////////////////////                                     //////////////////////
+/////////////////        BOARD DEVICE BAR ENUMERATION       ///////////////////
+////////////////////                                     //////////////////////
+///////////////////////////////////////////////////////////////////////////////
+///////////////////////////////////////////////////////////////////////////////
+//=============================================================================
+//=============================================================================
+//=============================================================================
+// Name: cci_pci_sriov_configure
+// Description: Callback used during SRIOV device initialization
+// Inputs: pcidev - kernel-provided device pointer.
+//         num_vfs - Number of VFs to enable.
+// Returns: 0 = success.
+// Comments:
+//=============================================================================
+static int cci_pci_sriov_configure(struct pci_dev *pcidev, int num_vfs)
+{
+
+   // for now, we do not support configuring sr_iov through sysfs, because it
+   // requires more complex deactivation and handover of AFUs between PF and
+   // VF. Instead, VF capability is configured via a load parameter (vf).
+   /*
+   if (num_vfs == 0){
+      // transfer AFU ownership back to PF
+      // TODO
+      // disable SR-IOV
+      pci_disable_sriov(pcidev);
+      PINFO("SRIOV disabled on this device\n");
+   }else{
+      // enable SR-IOV
+      if (0 == pci_enable_sriov(pcidev, num_vfs)){
+         PINFO("SRIOV Enabled on this device for %d VF%s\n",num_vfs, (num_vfs >1 ? "s" : ""));
+         // transfer AFU ownership to VF
+         // TODO
+      }else{
+         PINFO("Failed to enable SRIOV");
+      }
+   }
+   return 0;
+   */
+   return 1;
+}
+
+//=============================================================================
+// Name: cci_enumerate_vf_device
+// Description: Called during the device probe to initiate the enumeration of
+//              the Virtual Function device attributes and construct the
+//              internal objects.
+// Inputs: pcidev - kernel-provided device pointer.
+//         pcidevid - kernel-provided device id pointer.
+// Returns: 0 = success.
+// Comments:
+//=============================================================================
+static
+struct ccip_device * cci_enumerate_vf_device( struct pci_dev             *pcidev,
+                                              const struct pci_device_id *pcidevid)
+{
+
+   struct ccip_device *pccipdev        = NULL;
+   struct port_device *pportdev        = NULL;
+   int                 res             = 0;
+
+   PTRACEIN;
+
+   // Ignore VF if requested
+   // This is needed to tell the host node (aka Dom0) ccip driver to ignore
+   // the VFs so that the VF can be attached to a VM
+   if (0 == sriov_vf && 1 == sriov) {
+      // Make this a warning, so it always prints
+      PWARN("Ignoring VF, (sriov_vf == 0)\n");
+      return NULL;
+   }
+
+   // Check arguments
+   ASSERT(pcidev);
+   if ( NULL == pcidev ) {
+      PTRACEOUT_INT(-EINVAL);
+      return NULL;
+   }
+   ASSERT(pcidevid);
+   if ( NULL == pcidevid ) {
+      PTRACEOUT_INT(-EINVAL);
+      return NULL;
+    }
+
+   // Setup the PCIe device
+   //----------------------
+   res = pci_enable_device(pcidev);
+   if ( res < 0 ) {
+      PERR("Failed to enable device res=%d\n", res);
+      PTRACEOUT_INT(res);
+      return NULL;
+   }
+
+   // enable PCIe error reporting
+   pci_enable_pcie_error_reporting(pcidev);
+
+   // enable bus mastering and configure DMA
+   pci_set_master(pcidev);
+   pci_save_state(pcidev);
+
+   if (!dma_set_mask(&pcidev->dev, DMA_BIT_MASK(64))) {
+      dma_set_coherent_mask(&pcidev->dev, DMA_BIT_MASK(64));
+   } else if (!dma_set_mask(&pcidev->dev, DMA_BIT_MASK(32))) {
+      dma_set_coherent_mask(&pcidev->dev, DMA_BIT_MASK(32));
+   } else {
+      PERR("No suitable DMA support available.\n");
+      goto ERR;
+   }
+
+   // Create the CCI device object
+   //  Allocate a new CCI board device object
+   //  and populate it with its resource information
+   //----------------------------------------------
+   pccipdev = create_ccidevice();
+   ASSERT(NULL != pccipdev);
+   if( NULL == pccipdev) {
+      return NULL;
+   }
+
+   // Save the PCI device in the CCI object
+   ccip_dev_pci_dev(pccipdev) = pcidev;
+
+   // Acquire the BAR region
+   //  64 Bit BARs are actually spread
+   //  across 2 consecutive BARs. So we
+   //  use 0 and 2 rather than 0 and 1
+   //------------------------------------
+   {
+      btPhysAddr           pbarPhyAddr    = 0;
+      btVirtAddr           pbarVirtAddr   = 0;
+      size_t               barsize        = 0;
+
+
+      // As this is a VF we only expect 1 BAR for the Port
+      if( !cci_getBARAddress(  pcidev,
+                               0,
+                              &pbarPhyAddr,
+                              &pbarVirtAddr,
+                              &barsize) ){
+         goto ERR;
+      }
+
+      // Save the BAR information in the CCI Device object. For a VF it's a Port
+      ccip_portdev_phys_afu_mmio(pccipdev,0)    = __PHYS_ADDR_CAST(pbarPhyAddr);
+      ccip_portdev_kvp_afu_mmio(pccipdev,0)     = pbarVirtAddr;
+      ccip_portdev_len_afu_mmio(pccipdev,0)     = barsize;
+
+      PDEBUG("ccip_portdev_phys_afu_mmio(pccipdev) : %lx\n", ccip_portdev_phys_afu_mmio(pccipdev,0));
+      PDEBUG("ccip_portdev_kvp_afu_mmio(pccipdev) : %lx\n",(long unsigned int) ccip_portdev_kvp_afu_mmio(pccipdev,0));
+      PDEBUG("ccip_portdev_len_afu_mmio(pccipdev): %zu\n", ccip_portdev_len_afu_mmio(pccipdev,0));
+
+   }
+
+   // Save the Bus:Device:Function of PCIe device
+   ccip_dev_pcie_bustype(pccipdev)  = aal_bustype_PCIe;
+   ccip_dev_pcie_busnum(pccipdev)   = pcidev->bus->number;
+   ccip_dev_pcie_devnum(pccipdev)   = PCI_SLOT(pcidev->devfn);
+   ccip_dev_pcie_fcnnum(pccipdev)   = PCI_FUNC(pcidev->devfn);
+   ccip_dev_pcie_socketnum(pccipdev)= 0;
+
+   // Enumerate the device
+   //  Instantiate internal objects. Objects that represent
+   //  objects that can be allocated through the AALBus are
+   //  constructed around the aaldevice base and are published
+   //  with aalbus.
+   //---------------------------------------------------------
+
+   //In a VF there should be no FME region
+   if(0 != ccip_fmedev_kvp_afu_mmio(pccipdev)){
+      PERR("Invalid region [FME]\n");
+      goto ERR;
+   }
+
+
+   // Port Device initialization
+   //  The resources may reside in different Bars and at different offsets.
+   //  The driver must keep track of all resources it claims so it can
+   //  free them later.
+   //----------------------------------------------------------------------
+
+
+   // Discover and create Port device
+   //   Enumerates the Port feature list, creates the Port object.
+   //   Then add the new port object onto the list
+   //-------------------------------------------------------------
+   pportdev = get_port_device( ccip_portdev_phys_afu_mmio(pccipdev,0),
+                               ccip_portdev_kvp_afu_mmio(pccipdev,0),
+                               ccip_portdev_len_afu_mmio(pccipdev,0));
+
+   if ( NULL == pportdev ) {
+      PERR("Could not allocate memory for FME object\n");
+      res = -ENOMEM;
+      goto ERR;
+   }
+
+   // Record the resource
+   ccip_set_resource(pccipdev, 0);
+
+   PDEBUG("Created Port Device\n");
+   port_afu_Enable(pportdev);
+
+   // Point to our parent
+   ccip_port_to_ccidev(pportdev) = pccipdev;
+
+   // Inherits B:D:F from board
+   ccip_port_bustype(pportdev)   = ccip_dev_pcie_bustype(pccipdev);
+   ccip_port_busnum(pportdev)    = ccip_dev_pcie_busnum(pccipdev);
+   ccip_port_devnum(pportdev)    = ccip_dev_pcie_devnum(pccipdev);
+   ccip_port_fcnnum(pportdev)    = ccip_dev_pcie_fcnnum(pccipdev);
+   ccip_port_socketnum(pportdev) = ccip_dev_pcie_socketnum(pccipdev);
+
+   // Log the Port MMIO
+   print_sim_port_device(pportdev);
+
+   PDEBUG("Adding to list\n");
+
+   // Added it to the port list
+   kosal_list_add(&ccip_port_dev_list(pccipdev), &ccip_port_list_head(pportdev));
+
+   // No access to FME for VF
+   ccip_port_dev_fme(pportdev) = NULL;
+
+   PDEBUG("Creating Allocatable objects\n");
+
+   // Instantiate allocatable objects including AFUs if present.
+   //   Subdevice addresses start at 10x the 1 based port number to leave room for
+   //   10 devices beneath the port. E.e., STAP, PR, User AFU
+   if(!cci_port_dev_create_AAL_allocatable_objects(pportdev, 0) ){
+      goto ERR;
+   }
+   ccip_set_VFdev(pccipdev);
+
+
+   // Start logging timer
+   start_logging_timer();
+
+   return pccipdev;
+ERR:
+
+   // unmap MMIO region if valid region.
+   if( (NULL != pccipdev) &&
+       (NULL != ccip_portdev_kvp_afu_mmio(pccipdev,0))) {
+      PVERBOSE("Freeing Port BAR 0\n");
+      iounmap(ccip_fmedev_kvp_afu_mmio(pccipdev));
+      pci_release_region(pcidev, 0);
+   }
+
+   // Release MMIO region if PCI Resource reserved
+   if( (NULL != pccipdev) &&
+       ( 0 != ccip_portdev_phys_afu_mmio(pccipdev,0) ||
+         0 != ccip_portdev_len_afu_mmio(pccipdev,0)) )    {
+      pci_release_region(pcidev, 0);
+   }
+
+   if ( NULL != pccipdev ) {
+      kosal_kfree(pccipdev, sizeof(struct ccip_device));
+   }
+
+   PTRACEOUT_INT(res);
+   return NULL;
+}
+
+//=============================================================================
+// Name: cci_enumerate_device
+// Description: Called during the device probe to initiate the enumeration of
+//              the device attributes and construct the internal objects.
+// Inputs: pcidev - kernel-provided device pointer.
+//         pcidevid - kernel-provided device id pointer.
+// Returns: 0 = success.
+// Comments:
+//=============================================================================
+static
+struct ccip_device * cci_enumerate_device( struct pci_dev             *pcidev,
+                                           const struct pci_device_id *pcidevid)
+{
+
+   struct ccip_device * pccipdev       = NULL;
+
+   int                  res            = 0;
+
+   PTRACEIN;
+
+   // Check arguments
+   ASSERT(pcidev);
+   if ( NULL == pcidev ) {
+      PTRACEOUT_INT(-EINVAL);
+      return NULL;
+   }
+   ASSERT(pcidevid);
+   if ( NULL == pcidevid ) {
+      PTRACEOUT_INT(-EINVAL);
+      return NULL;
+    }
+
+   // Setup the PCIe device
+   //----------------------
+   res = pci_enable_device(pcidev);
+   if ( res < 0 ) {
+      PERR("Failed to enable device res=%d\n", res);
+      PTRACEOUT_INT(res);
+      return NULL;
+   }
+
+   // enable PCIe error reporting
+   pci_enable_pcie_error_reporting(pcidev);
+
+   // enable bus mastering and configure DMA
+   pci_set_master(pcidev);
+   pci_save_state(pcidev);
+   if (!dma_set_mask(&pcidev->dev, DMA_BIT_MASK(64))) {
+      dma_set_coherent_mask(&pcidev->dev, DMA_BIT_MASK(64));
+   } else if (!dma_set_mask(&pcidev->dev, DMA_BIT_MASK(32))) {
+      dma_set_coherent_mask(&pcidev->dev, DMA_BIT_MASK(32));
+   } else {
+      PERR("No suitable DMA support available.\n");
+      goto ERR;
+   }
+
+   // Create the CCI device object
+   //  Allocate a new CCI board device object
+   //  and populate it with its reource information
+   //----------------------------------------------
+   pccipdev = create_ccidevice();
+   ASSERT(NULL != pccipdev);
+   if( NULL == pccipdev ) {
+      goto ERR;
+   }
+
+   // Save the PCI device in the CCI object
+   ccip_dev_pci_dev(pccipdev) = pcidev;
+
+   // Acquire the BAR regions
+   //  64 Bit BARs are actually spread
+   //  across 2 consecutive BARs. So we
+   //  use 0 and 2 rather than 0 and 1
+   //------------------------------------
+   {
+      btPhysAddr           pbarPhyAddr    = 0;
+      btVirtAddr           pbarVirtAddr   = 0;
+      size_t               barsize        = 0;
+
+      // BAR 0  is the FME
+      if( !cci_getBARAddress(  pcidev,
+                               0,
+                              &pbarPhyAddr,
+                              &pbarVirtAddr,
+                              &barsize) ){
+         goto ERR;
+      }
+
+
+
+      // Save the BAR information in the CCI Device object
+      ccip_fmedev_phys_afu_mmio(pccipdev)    = __PHYS_ADDR_CAST(pbarPhyAddr);
+      ccip_fmedev_len_afu_mmio(pccipdev)     = barsize;
+      ccip_fmedev_kvp_afu_mmio(pccipdev)     = pbarVirtAddr;
+
+      PDEBUG("ccip_fmedev_phys_afu_mmio(pccipdev) : %lx\n", ccip_fmedev_phys_afu_mmio(pccipdev));
+      PDEBUG("ccip_fmedev_kvp_afu_mmio(pccipdev) : %lx\n",(long unsigned int) ccip_fmedev_kvp_afu_mmio(pccipdev));
+      PDEBUG("ccip_fmedev_len_afu_mmio(pccipdev): %zu\n", ccip_fmedev_len_afu_mmio(pccipdev));
+
+   }
+
+   // Save the Bus:Device:Function of PCIe device
+   ccip_dev_pcie_bustype(pccipdev)      = aal_bustype_PCIe;
+   ccip_dev_pcie_busnum(pccipdev)       = pcidev->bus->number;
+   ccip_dev_pcie_devnum(pccipdev)       = PCI_SLOT(pcidev->devfn);
+   ccip_dev_pcie_fcnnum(pccipdev)       = PCI_FUNC(pcidev->devfn);
+
+   // Enumerate the device
+   //  Instantiate internal objects. Objects that represent
+   //  objects that can be allocated through the AALBus are
+   //  constructed around the aaldevice base and are published
+   //  with aalbus.
+   //---------------------------------------------------------
+   //FME region
+   if(0 != ccip_fmedev_kvp_afu_mmio(pccipdev)){
+
+      PINFO(" FME mmio region   \n");
+
+      // Create the FME MMIO device object
+      //   Enumerates the FME feature list
+      //----------------------------------
+      ccip_dev_to_fme_dev(pccipdev) = get_fme_mmio_dev(ccip_fmedev_kvp_afu_mmio(pccipdev) );
+      if ( NULL == pccipdev->m_pfme_dev ) {
+         PERR("Could not allocate memory for FME object\n");
+         res = -ENOMEM;
+         goto ERR;
+      }
+
+      ccip_dev_pcie_socketnum(pccipdev) = ccip_dev_to_fme_dev(pccipdev)->m_pHDR->fab_capability.socket_id ;
+      PINFO(" Socket Num = %x   \n",ccip_dev_pcie_socketnum(pccipdev));
+
+      //disable the link status check for DCP because it is currently BDX based
+      if(pcidevid->device != PCIe_DEVICE_ID_RCiEP0_DCP) {
+         // Checking for PCIe0,PCIe1,UPI link status
+         if(!ccip_links_status(ccip_dev_to_fme_dev(pccipdev))){
+            PERR(" FPGA Interface links are not up \n");
+            goto ERR;
+         }
+      }
+
+      // Save the PCI device in the FME object
+      ccip_fme_dev_pci_dev(ccip_dev_to_fme_dev(pccipdev)) = pcidev;
+
+
+      // Instantiate AAL allocatable objects including AFUs if present
+      if(!cci_fme_dev_create_AAL_allocatable_objects(pccipdev)){
+         ccip_destroy_fme_mmio_dev(pccipdev->m_pfme_dev);
+         goto ERR;
+      }
+
+      //FIXME: PR doesn't work in SRIOV mode right now
+      //I think the PR flow assumes there is an AFU object and dereferences
+      //a NULL pointer
+      if(0 == sriov) {
+         // Creates AAL PR device object
+         if(!cci_create_AAL_PR_allocatable_objects(pccipdev)){
+            goto ERR;
+         }
+      }
+
+      // Creates AAL Power device object
+      if(!cci_create_AAL_power_Device(pccipdev)){
+         goto ERR;
+      }
+
+#if 1
+      // print fme CSRS
+      print_sim_fme_device(pccipdev->m_pfme_dev);
+#endif
+
+      create_perfmonitor(pcidev,ccip_dev_to_fme_dev(pccipdev));
+   }
+
+
+   // Port Device initialization
+   //  Loop through each Port Offset register to determine
+   //  if a Port has been implemented and where its resources are.
+   //  The resources may reside in different Bars and at different offsets.
+   //  The driver must keep track of all resources it claims so it can
+   //  free them later.
+   //----------------------------------------------------------------------
+   {
+      struct fme_device  *pfme_dev  = ccip_dev_to_fme_dev(pccipdev);
+      struct CCIP_FME_HDR *pfme_hdr = ccip_fme_hdr(pfme_dev);
+
+      int i=0;
+
+      for(i=0;  0!= pfme_hdr->port_offsets[i].port_imp  ;i++){
+         btPhysAddr pbarPhyAddr        = 0;
+         btUnsigned32bitInt bar        = pfme_hdr->port_offsets[i].port_bar;
+         btUnsigned64bitInt offset     = pfme_hdr->port_offsets[i].port_offset;
+         struct port_device *pportdev  = NULL;
+
+         PINFO("***** PORT %d MMIO region @ Bar %d offset %x *****\n",i , bar, pfme_hdr->port_offsets[i].port_offset);
+
+         // Check to see if the resource has already been acquired
+         if(!ccip_has_resource(pccipdev, bar)){
+
+            PVERBOSE("Getting resources from BAR %d\n", bar);
+
+            // Get the bar
+            if( !cci_getBARAddress(  pcidev,
+                                     bar,
+                                    &pbarPhyAddr,
+                                    &ccip_portdev_kvp_afu_mmio(pccipdev,bar),
+                                    &ccip_portdev_len_afu_mmio(pccipdev,bar)) ){
+               goto ERR;
+            }
+            ccip_portdev_phys_afu_mmio(pccipdev,bar)   = __PHYS_ADDR_CAST(pbarPhyAddr);
+
+            // Record the resource
+            ccip_set_resource(pccipdev, bar);
+
+            PDEBUG("Bar phys : %" PRIxPHYS_ADDR "\n", ccip_portdev_phys_afu_mmio(pccipdev,bar));
+            PDEBUG("Virt : %p\n", ccip_portdev_kvp_afu_mmio(pccipdev,bar));
+            PDEBUG("Len: %zu\n", ccip_portdev_len_afu_mmio(pccipdev,bar));
+         }
+
+         // Discover and create Port device
+         //   Enumerates the Port feature list, creates the Port object.
+         //   Then add the new port object onto the list
+         //-------------------------------------------------------------
+         pportdev = get_port_device( pbarPhyAddr + offset,
+                                     ccip_portdev_kvp_afu_mmio(pccipdev,bar) + offset,
+                                     ccip_portdev_len_afu_mmio(pccipdev,bar));
+         if ( NULL == pportdev ) {
+            PERR("Could not allocate memory for FME object\n");
+            res = -ENOMEM;
+            goto ERR;
+         }
+
+         PDEBUG("Created Port Device\n");
+         port_afu_Enable(pportdev);
+
+         // Point to our parent
+         ccip_port_to_ccidev(pportdev) = pccipdev;
+
+         ccip_dev_to_port_dev(pccipdev,i)  = pportdev;
+
+         // Inherits B:D:F from board
+         ccip_port_bustype(pportdev)   = ccip_dev_pcie_bustype(pccipdev);
+         ccip_port_busnum(pportdev)    = ccip_dev_pcie_busnum(pccipdev);
+         ccip_port_devnum(pportdev)    = ccip_dev_pcie_devnum(pccipdev);
+         ccip_port_fcnnum(pportdev)    = ccip_dev_pcie_fcnnum(pccipdev);
+         ccip_port_socketnum(pportdev) = ccip_dev_pcie_socketnum(pccipdev);
+         ccip_port_subdevnum(pportdev) = i;
+
+         // Log the Port MMIO
+         print_sim_port_device(pportdev);
+
+         PDEBUG("Adding to list\n");
+
+         // Added it to the port list
+         kosal_list_add(&ccip_port_dev_list(pccipdev), &ccip_port_list_head(pportdev));
+
+         // Save the FME parent for this port
+         ccip_port_dev_fme(pportdev) = pfme_dev;
+
+         PDEBUG("Creating Allocatable objects\n");
+
+         // Instantiate allocatable objects including AFUs if present.
+         //   Subdevice addresses start at 10x the 1 based port number to leave room for
+         //   10 devices beneath the port. E.e., STAP, PR, User AFU
+         // Enumerate AFUs in PF if not in SRIOV mode.
+         if (0 == sriov) {
+            if(!cci_port_dev_create_AAL_allocatable_objects(pportdev, i) ){
+               goto ERR;
+            }
+         }
+      }// End for loop
+
+      ccip_portdev_numports(pccipdev) = i;
+      ccip_portdev_maxVFs(pccipdev) = i;     // Can't have more VFs than ports for now
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,8,0)
+      if (0 != sriov) {
+         if (sriov > ccip_portdev_maxVFs(pccipdev)) {
+            sriov = ccip_portdev_maxVFs(pccipdev);
+            PINFO("Asked for more VFs than PORTs, setting to number of PORTs (%ld).\n", sriov);
+         }
+         // Set AFU Access control bit before enable SRIOV.
+         cci_config_afu_access_control(pccipdev, sriov, cci_config_afu_access_VF);
+  
+         if (0 == pci_enable_sriov(pcidev, sriov)){
+            PINFO("SRIOV Enabled on this device for %ld VF%s\n", sriov, (sriov > 1 ? "s" : ""));
+         }else{
+            // Clear AFU Access control bit if SRIOV enable fails.
+            cci_config_afu_access_control(pccipdev, sriov, cci_config_afu_access_PF);
+            PINFO("Failed to enable SRIOV");
+         }
+      }
+#endif /* LINUX_VERSION_CODE >= KERNEL_VERSION(3,8,0) */
+
+   }
+
+   // Start logging timer
+   start_logging_timer();
+
+
+   return pccipdev;
+ERR:
+{
+   int x;
+   PINFO(" -----ERROR -----   \n");
+   for(x=1; x<5; x++){
+      if(ccip_has_resource(pccipdev, x)){
+         PVERBOSE("Freeing Port BAR %d\n",x);
+         if( NULL != ccip_portdev_kvp_afu_mmio(pccipdev,x)) {
+             iounmap(ccip_portdev_kvp_afu_mmio(pccipdev,x));
+             pci_release_region(pcidev, x);
+             ccip_portdev_kvp_afu_mmio(pccipdev,x) = NULL;
+          }
+      }
+   }
+
+  if( NULL != ccip_fmedev_kvp_afu_mmio(pccipdev)) {
+     PVERBOSE("Freeing Port BAR 0\n");
+     remove_perfmonitor(pccipdev->m_pcidev);
+     iounmap(ccip_fmedev_kvp_afu_mmio(pccipdev));
+     pci_release_region(pcidev, 0);
+
+     if(NULL != ccip_dev_to_fme_dev(pccipdev)) {
+         kosal_kfree(ccip_dev_to_fme_dev(pccipdev),sizeof(struct fme_device ) );
+     }
+     ccip_fmedev_kvp_afu_mmio(pccipdev) = NULL;
+
+   }
+
+   if ( NULL != pccipdev ) {
+         kosal_kfree(pccipdev, sizeof(struct ccip_device));
+   }
+}
+
+   PTRACEOUT_INT(res);
+   return NULL;
+}
+
+//=============================================================================
+// Name: cci_config_afu_access_control
+// Description: enables or disables AFU access control setting
+// Interface: private
+// Inputs: pccipdev - ccip_device
+//                    num_ports - the number of VF ports to enable
+//                    mode - access control mode - either PF or VF
+// Outputs: none.
+// Comments:
+//=============================================================================
+static
+void
+cci_config_afu_access_control(struct ccip_device * pccipdev, unsigned long num_ports,
+                              enum cci_config_afu_access_type mode)
+{
+   int i ;
+   // get FME device
+   volatile struct fme_device *pfmedev;
+   struct CCIP_PORT_AFU_OFFSET port_offset;
+   pfmedev = ccip_dev_to_fme_dev(pccipdev);
+   if (NULL != pfmedev) {
+      for (i = 0; i < num_ports; i++) {
+         // transfer ownership of AFU in PORTi to VF
+         // ENABLE afu_access_control
+         port_offset.csr = pfmedev->m_pHDR->port_offsets[i].csr;
+         if(mode == cci_config_afu_access_VF)
+            port_offset.afu_access_control = 0x1;
+         else
+            port_offset.afu_access_control = 0x0;
+         pfmedev->m_pHDR->port_offsets[i].csr = port_offset.csr;
+      }
+   } else {
+      PINFO("No FME device, can't transfer ownership of VF.");
+   }
+}
+
+//=============================================================================
+// Name: cci_pci_remove
+// Description: Entry point called when a device registered with the PCIe
+//              subsystem is being removed
+// Interface: public
+// Inputs: pcidev - kernel-provided device pointer.
+// Outputs: none.
+// Comments: Searches through @g_device_list to find any spl2dev which has a
+//           cached pointer to pcidev and removes/destroys any found.
+//=============================================================================
+static
+void
+cci_pci_remove(struct pci_dev *pcidev)
+{
+   struct ccip_device   *pccidev    = NULL;
+   struct list_head     *This       = NULL;
+   struct list_head     *tmp        = NULL;
+
+   int found = 0;
+
+   PTRACEIN;
+
+   ASSERT(pcidev);
+   if ( NULL == pcidev ) {
+      PERR("PCI remove called with NULL.\n");
+      return;
+   }
+
+   //need to disable SRIOV before removing cci devices so that VF is removed
+   //before PF
+   // Search through our list of devices to find the one matching pcidev
+   #if LINUX_VERSION_CODE >= KERNEL_VERSION(3,8,0)
+      if (0 != sriov) {
+         struct ccip_device   *sriov_pf_pccidev    = NULL;
+
+         if ( !kosal_list_is_empty(&g_device_list) ) {
+            kosal_list_for_each(This, &g_device_list) {
+               pccidev = ccip_list_to_ccip_device(This);
+               if ( pccidev->m_pcidev == pcidev ) {
+                  if( NULL != ccip_dev_to_fme_dev(pccidev)) {
+                     sriov_pf_pccidev = pccidev;
+                  }
+               }
+            }
+         }
+
+         if(sriov_pf_pccidev) {
+            //pci_disable_sriov cannot be called while traversing g_device_list
+            //Disabling sriov will remove vf drivers and devices before this
+            //function finishes and will cause g_device_list to be updated
+            pci_disable_sriov(pcidev);
+            cci_config_afu_access_control(sriov_pf_pccidev, sriov, cci_config_afu_access_PF);
+         }
+      }
+   #endif
+
+   // Search through our list of devices to find the one matching pcidev
+   if ( !kosal_list_is_empty(&g_device_list) ) {
+
+      // Run through list of devices.  Use safe variant
+      //  as we will be deleting entries
+      kosal_list_for_each_safe(This, tmp, &g_device_list) {
+
+         pccidev = ccip_list_to_ccip_device(This);
+
+         if ( pccidev->m_pcidev == pcidev ) {
+            ++found;
+
+            PDEBUG("Deleting device 0x%p with list head 0x%p from list 0x%p\n",
+                  pccidev, This, &g_device_list);
+            cci_remove_device(pccidev);
+         }
+
+      }
+
+   }
+
+   if ( 0 == found ) {
+      PINFO("struct pci_dev * 0x%p not found in device list.\n", pcidev);
+   } else if ( found > 1 ) {
+      PINFO("struct pci_dev * 0x%p found in device list multiple times.\n", pcidev);
+   }
+
+   PTRACEOUT;
+}
+
+//=============================================================================
+// Name: cci_remove_device
+// Description: Performs generic cleanup and deletion of CCI object
+// Input: pccipdev - device to remove
+// Comment:
+// Returns: none
+// Comments:
+//=============================================================================
+void
+cci_remove_device(struct ccip_device *pccipdev)
+{
+   int x;
+   PDEBUG("Removing CCI device\n");
+
+   // Call PIP to ensure the object is idle and ready for removal
+   // TODO
+
+   // Release the resources used for ports
+   for(x=0; x<5; x++){
+      if(ccip_has_resource(pccipdev, x)){
+         if( NULL != ccip_portdev_kvp_afu_mmio(pccipdev,x)) {
+            if(!ccip_is_simulated(pccipdev)){
+               PVERBOSE("Freeing Port BAR %d\n",x);
+               iounmap(ccip_portdev_kvp_afu_mmio(pccipdev,x));
+               pci_release_region(ccip_dev_to_pci_dev(pccipdev), x);
+            }else{
+               kosal_kfree(ccip_portdev_kvp_afu_mmio(pccipdev,x),ccip_portdev_len_afu_mmio(pccipdev,x) );
+            }
+             ccip_portdev_kvp_afu_mmio(pccipdev,x) = NULL;
+          }
+      }
+   }
+
+   // Release FME Resources
+   if( NULL != ccip_fmedev_kvp_afu_mmio(pccipdev)) {
+      if(!ccip_is_simulated(pccipdev)){
+         PVERBOSE("Freeing FME BAR 0\n");
+         remove_perfmonitor(pccipdev->m_pcidev);
+         iounmap(ccip_fmedev_kvp_afu_mmio(pccipdev));
+         pci_release_region(ccip_dev_to_pci_dev(pccipdev), 0);
+      }else{
+         kosal_kfree(ccip_fmedev_kvp_afu_mmio(pccipdev),ccip_fmedev_len_afu_mmio(pccipdev) );
+      }
+      ccip_fmedev_kvp_afu_mmio(pccipdev) = NULL;
+   }
+
+   if( cci_aaldev_pci_dev_is_enabled(pccipdev) ) {
+      if(!ccip_is_simulated(pccipdev)){
+         PVERBOSE("Disabling PCIe device\n");
+         pci_disable_device(cci_aaldev_pci_dev(pccipdev));
+      }
+      cci_aaldev_pci_dev_clr_enabled(pccipdev);
+   }
+
+   // Destroy the device
+   //  Cleans up any child objects.
+   destroy_ccidevice(pccipdev);
+
+} // cci_remove_device
+
+
+///////////////////////////////////////////////////////////////////////////////
+///////////////////////////////////////////////////////////////////////////////
+////////////////////                                     //////////////////////
+/////////////////                CCI    Driver             ////////////////////
+////////////////////                                     //////////////////////
+///////////////////////////////////////////////////////////////////////////////
+///////////////////////////////////////////////////////////////////////////////
+//=============================================================================
+//=============================================================================
+
+//=============================================================================
+// Name: ccidrv_initDriver
+// Description: Initialized the CCI driver framework
+// Interface: public
+// Inputs: Callback structure - ???.
+// Outputs: none.
+// Comments: none.
+//=============================================================================
+int
+ccidrv_initDriver(void/*callback*/)
+{
+   int ret                          = 0;     // Return code
+
+   PTRACEIN;
+
+   // Initialize the list of devices controlled by this driver
+   kosal_list_init(&g_device_list);
+   kosal_mutex_init(&g_dev_list_sem);
+
+   // Display whether we are running with real or simulated hardware
+   PINFO("Using %s configuration.\n", (0 == sim) ? "FPGA hardware" : "simulated hardware");
+
+   // Process command line arguments
+   if ( 0 == sim ) {
+     // Expecting real hardware. Register with PCIe subsystem and wait for OS enumeration
+      ret =0;
+
+      // creates logging timer
+      create_logging_timer();
+
+      // Attempt to register with the kernel PCIe subsystem.
+      ret = pci_register_driver(&driver_info.pcidrv);
+      ASSERT(0 == ret);
+      if( 0 != ret ) {
+         PERR("Failed to register PCI driver. (%d)\n", ret);
+         goto ERR;
+      }
+
+      // Record the fact that the driver is registered with OS.
+      //  Used during uninstall.
+      driver_info.isregistered = 1;
+
+      // Create the Debug /sys argument
+      //  For now this is only instantiated when using real hardware as we don't have a
+      //  registered driver to hang the parameter off of otherwise.
+      if(driver_create_file(&driver_info.pcidrv.driver,&driver_attr_debug)){
+          DPRINTF (CCIPCIE_DBG_MOD, ": Failed to create debug attribute - Unloading module\n");
+          // Unregister the driver with the bus
+          ret = -EIO;
+          goto ERR;
+      }
+
+      // create the logging sysfs argument
+      if( create_logging_timervalue_sysfs(&driver_info.pcidrv.driver) ) {
+
+         DPRINTF (CCIPCIE_DBG_MOD, ": Failed to create Logging timer attributes\n");
+      }
+
+
+   } else {
+
+      // Enumerate and Instantiate the Simulated Devices
+      ret  = cci_sim_discover_devices(sim, &g_device_list);
+      ASSERT(0 == ret);
+      if(0 >ret){
+         PERR("Failed to create simulated CCI devices.\n");
+         // If cci_sim_discover_devices() fails it will have cleaned up.
+         goto ERR;
+      }
+
+      // creates logging timer
+      create_logging_timer();
+      // Start logging timer
+      start_logging_timer();
+
+   }
+
+   PTRACEOUT_INT(ret);
+   return ret;
+
+ERR:
+
+   if ( driver_info.isregistered ) {
+      pci_unregister_driver(&driver_info.pcidrv);
+      driver_info.isregistered = 0;
+   }
+
+   PTRACEOUT_INT(ret);
+   return ret;
+}
+
+
+//=============================================================================
+// Name: ccidrv_exitDriver
+// Description: Exit called when module is unloaded
+// Interface: public
+// Inputs: none.
+// Outputs: none.
+// Comments: Walks @g_device_list, destroying any device not registered with
+//             the PCIe subsystem.
+//=============================================================================
+void
+ccidrv_exitDriver(void)
+{
+   struct ccip_device *pccidev      = NULL;
+   struct list_head   *This         = NULL;
+   struct list_head   *tmp          = NULL;
+
+   PTRACEIN;
+
+   // Remove/destroy any devices that were not registered with the PCIe subsystem.
+
+   // Stop & Remove logging timer
+   if(0 ==sim) {
+
+      if( remove_logging_timervalue_syfs(&driver_info.pcidrv.driver) ) {
+            DPRINTF (CCIPCIE_DBG_MOD, ": Failed to Remove Logging timer attributes\n");
+      }
+   }
+
+   stop_logging_timer();
+   remove_logging_timer();
+
+
+   if( !kosal_list_is_empty(&g_device_list) ){
+
+      // Run through list of devices.  Use safe variant
+      //  as we will be deleting entries
+      kosal_list_for_each_safe(This, tmp, &g_device_list) {
+
+         // Get the device from the list entry
+         pccidev = ccip_list_to_ccip_device(This);
+
+         //Only remove cci devices that are not attached to PCIe(the sim ones)
+         //cci_pci_remove will handle the PCIe cci devices.  This check
+         //is needed for certain SRIOV cases where ccidrv_exitDriver and
+         //cci_pci_remove can conflict with each other with cci_remove_device
+         if(NULL == pccidev->m_pcidev) {
+            PDEBUG("<- Deleting device 0x%p with list head 0x%p from list 0x%p\n", pccidev,
+                                                                                   This,
+                                                                                   &g_device_list);
+            cci_remove_device(pccidev);
+         }
+      }// kosal_list_for_each_safe
+
+   }else {
+      PDEBUG("No registered Devices");
+
+   } // if( !kosal_list_is_empty(&g_device_list) )
+
+   if ( driver_info.isregistered ) {
+      pci_unregister_driver(&driver_info.pcidrv);
+      driver_info.isregistered = 0;
+   }
+
+
+   PINFO("<- %s removed.\n", DRV_DESCRIPTION);
+   PTRACEOUT;
+}
+
+
+
+//=============================================================================
+// Name: ccidrv_init
+// Description: Entry point called when the module is loaded
+// Interface: public
+// Inputs: none.
+// Outputs: none.
+// Comments: none.
+//=============================================================================
+static int
+ccidrv_init(void)
+{
+   int ret                          = 0;     // Return code
+
+   PTRACEIN;
+
+   //--------------------
+   // Display the sign-on
+   //--------------------
+   PINFO("Accelerator Abstraction Layer\n");
+   PINFO("-> %s\n",         DRV_DESCRIPTION);
+   PINFO("-> Version %s\n", DRV_VERSION);
+   PINFO("-> License %s\n", DRV_LICENSE);
+   PINFO("-> %s\n",       DRV_COPYRIGHT);
+
+   // Module parameter sanity check
+   if (0 == sriov && 0 != sriov_vf) {
+      PERR("sriov_vf must be enable with sriov\n");
+      return -EINVAL;
+   }
+
+   // Call the framework initialization
+   ret = ccidrv_initDriver(/* Callback */);
+   if( 0 == ret ){
+
+      // Initialize the User mode interface
+      ret = ccidrv_initUMAPI();
+   }
+
+   PTRACEOUT_INT(ret);
+   return ret;
+}
+
+
+//=============================================================================
+// Name: cciv4drv_exit
+// Description: Exit called when module is unloaded
+// Interface: public
+// Inputs: none.
+// Outputs: none.
+// Comments:
+//=============================================================================
+static
+void
+ccidrv_exit(void)
+{
+   // Exit the framework
+   ccidrv_exitUMAPI();
+   ccidrv_exitDriver();
+}
+
+
diff --git a/drivers/fpga/aal/cci/cci_pcie_driver_simulator.c b/drivers/fpga/aal/cci/cci_pcie_driver_simulator.c
new file mode 100644
index 000000000000..e3b79e9e16f0
--- /dev/null
+++ b/drivers/fpga/aal/cci/cci_pcie_driver_simulator.c
@@ -0,0 +1,423 @@
+//******************************************************************************
+// This  file  is  provided  under  a  dual BSD/GPLv2  license.  When using or
+//         redistributing this file, you may do so under either license.
+//
+//                            GPL LICENSE SUMMARY
+//
+//  Copyright(c) 2015-2017, Intel Corporation.
+//
+//  This program  is  free software;  you  can redistribute it  and/or  modify
+//  it  under  the  terms of  version 2 of  the GNU General Public License  as
+//  published by the Free Software Foundation.
+//
+//  This  program  is distributed  in the  hope that it  will  be useful,  but
+//  WITHOUT   ANY   WARRANTY;   without   even  the   implied   warranty    of
+//  MERCHANTABILITY  or  FITNESS  FOR  A  PARTICULAR  PURPOSE.  See  the   GNU
+//  General Public License for more details.
+//
+//  The  full  GNU  General Public License is  included in  this  distribution
+//  in the file called README.GPLV2-LICENSE.TXT.
+//
+//  Contact Information:
+//  Henry Mitchel, henry.mitchel at intel.com
+//  77 Reed Rd., Hudson, MA  01749
+//
+//                                BSD LICENSE
+//
+//  Copyright(c) 2011-2017, Intel Corporation.
+//
+//  Redistribution and  use  in source  and  binary  forms,  with  or  without
+//  modification,  are   permitted  provided  that  the  following  conditions
+//  are met:
+//
+//    * Redistributions  of  source  code  must  retain  the  above  copyright
+//      notice, this list of conditions and the following disclaimer.
+//    * Redistributions in  binary form  must  reproduce  the  above copyright
+//      notice,  this  list of  conditions  and  the  following disclaimer  in
+//      the   documentation   and/or   other   materials   provided  with  the
+//      distribution.
+//    * Neither   the  name   of  Intel  Corporation  nor  the  names  of  its
+//      contributors  may  be  used  to  endorse  or promote  products derived
+//      from this software without specific prior written permission.
+//
+//  THIS  SOFTWARE  IS  PROVIDED  BY  THE  COPYRIGHT HOLDERS  AND CONTRIBUTORS
+//  "AS IS"  AND  ANY  EXPRESS  OR  IMPLIED  WARRANTIES,  INCLUDING,  BUT  NOT
+//  LIMITED  TO, THE  IMPLIED WARRANTIES OF  MERCHANTABILITY  AND FITNESS  FOR
+//  A  PARTICULAR  PURPOSE  ARE  DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT
+//  OWNER OR CONTRIBUTORS BE LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,
+//  SPECIAL,  EXEMPLARY,  OR  CONSEQUENTIAL   DAMAGES  (INCLUDING,   BUT   NOT
+//  LIMITED  TO,  PROCUREMENT  OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF USE,
+//  DATA,  OR PROFITS;  OR BUSINESS INTERRUPTION)  HOWEVER  CAUSED  AND ON ANY
+//  THEORY  OF  LIABILITY,  WHETHER  IN  CONTRACT,  STRICT LIABILITY,  OR TORT
+//  (INCLUDING  NEGLIGENCE  OR OTHERWISE) ARISING  IN ANY WAY  OUT  OF THE USE
+//  OF  THIS  SOFTWARE, EVEN IF ADVISED  OF  THE  POSSIBILITY  OF SUCH DAMAGE.
+//******************************************************************************
+//****************************************************************************
+//        FILE: cci_pcie_driver_simulator.c
+//     CREATED: Oct 14, 2015
+//      AUTHOR: Joseph Grecco, Intel <joe.grecco@intel.com>
+//
+// PURPOSE:   This file contains the implementation of the simulated CCI
+//            device
+// HISTORY:
+// COMMENTS:
+// WHEN:          WHO:     WHAT:
+//****************************************************************************///
+#include "aalsdk/kernel/kosal.h"
+
+#define MODULE_FLAGS CCIPCIE_DBG_MOD
+
+#include "aalsdk/kernel/aalids.h"
+#include "aalsdk/kernel/aalbus.h"
+#include "aalsdk/kernel/ccip_defs.h"
+
+#include "cci_pcie_driver_PIPsession.h"
+
+#include "aalsdk/kernel/ccipdriver.h"
+#include "aalsdk/kernel/iaaldevice.h"
+
+
+#include "ccip_fme.h"
+#include "ccip_port.h"
+#include "cci_pcie_driver_simulator.h"
+#include "ccipdrv-events.h"
+
+
+extern int  ccip_sim_wrt_port_mmio(btVirtAddr);
+extern int  ccip_sim_wrt_fme_mmio(btVirtAddr);
+
+extern int print_sim_fme_device(struct fme_device *);
+extern int print_sim_port_device(struct port_device *);
+
+int cci_create_sim_afu(btVirtAddr,unsigned ,struct aal_device_id*,kosal_list_head *);
+
+
+static
+struct ccip_device * cci_enumerate_simulated_device( btVirtAddr bar0,
+                                                     btVirtAddr bar2,
+                                                     struct aal_device_id *pdevid);
+//=============================================================================
+// nextAFU_addr - Keeps the next available address for new AFUs
+//=============================================================================
+static struct aal_device_addr nextAFU_addr = {
+   .m_bustype   = aal_bustype_Host,
+   { .m_busnum  = 1 },     //
+   .m_devicenum = 0,       //
+   .m_functnum  = 1,       //
+   .m_subdevnum = 0,       // AFU
+   .m_socketnum = 0
+};
+
+
+//=============================================================================
+// Name: cci_sim_alloc_next_afu_addr
+// Description: Allocate the next AFU address
+// Interface: public
+// Returns 0 - success
+// Inputs: none
+// Outputs: none.
+// Comments: Allocates sequential addresses.  This is a hack for simulation
+//           but is adequate.
+//=============================================================================
+struct aal_device_addr
+cci_sim_alloc_next_afu_addr(void)
+{
+   ++(nextAFU_addr.m_devicenum);
+   if( 0 == (nextAFU_addr.m_devicenum &= 0xffff) ) {
+      ++(nextAFU_addr.m_busnum);
+      nextAFU_addr.m_busnum &= 0xffff;
+   }
+   return nextAFU_addr;
+} // cci_alloc_next_afu_addr
+
+
+//=============================================================================
+// Name: cci_sim_discover_devices
+// Description: Performs the functionality of the PCIe OS enumeration functions
+//              for real hardware.
+// Inputs: numdevices - Number of AFUs to "discover".
+//         g_device_list - List head of global device list.
+// Outputs: 0 - success.
+// Comments: none.
+//=============================================================================
+int cci_sim_discover_devices(unsigned numdevices,
+                             kosal_list_head *pg_device_list)
+{
+   struct aal_device_id aalid;
+   btVirtAddr           bar0, bar2        = NULL;
+
+   PVERBOSE("Creating %d simulated CCI devices", numdevices);
+
+   // Loop through and probe each simulated device
+   while(numdevices--){
+      struct ccip_device *pccidev = NULL;
+
+      // Allocate the BAR for the simulated device
+      bar0 = kosal_kzmalloc( CCI_SIM_APERTURE_SIZE );
+      if(NULL == bar0){
+         PERR("Unable to allocate system memory for simulated BAR 0\n");
+         return -EINVAL;
+      }
+
+      // Allocate the BAR for the simulated device
+      bar2 = kosal_kzmalloc( CCI_SIM_APERTURE_SIZE );
+      if(NULL == bar2){
+         PERR("Unable to allocate system memory for simulated BAR 2\n");
+         if(bar0){
+            kosal_kfree(bar0, CCI_SIM_APERTURE_SIZE);
+         }
+         return -EINVAL;
+      }
+
+      // Create Channel AFU for this device
+      aaldevid_addr(aalid) = cci_sim_alloc_next_afu_addr();
+
+      aaldevid_devaddr_bustype(aalid) = aal_bustype_Host;
+
+      // Enumerate the features of the simulated device
+      pccidev = cci_enumerate_simulated_device( bar0,
+                                                bar2,
+                                                &aalid);
+
+      // If all went well record this device on our
+      //  list of devices owned by the driver
+      if(NULL == pccidev){
+         kosal_kfree(bar0, CCI_SIM_APERTURE_SIZE);
+         kosal_kfree(bar2, CCI_SIM_APERTURE_SIZE);
+         continue;
+      }
+
+      kosal_list_add(&(pccidev->m_list), pg_device_list);
+
+   }// end while
+
+   if(kosal_list_is_empty(pg_device_list)){
+      return -EIO;
+   }
+   return 0;
+}
+
+
+//=============================================================================
+// Name: cci_enumerate_simulated_device
+// Description: Called during the device probe to initiate the enumeration of
+//              the device attributes and construct the internal objects.
+// Inputs: pcidev - kernel-provided device pointer.
+//         pcidevid - kernel-provided device id pointer.
+// Returns: 0 = success.
+// Comments:
+//=============================================================================
+static
+struct ccip_device * cci_enumerate_simulated_device( btVirtAddr bar0,
+                                                     btVirtAddr bar2,
+                                                     struct aal_device_id *pdevid)
+{
+
+   struct ccip_device * pccipdev       = NULL;
+
+   int                  res            = 0;
+
+   PTRACEIN;
+
+   // Check arguments
+   ASSERT(bar0);
+   if ( NULL == bar0 ) {
+      PTRACEOUT_INT(-EINVAL);
+      return NULL;
+   }
+   ASSERT(bar2);
+   if ( NULL == bar2 ) {
+      PTRACEOUT_INT(-EINVAL);
+      return NULL;
+    }
+   ASSERT(pdevid);
+   if ( NULL == pdevid ) {
+      PTRACEOUT_INT(-EINVAL);
+      return NULL;
+    }
+
+   // Create the CCI device object
+   pccipdev = create_ccidevice();
+   ASSERT(NULL != pccipdev);
+   if(NULL  == pccipdev ) {
+      return NULL;
+   }
+   ccip_dev_pci_dev(pccipdev) = NULL;
+
+   // Save the Bus:Device:Function of simulated device
+   ccip_dev_pcie_bustype(pccipdev)     = aal_bustype_Host;
+   ccip_dev_pcie_busnum(pccipdev)      = aaldevid_devaddr_busnum(*pdevid);
+   ccip_dev_pcie_devnum(pccipdev)      = aaldevid_devaddr_devnum(*pdevid);
+   ccip_dev_pcie_fcnnum(pccipdev)      = aaldevid_devaddr_fcnnum(*pdevid);
+   ccip_dev_pcie_socketnum(pccipdev)   = aaldevid_devaddr_socketnum(*pdevid);
+
+   // Mark this device as simulated
+   ccip_set_simulated(pccipdev);
+
+   // FME Device initialization
+   //---------------------------
+
+   // Save the FME information in the CCI Device object
+   ccip_fmedev_phys_afu_mmio(pccipdev)    = __PHYS_ADDR_CAST(kosal_virt_to_phys(bar0));
+   ccip_fmedev_len_afu_mmio(pccipdev)     = CCI_SIM_APERTURE_SIZE;
+   ccip_fmedev_kvp_afu_mmio(pccipdev)     = bar0;
+
+   PDEBUG("ccip_fmedev_phys_afu_mmio(pccipdev) : %lx\n", ccip_fmedev_phys_afu_mmio(pccipdev));
+   PDEBUG("ccip_fmedev_kvp_afu_mmio(pccipdev) : %lx\n",(long unsigned int) ccip_fmedev_kvp_afu_mmio(pccipdev));
+   PDEBUG("ccip_fmedev_len_afu_mmio(pccipdev): %zu\n", ccip_fmedev_len_afu_mmio(pccipdev));
+
+   // Now populate the simulated MMIO
+   ccip_sim_wrt_fme_mmio(ccip_fmedev_kvp_afu_mmio(pccipdev));
+
+   // Enumerate the device
+   //  Instantiate internal objects. Objects that represent
+   //  objects that can be allocated through the AALBus are
+   //  constructed around the aaldevice base and are published
+   //  with aalbus.
+   //---------------------------------------------------------
+   //FME region
+   if(0 != ccip_fmedev_kvp_afu_mmio(pccipdev)){
+
+      PINFO(" FME mmio region   \n");
+
+      // Create the FME MMIO device object
+      //   Enumerates the FME feature list
+      //----------------------------------
+      ccip_dev_to_fme_dev(pccipdev) = get_fme_mmio_dev(ccip_fmedev_kvp_afu_mmio(pccipdev) );
+      if ( NULL == pccipdev->m_pfme_dev ) {
+         PERR("Could not allocate memory for FME object\n");
+         res = -ENOMEM;
+         goto ERR;
+      }
+
+      // Instantiate allocatable objects
+      if(!cci_fme_dev_create_AAL_allocatable_objects(pccipdev)){
+         goto ERR;
+      }
+
+      // Creates AAL PR device object
+      if(!cci_create_AAL_PR_allocatable_objects(pccipdev)){
+         goto ERR;
+      }
+
+      // Creates AAL Power device object
+      if(!cci_create_AAL_power_Device(pccipdev)){
+         goto ERR;
+      }
+
+      // print FME MMIO
+      print_sim_fme_device(ccip_dev_to_fme_dev(pccipdev));
+
+   } // End FME region
+
+   // Port Device initialization
+   //---------------------------
+
+   // Save the Port information in the CCI Device object
+
+   ccip_portdev_phys_afu_mmio(pccipdev,0)    = __PHYS_ADDR_CAST(kosal_virt_to_phys(bar2));
+   ccip_portdev_len_afu_mmio(pccipdev,0)     = CCI_SIM_APERTURE_SIZE;
+   ccip_portdev_kvp_afu_mmio(pccipdev,0)     = bar2;
+
+   PDEBUG("ccip_portdev_phys_afu_mmio(pccipdev) : %" PRIxPHYS_ADDR "\n", ccip_portdev_phys_afu_mmio(pccipdev,0));
+   PDEBUG("ccip_portdev_len_afu_mmio(pccipdev): %zu\n", ccip_portdev_len_afu_mmio(pccipdev,0));
+   PDEBUG("ccip_portdev_kvp_afu_mmio(pccipdev) : %p\n", ccip_portdev_kvp_afu_mmio(pccipdev,0));
+   PDEBUG("End of Port Space %p\n", ccip_portdev_kvp_afu_mmio(pccipdev,0) + CCI_SIM_APERTURE_SIZE);
+   // Now populate the simulated Port MMIO
+   ccip_sim_wrt_port_mmio(ccip_portdev_kvp_afu_mmio(pccipdev,0));
+
+   // Enumerate the devices
+   //  Loop through each Port Offset register to determine
+   //  if a Port has been implemented and where its resources are.
+   //  Since this is a simulated device all of the Ports are in the
+   //  ccip_portdev_kvp_afu_mmio() location.  In real hardware the
+   //  resources may reside in different Bars and at different offsets.
+   //  The driver must keep track of all resources it claims so it can
+   //  free them later.
+   //------------------------------------------------------------------
+   {
+      struct fme_device  *pfme_dev  = ccip_dev_to_fme_dev(pccipdev);
+      struct CCIP_FME_HDR *pfme_hdr = ccip_fme_hdr(pfme_dev);
+      struct port_device *pportdev  = NULL;
+      int i=0;
+
+      for(i=0;  0!= pfme_hdr->port_offsets[i].port_imp  ;i++){
+
+         PINFO("***** PORT %d MMIO region @ Bar %d offset %x *****\n",i , pfme_hdr->port_offsets[i].port_bar, pfme_hdr->port_offsets[i].port_offset);
+
+         // Discover and create Port device
+         //   Enumerates the Port feature list, creates the Port object.
+         //   Then add the new port object onto the list
+         //-------------------------------------------------------------
+         pportdev = get_port_device( kosal_virt_to_phys(ccip_portdev_kvp_afu_mmio(pccipdev,0)) + pfme_hdr->port_offsets[i].port_offset,
+                                     ccip_portdev_kvp_afu_mmio(pccipdev,0) + pfme_hdr->port_offsets[i].port_offset,
+                                     ccip_portdev_len_afu_mmio(pccipdev,0));
+         if ( NULL == pportdev ) {
+            PERR("Could not allocate memory for FME object\n");
+            res = -ENOMEM;
+            goto ERR;
+         }
+
+         ccip_set_resource(pccipdev, pfme_hdr->port_offsets[i].port_bar);
+
+         PDEBUG("Created Port Device\n");
+
+         // Point to our parent
+         ccip_port_to_ccidev(pportdev) = pccipdev;
+
+         ccip_dev_to_port_dev(pccipdev,i)  = pportdev;
+
+         // Inherits B:D:F from board
+         ccip_port_bustype(pportdev)        = ccip_dev_pcie_bustype(pccipdev);
+         ccip_port_busnum(pportdev)         = (btUnsigned16bitInt) ccip_dev_pcie_busnum(pccipdev);
+         ccip_port_devnum(pportdev)         = ccip_dev_pcie_devnum(pccipdev);
+         ccip_port_fcnnum(pportdev)         = ccip_dev_pcie_fcnnum(pccipdev);
+         ccip_port_socketnum(pportdev)      = ccip_dev_pcie_socketnum(pccipdev);
+
+         // Log the Port MMIO
+         print_sim_port_device(pportdev);
+
+         PDEBUG("Adding to list\n");
+
+         // Added it to the port list
+         kosal_list_add(&ccip_port_dev_list(pccipdev), &ccip_port_list_head(pportdev));
+
+         // Save the FME parent for this port
+         ccip_port_dev_fme(pportdev) = pfme_dev;
+
+         PDEBUG("Creating Allocatable objects\n");
+
+         // Instantiate allocatable objects including AFUs if present. Port subdevice address is 0 based.
+         if(!cci_port_dev_create_AAL_allocatable_objects(pportdev, i)){
+            goto ERR;
+         }
+      }// End for
+
+   }// end block
+
+   return pccipdev;
+ERR:
+
+   PERR(" -----ERROR -----   \n");
+
+   if( NULL != ccip_fmedev_kvp_afu_mmio(pccipdev)) {
+      if(ccip_dev_to_fme_dev(pccipdev)){
+         ccip_destroy_fme_mmio_dev(ccip_dev_to_fme_dev(pccipdev));
+      }
+      ccip_fmedev_kvp_afu_mmio(pccipdev) = NULL;
+   }
+
+   if( NULL != ccip_portdev_kvp_afu_mmio(pccipdev,0)) {
+      kosal_kfree(ccip_portdev_kvp_afu_mmio(pccipdev,0), ccip_portdev_len_afu_mmio(pccipdev,0) );
+      ccip_portdev_kvp_afu_mmio(pccipdev,0) = NULL;
+   }
+
+   if ( NULL != pccipdev ) {
+      kosal_kfree( pccipdev, sizeof(struct ccip_device) );
+   }
+
+
+   PTRACEOUT_INT(res);
+   return NULL;
+}
+
diff --git a/drivers/fpga/aal/cci/cci_pcie_driver_simulator.h b/drivers/fpga/aal/cci/cci_pcie_driver_simulator.h
new file mode 100644
index 000000000000..084ec968ff2b
--- /dev/null
+++ b/drivers/fpga/aal/cci/cci_pcie_driver_simulator.h
@@ -0,0 +1,102 @@
+//******************************************************************************
+// This  file  is  provided  under  a  dual BSD/GPLv2  license.  When using or
+//         redistributing this file, you may do so under either license.
+//
+//                            GPL LICENSE SUMMARY
+//
+//  Copyright(c) 2011-2017, Intel Corporation.
+//
+//  This program  is  free software;  you  can redistribute it  and/or  modify
+//  it  under  the  terms of  version 2 of  the GNU General Public License  as
+//  published by the Free Software Foundation.
+//
+//  This  program  is distributed  in the  hope that it  will  be useful,  but
+//  WITHOUT   ANY   WARRANTY;   without   even  the   implied   warranty    of
+//  MERCHANTABILITY  or  FITNESS  FOR  A  PARTICULAR  PURPOSE.  See  the   GNU
+//  General Public License for more details.
+//
+//  The  full  GNU  General Public License is  included in  this  distribution
+//  in the file called README.GPLV2-LICENSE.TXT.
+//
+//  Contact Information:
+//  Henry Mitchel, henry.mitchel at intel.com
+//  77 Reed Rd., Hudson, MA  01749
+//
+//                                BSD LICENSE
+//
+//  Copyright(c) 2011-2017, Intel Corporation.
+//
+//  Redistribution and  use  in source  and  binary  forms,  with  or  without
+//  modification,  are   permitted  provided  that  the  following  conditions
+//  are met:
+//
+//    * Redistributions  of  source  code  must  retain  the  above  copyright
+//      notice, this list of conditions and the following disclaimer.
+//    * Redistributions in  binary form  must  reproduce  the  above copyright
+//      notice,  this  list of  conditions  and  the  following disclaimer  in
+//      the   documentation   and/or   other   materials   provided  with  the
+//      distribution.
+//    * Neither   the  name   of  Intel  Corporation  nor  the  names  of  its
+//      contributors  may  be  used  to  endorse  or promote  products derived
+//      from this software without specific prior written permission.
+//
+//  THIS  SOFTWARE  IS  PROVIDED  BY  THE  COPYRIGHT HOLDERS  AND CONTRIBUTORS
+//  "AS IS"  AND  ANY  EXPRESS  OR  IMPLIED  WARRANTIES,  INCLUDING,  BUT  NOT
+//  LIMITED  TO, THE  IMPLIED WARRANTIES OF  MERCHANTABILITY  AND FITNESS  FOR
+//  A  PARTICULAR  PURPOSE  ARE  DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT
+//  OWNER OR CONTRIBUTORS BE LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,
+//  SPECIAL,  EXEMPLARY,  OR  CONSEQUENTIAL   DAMAGES  (INCLUDING,   BUT   NOT
+//  LIMITED  TO,  PROCUREMENT  OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF USE,
+//  DATA,  OR PROFITS;  OR BUSINESS INTERRUPTION)  HOWEVER  CAUSED  AND ON ANY
+//  THEORY  OF  LIABILITY,  WHETHER  IN  CONTRACT,  STRICT LIABILITY,  OR TORT
+//  (INCLUDING  NEGLIGENCE  OR OTHERWISE) ARISING  IN ANY WAY  OUT  OF THE USE
+//  OF  THIS  SOFTWARE, EVEN IF ADVISED  OF  THE  POSSIBILITY  OF SUCH DAMAGE.
+//******************************************************************************
+//****************************************************************************
+//        FILE: cciv4_simulator.h
+//     CREATED: Jul 27, 2015
+//      AUTHOR: Joseph Grecco <joe.grecco@intel.com>
+//
+// PURPOSE:   Definitions for CCIv3 Simulator
+// HISTORY:
+// COMMENTS:
+// WHEN:          WHO:     WHAT:
+//****************************************************************************///
+#ifndef __CCI_PCIE_DRIVER_SIMULATOR_H__
+#define __CCI_PCIE_DRIVER_SIMULATOR_H__
+
+#include "aalsdk/kernel/kosal.h"
+
+#define CCI_SIM_APERTURE_SIZE     (  0x120000  )       /// Size of device CSR region, in bytes
+
+// Using NLB AFU ID for Mode 0 NLB
+#ifndef BDX_SIM
+   #define BDX_SIM 0
+#endif
+#ifndef SKX_SIM
+   #define SKX_SIM 1
+#endif
+
+// FWIW, I think the High and Low are reversed, here.
+#if BDX_SIM
+   #define CCI_SIM_AFUIDH         ( 0xC000C9660D824272L )
+   #define CCI_SIM_AFUIDL         ( 0x9AEFFE5F84570612L )
+#elif SKX_SIM
+   #define CCI_SIM_AFUIDH         ( 0xD8424DC4A4A3C413L )
+   #define CCI_SIM_AFUIDL         ( 0xF89E433683F9040BL )
+#endif /* BDX */
+
+#define CCI_SIM_MAFUIDH           ( 0x6d0b2b05111c460eL )
+#define CCI_SIM_MAFUIDL           ( 0xaaf163c9f423dc1dL )
+
+#define CCI_SIM_CMAFUIDH          ( 0xf05c0786e3e64b43L )
+#define CCI_SIM_CMAFUIDL          ( 0x94d78e96d28152c6L )
+
+//
+// Prototypes
+int cci_sim_discover_devices(unsigned  numdevices,
+                             kosal_list_head *g_device_list);
+
+
+
+#endif /* CCI_PCIE_DRIVER_SIMULATOR_H_ */
diff --git a/drivers/fpga/aal/cci/cci_pcie_driver_umapi.h b/drivers/fpga/aal/cci/cci_pcie_driver_umapi.h
new file mode 100644
index 000000000000..682425aa142c
--- /dev/null
+++ b/drivers/fpga/aal/cci/cci_pcie_driver_umapi.h
@@ -0,0 +1,140 @@
+//******************************************************************************
+// This  file  is  provided  under  a  dual BSD/GPLv2  license.  When using or
+//         redistributing this file, you may do so under either license.
+//
+//                            GPL LICENSE SUMMARY
+//
+//  Copyright(c) 2015-2017, Intel Corporation.
+//
+//  This program  is  free software;  you  can redistribute it  and/or  modify
+//  it  under  the  terms of  version 2 of  the GNU General Public License  as
+//  published by the Free Software Foundation.
+//
+//  This  program  is distributed  in the  hope that it  will  be useful,  but
+//  WITHOUT   ANY   WARRANTY;   without   even  the   implied   warranty    of
+//  MERCHANTABILITY  or  FITNESS  FOR  A  PARTICULAR  PURPOSE.  See  the   GNU
+//  General Public License for more details.
+//
+//  The  full  GNU  General Public License is  included in  this  distribution
+//  in the file called README.GPLV2-LICENSE.TXT.
+//
+//  Contact Information:
+//  Henry Mitchel, henry.mitchel at intel.com
+//  77 Reed Rd., Hudson, MA  01749
+//
+//                                BSD LICENSE
+//
+//  Copyright(c) 2015-2017, Intel Corporation.
+//
+//  Redistribution and  use  in source  and  binary  forms,  with  or  without
+//  modification,  are   permitted  provided  that  the  following  conditions
+//  are met:
+//
+//    * Redistributions  of  source  code  must  retain  the  above  copyright
+//      notice, this list of conditions and the following disclaimer.
+//    * Redistributions in  binary form  must  reproduce  the  above copyright
+//      notice,  this  list of  conditions  and  the  following disclaimer  in
+//      the   documentation   and/or   other   materials   provided  with  the
+//      distribution.
+//    * Neither   the  name   of  Intel  Corporation  nor  the  names  of  its
+//      contributors  may  be  used  to  endorse  or promote  products derived
+//      from this software without specific prior written permission.
+//
+//  THIS  SOFTWARE  IS  PROVIDED  BY  THE  COPYRIGHT HOLDERS  AND CONTRIBUTORS
+//  "AS IS"  AND  ANY  EXPRESS  OR  IMPLIED  WARRANTIES,  INCLUDING,  BUT  NOT
+//  LIMITED  TO, THE  IMPLIED WARRANTIES OF  MERCHANTABILITY  AND FITNESS  FOR
+//  A  PARTICULAR  PURPOSE  ARE  DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT
+//  OWNER OR CONTRIBUTORS BE LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,
+//  SPECIAL,  EXEMPLARY,  OR  CONSEQUENTIAL   DAMAGES  (INCLUDING,   BUT   NOT
+//  LIMITED  TO,  PROCUREMENT  OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF USE,
+//  DATA,  OR PROFITS;  OR BUSINESS INTERRUPTION)  HOWEVER  CAUSED  AND ON ANY
+//  THEORY  OF  LIABILITY,  WHETHER  IN  CONTRACT,  STRICT LIABILITY,  OR TORT
+//  (INCLUDING  NEGLIGENCE  OR OTHERWISE) ARISING  IN ANY WAY  OUT  OF THE USE
+//  OF  THIS  SOFTWARE, EVEN IF ADVISED  OF  THE  POSSIBILITY  OF SUCH DAMAGE.
+//******************************************************************************
+//****************************************************************************
+//        FILE: cci_pcie_driver_umapi.h
+//     CREATED: 02/19/2016
+//      AUTHOR: Joseph Grecco
+//
+//          AAL FPGA device driver for CCI protocol compliant devices.
+//           User Mode Interface for the AAL CCI device driver
+// HISTORY:
+// COMMENTS:
+// WHEN:          WHO:     WHAT:
+// 10/20/2015     JG       Initial version started
+//****************************************************************************
+#ifndef __AALKERNEL_AAL_PCIE_DRIVER_UMAPI_H__
+#define __AALKERNEL_AAL_PCIE_DRIVER_UMAPI_H__
+#include "aalsdk/kernel/kosal.h"
+#include "aalsdk/kernel/aalbus.h"
+#include "aalsdk/kernel/ccipdriver.h"
+
+#if 0
+#define DEV_NAME          "aalui"
+
+#ifndef DRV_VERSION
+# define DRV_VERSION      "EXPERIMENTAL VERSION"
+#endif
+
+#define AALUI_DRV_MAJVERSION     (0x00000001)
+#define AALUI_DRV_MINVERSION     (0x00000000)
+#define AALUI_DRV_RELEASE        (0x00000000)
+
+// TODO THESE NEED PROPER DEFINITION IN IDS
+#define  AALUI_DRV_INTC          (0x0000000000002000)
+#endif
+//=============================================================================
+// Name: um_APIdriver
+// Description: CCI User Mode API Class
+//=============================================================================
+struct um_driver {
+
+   // List of current sessions
+   // this is the head, and is linked with ccidrv_session->m_sessions
+   kosal_semaphore          m_qsem;
+   kosal_list_head          m_sessq;
+
+   // Private semaphore
+   kosal_semaphore          m_sem;
+
+   /* list of allocated wsids */
+   kosal_semaphore          wsid_list_sem;
+   kosal_list_head          wsid_list_head;
+};
+
+//=============================================================================
+// Name: ccidrv_session
+// Description: Session structure holds state and other context for a user
+//              session with the device subsystem.
+//=============================================================================
+struct ccidrv_session {
+   // PIP to UI driver interface
+   struct aal_uiapi           m_msgHandler;
+
+   // Owning driver module (UDDI in this case)
+   struct ui_driver          *m_aaldriver;
+
+   // Head of list of devices (struct aaldev_owner->m_devicelist) owned by this session
+   kosal_list_head            m_devicelist;
+
+   // Wait queue used for poll
+   kosal_poll_object          m_waitq;
+
+   // Private semaphore
+   kosal_semaphore            m_sem;
+
+   // Link to global UDDI session list.  head is ui_driver->m_sessq.
+   kosal_list_head            m_sessions;
+
+   // Event queue
+   aal_queue_t                m_eventq;
+
+   // Pid of process associated with this session
+   btPID                      m_pid;
+
+};
+
+
+#endif // __AALKERNEL_AAL_PCIE_DRIVER_UMAPI_H__
+
diff --git a/drivers/fpga/aal/cci/cci_pcie_driver_umapi_common.c b/drivers/fpga/aal/cci/cci_pcie_driver_umapi_common.c
new file mode 100644
index 000000000000..b057f658c5c1
--- /dev/null
+++ b/drivers/fpga/aal/cci/cci_pcie_driver_umapi_common.c
@@ -0,0 +1,1138 @@
+//******************************************************************************
+// This  file  is  provided  under  a  dual BSD/GPLv2  license.  When using or
+//         redistributing this file, you may do so under either license.
+//
+//                            GPL LICENSE SUMMARY
+//
+//  Copyright(c) 2015-2017, Intel Corporation.
+//
+//  This program  is  free software;  you  can redistribute it  and/or  modify
+//  it  under  the  terms of  version 2 of  the GNU General Public License  as
+//  published by the Free Software Foundation.
+//
+//  This  program  is distributed  in the  hope that it  will  be useful,  but
+//  WITHOUT   ANY   WARRANTY;   without   even  the   implied   warranty    of
+//  MERCHANTABILITY  or  FITNESS  FOR  A  PARTICULAR  PURPOSE.  See  the   GNU
+//  General Public License for more details.
+//
+//  The  full  GNU  General Public License is  included in  this  distribution
+//  in the file called README.GPLV2-LICENSE.TXT.
+//
+//  Contact Information:
+//  Henry Mitchel, henry.mitchel at intel.com
+//  77 Reed Rd., Hudson, MA  01749
+//
+//                                BSD LICENSE
+//
+//  Copyright(c) 2015-2017, Intel Corporation.
+//
+//  Redistribution and  use  in source  and  binary  forms,  with  or  without
+//  modification,  are   permitted  provided  that  the  following  conditions
+//  are met:
+//
+//    * Redistributions  of  source  code  must  retain  the  above  copyright
+//      notice, this list of conditions and the following disclaimer.
+//    * Redistributions in  binary form  must  reproduce  the  above copyright
+//      notice,  this  list of  conditions  and  the  following disclaimer  in
+//      the   documentation   and/or   other   materials   provided  with  the
+//      distribution.
+//    * Neither   the  name   of  Intel  Corporation  nor  the  names  of  its
+//      contributors  may  be  used  to  endorse  or promote  products derived
+//      from this software without specific prior written permission.
+//
+//  THIS  SOFTWARE  IS  PROVIDED  BY  THE  COPYRIGHT HOLDERS  AND CONTRIBUTORS
+//  "AS IS"  AND  ANY  EXPRESS  OR  IMPLIED  WARRANTIES,  INCLUDING,  BUT  NOT
+//  LIMITED  TO, THE  IMPLIED WARRANTIES OF  MERCHANTABILITY  AND FITNESS  FOR
+//  A  PARTICULAR  PURPOSE  ARE  DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT
+//  OWNER OR CONTRIBUTORS BE LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,
+//  SPECIAL,  EXEMPLARY,  OR  CONSEQUENTIAL   DAMAGES  (INCLUDING,   BUT   NOT
+//  LIMITED  TO,  PROCUREMENT  OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF USE,
+//  DATA,  OR PROFITS;  OR BUSINESS INTERRUPTION)  HOWEVER  CAUSED  AND ON ANY
+//  THEORY  OF  LIABILITY,  WHETHER  IN  CONTRACT,  STRICT LIABILITY,  OR TORT
+//  (INCLUDING  NEGLIGENCE  OR OTHERWISE) ARISING  IN ANY WAY  OUT  OF THE USE
+//  OF  THIS  SOFTWARE, EVEN IF ADVISED  OF  THE  POSSIBILITY  OF SUCH DAMAGE.
+//******************************************************************************
+//****************************************************************************
+//        FILE: cci_pcie_driver_umapi_common.c
+//     CREATED: 10/23/2015
+//      AUTHOR: Joseph Grecco, Intel Corporation
+//
+// PURPOSE:  This file contains the OS independent code for the
+//           Accelerator Abstraction Layer (AAL)
+//           User Mode Interface for the AAL CCI device driver
+// HISTORY:
+// COMMENTS:
+// WHEN:          WHO:     WHAT:
+// 10/203/2015     JG       Initial version started
+//****************************************************************************
+#include "aalsdk/kernel/kosal.h"
+
+#define MODULE_FLAGS UIDRV_DBG_MOD
+
+
+#include "cci_pcie_driver_umapi.h"
+#include "ccipdrv-events.h"
+
+// Prototypes
+struct ccidrv_session * ccidrv_session_create(btPID );
+btInt ccidrv_session_destroy(struct ccidrv_session * );
+btInt ccidrv_messageHandler( struct ccidrv_session  *,
+                             btUnsigned32bitInt     ,
+                             struct ccipui_ioctlreq *,
+                             btWSSize               ,
+                             struct ccipui_ioctlreq *,
+                             btWSSize              *);
+
+btInt ccidrv_sendevent( struct aaldev_ownerSession *,
+                        struct aal_q_item *);
+
+btInt ccidrv_flush_eventqueue(  struct ccidrv_session *psess);
+
+btInt process_send_message(struct ccidrv_session  *,
+                           struct ccipui_ioctlreq *,
+                           struct ccipui_ioctlreq *,
+                           btWSSize               *);
+
+btInt process_bind_request( struct ccidrv_session  *psess,
+                            struct ccipui_ioctlreq *preq);
+btInt ccidrv_marshal_upstream_message( struct ccipui_ioctlreq *preq,
+                                       struct aal_q_item     *pqitem,
+                                       struct ccipui_ioctlreq *resp,
+                                       btWSSize              *pOutbufsize);
+struct aal_wsid *ccidrv_valwsid(btWSID);
+
+extern struct um_driver umDriver;
+
+///////////////////////////////////////////////////////////////////////////////
+///////////////////////////////////////////////////////////////////////////////
+////////////////////                                     //////////////////////
+/////////////////              SESSION METHODS              ///////////////////
+////////////////////                                     //////////////////////
+///////////////////////////////////////////////////////////////////////////////
+///////////////////////////////////////////////////////////////////////////////
+//=============================================================================
+//=============================================================================
+
+//=============================================================================
+// Name: ccidrv_session_create
+// Description: Create a new application session
+// Interface: public
+// Inputs: pid - ID of process
+// Outputs: none.
+// Comments: The process ID is used to identify the session uniquely.
+//           The session is a context that hold information related to the
+//           application process. It holds things like the list of devices
+//           allocated by this process, the event queue used to communicate
+//           back to the application and the signaling object for waking the
+//           process.
+//=============================================================================
+struct ccidrv_session * ccidrv_session_create(btPID pid)
+{
+   // Allocate the Session object
+   struct ccidrv_session * psession = (struct ccidrv_session * )kosal_kmalloc(sizeof(struct ccidrv_session));
+   if(unlikely (psession == NULL) ){
+      PERR(": failed to malloc session object\n");
+      return NULL;
+   }
+
+   // Initialize session's lists, queues and sync objects
+   //   m_sessions is used to place this session on the list of sessions
+   //   held by the driver.
+   kosal_list_init(&psession->m_sessions);
+
+   //  m_devicelist is the root of the list of devices currently held by
+   //  this session.
+
+   kosal_list_init(&psession->m_devicelist);
+
+   // m_waitq is used for asynchronous signaling (see poll)
+   kosal_init_waitqueue_head(&psession->m_waitq);
+
+   // m_eventq holds events waiting to be delivered
+   aal_queue_init(&psession->m_eventq);
+
+   kosal_mutex_init(&psession->m_sem);
+
+   // Record the process that opened us
+   psession->m_pid = pid;
+
+   return psession;
+}
+
+//=============================================================================
+// Name: ccidrv_session_destroy
+// Description: Destroy the application session
+// Interface: public
+// Inputs: psess - session to detroy
+// Outputs: none.
+// Comments: responsible for flushing all queues and canceling any outstanding
+//           transactions.  All devices are freed.
+//=============================================================================
+int ccidrv_session_destroy(struct ccidrv_session * psess)
+{
+   // Variables for walking the device list
+    struct aaldev_owner  *devowner_itr=NULL, *tmp=NULL;
+    struct aal_device *pdev=NULL;
+    struct aaldev_ownerSession *ownerSessp = NULL;
+
+    PVERBOSE("Destroying session %p\n",psess);
+
+    // Protect the critical section
+    if (kosal_sem_get_krnl_alertable(&psess->m_sem))
+    {
+       PERR("Failed to claim semaphore.  FATAL ERROR!\n");
+       return -EIO;
+    }
+
+    // Flush the event queue and wake anything waiting
+    ccidrv_flush_eventqueue(psess);
+    kosal_wake_up_interruptible (&psess->m_waitq);
+
+    PVERBOSE("Closing UI channel\n");
+
+    // Walk through the list of ./prepdevices and free them
+    kosal_list_for_each_entry_safe(devowner_itr, tmp, &psess->m_devicelist, m_devicelist, struct aaldev_owner) {
+
+       PVERBOSE("Walking device list %p %p \n",psess, devowner_itr);
+
+       // devowner_itr has the aaldev_owner object. The device owner object
+       //  holds the context about this ownership relationship. E.g., owner PID, the device itself etc..
+       pdev = devowner_itr->m_device;  // Get the device to free
+
+       // Device owner session is the instance of the interfaces
+       // for this device/session binding
+       ownerSessp = dev_OwnerSession(pdev,psess->m_pid);
+
+       // Unbind the PIP from the session. This gives the driver a chance to cleanup
+       //  the hardware if necessary
+       if(unlikely(!aaldev_pipmsgHandlerp(pdev)->unBindSession( ownerSessp ))){
+          PERR("uid_errnumCouldNotUnBindPipInterface\n");
+
+       }
+
+       // Update the ownerslist
+       if(unlikely( dev_removeOwner( pdev,
+                                     psess->m_pid) != 1 )){
+          PERR("Failed to remove owner\n");
+       }
+
+    } // end kosal_list_for_each_entry_safe
+
+    // Remove from the UDDI session list
+    if (kosal_sem_get_krnl_alertable( &umDriver.m_qsem)){
+       PERR("Failed to claim semaphore.  FATAL ERROR!\n");
+       return -EIO;
+    }
+    kosal_list_del(&psess->m_sessions);
+    kosal_sem_put( &umDriver.m_qsem);
+
+    kosal_sem_put(&psess->m_sem);
+    kosal_kfree(psess, sizeof(struct ccidrv_session));
+
+    PVERBOSE("done\n");
+    return 0;
+}
+
+///////////////////////////////////////////////////////////////////////////////
+///////////////////////////////////////////////////////////////////////////////
+////////////////////                                     //////////////////////
+/////////////////        MESSAGE PROCESSING METHODS         ///////////////////
+////////////////////                                     //////////////////////
+///////////////////////////////////////////////////////////////////////////////
+///////////////////////////////////////////////////////////////////////////////
+//=============================================================================
+//=============================================================================
+
+//=============================================================================
+// Name: ccidrv_messageHandler
+// Description: Implements the OS independent message handler.
+// Interface: public
+// Inputs: psess - CCI Driver session
+//         cmd - Command number
+//         preq - Pointer to Request (input buffer)
+//         InbufSize - Size of input buffer
+//         presp - Pointer to response (output buffer)
+//         pOutbufSize - Pointer to output buffer size
+// Outputs: number of bytes in payload to return
+// Returns: status code: 0 == success
+// Comments: This function is responsible for making sure the response header
+//           is updated. E.g., Just returning a non-zero OutputBufsize does
+//           not update the response header size field.
+//           This is because the AALUID_IOCTL_GETMSG_DESC sets the size field
+//           in the header but does NOT return any payload.
+//=============================================================================
+btInt
+ccidrv_messageHandler( struct ccidrv_session  *psess,
+                       btUnsigned32bitInt      cmd,
+                       struct ccipui_ioctlreq *preq,
+                       btWSSize                InbufSize,
+                       struct ccipui_ioctlreq *presp,
+                       btWSSize               *pOutbufSize)
+{
+
+   // Variables used in the Device Allocate Messages
+   struct aal_q_item *pqitem = NULL; // Generic request queue item
+
+   // response buffer size (will be used below)
+   btWSSize OutbufSize = 0;
+
+#if 1
+# define UIDRV_IOCTL_CASE(x) case x : PDEBUG("%s\n", #x);
+#else
+# define UIDRV_IOCTL_CASE(x) case x :
+#endif
+
+   PTRACEIN;
+
+   UNREFERENCED_PARAMETER(InbufSize);
+
+   ASSERT(NULL != presp);
+   ASSERT(NULL != pOutbufSize);
+   if ( presp == NULL ) return -EINVAL;
+   if ( pOutbufSize == NULL ) return -EINVAL;
+
+   // Save the response buffer size
+   OutbufSize = *pOutbufSize;
+
+   // Assume no payload to return
+   *pOutbufSize = 0;
+
+   // Process the message
+   switch ( cmd ) {
+
+      // Get next queued message descriptor
+      // Returns infromation about teh upstream
+      //  message on the queue without returning the actual message
+      //--------------------------------------
+      UIDRV_IOCTL_CASE(AALUID_IOCTL_GETMSG_DESC) {
+         // Make sure there is a message to be had
+         if ( _aal_q_empty(&psess->m_eventq) ) {
+            PTRACEOUT_INT(-EAGAIN);
+            return -EAGAIN;
+         }
+
+         // Peek the head of the message queue
+         pqitem = _aal_q_peek(&psess->m_eventq);
+         if ( NULL == pqitem ) {
+            PERR("Corrupt event queue\n");
+            PTRACEOUT_INT(-EFAULT);
+            return -EFAULT;
+         }
+
+         // Return the type and total size of the message that will be returned
+         //  but no paylod is returned so leave *pOutbufSize = 0
+         presp->id   = (uid_msgIDs_e)QI_QID(pqitem);
+         presp->size = QI_LEN(pqitem);
+
+         PVERBOSE("Getting Message Decriptor - size = %" PRIu64 "\n", presp->size);
+
+         PTRACEOUT_INT(0);
+      } return 0; // case AALUID_IOCTL_GETMSG_DESC:
+
+
+      // Get the next message off of the queue
+      // returns a copy of the message and moves the item to
+      // the pending queue
+      //----------------------------------------------------
+      UIDRV_IOCTL_CASE(AALUID_IOCTL_GETMSG) {
+         // Make sure there is a message to be had
+         if ( _aal_q_empty(&psess->m_eventq) ) {
+            PERR("No Message available\n");
+            PTRACEOUT_INT(-EAGAIN);
+            return -EAGAIN;
+         }
+
+         //------------------------
+         // Get the request message
+         //------------------------
+         pqitem = _aal_q_dequeue(&psess->m_eventq);
+         if ( NULL == pqitem ) {
+            PERR("Invalid or corrupted request\n");
+            PTRACEOUT_INT(-EFAULT);
+            return -EFAULT;
+         }
+
+         // Process the request.
+         //   Function will update response header and pOutbufSize, Restore the
+         //   value of pOutBufSize
+         *pOutbufSize = OutbufSize;
+         return ccidrv_marshal_upstream_message(preq, pqitem, presp, pOutbufSize);
+
+      } break; // case  AALUID_IOCTL_GETMSG:
+
+
+      // Send the message to the device or PIP (SW driver)
+      //-------------------------------------------------
+      UIDRV_IOCTL_CASE(AALUID_IOCTL_SENDMSG) {
+         // Process the request. Function will update response header and pOutbufSize
+         *pOutbufSize = OutbufSize;
+         return process_send_message(psess, preq, presp, pOutbufSize);
+      } break;
+
+      // Process Bind device
+      //--------------------
+      UIDRV_IOCTL_CASE(AALUID_IOCTL_BINDDEV) {
+         // Process the request. Function will update response header and pOutbufSize
+         return process_bind_request(psess, preq);
+      } break;
+
+      // Activate device - This is a framework command that
+      // causes a device to "appear" in to the system
+      UIDRV_IOCTL_CASE(AALUID_IOCTL_ACTIVATEDEV) {
+         PERR("TODO\n");
+      } break;
+
+      // Deactivate device - This is a framework command that
+      // causes a device to be removed from the system
+      UIDRV_IOCTL_CASE(AALUID_IOCTL_DEACTIVATEDEV) {
+         PERR("TODO\n");
+      } break;
+
+      default : {
+         PERR("Invalid IOCTL = 0x%x\n", cmd);
+      } break;
+   } //  switch (cmd)
+
+   PTRACEOUT_INT(-1);
+   return -1;
+}
+
+//=============================================================================
+// Name: process_send_message
+// Description: Process a send request
+// Interface: public
+// Inputs: psess - session
+//         preq - request header
+// Outputs: pOutbufSize must be set to size of payload to return or zero if none
+// Comments:
+//=============================================================================
+btInt
+process_send_message(struct ccidrv_session  *psess,
+                     struct ccipui_ioctlreq *preq,
+                     struct ccipui_ioctlreq *presp,
+                     btWSSize               *pOutbufSize)
+{
+   btInt                              ret = 0;
+   struct aal_device                 *pdev;
+   struct aaldev_ownerSession        *ownSessp;
+   struct aal_pipmessage              pipMessage;
+   ui_shutdownreason_e                shutdown_reason;
+   btTime                             timeleft;
+
+//   btWSSize                             messagesize;
+
+#if 1
+# define UIDRV_PROCESS_SEND_MESSAGE_CASE(x) case x : PDEBUG("%s\n", #x);
+#else
+# define UIDRV_PROCESS_SEND_MESSAGE_CASE(x) case x :
+#endif
+
+   PTRACEIN;
+   ASSERT(NULL != psess);
+   ASSERT(NULL != preq);
+
+   if( (NULL == psess) || (NULL == preq)) {
+      PERR("Invalid Input parameter \n");
+      ret = -EINVAL;
+      return ret ;
+   }
+
+   // Process the request copying in remaining request arguments as appropriate
+   //--------------------------------------------------------------------------
+   switch ( preq->id ) {
+
+      // Send a message to the AFU via the PIP message handler
+      //------------------------------------------------------
+      UIDRV_PROCESS_SEND_MESSAGE_CASE(reqid_UID_SendAFU) {
+         // Get the handle and validate
+         pdev = aaldev_handle_to_devp(preq->handle);
+         if ( unlikely(NULL == pdev) ) {
+            PERR("Invalid device handle %p returned %p\n", preq->handle, pdev);
+            ret = -EINVAL;
+            PTRACEOUT_INT(ret);
+            return ret;
+         }
+
+
+         // Get the ownerSession for this device - The ownerSession is
+         //  an object that holds the state of a session between a device
+         //  and a particular process. Since a shared device may be "owned"
+         //  by multiple processes simultaneously, the device maintains a
+         //  a list of ownerSessions it is currently a member of.
+         //----------------------------------------------------------------
+         //
+         // Get ownerSession for this pid on the device
+         //
+         ownSessp = dev_OwnerSession(pdev,psess->m_pid);
+         if ( NULL == ownSessp ) {
+            PERR("Not owner or no message handler during Process Send Message.\n");
+            ret = -EACCES;
+            PTRACEOUT_INT(ret);
+            return ret;
+         }
+         PDEBUG("Got owner %p\n", ownSessp);
+
+         // Wrap the message and transaction identification
+         //  pipMessage is a generic message wrapper for all
+         //  PIP message handlers
+         pipMessage.m_message       = aalui_ioctlPayload(preq);
+         pipMessage.m_response      = aalui_ioctlPayload(presp);
+         pipMessage.m_respbufSize   = *pOutbufSize;
+         pipMessage.m_tranID        = preq->tranID;
+         pipMessage.m_context       = preq->context;
+         pipMessage.m_errcode       = uid_errnumOK;
+
+         // Send the message on to the device specific command handler.
+         //  This macro resolves to calling the low level, device specific, command
+         //  handler called the Physical Interface Protocol (PIP).  This enabled devices
+         //  served by this driver have custom low level drivers.
+         ret = aalsess_pipSendMessage(ownSessp)(ownSessp, &pipMessage);
+
+         // If there is data to return the size of the response payload
+         //   as long as it will fit
+         if(pipMessage.m_respbufSize <= *pOutbufSize ){
+            *pOutbufSize = pipMessage.m_respbufSize;
+         }else{
+            *pOutbufSize =0;
+         }
+
+         // It is the responsibility of this function to update the
+         //   response header as the low-level driver (PIP) does not
+         //   see the message header.
+         presp->size             = *pOutbufSize;
+         presp->errcode          = pipMessage.m_errcode;
+
+         PTRACEOUT_INT(ret);
+      } return ret; // case reqid_UID_SendAFU
+
+      // Shutdown the driver for this process
+      //-------------------------------------
+      UIDRV_PROCESS_SEND_MESSAGE_CASE(reqid_UID_Shutdown) {
+         // Create shutdown  request object
+         struct ccipdrv_event_afu_response_event *newreq;
+
+         shutdown_reason =((struct aalui_Shutdown*) aalui_ioctlPayload(preq))->m_reason;
+
+         // Assume kernel shutdown takes zero time for now so return original
+         //   timeout value in event which indicates how much time as actually
+         //   used to shutdown (timeout-amount used(0) = timeleft
+         timeleft = ((struct aalui_Shutdown*)aalui_ioctlPayload(preq))->m_timeout;
+
+         PDEBUG("Received a shutdown ioctl reason %d\n", shutdown_reason);
+         newreq = ccipdrv_event_shutdown_event_create( shutdown_reason,
+                                                       timeleft,
+                                                      &preq->tranID,
+                                                       preq->context,
+                                                       uid_errnumOK);
+         ASSERT(NULL != newreq);
+         if ( NULL == newreq ) {
+            ret = -ENOMEM;
+            PTRACEOUT_INT(ret);
+            return ret;
+         }
+
+         // Enqueue the shutdown event
+         _aal_q_enqueue(ui_evtp_afuresponse_to_qip(newreq), &psess->m_eventq);
+
+         // Unblock select() calls.
+         kosal_wake_up_interruptible( &psess->m_waitq);
+
+         *pOutbufSize =0;
+      } break; // case reqid_UID_Shutdown
+
+      default : {
+         PERR("Unrecognized send message option %d\n", preq->id);
+         PTRACEOUT_INT(-EINVAL);
+         *pOutbufSize =0;
+      } return -EINVAL;
+
+   } // switch (preq->id)
+
+   PTRACEOUT_INT(0);
+   return 0;
+} // process_send_message
+
+
+
+//=============================================================================
+// Name: process_bind_request
+// Description: Process a bind request
+// Interface: public
+// Inputs: psess - session
+//         preq - request headers
+//         arg - original user input args
+// Outputs: none.
+// Comments: This function process the session bind and unbind requests.
+//           Basically Bind/Unbind are similar to Open/Close in a traditional
+//           character driver. Unlike a traditional driver we do not use device
+//           nodes to represent the
+//=============================================================================
+btInt
+process_bind_request(struct ccidrv_session  *psess,
+                     struct ccipui_ioctlreq *preq)
+{
+   struct aal_device                            *pdev         = NULL;
+   struct ccipdrv_event_afu_response_event      *bindcmplt    = NULL;
+   struct ccipdrv_event_afu_response_event      *unbindcmplt  = NULL;
+   struct ccipdrv_DeviceAttributes               bindevt      = {0};
+   struct aaldev_ownerSession                   *ownerSessp   = NULL;
+   btInt                                         ret          = 0;
+
+#if 1
+# define UIDRV_PROCESS_BIND_REQUEST_CASE(x) case x : PDEBUG("%s\n", #x);
+#else
+# define UIDRV_PROCESS_BIND_REQUEST_CASE(x) case x :
+#endif
+
+   ASSERT(NULL != psess);
+   ASSERT(NULL != preq);
+
+   if( (NULL == psess) || (NULL == preq)) {
+      PERR("Invalid Input parameter \n");
+      ret = -EINVAL;
+      return ret ;
+   }
+
+   switch ( preq->id ) {
+      //--------------------
+      //Process bind request
+      //--------------------
+      UIDRV_PROCESS_BIND_REQUEST_CASE(reqid_UID_Bind) {
+         // Get the device from the handle and validate
+         pdev = aaldev_handle_to_devp(preq->handle);
+         ASSERT(NULL != pdev);
+         if ( unlikely( NULL == pdev ) ) {
+            PERR("Invalid device handle %p\n", preq->handle);
+            ret = -EINVAL;
+            PTRACEOUT_INT(ret);
+            return ret;
+         }
+
+         // Make sure the device has a PIP bound to it
+         if ( unlikely( NULL == aaldev_pipp(pdev) ) ) {
+            PERR("uid_errnumDeviceHasNoPIPAssigned\n");
+            // Create error event
+            bindcmplt = ccipdrv_event_bindcmplt_create(NULL, NULL, uid_errnumDeviceHasNoPIPAssigned, preq);
+            goto BIND_DONE;
+         }
+
+         // Get the ownerSession for this device - The ownerSession is
+         //  an object that holds the state of a session between a device
+         //  and a particular process. Since a shared device may be "owned"
+         //  by multiple processes simultaneously, the device maintains a
+         //  a list of ownerSessions it is currently a member of.
+         ownerSessp = dev_OwnerSession(pdev, psess->m_pid);
+         if ( NULL == ownerSessp ) {
+            PERR("Process not owner of this device.\n");
+            // Create error event
+            bindcmplt = ccipdrv_event_bindcmplt_create(NULL, NULL, uid_errnumNotDeviceOwner, preq);
+            goto BIND_DONE;
+         }
+
+         // Set the owner session - Through the owner session
+         //  the system can always get to the device (downstream)
+         //  and the UIdrv session (upstream).
+         ownerSessp->m_device   = pdev;                  // Device
+         ownerSessp->m_UIHandle = psess;                 // This session
+         ownerSessp->m_ownerContext =  *((btVirtAddr*)preq->payload);     // Used by AIA for routing
+
+         PDEBUG("Owner Context %p\n",  *((btVirtAddr*)preq->payload));
+
+         //---------------------------------------------------
+         // Bind the PIP to the session
+         //   Allows the PIP to do anything it needs to record
+         //   the presence of this session.
+         //---------------------------------------------------
+         if ( unlikely( !aaldev_pipmsgHandlerp(pdev)->bindSession(ownerSessp) ) ) {
+            PERR("uid_errnumCouldNotBindPipInterface\n");
+            // Create error event
+            bindcmplt = ccipdrv_event_bindcmplt_create(NULL, NULL, uid_errnumCouldNotBindPipInterface, preq);
+            goto BIND_DONE;
+         }
+         //----------------------------------------------------------------
+         // Update the ownerslist - changes owning session.
+         //   Replaces the current session attributes
+         //   and moves the device to this session's
+         //   device list. This function only updates an existing session.
+         //   The process must already be on the ownerstack for this to
+         //   this to succeed. This has already been determined above
+         //   by the dev_OwnerSession() call.
+         //----------------------------------------------------------------
+         PDEBUG("Changing owner session to UI\n");
+         kosal_sem_get_user_alertable( &psess->m_sem );
+         if ( unlikely( aaldev_addowner_OK != dev_updateOwner(pdev,                 // Device
+                                                              psess->m_pid,         // Process ID
+                                                              ownerSessp,           // New session attributes
+                                                              &psess->m_devicelist) // Head of our session device list
+                      )
+            ) {
+            PERR("Failed to update owner: uid_errnumCouldNotClaimDevice\n");
+            // Create error event
+            bindcmplt = ccipdrv_event_bindcmplt_create(NULL, NULL, uid_errnumCouldNotClaimDevice, preq);
+         } else {
+            // Fill out the extended bind parameters
+            bindevt.m_mappableAPI = aaldev_mappableAPI(pdev);
+            bindevt.m_size =0;
+
+            PDEBUG("Creating bind event MAPPABLE = 0x%x\n", bindevt.m_mappableAPI);
+
+            // Create the completion event
+            bindcmplt = ccipdrv_event_bindcmplt_create(preq->handle, &bindevt, uid_errnumOK, preq);
+         }
+         kosal_sem_put( &psess->m_sem );
+         ret = 0;
+      } goto BIND_DONE; // case reqid_UID_Bind
+
+      //----------------------
+      //Process Unbind request
+      //----------------------
+      UIDRV_PROCESS_BIND_REQUEST_CASE(reqid_UID_UnBind) {
+         // Get the device from the handle and validate
+         pdev = aaldev_handle_to_devp(preq->handle);
+         ASSERT(NULL != pdev);
+         if ( unlikely( NULL == pdev ) ) {
+            PERR("Invalid device handle %p\n", preq->handle);
+            ret = -EINVAL;
+            PTRACEOUT_INT(ret);
+            return ret;
+         }
+
+         // Get the device session for this device
+         // Get the default message interface
+         ownerSessp = dev_OwnerSession(pdev, psess->m_pid);
+         if ( NULL == ownerSessp ) {
+            // TODO: no error event here?
+            PERR("Not owner or no message handler during UnBind Request.\n");
+            ret = -EACCES;
+            PTRACEOUT_INT(ret);
+            return ret;
+         }
+
+         // Unbind the PIP from the session
+         if ( unlikely( !aaldev_pipmsgHandlerp(pdev)->unBindSession(ownerSessp) ) ) {
+             PERR("uid_errnumCouldNotUnBindPipInterface\n");
+             // Create error event
+             unbindcmplt = ccipdrv_event_Unbindcmplt_create(uid_errnumCouldNotUnBindPipInterface,preq);
+             ret = -EINVAL;
+             goto UNBIND_DONE;
+         }
+
+         // Update the owner's list
+         if ( unlikely( !dev_removeOwner(pdev, psess->m_pid) ) ) {
+            PERR("Failed to update owner\n");
+            unbindcmplt = ccipdrv_event_Unbindcmplt_create(uid_errnumNotDeviceOwner, preq);
+            ret = -EINVAL;
+         } else {
+            unbindcmplt = ccipdrv_event_Unbindcmplt_create(uid_errnumOK, preq);
+         }
+         ret = 0;
+      } goto UNBIND_DONE; // case reqid_UID_UnBind
+
+      default : {
+         PERR("Unrecognized Bind option %d\n", preq->id);
+         ret = -EINVAL;
+         PTRACEOUT_INT(ret);
+         return ret;
+      }
+
+   }  // switch(preq->id)
+
+   //-------------------
+   // Generate the event
+   //-------------------
+
+BIND_DONE:
+   ASSERT(NULL != bindcmplt);
+   if ( NULL == bindcmplt ) {
+      if ( 0 == ret ) {
+         ret = -ENOMEM;
+      }
+      PTRACEOUT_INT(ret);
+      return ret;
+   }
+
+   // Enqueue the completion event
+   _aal_q_enqueue(ui_evtp_afuresponse_to_qip(bindcmplt), &psess->m_eventq);
+   kosal_wake_up_interruptible( &psess->m_waitq );
+
+   PTRACEOUT_INT(ret);
+   return ret;
+
+UNBIND_DONE:
+   ASSERT(NULL != unbindcmplt);
+   if ( NULL == unbindcmplt ) {
+      if ( 0 == ret ) {
+         ret = -ENOMEM;
+      }
+      PTRACEOUT_INT(ret);
+      return ret;
+   }
+
+   // Enqueue the completion event
+   _aal_q_enqueue(ui_evtp_afuresponse_to_qip(unbindcmplt), &psess->m_eventq);
+
+   // Unblock select() calls.
+   kosal_wake_up_interruptible( &psess->m_waitq );
+
+   PTRACEOUT_INT(ret);
+   return ret;
+}  // process_bind_request
+
+//=============================================================================
+// Name: ccidrv_marshal_upstream_message
+// Description: Pre-process a queued message targeted for the application.
+//              Called from AALUID_IOCTL_GETMSG, the message is unpacked,
+//              any kernel level functions performed and the user mode event
+//              parameters are returned.
+// Interface: private
+// Inputs: unsigned long arg - pointer to user space event target
+//         struct ccipui_ioctlreq *preq - request header
+//         struct aal_q_item *pqitem - message to process
+// Outputs: length of output buffer is copied to *Outbufsize.
+//          return code: 0 == success
+// Comments: Kernel event is destroyed
+//=============================================================================
+btInt
+ccidrv_marshal_upstream_message( struct ccipui_ioctlreq *preq,
+                                 struct aal_q_item     *pqitem,
+                                 struct ccipui_ioctlreq *resp,
+                                 btWSSize              *pOutbufsize)
+{
+   btInt    ret = 0;
+
+#if 1
+# define UIDRV_PROCESS_MESSAGE_CASE(x) case x : PDEBUG("%s\n", #x);
+#else
+# define UIDRV_PROCESS_MESSAGE_CASE(x) case x :
+#endif
+
+   PTRACEIN;
+
+   ASSERT(NULL != pqitem);
+   ASSERT(NULL != resp);
+   ASSERT(NULL != pOutbufsize);
+   ASSERT(NULL != preq);
+
+   if((NULL == pqitem) || (NULL == resp) || (NULL == pOutbufsize) || (NULL == preq)){
+      PERR("Invalid input argument");
+      return -EINVAL;
+   }
+
+   // Copy the header portion of the request back
+   resp->id      = (uid_msgIDs_e)QI_QID(pqitem);
+   resp->errcode = qip_to_ui_evtp_afuresponse(pqitem)->m_errnum;
+   resp->handle  = qip_to_ui_evtp_afuresponse(pqitem)->m_devhandle;
+   resp->context = qip_to_ui_evtp_afuresponse(pqitem)->m_context;
+   resp->tranID  = qip_to_ui_evtp_afuresponse(pqitem)->m_tranID;
+
+   // Make sure there is room for the payload
+   if ( *pOutbufsize < QI_LEN(pqitem) ) {
+      PERR("No room for event payload. Outbuf payload size = %d Event Payload = %d\n",(int) *pOutbufsize,  (int) QI_LEN(pqitem));
+      ccipdrv_event_afuresponse_destroy(qip_to_ui_evtp_afuresponse(pqitem));
+      *pOutbufsize = 0;
+      PTRACEOUT_INT(ret);
+      return -EINVAL;
+   }
+
+   // Payload size
+   *pOutbufsize = resp->size = QI_LEN(pqitem);
+
+   // Copy the payload
+   memcpy(resp->payload, qip_to_ui_evtp_afuresponse(pqitem)->m_payload, (size_t)resp->size);
+
+   PVERBOSE("Sending Event Event ID = %d\n",((struct aalui_WSMEvent*)(resp->payload))->evtID );
+
+   //Destroy the event
+   ccipdrv_event_afuresponse_destroy(qip_to_ui_evtp_afuresponse(pqitem));
+
+   PTRACEOUT_INT(ret);
+   return ret;
+} // ccidrv_process_message
+
+//=============================================================================
+// Name: ccidrv_sendevent
+// Description: Implements the PIP UI driver message handler
+// Interface: public
+// Inputs:
+// Outputs: none.
+// Comments:
+//=============================================================================
+btInt
+ccidrv_sendevent(struct aaldev_ownerSession * pOwnerSession,
+                 struct aal_q_item *eventp)
+{
+   btInt                 ret   = 0;
+   struct ccidrv_session *psess = (struct ccidrv_session *)pOwnerSession->m_UIHandle;
+
+   PTRACEIN;
+   ASSERT(NULL != psess);
+   if( NULL == psess) {
+      PERR("Invalid Input parameter \n");
+      ret = -EINVAL;
+      return ret ;
+   }
+
+   if ( NULL != eventp ) {
+
+      if ( kosal_sem_get_user_alertable(&psess->m_sem) ) { /* FIXME */ }
+      PDEBUG("Waking Up AIA with event\n");
+
+      // Enqueue the completion event
+      _aal_q_enqueue(eventp, &psess->m_eventq);
+
+      // Unblock select() calls.
+      kosal_wake_up_interruptible( &psess->m_waitq);
+      kosal_sem_put(&psess->m_sem);
+   }
+
+   PTRACEOUT_INT(ret);
+   return ret;
+}
+
+
+///////////////////////////////////////////////////////////////////////////////
+///////////////////////////////////////////////////////////////////////////////
+////////////////////                                     //////////////////////
+/////////////////              UTILITY METHODS              ///////////////////
+////////////////////                                     //////////////////////
+///////////////////////////////////////////////////////////////////////////////
+///////////////////////////////////////////////////////////////////////////////
+//=============================================================================
+//=============================================================================
+
+
+//=============================================================================
+// Name: ccidrv_getwsid
+// Description: Allocates a WSID object
+// Interface: public
+// Inputs: pdev - aal_device pointer
+//         id - Workspace Manager assigned ID
+// Outputs: none.
+// Comments:
+//=============================================================================
+struct aal_wsid* ccidrv_getwsid(struct aal_device *pdev,
+                                unsigned long long id)
+{
+   static btUnsigned64bitInt     nextWSID = 1;
+
+   struct aal_wsid * pwsid = NULL;
+   int status;
+
+
+#ifdef __i386__
+   pwsid = (struct aal_wsid * )__get_free_page(GFP_KERNEL);
+#else
+   pwsid = (struct aal_wsid * )kosal_kmalloc(sizeof(struct aal_wsid));
+#endif
+
+   if(unlikely (pwsid == NULL) ){
+      DPRINTF (UIDRV_DBG_FILE, ": failed to malloc WSID object\n");
+      return NULL;
+   }
+
+   /* get list manipulation semaphore */
+   status = kosal_sem_get_krnl_alertable(&umDriver.wsid_list_sem);
+   if (0 != status) {
+      DPRINTF (UIDRV_DBG_FILE, ": couldn't add WSID to alloc_list\n");
+#ifdef __i386__
+      free_page(pwsid);
+#else
+      kosal_kfree(pwsid,sizeof(struct aal_wsid));
+#endif
+      return NULL;
+   }
+
+   // Check the WSID for roll over. This gives us a very large number of WSIDs before
+   //   roll over.
+   if( 0 == wsid_to_wsidHandle(nextWSID) ){
+      nextWSID = 1;
+   }
+
+   pwsid->m_device = pdev;
+   pwsid->m_handle = wsid_to_wsidHandle(nextWSID);
+   pwsid->m_id = id;
+   kosal_list_init(&pwsid->m_list);
+   kosal_list_init(&pwsid->m_alloc_list);
+
+   PDEBUG(": Created WSID %llu [Handle %llx] for device id %llx \n", nextWSID, pwsid->m_handle, id);
+
+   /* add to allocated list */
+   kosal_list_add_head(&pwsid->m_alloc_list, &umDriver.wsid_list_head);
+
+   nextWSID++;
+
+   /* release semaphore */
+   kosal_sem_put(&umDriver.wsid_list_sem);
+
+   return pwsid;
+}
+
+
+/** @brief free the WSID object
+ * @param[in] pwsid pointer to WSID object to free.
+ * @return zero if successful, -EINTR if couldn't get list manipulation
+ * lock, -EINVAL if workspace ID appears to be invalid, -EBUSY if still
+ * on an ownership list */
+btInt ccidrv_freewsid(struct aal_wsid *pwsid)
+{
+   int status;
+
+   /* cheap paranoia. */
+   if (NULL == pwsid) {
+      return -EINVAL;
+   }
+
+   /* check if wsid is on an ownership list */
+   if (!kosal_list_is_empty(&pwsid->m_list)) {
+      DPRINTF (UIDRV_DBG_FILE, ": wsid %p appears to be on an "
+         "ownership list; not freeing\n", pwsid);
+      return -EBUSY;
+   }
+
+   /* search for the provided wsid on the known list */
+   if (NULL ==  ccidrv_valwsid( pwsid_to_wsidHandle(pwsid) )) {
+      return -EINVAL;
+   }
+
+   status = kosal_sem_get_krnl_alertable(&umDriver.wsid_list_sem);
+   if (0 != status) {
+      return status;
+   }
+   kosal_list_del(&pwsid->m_alloc_list);
+   kosal_sem_put(&umDriver.wsid_list_sem);
+
+#ifdef __i386__
+   free_page(pwsid);
+#else
+   kosal_kfree(pwsid, sizeof(struct aal_wsid *));
+#endif
+
+   return 0;
+}
+
+//=============================================================================
+// Name: ccidrv_flush_eventqueue
+// Description: flush the event queue
+// Interface: private
+// Inputs: psess - session pointer
+// Outputs: none.
+// Comments:
+//=============================================================================
+int ccidrv_flush_eventqueue(  struct ccidrv_session *psess)
+{
+   int ret = 0;
+   struct aal_q_item *pqitem;
+   DPRINTF( UIDRV_DBG_IOCTL, ": Flushing event queue\n" );
+   while(!_aal_q_empty(&psess->m_eventq) ) {
+      DPRINTF( UIDRV_DBG_IOCTL, ": Not Empty\n" );
+
+      //------------------------
+      // Get the request message
+      //------------------------
+      pqitem = _aal_q_dequeue(&psess->m_eventq);
+      if(pqitem == NULL) {
+         DPRINTF( UIDRV_DBG_IOCTL, ": Invalid or corrupted request on flush\n" );
+         continue;
+      }
+      DPRINTF( UIDRV_DBG_IOCTL, ": Flushing Response event\n" );
+      ccipdrv_event_afuresponse_destroy(qip_to_ui_evtp_afuresponse(pqitem));
+   }
+   return ret;
+}
+
+//=============================================================================
+// Name: ccidrv_valwsid
+/** @brief check if a provided wsid is on the list of known allocated wsids
+ * @param[in] wsidHandle handle to workspace to validate
+ * @return zero on success
+ * grab the list lock, walk the list, and compare pointers. */
+//=============================================================================
+struct aal_wsid *ccidrv_valwsid(btWSID wsidHandle)
+{
+   int status;
+   struct aal_wsid *listwsid_p;
+
+   if( 0 == wsidHandle) {
+      PERR(": wsid was 0\n");
+      return NULL;
+   }
+
+   status = kosal_sem_get_krnl_alertable(&umDriver.wsid_list_sem);
+   if (0 != status) {
+      PERR(": couldn't get list semaphore\n");
+      kosal_sem_put(&umDriver.wsid_list_sem);
+      return NULL;
+   }
+
+   kosal_list_for_each_entry(listwsid_p, &umDriver.wsid_list_head, m_alloc_list, struct aal_wsid) {
+      if (listwsid_p->m_handle == wsidHandle) {
+         kosal_sem_put(&umDriver.wsid_list_sem);
+         return listwsid_p;
+      }
+   }
+
+   kosal_sem_put(&umDriver.wsid_list_sem);
+
+   PINFO(": wsid %llu not on list\n", wsidHandle);
+
+   return NULL;
+}
+
+/** @brief search for a given wsid in the provided uidrv_session
+ * @param[in] ccidrv_sess_p pointer to uidrv session to dig through
+ * @param[in] wsidHandle to workspace ID to check
+ * @return NULL if pointer is not found, wsid_p if it is
+ *
+ * both input pointers are assumed already to be non-NULL.
+ *
+ * should this functionality be part of the workspace manager?  why are wsids
+ * even leaked out of the workspace manager?  shouldn't everything out here be
+ * manipulated through completely opaque workspace IDs (long long int)?
+ */
+struct aal_wsid *find_wsid( const struct ccidrv_session *ccidrv_sess_p,
+                            btWSID wsidHandle)
+{
+   const struct aaldev_owner *owner_p;
+   const struct aaldev_ownerSession *ownersess_p;
+   struct aal_wsid *cur_wsid_p = NULL;
+
+   PDEBUG("Looking for WSID Handle %llx\n", wsidHandle);
+
+   /* start by checking if the passed wsid is even valid */
+   if (NULL == ccidrv_valwsid(wsidHandle)) {
+      PERR("WSID Invalid\n");
+      return NULL;
+   }
+
+   /* if this session is not associated with a device, don't bother checking
+    * ownership of the wsid, since there may not be any.  */
+   if (kosal_list_is_empty(&ccidrv_sess_p->m_devicelist)) {
+      return ccidrv_valwsid(wsidHandle);
+   }
+
+   /* if this session is associated with a device, (IE m_devicelist is not
+    * empty,) then any wsid we handle needs to be on one of our device's
+    * ownership lists, otherwise we shouldn't be touching it.
+    *
+    * struct ccidrv_session contains list head of
+    *   struct aaldev_owner which contains
+    *     struct aaldev_ownerSession which contains the list head of
+    *       struct aal_wsid */
+  PVERBOSE("looking at list head %p for wsid %llx\n", &(ccidrv_sess_p->m_devicelist), wsidHandle );
+   kosal_list_for_each_entry(owner_p, &(ccidrv_sess_p->m_devicelist), m_devicelist, struct aaldev_owner) {
+      PVERBOSE("examining owner_p %p\n", owner_p);
+      ownersess_p = &(owner_p->m_sess);
+
+      kosal_list_for_each_entry(cur_wsid_p, &(ownersess_p->m_wshead), m_list, struct aal_wsid) {
+         if (cur_wsid_p->m_handle == wsidHandle) {
+            PVERBOSE("  wsid ID %lld at %p found\n",cur_wsid_p->m_handle, cur_wsid_p);
+            return cur_wsid_p;
+         }
+      }
+   }
+
+   PVERBOSE("wsid %llu NOT found on any owner lists\n", wsidHandle);
+
+   return NULL;
+}
+
diff --git a/drivers/fpga/aal/cci/cci_pcie_driver_umapi_linux.c b/drivers/fpga/aal/cci/cci_pcie_driver_umapi_linux.c
new file mode 100644
index 000000000000..6793d6ce9575
--- /dev/null
+++ b/drivers/fpga/aal/cci/cci_pcie_driver_umapi_linux.c
@@ -0,0 +1,605 @@
+//******************************************************************************
+// This  file  is  provided  under  a  dual BSD/GPLv2  license.  When using or
+//         redistributing this file, you may do so under either license.
+//
+//                            GPL LICENSE SUMMARY
+//
+//  Copyright(c) 2015-2017, Intel Corporation.
+//
+//  This program  is  free software;  you  can redistribute it  and/or  modify
+//  it  under  the  terms of  version 2 of  the GNU General Public License  as
+//  published by the Free Software Foundation.
+//
+//  This  program  is distributed  in the  hope that it  will  be useful,  but
+//  WITHOUT   ANY   WARRANTY;   without   even  the   implied   warranty    of
+//  MERCHANTABILITY  or  FITNESS  FOR  A  PARTICULAR  PURPOSE.  See  the   GNU
+//  General Public License for more details.
+//
+//  The  full  GNU  General Public License is  included in  this  distribution
+//  in the file called README.GPLV2-LICENSE.TXT.
+//
+//  Contact Information:
+//  Henry Mitchel, henry.mitchel at intel.com
+//  77 Reed Rd., Hudson, MA  01749
+//
+//                                BSD LICENSE
+//
+//  Copyright(c) 2015-2017, Intel Corporation.
+//
+//  Redistribution and  use  in source  and  binary  forms,  with  or  without
+//  modification,  are   permitted  provided  that  the  following  conditions
+//  are met:
+//
+//    * Redistributions  of  source  code  must  retain  the  above  copyright
+//      notice, this list of conditions and the following disclaimer.
+//    * Redistributions in  binary form  must  reproduce  the  above copyright
+//      notice,  this  list of  conditions  and  the  following disclaimer  in
+//      the   documentation   and/or   other   materials   provided  with  the
+//      distribution.
+//    * Neither   the  name   of  Intel  Corporation  nor  the  names  of  its
+//      contributors  may  be  used  to  endorse  or promote  products derived
+//      from this software without specific prior written permission.
+//
+//  THIS  SOFTWARE  IS  PROVIDED  BY  THE  COPYRIGHT HOLDERS  AND CONTRIBUTORS
+//  "AS IS"  AND  ANY  EXPRESS  OR  IMPLIED  WARRANTIES,  INCLUDING,  BUT  NOT
+//  LIMITED  TO, THE  IMPLIED WARRANTIES OF  MERCHANTABILITY  AND FITNESS  FOR
+//  A  PARTICULAR  PURPOSE  ARE  DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT
+//  OWNER OR CONTRIBUTORS BE LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,
+//  SPECIAL,  EXEMPLARY,  OR  CONSEQUENTIAL   DAMAGES  (INCLUDING,   BUT   NOT
+//  LIMITED  TO,  PROCUREMENT  OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF USE,
+//  DATA,  OR PROFITS;  OR BUSINESS INTERRUPTION)  HOWEVER  CAUSED  AND ON ANY
+//  THEORY  OF  LIABILITY,  WHETHER  IN  CONTRACT,  STRICT LIABILITY,  OR TORT
+//  (INCLUDING  NEGLIGENCE  OR OTHERWISE) ARISING  IN ANY WAY  OUT  OF THE USE
+//  OF  THIS  SOFTWARE, EVEN IF ADVISED  OF  THE  POSSIBILITY  OF SUCH DAMAGE.
+//******************************************************************************
+//****************************************************************************
+//        FILE: cci_pcie_driver_umapi_linux.c
+//     CREATED: 10/20/2015
+//      AUTHOR: Joseph Grecco
+//
+// PURPOSE:  This file contains the main startup and shutdown code for the
+//           Accelerator Abstraction Layer (AAL)
+//           User Mode Interface for the AAL CCI device driver
+// HISTORY:
+// COMMENTS:
+// WHEN:          WHO:     WHAT:
+// 10/20/2015     JG       Initial version started
+//****************************************************************************
+#include "aalsdk/kernel/kosal.h"
+
+#define MODULE_FLAGS UIDRV_DBG_MOD
+
+#include "cci_pcie_driver_umapi_linux.h"
+#include "cci_pcie_driver_internal.h"
+//#include "cciui-events.h"
+//#include "aalsdk/kernel/aalui-events.h"
+
+
+//////////////////////////////////////////////////////////////////////////////////////
+
+// Major device number to use for the device nodes
+btInt majornum = 0;
+
+//////////////////////////////////////////////////////////////////////////////////////
+
+
+//=============================================================================
+// Driver Parameters
+//=============================================================================
+
+//
+//  Declarations for module parameters - Enables parameter value passing from
+//                                       insmod and permissions as seen from /sys
+//
+MODULE_PARM_DESC(majornum, "major device number");
+module_param    (majornum, int, 0444);
+
+// Prototypes
+btInt ccidrv_open(struct inode *, struct file *);
+btInt ccidrv_close(struct inode *, struct file *);
+
+btInt ccidrv_mmap(struct file *, struct vm_area_struct *);
+btUnsignedInt ccidrv_poll(struct file *, poll_table *);
+
+#if HAVE_UNLOCKED_IOCTL
+long ccidrv_ioctl(struct file *file,
+                 unsigned int cmd,
+                 unsigned long arg);
+#else
+int ccidrv_ioctl(struct inode *inode,
+                struct file *file,
+                unsigned int cmd,
+                unsigned long arg);
+#endif
+
+extern btInt ccidrv_messageHandler( struct ccidrv_session   *psess,
+                                    btUnsigned32bitInt       cmd,
+                                    struct ccipui_ioctlreq   *preq,
+                                    btWSSize                 InbufSize,
+                                    struct ccipui_ioctlreq   *presp,
+                                    btWSSize                *pOutbufSize);
+
+
+
+///////////////////////////////////////////////////////////////////////////////
+///////////////////////////////////////////////////////////////////////////////
+////////////////////                                     //////////////////////
+/////////////////     UNIVERSAL DEVICE DRIVER INTERFACE     ///////////////////
+////////////////////                                     //////////////////////
+///////////////////////////////////////////////////////////////////////////////
+///////////////////////////////////////////////////////////////////////////////
+//=============================================================================
+//=============================================================================
+
+
+//=============================================================================
+// Name: ui_driver
+// Description: This is the UI Driver Object singleton. This is
+//              object that gets registered with AALBus.  It is a device driver
+//              in name only. It does not actually control any device HW.
+//              As a device driver module it is allowed to expose a user mode
+//              interface.
+//=============================================================================
+struct um_APIdriver thisDriver = {
+
+      .m_fops = {
+         .owner          = THIS_MODULE,
+         .poll           = ccidrv_poll,
+#if HAVE_UNLOCKED_IOCTL
+         .unlocked_ioctl = ccidrv_ioctl,
+#else
+         .ioctl          = ccidrv_ioctl,  // Deprecated in 2.6.36
+#endif
+         .mmap           = ccidrv_mmap,
+         .open           = ccidrv_open,
+         .release        = ccidrv_close,
+      },
+};
+
+// Common driver object
+struct um_driver umDriver;
+
+
+///////////////////////////////////////////////////////////////////////////////
+///////////////////////////////////////////////////////////////////////////////
+////////////////////                                     //////////////////////
+/////////////////              UMAPI METHODS               ////////////////////
+////////////////////                                     //////////////////////
+///////////////////////////////////////////////////////////////////////////////
+///////////////////////////////////////////////////////////////////////////////
+//=============================================================================
+//=============================================================================
+
+//=============================================================================
+// Name: ccidrv_initUMAPI
+// Description: Initialization routine for the module. Registers with the bus
+//              driver
+// Interface: public
+// Inputs: none.
+// Outputs: none.
+// Comments:
+//=============================================================================
+int
+ccidrv_initUMAPI(void)
+{
+   int res                 = 0;
+
+   char * devname          = "uidrv";
+
+   PVERBOSE("Installing CCI Driver API\n");
+   //---------------------------
+   // Initialize data structures
+   //---------------------------
+   kosal_mutex_init(&umDriver.m_qsem);
+   kosal_list_init(&umDriver.m_sessq);
+   kosal_mutex_init(&umDriver.m_sem);
+
+   kosal_mutex_init(&umDriver.wsid_list_sem);
+   kosal_list_init(&umDriver.wsid_list_head);
+
+   PDEBUG("Allocating major number for \"%s\"\n",devname);
+
+   res = alloc_chrdev_region(&thisDriver.m_devtype, 0, 1, devname);
+
+   if ( res < 0 ) {
+      PERR("Failed to allocate major device number for \"%s\"\n", devname);
+      return res;
+   }
+
+   PDEBUG("Using major number %d for \"%s\"\n", MAJOR(thisDriver.m_devtype), devname);
+
+   cdev_init(&thisDriver.m_cdev, &thisDriver.m_fops);
+   thisDriver.m_cdev.ops   = &thisDriver.m_fops;
+   thisDriver.m_cdev.owner = THIS_MODULE;
+
+  res = cdev_add(&thisDriver.m_cdev, thisDriver.m_devtype, 1);
+   if ( res ) {
+     PERR("Failed to register character device : ret = %d\n", res);
+     goto ERROR;
+   }
+
+   thisDriver.m_class = class_create(THIS_MODULE, devname);
+   if(NULL == thisDriver.m_class){
+      PERR("Could Not create class device\n");
+            goto ERROR;
+   }
+
+   thisDriver.m_device = device_create(thisDriver.m_class, NULL, thisDriver.m_devtype, "%s", devname);
+
+   return res;
+
+   ERROR:
+      device_destroy(thisDriver.m_class, thisDriver.m_devtype);
+      cdev_del(&thisDriver.m_cdev);
+      class_destroy(thisDriver.m_class);
+      unregister_chrdev_region(thisDriver.m_devtype, 1);
+      return res;
+
+}
+
+
+//=============================================================================
+// Name: ccidrv_exitUMAPI
+// Description: Removes device from filesystem and registration
+// Interface: public
+// Inputs: none.
+// Outputs: none.
+// Comments:
+//=============================================================================
+void ccidrv_exitUMAPI(void)
+{
+
+   PVERBOSE(" Exiting\n");
+
+   // TODO FLUSH ALL Messages
+
+   device_destroy(thisDriver.m_class, thisDriver.m_devtype);
+   cdev_del(&thisDriver.m_cdev);
+   class_destroy(thisDriver.m_class);
+   unregister_chrdev_region(thisDriver.m_devtype, 1);
+
+}
+
+//=============================================================================
+//=============================================================================
+///////////////////////////////////////////////////////////////////////////////
+////////////////////                                     //////////////////////
+/////////////////          CCI SYSTEM CALL INTERFACE       ////////////////////
+////////////////////                                     //////////////////////
+///////////////////////////////////////////////////////////////////////////////
+//=============================================================================
+//=============================================================================
+
+//=============================================================================
+// Name: aalccidrv_ioctl
+// Description: Implements the ioctl system call
+// Interface: public
+// Inputs: .
+// Outputs: none.
+// Comments: Entry point for all requests from user space
+//=============================================================================
+#if HAVE_UNLOCKED_IOCTL
+long ccidrv_ioctl(struct file *file,
+                 unsigned int cmd,
+                 unsigned long arg)
+#else
+int ccidrv_ioctl(struct inode *inode,
+                struct file *file,
+                unsigned int cmd,
+                unsigned long arg)
+#endif
+
+{
+   struct ccidrv_session *psess = (struct ccidrv_session *) file->private_data;
+
+   // Generic variables
+   int                     ret=0;
+   struct ccipui_ioctlreq  req;                       // User IOCTL header
+
+   struct ccipui_ioctlreq *pfullrequest      = NULL;  // Full message with var data
+   btWSSize                FullRequestSize   = 0;     // Size of the user buffer (header + payload)
+   btWSSize                Outbufsize        = 0;     // Size of usable return payload buffer
+   struct ccipui_ioctlreq *pfullresponse     = NULL;  // Buffer to put return response if any.
+
+   ASSERT(NULL != psess );
+   if ( NULL == psess ) {
+      PERR("No session for message\n");
+      return -EINVAL;
+   }
+
+   //---------------------
+   // Get the user request
+   //---------------------
+   // Read header
+   if ( copy_from_user(&req, (void *)arg, sizeof(req)) ) {
+      return -EFAULT;
+   }
+
+   // Total user buffer size is the size of the header structure ccipui_ioctlreq + payload size
+   FullRequestSize = (sizeof(struct ccipui_ioctlreq)) + aalui_ioctlPayloadSize(&req);
+
+   ASSERT(FullRequestSize <= KMALLOC_MAX_SIZE);
+   if ( FullRequestSize > KMALLOC_MAX_SIZE ) {
+      PERR("Request size too large: %" PRIu64 "\n", FullRequestSize);
+      return -EINVAL;
+   }
+
+   // If there is a payload then allocate a bige enough buffer and copy it in.
+   if ( FullRequestSize > sizeof(struct ccipui_ioctlreq) ) {
+
+      PINFO("UIDRV is reading message with payload of size %" PRIu64 "\n", aalui_ioctlPayloadSize(&req));
+      pfullrequest = (struct ccipui_ioctlreq *) kosal_kzmalloc(FullRequestSize);
+
+      // Read whole message
+      if ( copy_from_user(pfullrequest, (void *)arg, FullRequestSize) ) {
+         kosal_kfree(pfullrequest, FullRequestSize);
+         return -EFAULT;
+      }
+
+   } else {
+      //Header is all there is. No need to read it again. Just point to req earlier.
+      pfullrequest = &req;
+   }
+
+   // Allocate a temporary buffer for the response. Note that for simplicity the payload
+   //   of the original request will be used for the response as well. I.e., The response buffer
+   //   is the same size as the request buffer.  The response will be copied over the original
+   //   user mode request.
+   //-------------------------------------------------------------------------------------------
+   pfullresponse = (struct ccipui_ioctlreq *) kosal_kzmalloc(FullRequestSize);
+   ASSERT(NULL != pfullresponse);
+   if ( NULL == pfullresponse ) {
+      if ( &req != pfullrequest ) {
+         kosal_kfree(pfullrequest, FullRequestSize);
+      }
+      PERR("Unable to allocate memory \n");
+      ret = -ENOMEM;
+      return ret;
+   }
+
+   // Limit on response payload.  This will be changed by the request processor to the actual return size
+   //  or zero if no response data.
+   Outbufsize = aalui_ioctlPayloadSize(&req);
+
+   *pfullresponse = req;   // Copy the original header for the response and change as needed
+   // Pass the message to OS independent processing. Note that some functions that don't return a
+   // payload use only the request header to return their data. So the whole response buffer must be passed.
+   ret = ccidrv_messageHandler(psess,
+                               cmd,
+                               pfullrequest,
+                               FullRequestSize,
+                               pfullresponse,                       // Pointer to output response
+                               &Outbufsize);                        // Outbuf buffer size
+
+   if ( 0 == ret ) {
+
+      btWSSize FullResponseSize = sizeof(struct ccipui_ioctlreq) + Outbufsize;
+
+      // Copy the Response back.
+      PINFO("UIDRV is writing %" PRIu64 "-byte response message with payload of size %" PRIu64 " bytes with %llx\n", FullResponseSize, pfullresponse->size, (btWSID)(*pfullresponse->payload));
+      ret = copy_to_user((void*)arg, pfullresponse, FullResponseSize);
+
+   } else {
+      PDEBUG("ccidrv_messageHandler failed\n");
+      ret = -EINVAL;
+   }
+
+   // Free response buffer
+   if ( NULL != pfullresponse ) {
+      kosal_kfree(pfullresponse, FullRequestSize);
+   }
+
+   // Free message copy if it had a payload
+   if ( &req != pfullrequest ) {
+      kosal_kfree(pfullrequest, FullRequestSize);
+   }
+
+   return ret;
+}
+
+
+//=============================================================================
+// Name: ccidrv_open
+// Description: Implements the open system call
+// Interface: public
+// Inputs: inode - pointer to inode for device node
+//         file - pointer to file instance for this open
+// Outputs: none.
+// Comments: Creates a per process session instance with the device control
+//           subsystem.The session holds the state and context between an
+//           application process, the device and associated servciecs (e.g,
+//           workspace manager).
+//           The UDDI maintains a list of all open sessions.
+//=============================================================================
+int ccidrv_open  (struct inode *inode, struct file *file)
+{
+   struct ccidrv_session *psess = NULL;
+   int ret = 0;
+
+   DPRINTF (UIDRV_DBG_FILE, ":Opened by pid = %d tgid = %d\n",current->pid, current->tgid );
+
+   // Create a session
+   psess = ccidrv_session_create( current->tgid );
+   if( unlikely( psess == NULL ) ) {
+      DPRINTF (UIDRV_DBG_FILE, "Create session failed.\n" );
+      return -ENOMEM;
+   }
+
+   file->private_data = psess;
+
+   // Add it to the list of sessions
+   if (kosal_sem_get_krnl_alertable( &umDriver.m_qsem)) { /* FIXME */ }
+   list_add_tail( &psess->m_sessions, &umDriver.m_sessq);
+   up( &umDriver.m_qsem);
+
+   DPRINTF (UIDRV_DBG_FILE, "Application Session Created sess=%p\n", psess);
+   return ret;
+}
+
+//=============================================================================
+// Name: ccidrv_close
+// Description: Implements the close system call
+// Interface: public
+// Inputs: .
+// Outputs: none.
+// Comments: Close pulls the plug on any outstanding transactions. This implies
+//           that notifications for completion may not be sent to the
+//           application. Ideally the app is in a quiescent state before
+//           calling.
+//=============================================================================
+int ccidrv_close (struct inode *inode, struct file *file)
+{
+   struct ccidrv_session *psess = file->private_data;
+   file->private_data = NULL;
+   DPRINTF (UIDRV_DBG_FILE, ": Closing session %p\n",psess);
+
+   return ccidrv_session_destroy(psess);
+}
+
+//=============================================================================
+// Name: ccidrv_poll
+// Description: Called from select, poll or epoll call.
+// Interface: public
+// Inputs: .
+// Outputs: none.
+// Comments:
+//=============================================================================
+unsigned int ccidrv_poll ( struct file *file, poll_table *wait )
+{
+   struct ccidrv_session *psess = ( struct ccidrv_session * ) file->private_data;
+   unsigned int mask = 0;
+
+   // Put session's waitq in the poll table
+   poll_wait ( file, &psess->m_waitq, wait );
+
+   // If there is a request on the queue wakeup sleeper
+   if (kosal_sem_get_krnl_alertable( &psess->m_sem )) { /* FIXME */ }
+   if( !_aal_q_empty(&psess->m_eventq) ){
+      DPRINTF( UIDRV_DBG_FILE, ": Message available. Waking sleepers\n" );
+      mask |= POLLPRI;  // Device request completion
+   }
+   up ( &psess->m_sem );
+
+   return mask;
+}
+
+
+///////////////////////////////////////////////////////////////////////////////
+///////////////////////////////////////////////////////////////////////////////
+////////////////////                                     //////////////////////
+/////////////////               MMAP METHOD                 ///////////////////
+////////////////////                                     //////////////////////
+///////////////////////////////////////////////////////////////////////////////
+///////////////////////////////////////////////////////////////////////////////
+//=============================================================================
+//=============================================================================
+
+
+//=============================================================================
+// Name: ccidrv_mmap
+// Description: mmap system call
+// Interface: public
+// Inputs: .
+// Outputs: none.
+// Comments: The mmap system call parameter "offset" (aka vm_pgoff) has been
+//           overloaded to mean Workspace ID (wsid).  Because the mmap() call
+//           expects a page aligned offset AND the kernel page aligns the
+//           vm_pgoff value, the wsid (an unsigned long long) is encoded into
+//           a page aligned value.
+//=============================================================================
+int
+ccidrv_mmap  (struct file *file, struct vm_area_struct *vma)
+{
+   struct aaldev_ownerSession    *ownerSessp = NULL;
+   struct aal_wsid *wsidp = NULL;
+   struct ccidrv_session * psess = NULL;
+   struct aal_device *pdev = NULL;
+
+   PTRACEIN;
+   PVERBOSE("In UIDRV  MMAP\n");
+
+   //////////////////////////////////////////////////////////////////////////////////
+   if(vma->vm_pgoff == 0 ) {
+      DPRINTF( UIDRV_DBG_MMAP, "Invalid WSID\n");
+      goto failed;
+   }
+
+   /* session information is squirreled away in our private data */
+   psess = (struct ccidrv_session *) file->private_data;
+   if (NULL == psess) {
+      DPRINTF( UIDRV_DBG_MMAP, "Invalid session\n");
+      goto failed;
+   }
+   PDEBUG("WSID offset %lu  handle is %llx\n",vma->vm_pgoff, pgoff_to_wsidHandle(vma->vm_pgoff));
+
+   /* check wsidp vs known list of wsids */
+   wsidp = find_wsid(psess, pgoff_to_wsidHandle(vma->vm_pgoff));
+   if (NULL == wsidp) {
+      DPRINTF( UIDRV_DBG_MMAP, "WSID not found on list owned WSIDs\n");
+      goto failed;
+   }
+
+   // pull the aal_device out of the workspace
+   pdev = wsidp->m_device;
+   if(unlikely(!aaldev_valid(pdev))){
+      DPRINTF( UIDRV_DBG_MMAP, "Invalid WSID\n");
+      goto failed;
+   }
+
+   // Get the device session
+   ownerSessp = dev_OwnerSession(pdev,psess->m_pid);
+   if(unlikely(ownerSessp == NULL)){
+      DPRINTF( UIDRV_DBG_MMAP, "Not device owner\n");
+      goto failed;
+   }
+
+   DPRINTF( UIDRV_DBG_MMAP, "Mmap WS pgoff = %lx \n", vma->vm_pgoff);
+   DPRINTF( UIDRV_DBG_MMAP, "Mmap WS device = %p tid = %d\n", pdev,psess->m_pid );
+   DPRINTF( UIDRV_DBG_MMAP, "Mmap WS %p id = 0x%llx.\n", wsidp,wsidp->m_id);
+
+   //==================================================
+   // Check for permission and correctness of interface
+   //==================================================
+#if 0
+   // Move this code to pip-specific mmap functions AND
+   // add intelligence about type of memory being mapped
+   // e.g. && workspaceid.type == CSR // then fail
+   // that is, CSR mapping is disabled but allow buffer mapping
+   // or -- if CSR mapping is allowed but in multi-process mode then they would
+   // not be allowed.
+   if(!aaldev_allowsDirectAPI(pdev)){
+      DPRINTF( UIDRV_DBG_MMAP, "Direct PIP access not allowed on this device.\n");
+      goto failed;
+   }
+#endif
+
+   if(!aaldev_haspip(pdev)) {
+      DPRINTF( UIDRV_DBG_MMAP, "Device has no PIP.\n");
+      goto failed;
+
+   }
+
+   if(!aalpip_hasmmap( aaldev_pipp(pdev) ) ){
+      DPRINTF( UIDRV_DBG_MMAP, "Device PIP does not support mmap.\n");
+      goto failed;
+   }
+
+   //------------------------------------
+   // Call the device's PIP::fop:mmap
+   //------------------------------------
+
+   // Call through the device PIP to the mmap() method
+   if( aalpip_mmap( aaldev_pipp(pdev) )( ownerSessp,
+                                         wsidp,
+                                         vma ) < 0) {
+       DPRINTF( UIDRV_DBG_MMAP, "Mmap WS 0x%llx Failed.\n", wsidp->m_id);
+       goto failed;
+   }
+   DPRINTF( UIDRV_DBG_MMAP, "Mmap WS Success.\n");
+   return 0;
+
+failed:
+   return -EINVAL;
+
+}
+
diff --git a/drivers/fpga/aal/cci/cci_pcie_driver_umapi_linux.h b/drivers/fpga/aal/cci/cci_pcie_driver_umapi_linux.h
new file mode 100644
index 000000000000..680ffac8e6d8
--- /dev/null
+++ b/drivers/fpga/aal/cci/cci_pcie_driver_umapi_linux.h
@@ -0,0 +1,105 @@
+//******************************************************************************
+// This  file  is  provided  under  a  dual BSD/GPLv2  license.  When using or
+//         redistributing this file, you may do so under either license.
+//
+//                            GPL LICENSE SUMMARY
+//
+//  Copyright(c) 2015-2017, Intel Corporation.
+//
+//  This program  is  free software;  you  can redistribute it  and/or  modify
+//  it  under  the  terms of  version 2 of  the GNU General Public License  as
+//  published by the Free Software Foundation.
+//
+//  This  program  is distributed  in the  hope that it  will  be useful,  but
+//  WITHOUT   ANY   WARRANTY;   without   even  the   implied   warranty    of
+//  MERCHANTABILITY  or  FITNESS  FOR  A  PARTICULAR  PURPOSE.  See  the   GNU
+//  General Public License for more details.
+//
+//  The  full  GNU  General Public License is  included in  this  distribution
+//  in the file called README.GPLV2-LICENSE.TXT.
+//
+//  Contact Information:
+//  Henry Mitchel, henry.mitchel at intel.com
+//  77 Reed Rd., Hudson, MA  01749
+//
+//                                BSD LICENSE
+//
+//  Copyright(c) 2015-2017, Intel Corporation.
+//
+//  Redistribution and  use  in source  and  binary  forms,  with  or  without
+//  modification,  are   permitted  provided  that  the  following  conditions
+//  are met:
+//
+//    * Redistributions  of  source  code  must  retain  the  above  copyright
+//      notice, this list of conditions and the following disclaimer.
+//    * Redistributions in  binary form  must  reproduce  the  above copyright
+//      notice,  this  list of  conditions  and  the  following disclaimer  in
+//      the   documentation   and/or   other   materials   provided  with  the
+//      distribution.
+//    * Neither   the  name   of  Intel  Corporation  nor  the  names  of  its
+//      contributors  may  be  used  to  endorse  or promote  products derived
+//      from this software without specific prior written permission.
+//
+//  THIS  SOFTWARE  IS  PROVIDED  BY  THE  COPYRIGHT HOLDERS  AND CONTRIBUTORS
+//  "AS IS"  AND  ANY  EXPRESS  OR  IMPLIED  WARRANTIES,  INCLUDING,  BUT  NOT
+//  LIMITED  TO, THE  IMPLIED WARRANTIES OF  MERCHANTABILITY  AND FITNESS  FOR
+//  A  PARTICULAR  PURPOSE  ARE  DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT
+//  OWNER OR CONTRIBUTORS BE LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,
+//  SPECIAL,  EXEMPLARY,  OR  CONSEQUENTIAL   DAMAGES  (INCLUDING,   BUT   NOT
+//  LIMITED  TO,  PROCUREMENT  OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF USE,
+//  DATA,  OR PROFITS;  OR BUSINESS INTERRUPTION)  HOWEVER  CAUSED  AND ON ANY
+//  THEORY  OF  LIABILITY,  WHETHER  IN  CONTRACT,  STRICT LIABILITY,  OR TORT
+//  (INCLUDING  NEGLIGENCE  OR OTHERWISE) ARISING  IN ANY WAY  OUT  OF THE USE
+//  OF  THIS  SOFTWARE, EVEN IF ADVISED  OF  THE  POSSIBILITY  OF SUCH DAMAGE.
+//******************************************************************************
+//****************************************************************************
+//        FILE: cci_pcie_driver_umapi_linux.h
+//     CREATED: 10/20/2015
+//      AUTHOR: Joseph Grecco
+//
+// PURPOSE:  This file contains Linux definitions for the
+//           Accelerator Abstraction Layer (AAL)
+//           User Mode Interface for the AAL CCI device driver
+// HISTORY:
+// COMMENTS:
+// WHEN:          WHO:     WHAT:
+// 10/20/2015     JG       Initial version started
+//****************************************************************************
+#ifndef __AALKERNEL_AAL_PCIE_DRIVER_UMAPI_LINUX_H__
+#define __AALKERNEL_AAL_PCIE_DRIVER_UMAPI_LINUX_H__
+#include "aalsdk/kernel/kosal.h"
+#include "aalsdk/kernel/aalbus.h"
+#include "aalsdk/kernel/ccipdriver.h"
+#include "cci_pcie_driver_umapi.h"
+
+#define DEV_NAME          "aalui"
+
+#ifndef DRV_VERSION
+# define DRV_VERSION      "EXPERIMENTAL VERSION"
+#endif
+
+#define AALUI_DRV_MAJVERSION     (0x00000001)
+#define AALUI_DRV_MINVERSION     (0x00000000)
+#define AALUI_DRV_RELEASE        (0x00000000)
+
+// TODO THESE NEED PROPER DEFINITION IN IDS
+#define  AALUI_DRV_INTC          (0x0000000000002000)
+
+//=============================================================================
+// Name: um_APIdriver
+// Description: CCI User Mode API Class
+//=============================================================================
+struct um_APIdriver {
+   dev_t           m_devtype;
+
+   struct file_operations      m_fops;  // Interface
+   struct cdev                 m_cdev;  // character device
+   btInt                       m_major; // major number of device node
+
+   struct device              *m_device;
+   struct class               *m_class;
+};
+
+
+#endif // __AALKERNEL_AAL_PCIE_DRIVER_UMAPI_LINUX_H__
+
diff --git a/drivers/fpga/aal/cci/ccip_afu.c b/drivers/fpga/aal/cci/ccip_afu.c
new file mode 100644
index 000000000000..51f6299e83ff
--- /dev/null
+++ b/drivers/fpga/aal/cci/ccip_afu.c
@@ -0,0 +1,698 @@
+//******************************************************************************
+// This  file  is  provided  under  a  dual BSD/GPLv2  license.  When using or
+//         redistributing this file, you may do so under either license.
+//
+//                            GPL LICENSE SUMMARY
+//
+//  Copyright(c) 2015-2017, Intel Corporation.
+//
+//  This program  is  free software;  you  can redistribute it  and/or  modify
+//  it  under  the  terms of  version 2 of  the GNU General Public License  as
+//  published by the Free Software Foundation.
+//
+//  This  program  is distributed  in the  hope that it  will  be useful,  but
+//  WITHOUT   ANY   WARRANTY;   without   even  the   implied   warranty    of
+//  MERCHANTABILITY  or  FITNESS  FOR  A  PARTICULAR  PURPOSE.  See  the   GNU
+//  General Public License for more details.
+//
+//  The  full  GNU  General Public License is  included in  this  distribution
+//  in the file called README.GPLV2-LICENSE.TXT.
+//
+//  Contact Information:
+//  Henry Mitchel, henry.mitchel at intel.com
+//  77 Reed Rd., Hudson, MA  01749
+//
+//                                BSD LICENSE
+//
+//  Copyright(c) 2015-2017, Intel Corporation.
+//
+//  Redistribution and  use  in source  and  binary  forms,  with  or  without
+//  modification,  are   permitted  provided  that  the  following  conditions
+//  are met:
+//
+//    * Redistributions  of  source  code  must  retain  the  above  copyright
+//      notice, this list of conditions and the following disclaimer.
+//    * Redistributions in  binary form  must  reproduce  the  above copyright
+//      notice,  this  list of  conditions  and  the  following disclaimer  in
+//      the   documentation   and/or   other   materials   provided  with  the
+//      distribution.
+//    * Neither   the  name   of  Intel  Corporation  nor  the  names  of  its
+//      contributors  may  be  used  to  endorse  or promote  products derived
+//      from this software without specific prior written permission.
+//
+//  THIS  SOFTWARE  IS  PROVIDED  BY  THE  COPYRIGHT HOLDERS  AND CONTRIBUTORS
+//  "AS IS"  AND  ANY  EXPRESS  OR  IMPLIED  WARRANTIES,  INCLUDING,  BUT  NOT
+//  LIMITED  TO, THE  IMPLIED WARRANTIES OF  MERCHANTABILITY  AND FITNESS  FOR
+//  A  PARTICULAR  PURPOSE  ARE  DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT
+//  OWNER OR CONTRIBUTORS BE LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,
+//  SPECIAL,  EXEMPLARY,  OR  CONSEQUENTIAL   DAMAGES  (INCLUDING,   BUT   NOT
+//  LIMITED  TO,  PROCUREMENT  OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF USE,
+//  DATA,  OR PROFITS;  OR BUSINESS INTERRUPTION)  HOWEVER  CAUSED  AND ON ANY
+//  THEORY  OF  LIABILITY,  WHETHER  IN  CONTRACT,  STRICT LIABILITY,  OR TORT
+//  (INCLUDING  NEGLIGENCE  OR OTHERWISE) ARISING  IN ANY WAY  OUT  OF THE USE
+//  OF  THIS  SOFTWARE, EVEN IF ADVISED  OF  THE  POSSIBILITY  OF SUCH DAMAGE.
+//******************************************************************************
+//****************************************************************************
+/// @file ccip_afu.c
+/// @brief  Definitions for ccip User AFU.
+/// @ingroup aalkernel_ccip
+/// @verbatim
+//        FILE: ccip_port_mmio.c
+//     CREATED: Nov 9, 2015
+//      AUTHOR:
+//
+// PURPOSE:   This file contains the implementation of the CCIP AFU
+//             low-level function (i.e., Physical Interface Protocol driver).
+// HISTORY:
+// COMMENTS:
+// WHEN:          WHO:     WHAT:
+//****************************************************************************///
+#include "aalsdk/kernel/kosal.h"
+#define MODULE_FLAGS CCIPCIE_DBG_MOD
+
+#include "aalsdk/kernel/AALTransactionID_s.h"
+#include "aalsdk/kernel/aalbus-ipip.h"
+#include "aalsdk/kernel/ccip_defs.h"
+
+#include "aalsdk/kernel/ccipdriver.h"
+#include "ccipdrv-events.h"
+
+#include "ccip_port.h"
+#include "cci_pcie_driver_PIPsession.h"
+
+///////////////////////////////////////////////////////////////////////////////
+///////////////////////////////////////////////////////////////////////////////
+////////////////////                                     //////////////////////
+/////////////////           AAL SUPPORT FUNCTIONS          ////////////////////
+////////////////////                                     //////////////////////
+///////////////////////////////////////////////////////////////////////////////
+///////////////////////////////////////////////////////////////////////////////
+
+static int CommandHandler( struct aaldev_ownerSession *,
+                           struct aal_pipmessage*);
+extern int cci_mmap(struct aaldev_ownerSession *pownerSess,
+                           struct aal_wsid *wsidp,
+                           btAny os_specific);
+
+
+//=============================================================================
+// cci_FMEpip
+// Description: Physical Interface Protocol Interface for the SPL2 AFU
+//              kernel based AFU engine.
+//=============================================================================
+struct aal_ipip cci_AFUpip = {
+   .m_messageHandler = {
+      .sendMessage   = CommandHandler,       // Command Handler
+      .bindSession   = BindSession,          // Session binder
+      .unBindSession = UnbindSession,        // Session unbinder
+   },
+
+   .m_fops = {
+     .mmap = cci_mmap,
+   },
+
+   // Methods for binding and unbinding PIP to generic aal_device
+   //  Unused in this PIP
+   .binddevice    = NULL,      // Binds the PIP to the device
+   .unbinddevice  = NULL,      // Binds the PIP to the device
+};
+
+///============================================================================
+/// Name: cci_create_AAL_UAFU_Device
+/// @brief Creates and registers User AFU object (resource) we want to
+///        expose through AAL.
+///
+/// @param[in] pportdev - Port device
+/// @param[in] paalid - Base AAL ID for this device.
+/// @return    AAL Device pointer
+///============================================================================
+struct cci_aal_device   *
+            cci_create_AAL_UAFU_Device( struct port_device        *pportdev,
+                                        btPhysAddr                 phys_mmio,
+                                        struct CCIP_AFU_Header    *pafu_hdr,
+                                        struct aal_device_id      *paalid)
+{
+   struct cci_aal_device   *pcci_aaldev = NULL;
+   int ret;
+
+   PTRACEIN;
+
+   PVERBOSE("Instantiating User AFU\n");
+   PVERBOSE("User AFU\n");
+   PVERBOSE( "> Feature_ID = %x \n",pafu_hdr->ccip_dfh.Feature_ID);
+   PVERBOSE("> Feature_rev = %x \n",pafu_hdr->ccip_dfh.Feature_rev);
+   PVERBOSE( "> Type = %x \n",pafu_hdr->ccip_dfh.Type);
+   PVERBOSE( "> afu_id_l.afu_id_l= %lx \n",( long unsigned int)pafu_hdr->ccip_afu_id_l.afu_id_l);
+   PVERBOSE( "> afu_id_h.afu_id_h= %lx \n",( long unsigned int)pafu_hdr->ccip_afu_id_h.afu_id_h);
+   PVERBOSE( "> next_DFH_offset = %x \n",pafu_hdr->ccip_dfh.next_DFH_offset);
+   PVERBOSE( "> next_afu.afu_id_offset= %x \n",pafu_hdr->ccip_next_afu.afu_id_offset);
+
+   // Construct the cci_aal_device object
+   pcci_aaldev = cci_create_aal_device();
+   ASSERT(NULL != pcci_aaldev);
+   if(NULL == pcci_aaldev ){
+      return NULL;
+   }
+
+   // Make it a User AFU
+   cci_aaldev_type(pcci_aaldev)     = cci_dev_UAFU;
+
+   // Record parentage
+   cci_aaldev_pport(pcci_aaldev)    = pportdev;       // Save its port
+   cci_aaldev_pfme(pcci_aaldev)     = ccip_port_dev_fme(pportdev);
+   cci_aaldev_pci_dev(pcci_aaldev) = ccip_dev_to_pci_dev( ccip_port_to_ccidev(pportdev) );
+
+   // Device Address is the same as the Port. Set the AFU ID information
+   // The following attributes describe the interfaces supported by the device
+   aaldevid_afuguidl(*paalid)            = pafu_hdr->ccip_afu_id_l.afu_id_l;
+   aaldevid_afuguidh(*paalid)            = pafu_hdr->ccip_afu_id_h.afu_id_h;
+   aaldevid_pipguid(*paalid)             = CCIP_AFU_PIPIID;
+
+   // Set the interface permissions
+   // Enable MMIO-R
+   cci_aaldev_set_allow_map_mmior_space(pcci_aaldev);
+
+   // Setup the MMIO region parameters
+   cci_aaldev_kvp_afu_mmio(pcci_aaldev)   = (btVirtAddr)pafu_hdr;
+   cci_aaldev_len_afu_mmio(pcci_aaldev)   = CCI_MMIO_SIZE;
+   cci_aaldev_phys_afu_mmio(pcci_aaldev)  = phys_mmio;
+
+   // Create the AAL device and attach it to the CCI device object
+   cci_aaldev_to_aaldev(pcci_aaldev)  =  aaldev_create( "CCIPAFU",          // AAL device base name
+                                                        &*paalid,             // AAL ID
+                                                        &cci_AFUpip);
+
+   //CCI device object create fails, delete AFU AAL device
+   if(NULL == cci_aaldev_to_aaldev(pcci_aaldev) ){
+      cci_destroy_aal_device(pcci_aaldev);
+      return NULL;
+   }
+
+   //===========================================================
+   // Set up the optional aal_device attributes
+   //
+
+   // Set how many owners are allowed access to this device simultaneously
+   cci_aaldev_to_aaldev(pcci_aaldev)->m_maxowners = 1;
+
+   // Set the config space mapping permissions
+   cci_aaldev_to_aaldev(pcci_aaldev)->m_mappableAPI = AAL_DEV_APIMAP_NONE;
+   if( cci_aaldev_allow_map_csr_read_space(pcci_aaldev) ){
+      cci_aaldev_to_aaldev(pcci_aaldev)->m_mappableAPI |= AAL_DEV_APIMAP_CSRWRITE;
+   }
+
+   if( cci_aaldev_allow_map_csr_write_space(pcci_aaldev) ){
+      cci_aaldev_to_aaldev(pcci_aaldev)->m_mappableAPI |= AAL_DEV_APIMAP_CSRREAD;
+   }
+
+   if( cci_aaldev_allow_map_mmior_space(pcci_aaldev) ){
+      cci_aaldev_to_aaldev(pcci_aaldev)->m_mappableAPI |= AAL_DEV_APIMAP_MMIOR;
+   }
+
+   if( cci_aaldev_allow_map_umsg_space(pcci_aaldev) ){
+      cci_aaldev_to_aaldev(pcci_aaldev)->m_mappableAPI |= AAL_DEV_APIMAP_UMSG;
+   }
+
+   // The PIP uses the PIP context to get a handle to the CCI Device from the generic device.
+   aaldev_pip_context(cci_aaldev_to_aaldev(pcci_aaldev)) = (void*)pcci_aaldev;
+
+   // Method called when the device is released (i.e., its destructor)
+   //  The canonical release device calls the user's release method.
+   //  If NULL is provided then only the canonical behavior is done
+   dev_setrelease(cci_aaldev_to_aaldev(pcci_aaldev), cci_release_device);
+
+   // Record the uAFU in the port
+   ccip_port_uafu_dev(pportdev) = pcci_aaldev;
+
+   // Device is ready for use.  Publish it with the Configuration Management Subsystem
+   ret = cci_publish_aaldevice(pcci_aaldev);
+   ASSERT(ret == 0);
+   if(0> ret){
+      PERR("Failed to initialize AAL Device for FME[%d:%d:%d:%d]",aaldevid_devaddr_busnum(*paalid),
+                                                                  aaldevid_devaddr_devnum(*paalid),
+                                                                  aaldevid_devaddr_fcnnum(*paalid),
+                                                                  aaldevid_devaddr_subdevnum(*paalid));
+      cci_destroy_aal_device(pcci_aaldev);
+      ccip_port_uafu_dev(pportdev) = NULL;
+      return NULL;
+   }
+
+   PTRACEOUT;
+   return pcci_aaldev;
+}
+
+//=============================================================================
+// Name: CommandHandler
+// Description: Implements the PIP command handler
+// Interface: public
+// Inputs: pownerSess - Session between App and device
+//         Message - Message to process
+// Outputs: none.
+// Comments:
+//=============================================================================
+int
+CommandHandler(struct aaldev_ownerSession *pownerSess,
+               struct aal_pipmessage      *Message)
+{
+#if (1 == ENABLE_DEBUG)
+#define AFU_COMMAND_CASE(x) case x : PDEBUG("%s\n", #x);
+#else
+#define AFU_COMMAND_CASE(x) case x :
+#endif // ENABLE_DEBUG
+
+   // Private session object set at session bind time (i.e., when object allocated)
+   struct cci_PIPsession *pSess = (struct cci_PIPsession *)aalsess_pipHandle(pownerSess);
+   struct cci_aal_device  *pdev  = NULL;
+
+   // Overall return value for this function. Set before exiting if there is an error.
+   //    retval = 0 means good return.
+   int retval = 0;
+   // if we return a request error, return this.  usually it's an invalid request error.
+   uid_errnum_e request_error       = uid_errnumInvalidRequest;
+
+   // UI Driver message
+   struct aalui_CCIdrvMessage *pmsg = (struct aalui_CCIdrvMessage *) Message->m_message;
+
+   // Save original response buffer size in case we return something
+   btWSSize         respBufSize     = Message->m_respbufSize;
+
+   // Assume returning nothing. By setting the response buffer size to 0
+   //   we tell the upstream side that there is no payload to copy back.
+   //   Setting it here means we don't have to set it (or forget to) in each
+   //   command.  We've recorded the payload buffer size above if we do need
+   //   intend to send a payload.
+   Message->m_respbufSize          = 0;
+
+   PTRACEIN;
+
+   // Perform some basic checks while assigning the pdev
+   ASSERT(NULL != pSess );
+   if ( NULL == pSess ) {
+      PDEBUG("Error: No PIP session\n");
+      return -EIO;
+   }
+
+   // Get the cci device
+   pdev = cci_PIPsessionp_to_ccidev(pSess);
+   if ( NULL == pdev ) {
+      PDEBUG("Error: No device\n");
+      return -EIO;
+   }
+
+   //=====================
+   // Message processor
+   //=====================
+   switch ( pmsg->cmd ) {
+
+      AFU_COMMAND_CASE(ccipdrv_afucmdPort_afuQuiesceAndHalt) {
+         if(0 != port_afu_quiesce_and_halt( cci_aaldev_pport(pdev) )){
+            // Failure event
+            PERR("TIMEOUT\n");
+            Message->m_errcode = uid_errnumTimeout;
+            break;
+         }
+
+         // Success Event
+         Message->m_errcode = uid_errnumOK;
+
+      } break;
+
+      AFU_COMMAND_CASE(ccipdrv_afucmdPort_afuEnable) {
+         if(0 != port_afu_Enable( cci_aaldev_pport(pdev) )){
+            PERR("TIMEOUT\n");
+            // Failure event
+            Message->m_errcode = uid_errnumTimeout;
+            break;
+         }
+
+         // Success Event
+         Message->m_errcode = uid_errnumOK;
+
+      } break;
+
+
+      // Returns a workspace ID for the Config Space
+      AFU_COMMAND_CASE(ccipdrv_getMMIORmap) {
+         struct ccidrvreq *preq = (struct ccidrvreq *)pmsg->payload;
+         struct aalui_WSMEvent WSID;
+         struct aal_wsid   *wsidp            = NULL;
+
+         if ( !cci_aaldev_allow_map_mmior_space(pdev) ) {
+            PERR("Failed ccipdrv_getMMIOR map Permission\n");
+            PERR("Direct API access not permitted on this device\n");
+            Message->m_errcode = uid_errnumPermission;
+            break;
+         }
+
+         //------------------------------------------------------------
+         // Create the WSID object and add to the list for this session
+         //------------------------------------------------------------
+         if ( WSID_MAP_MMIOR != preq->ahmreq.u.wksp.m_wsid ) {
+            PERR("Failed ccipdrv_getMMIOR map Parameter\n");
+
+            PERR("Bad WSID on ccipdrv_getMMIORmap\n");
+            Message->m_errcode = uid_errnumBadParameter;
+            break;
+         }
+
+         wsidp = ccidrv_getwsid(pownerSess->m_device, preq->ahmreq.u.wksp.m_wsid);
+         if ( NULL == wsidp ) {
+            PERR("Could not allocate workspace\n");
+            retval = -ENOMEM;
+            /* generate a failure event back to the caller? */
+            goto ERROR;
+         }
+
+         wsidp->m_type = WSM_TYPE_MMIO;
+         PDEBUG("Getting CSR %s Aperature WSID %p using id %llx .\n",
+                   ((WSID_CSRMAP_WRITEAREA == preq->ahmreq.u.wksp.m_wsid) ? "Write" : "Read"),
+                   wsidp,
+                   preq->ahmreq.u.wksp.m_wsid);
+
+         PDEBUG("Apt = %" PRIxPHYS_ADDR " Len = %d.\n",cci_aaldev_phys_afu_mmio(pdev), (int)cci_aaldev_len_afu_mmio(pdev));
+
+         // Set up the return payload
+         WSID.evtID           = uid_wseventMMIOMap;
+         WSID.wsParms.wsid    = pwsid_to_wsidHandle(wsidp);
+         WSID.wsParms.physptr = cci_aaldev_phys_afu_mmio(pdev);
+         WSID.wsParms.size    = cci_aaldev_len_afu_mmio(pdev);
+
+         // Make this atomic. Check the original response buffer size for room
+         if(respBufSize >= sizeof(struct aalui_WSMEvent)){
+            *((struct aalui_WSMEvent*)Message->m_response) = WSID;
+            Message->m_respbufSize = sizeof(struct aalui_WSMEvent);
+         }else{
+            PERR("No room to return WSID. Required sized %ld but size provided %ld\n", sizeof(struct aalui_WSMEvent), (long int)respBufSize);
+            Message->m_errcode = uid_errnumNoMem;
+            ccidrv_freewsid(wsidp);
+            break;
+         }
+         PDEBUG("Buf size =  %u Returning WSID %llx\n",(unsigned int)Message->m_respbufSize, WSID.wsParms.wsid  );
+         Message->m_errcode = uid_errnumOK;
+
+         // Add the new wsid onto the session
+         aalsess_add_ws(pownerSess, wsidp->m_list);
+
+      } break;
+
+      AFU_COMMAND_CASE(ccipdrv_afucmdWKSP_ALLOC)
+      {
+         struct ccidrvreq    *preq        = (struct ccidrvreq *)pmsg->payload;
+         btVirtAddr           krnl_virt   = NULL;
+         struct aal_wsid     *wsidp       = NULL;
+         struct aalui_WSMEvent WSID;
+         btHANDLE             iova        = NULL;;
+
+         PDEBUG( "Allocating %lu bytes \n", (unsigned long)preq->ahmreq.u.wksp.m_size);
+         if( NULL== cci_aaldev_pci_dev(pdev) ) {
+            // Normal flow -- create the needed workspace.
+            krnl_virt = (btVirtAddr)kosal_alloc_contiguous_mem_nocache(preq->ahmreq.u.wksp.m_size);
+            if (NULL == krnl_virt) {
+               Message->m_errcode = uid_errnumNoMem;
+               break;
+            }
+         }else{
+            krnl_virt = kosal_alloc_dma_coherent( ccip_dev_pci_dev(pdev), preq->ahmreq.u.wksp.m_size, &iova);
+            if (NULL == krnl_virt) {
+               Message->m_errcode = uid_errnumNoMem;
+               break;
+            }
+         }
+         //------------------------------------------------------------
+         // Create the WSID object and add to the list for this session
+         //------------------------------------------------------------
+         wsidp = ccidrv_getwsid(pownerSess->m_device, (btWSID)krnl_virt);
+         if ( NULL == wsidp ) {
+            PERR("Couldn't allocate task workspace\n");
+            retval = -ENOMEM;
+            /* send a failure event back to the caller? */
+            goto ERROR;
+         }
+
+         wsidp->m_size = preq->ahmreq.u.wksp.m_size;
+         wsidp->m_type = WSM_TYPE_VIRTUAL;
+         PDEBUG("Creating Physical WSID %p.\n", wsidp);
+
+         // Add the new wsid onto the session
+         aalsess_add_ws(pownerSess, wsidp->m_list);
+
+         PINFO("CCI WS alloc wsid=0x%" PRIx64 " phys=0x%" PRIxPHYS_ADDR  " kvp=0x%" PRIx64 " size=%" PRIu64 " success!\n",
+                  preq->ahmreq.u.wksp.m_wsid,
+                  kosal_virt_to_phys((btVirtAddr)wsidp->m_id),
+                  wsidp->m_id,
+                  wsidp->m_size);
+
+         // Set up the return payload
+         WSID.evtID           = uid_wseventAllocate;
+         WSID.wsParms.wsid    = pwsid_to_wsidHandle(wsidp);
+         if( NULL== cci_aaldev_pci_dev(pdev) ) {
+            WSID.wsParms.physptr = (btWSID)kosal_virt_to_phys(krnl_virt);
+            wsidp->m_dmahandle = (btHANDLE)kosal_virt_to_phys(krnl_virt);
+         }else{
+            WSID.wsParms.physptr = (btWSID)iova;
+            wsidp->m_dmahandle = iova;
+         }
+         WSID.wsParms.size    = preq->ahmreq.u.wksp.m_size;
+
+         // Make this atomic. Check the original response buffer size for room
+         if(respBufSize >= sizeof(struct aalui_WSMEvent)){
+            *((struct aalui_WSMEvent*)Message->m_response) = WSID;
+            Message->m_respbufSize = sizeof(struct aalui_WSMEvent);
+         }
+         PDEBUG("Buf size =  %u Returning WSID %llx\n",(unsigned int)Message->m_respbufSize, WSID.wsParms.wsid  );
+         Message->m_errcode = uid_errnumOK;
+
+      } break; // case fappip_afucmdWKSP_VALLOC
+
+
+      //============================
+      //  Free Workspace
+      //============================
+      AFU_COMMAND_CASE(ccipdrv_afucmdWKSP_FREE) {
+         struct ccidrvreq    *preq        = (struct ccidrvreq *)pmsg->payload;
+         btVirtAddr           krnl_virt   = NULL;
+         struct aal_wsid     *wsidp       = NULL;
+
+         ASSERT(0 != preq->ahmreq.u.wksp.m_wsid);
+         if ( 0 == preq->ahmreq.u.wksp.m_wsid ) {
+            PDEBUG("WKSP_IOC_FREE: WS id can't be 0.\n");
+            Message->m_errcode = uid_errnumBadParameter;
+            break;
+         }
+
+         // Get the workspace ID object
+         wsidp = ccidrv_valwsid(preq->ahmreq.u.wksp.m_wsid);
+
+         ASSERT(wsidp);
+         if ( NULL == wsidp ) {
+            Message->m_errcode = uid_errnumBadParameter;
+            break;
+         }
+
+         // Free the buffer
+         if(  WSM_TYPE_VIRTUAL != wsidp->m_type ) {
+            PDEBUG( "Workspace free failed due to bad WS type. Should be %d but received %d\n",WSM_TYPE_VIRTUAL,
+                  wsidp->m_type);
+
+            Message->m_errcode = uid_errnumBadParameter;
+            break;
+         }
+
+         krnl_virt = (btVirtAddr)wsidp->m_id;
+         if( NULL== cci_aaldev_pci_dev(pdev) ) {
+            kosal_free_contiguous_mem(krnl_virt, wsidp->m_size);
+         }else{
+            kosal_free_dma_coherent( ccip_dev_pci_dev(pdev), krnl_virt, wsidp->m_size, wsidp->m_dmahandle);
+         }
+
+         // remove the wsid from the device and destroy
+         kosal_list_del_init(&wsidp->m_list);
+         ccidrv_freewsid(wsidp);
+
+         PVERBOSE("Sending the WKSP Free event.\n");
+         Message->m_errcode = uid_errnumOK;
+
+      } break; // case fappip_afucmdWKSP_FREE
+
+      //============================
+      //  Get number of uMSGs
+      //============================
+      AFU_COMMAND_CASE(ccipdrv_afucmdGetNumUmsgs) {
+         struct ccidrvreq    *presp                         = (struct ccidrvreq *)Message->m_response;
+         struct CCIP_PORT_DFL_UMSG            *puMsgvirt    = NULL;
+
+         if(false == get_port_feature( cci_aaldev_pport(pdev),
+                                       CCIP_PORT_DFLID_USMG,
+                                       NULL,
+                                       (btVirtAddr*)&puMsgvirt)){
+            Message->m_errcode = uid_errnumNoMap;
+            break;
+         }
+         PVERBOSE("uMSG feature Header %p\n", puMsgvirt);
+
+         PVERBOSE("Returning number of uMSGs = %d.\n",puMsgvirt->ccip_umsg_capability.no_umsg_alloc_port);
+         presp->ahmreq.u.mem_uv2id.mem_id = puMsgvirt->ccip_umsg_capability.no_umsg_alloc_port;
+         Message->m_respbufSize = respBufSize;
+         Message->m_errcode = uid_errnumOK;
+
+      } break; // case ccipdrv_afucmdGetNumUmsgs
+
+      //============================
+      //  Set uMSG Mode
+      //============================
+      AFU_COMMAND_CASE(ccipdrv_afucmdSetUmsgMode) {
+         struct ccidrvreq    *preq                          = (struct ccidrvreq *)pmsg->payload;
+         struct CCIP_PORT_DFL_UMSG            *puMsgvirt    = NULL;
+
+         if(false == get_port_feature( cci_aaldev_pport(pdev),
+                                       CCIP_PORT_DFLID_USMG,
+                                       NULL,
+                                       (btVirtAddr*)&puMsgvirt)){
+            Message->m_errcode = uid_errnumNoMap;
+            break;
+         }
+         PVERBOSE("uMSG feature Header %llx\n", (0xFFFFFFFF & preq->ahmreq.u.wksp.m_wsid));
+
+         puMsgvirt->ccip_umsg_mode.umsg_hit = (0xFFFFFFFF & preq->ahmreq.u.wksp.m_wsid);
+         Message->m_errcode = uid_errnumOK;
+
+      } break; // case ccipdrv_afucmdSetUmsgMode
+
+      AFU_COMMAND_CASE(ccipdrv_afucmdGet_UmsgBase)
+      {
+         struct ccidrvreq              *preq          = (struct ccidrvreq *)pmsg->payload;
+         struct CCIP_PORT_DFL_UMSG     *puMsgvirt     = NULL;
+         btVirtAddr                     krnl_virt     = NULL;
+         struct aal_wsid               *wsidp         = NULL;
+         struct aalui_WSMEvent          WSID;
+         btWSSize                       size          = 0;
+         btHANDLE                       iova          = 0;
+
+
+         if(false == get_port_feature( cci_aaldev_pport(pdev),
+                                       CCIP_PORT_DFLID_USMG,
+                                       NULL,
+                                       (btVirtAddr*)&puMsgvirt)){
+            Message->m_errcode = uid_errnumNoMap;
+            break;
+         }
+
+         if( 0 != puMsgvirt->ccip_umsg_base_address.umsg_base_address){
+            Message->m_errcode = uid_errnumInvalidRequest;
+            PERR("uMSG base already set\n");
+            break;
+         }
+         size = puMsgvirt->ccip_umsg_capability.no_umsg_alloc_port * CCIP_UMSG_SIZE;
+         PDEBUG( "Allocating %lu bytes for uMSG\n", (unsigned long)size);
+
+         // Normal flow -- create the needed workspace.
+         if( NULL== cci_aaldev_pci_dev(pdev) ) {
+            // Normal flow -- create the needed workspace.
+            krnl_virt = (btVirtAddr)kosal_alloc_contiguous_mem_nocache(size);
+            if (NULL == krnl_virt) {
+               Message->m_errcode = uid_errnumNoMem;
+               break;
+            }
+            puMsgvirt->ccip_umsg_base_address.umsg_base_address = kosal_virt_to_phys(krnl_virt);
+         }else{
+            krnl_virt = kosal_alloc_dma_coherent( ccip_dev_pci_dev(pdev),size, &iova);
+            if (NULL == krnl_virt) {
+               Message->m_errcode = uid_errnumNoMem;
+               break;
+            }
+            puMsgvirt->ccip_umsg_base_address.umsg_base_address = (btPhysAddr)iova;
+         }
+
+
+         // Set the uMSG area
+         PDEBUG("uMSG @ %p [%" PRIxPHYS_ADDR "]\n", krnl_virt, (btPhysAddr)puMsgvirt->ccip_umsg_base_address.umsg_base_address);
+
+         // Enable uMsg operation
+         // FIXME: Disable UMSgs until BBS bug with Readline_S is resolved
+         puMsgvirt->ccip_umsg_capability.status_umsg_engine = 0;
+         {
+            // Wait for the uMSG engine to start
+            btTime delay = 10;
+            btTime totaldelay = 0;
+
+            while(0 == puMsgvirt->ccip_umsg_capability.umsg_init_status)
+            {
+               // Sleep
+               kosal_udelay(delay);
+
+               // total delay
+               totaldelay = totaldelay + delay;
+               if (totaldelay > 1000)   {
+                  PDEBUG("Timed out waiting for uMSG engine to start\n");
+                  Message->m_errcode = uid_errnumTimeout;
+                  puMsgvirt->ccip_umsg_base_address.umsg_base_address = 0;
+
+                  if( NULL== cci_aaldev_pci_dev(pdev) ) {
+                     kosal_free_contiguous_mem(krnl_virt, size);
+                  }else{
+                     kosal_free_dma_coherent( ccip_dev_pci_dev(pdev), krnl_virt, size, iova);
+                  }
+
+                  return 0;
+               }
+            }
+         }
+
+         //------------------------------------------------------------
+         // Create the WSID object and add to the list for this session
+         //------------------------------------------------------------
+         wsidp = ccidrv_getwsid(pownerSess->m_device, (btWSID)krnl_virt);
+         if ( NULL == wsidp ) {
+            PERR("Couldn't allocate task workspace\n");
+            retval = -ENOMEM;
+            /* send a failure event back to the caller? */
+            goto ERROR;
+         }
+
+         wsidp->m_size = size;
+         wsidp->m_type = WSM_TYPE_VIRTUAL;
+         PDEBUG("Creating uMSG WSID %p.\n", wsidp);
+
+         // Add the new wsid onto the session
+         aalsess_add_ws(pownerSess, wsidp->m_list);
+
+         PINFO("CCI uMSG wsid=0x%" PRIx64 " phys=0x%" PRIxPHYS_ADDR  " kvp=0x%" PRIx64 " size=%" PRIu64 " success!\n",
+                  preq->ahmreq.u.wksp.m_wsid,
+                  kosal_virt_to_phys((btVirtAddr)wsidp->m_id),
+                  wsidp->m_id,
+                  wsidp->m_size);
+
+         // Set up the return payload
+         WSID.evtID           = uid_wseventAllocate;
+         WSID.wsParms.wsid    = pwsid_to_wsidHandle(wsidp);
+         WSID.wsParms.physptr = (btWSID) puMsgvirt->ccip_umsg_base_address.umsg_base_address;
+         WSID.wsParms.size    = size;
+
+         // Make this atomic. Check the original response buffer size for room
+         if(respBufSize >= sizeof(struct aalui_WSMEvent)){
+            *((struct aalui_WSMEvent*)Message->m_response) = WSID;
+            Message->m_respbufSize = sizeof(struct aalui_WSMEvent);
+            PDEBUG("Buf size =  %u Returning WSID %llx\n",(unsigned int)Message->m_respbufSize, WSID.wsParms.wsid  );
+            Message->m_errcode = uid_errnumOK;
+         }else{
+            PERR("No room to return WSID\n");
+            Message->m_errcode = uid_errnumNoMem;
+         }
+
+
+      } break; // case ccipdrv_afucmdGet_UmsgBase
+
+
+      default: {
+
+         PDEBUG("Unrecognized command %" PRIu64 " or 0x%" PRIx64 " in AFUCommand\n", pmsg->cmd, pmsg->cmd);
+         Message->m_errcode = request_error;
+         retval = -EINVAL;
+      } break;
+   } // switch (pmsg->cmd)
+
+   ASSERT(0 == retval);
+
+ERROR:
+   return retval;
+}
diff --git a/drivers/fpga/aal/cci/ccip_fme.c b/drivers/fpga/aal/cci/ccip_fme.c
new file mode 100644
index 000000000000..dd78fbb3e3cf
--- /dev/null
+++ b/drivers/fpga/aal/cci/ccip_fme.c
@@ -0,0 +1,890 @@
+//******************************************************************************
+// This  file  is  provided  under  a  dual BSD/GPLv2  license.  When using or
+//         redistributing this file, you may do so under either license.
+//
+//                            GPL LICENSE SUMMARY
+//
+//  Copyright(c) 2015-2017, Intel Corporation.
+//
+//  This program  is  free software;  you  can redistribute it  and/or  modify
+//  it  under  the  terms of  version 2 of  the GNU General Public License  as
+//  published by the Free Software Foundation.
+//
+//  This  program  is distributed  in the  hope that it  will  be useful,  but
+//  WITHOUT   ANY   WARRANTY;   without   even  the   implied   warranty    of
+//  MERCHANTABILITY  or  FITNESS  FOR  A  PARTICULAR  PURPOSE.  See  the   GNU
+//  General Public License for more details.
+//
+//  The  full  GNU  General Public License is  included in  this  distribution
+//  in the file called README.GPLV2-LICENSE.TXT.
+//
+//  Contact Information:
+//  Henry Mitchel, henry.mitchel at intel.com
+//  77 Reed Rd., Hudson, MA  01749
+//
+//                                BSD LICENSE
+//
+//  Copyright(c) 2015-2017, Intel Corporation.
+//
+//  Redistribution and  use  in source  and  binary  forms,  with  or  without
+//  modification,  are   permitted  provided  that  the  following  conditions
+//  are met:
+//
+//    * Redistributions  of  source  code  must  retain  the  above  copyright
+//      notice, this list of conditions and the following disclaimer.
+//    * Redistributions in  binary form  must  reproduce  the  above copyright
+//      notice,  this  list of  conditions  and  the  following disclaimer  in
+//      the   documentation   and/or   other   materials   provided  with  the
+//      distribution.
+//    * Neither   the  name   of  Intel  Corporation  nor  the  names  of  its
+//      contributors  may  be  used  to  endorse  or promote  products derived
+//      from this software without specific prior written permission.
+//
+//  THIS  SOFTWARE  IS  PROVIDED  BY  THE  COPYRIGHT HOLDERS  AND CONTRIBUTORS
+//  "AS IS"  AND  ANY  EXPRESS  OR  IMPLIED  WARRANTIES,  INCLUDING,  BUT  NOT
+//  LIMITED  TO, THE  IMPLIED WARRANTIES OF  MERCHANTABILITY  AND FITNESS  FOR
+//  A  PARTICULAR  PURPOSE  ARE  DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT
+//  OWNER OR CONTRIBUTORS BE LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,
+//  SPECIAL,  EXEMPLARY,  OR  CONSEQUENTIAL   DAMAGES  (INCLUDING,   BUT   NOT
+//  LIMITED  TO,  PROCUREMENT  OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF USE,
+//  DATA,  OR PROFITS;  OR BUSINESS INTERRUPTION)  HOWEVER  CAUSED  AND ON ANY
+//  THEORY  OF  LIABILITY,  WHETHER  IN  CONTRACT,  STRICT LIABILITY,  OR TORT
+//  (INCLUDING  NEGLIGENCE  OR OTHERWISE) ARISING  IN ANY WAY  OUT  OF THE USE
+//  OF  THIS  SOFTWARE, EVEN IF ADVISED  OF  THE  POSSIBILITY  OF SUCH DAMAGE.
+//******************************************************************************
+//****************************************************************************
+/// @file ccip_fme.c
+/// @brief  Implements the FPGA Management Engine (FME).
+/// @ingroup aalkernel_ccip
+/// @verbatim
+//        FILE: ccip_fme.c
+//     CREATED: Sept 24, 2015
+//      AUTHOR: Ananda Ravuri, Intel <ananda.ravuri@intel.com>
+//              Joseph Grecco, Intel <joe.grecco@intel.com>
+//
+// PURPOSE:   This file contains the definations of the CCIP FME
+//             Device Feature List and CSR.
+// HISTORY:
+// COMMENTS:
+// WHEN:          WHO:     WHAT:
+//****************************************************************************///
+#include "aalsdk/kernel/kosal.h"
+
+#define MODULE_FLAGS CCIPCIE_DBG_MOD // Prints all
+
+#include "aalsdk/kernel/AALTransactionID_s.h"
+#include "aalsdk/kernel/aalbus-ipip.h"
+
+#include "aalsdk/kernel/ccipdriver.h"
+#include "ccipdrv-events.h"
+#include "ccip_perfmon.h"
+#include "aalsdk/kernel/ccip_defs.h"
+#include "ccip_fme.h"
+#include "cci_pcie_driver_PIPsession.h"
+
+
+
+///////////////////////////////////////////////////////////////////////////////
+///////////////////////////////////////////////////////////////////////////////
+////////////////////                                     //////////////////////
+/////////////////          AAL SUPPORT FUNCTIONS           ////////////////////
+////////////////////                                     //////////////////////
+///////////////////////////////////////////////////////////////////////////////
+///////////////////////////////////////////////////////////////////////////////
+
+static int CommandHandler( struct aaldev_ownerSession *,
+                           struct aal_pipmessage*);
+extern int cci_mmap( struct aaldev_ownerSession *pownerSess,
+                     struct aal_wsid *wsidp,
+                     btAny os_specific);
+
+//=============================================================================
+// cci_FMEpip
+// Description: Physical Interface Protocol Interface for the SPL2 AFU
+//              kernel based AFU engine.
+//=============================================================================
+struct aal_ipip cci_FMEpip = {
+   .m_messageHandler = {
+      .sendMessage   = CommandHandler,       // Command Handler
+      .bindSession   = BindSession,          // Session binder
+      .unBindSession = UnbindSession,        // Session unbinder
+   },
+
+   .m_fops = {
+     .mmap = cci_mmap,
+   },
+
+   // Methods for binding and unbinding PIP to generic aal_device
+   //  Unused in this PIP
+   .binddevice    = NULL,      // Binds the PIP to the device
+   .unbinddevice  = NULL,      // Binds the PIP to the device
+};
+
+
+//=============================================================================
+// Name: CommandHandler
+// Description: Implements the PIP command handler
+// Interface: public
+// Inputs: pownerSess - Session between App and device
+//         Message - Message to process
+// Outputs: none.
+// Comments:
+//=============================================================================
+int
+CommandHandler(struct aaldev_ownerSession *pownerSess,
+               struct aal_pipmessage      *Message)
+{
+#if (1 == ENABLE_DEBUG)
+#define AFU_COMMAND_CASE(x) case x : PDEBUG("%s\n", #x);
+#else
+#define AFU_COMMAND_CASE(x) case x :
+#endif // ENABLE_DEBUG
+
+   // Private session object set at session bind time (i.e., when object allocated)
+   struct cci_PIPsession *pSess = (struct cci_PIPsession *)aalsess_pipHandle(pownerSess);
+   struct cci_aal_device  *pdev  = NULL;
+
+   // Overall return value for this function. Set before exiting if there is an error.
+   //    retval = 0 means good return.
+   int retval = 0;
+
+   // UI Driver message
+   struct aalui_CCIdrvMessage *pmsg = (struct aalui_CCIdrvMessage *) Message->m_message;
+
+   // Save original response buffer size in case we return something
+   btWSSize         respBufSize     = Message->m_respbufSize;
+
+
+   // if we return a request error, return this.  usually it's an invalid request error.
+   uid_errnum_e request_error = uid_errnumInvalidRequest;
+
+   PINFO("In CCI Command handler, AFUCommand().\n");
+
+   // Perform some basic checks while assigning the pdev
+   ASSERT(NULL != pSess );
+   if ( NULL == pSess ) {
+      PDEBUG("Error: No PIP session\n");
+      return -EIO;
+   }
+
+   // Get the cci device
+   pdev = cci_PIPsessionp_to_ccidev(pSess);
+   if ( NULL == pdev ) {
+      PDEBUG("Error: No device\n");
+      return -EIO;
+   }
+
+   //=====================
+   // Message processor
+   //=====================
+   switch ( pmsg->cmd ) {
+
+      // Returns a workspace ID for the Config Space
+      AFU_COMMAND_CASE(ccipdrv_getMMIORmap) {
+         struct ccidrvreq *preq = (struct ccidrvreq *)pmsg->payload;
+         struct aalui_WSMEvent WSID;
+         struct aal_wsid   *wsidp            = NULL;
+
+         if ( !cci_aaldev_allow_map_mmior_space(pdev) ) {
+            PERR("Failed ccipdrv_getMMIOR map Permission\n");
+            PERR("Direct API access not permitted on this device\n");
+            Message->m_errcode = uid_errnumPermission;
+            break;
+         }
+
+         //------------------------------------------------------------
+         // Create the WSID object and add to the list for this session
+         //------------------------------------------------------------
+         if ( WSID_MAP_MMIOR != preq->ahmreq.u.wksp.m_wsid ) {
+            PERR("Failed ccipdrv_getMMIOR map Parameter\n");
+
+            PERR("Bad WSID on ccipdrv_getMMIORmap\n");
+            Message->m_errcode = uid_errnumBadParameter;
+            break;
+         }
+
+         wsidp = ccidrv_getwsid(pownerSess->m_device, preq->ahmreq.u.wksp.m_wsid);
+         if ( NULL == wsidp ) {
+            PERR("Could not allocate workspace\n");
+            retval = -ENOMEM;
+            /* generate a failure event back to the caller? */
+            goto ERROR;
+         }
+
+         wsidp->m_type = WSM_TYPE_MMIO;
+         PDEBUG("Getting CSR %s Aperature WSID %p using id %llx .\n",
+                   ((WSID_CSRMAP_WRITEAREA == preq->ahmreq.u.wksp.m_wsid) ? "Write" : "Read"),
+                   wsidp,
+                   preq->ahmreq.u.wksp.m_wsid);
+
+         PDEBUG("Apt = %" PRIxPHYS_ADDR " Len = %d.\n",cci_aaldev_phys_afu_mmio(pdev), (int)cci_aaldev_len_afu_mmio(pdev));
+
+         // Set up the return payload
+         WSID.evtID           = uid_wseventMMIOMap;
+         WSID.wsParms.wsid    = pwsid_to_wsidHandle(wsidp);
+         WSID.wsParms.physptr = cci_aaldev_phys_afu_mmio(pdev);
+         WSID.wsParms.size    = cci_aaldev_len_afu_mmio(pdev);
+
+         // Make this atomic. Check the original response buffer size for room
+         if(respBufSize >= sizeof(struct aalui_WSMEvent)){
+            *((struct aalui_WSMEvent*)Message->m_response) = WSID;
+            Message->m_respbufSize = sizeof(struct aalui_WSMEvent);
+         }
+         PDEBUG("Buf size =  %u Returning WSID %llx\n",(unsigned int)Message->m_respbufSize, WSID.wsParms.wsid  );
+         Message->m_errcode = uid_errnumOK;
+
+         // Add the new wsid onto the session
+         aalsess_add_ws(pownerSess, wsidp->m_list);
+
+      } break;
+
+      AFU_COMMAND_CASE(ccipdrv_getPerfMonitor) {
+
+         bt32bitInt res;
+         struct CCIP_PERF_COUNTERS perfcounter;
+         PVERBOSE("ccipdrv_getPerfMonitor \n");
+
+         res= get_perfmon_counters(cci_aaldev_pfme(pdev) ,&perfcounter);
+         if(0 != res )
+         {
+            Message->m_errcode = uid_errnumPermission;
+                   break;
+         }
+
+        if(respBufSize >= sizeof(struct CCIP_PERF_COUNTERS)){
+           PVERBOSE("ccipdrv_getPerfMonitor  Valid Buffer\n");
+           *((struct CCIP_PERF_COUNTERS*)Message->m_response) = perfcounter;
+           Message->m_respbufSize = sizeof(struct CCIP_PERF_COUNTERS);
+        }
+
+         Message->m_errcode = uid_errnumOK;
+
+      } break; // case ccipdrv_getPerfMonitor
+
+      AFU_COMMAND_CASE(ccipdrv_getFMEError) {
+
+          bt32bitInt res               = 0;
+          struct CCIP_ERROR fme_error  = {0};
+
+          PVERBOSE("ccipdrv_getFmeError \n");
+
+          res= get_fme_error(cci_aaldev_pfme(pdev) ,&fme_error);
+          if(0 != res ) {
+             Message->m_errcode = uid_errnumBadParameter;
+             break;
+          }
+
+         if(respBufSize >= sizeof(struct CCIP_ERROR)){
+            PVERBOSE("ccipdrv_getFmeErrors  Valid Buffer\n");
+            *((struct CCIP_ERROR*)Message->m_response) = fme_error;
+            Message->m_respbufSize = sizeof(struct CCIP_ERROR);
+         }
+
+          Message->m_errcode = uid_errnumOK;
+
+       } break; // case ccipdrv_getFMEError
+
+       AFU_COMMAND_CASE(ccipdrv_SetFMEErrorMask) {
+
+          struct ccidrvreq *preq = (struct ccidrvreq *)pmsg->payload;
+          PVERBOSE("ccipdrv_fmeSetErrorMask \n");
+
+          if(NULL == preq) {
+             Message->m_errcode = uid_errnumBadParameter;
+             break;
+          }
+
+ 
+          if(0 != preq->ahmreq.u.error_csr.error0 )   {
+             ccip_fme_gerr(cci_aaldev_pfme(pdev))->fme_err_mask.csr = preq->ahmreq.u.error_csr.error0;
+          }
+
+          if(0 != preq->ahmreq.u.error_csr.pcie0_err )   {
+             ccip_fme_gerr(cci_aaldev_pfme(pdev))->pcie0_err_mask.csr = preq->ahmreq.u.error_csr.pcie0_err;
+          }
+
+          if(0 != preq->ahmreq.u.error_csr.pcie1_err )   {
+             ccip_fme_gerr(cci_aaldev_pfme(pdev))->pcie1_err_mask.csr = preq->ahmreq.u.error_csr.pcie1_err;
+          }
+
+          if(0 != preq->ahmreq.u.error_csr.ras_gerr )   {
+             ccip_fme_gerr(cci_aaldev_pfme(pdev))->ras_gerr_mask.csr = preq->ahmreq.u.error_csr.ras_gerr;
+          }
+
+          if(0 != preq->ahmreq.u.error_csr.ras_berror )   {
+             ccip_fme_gerr(cci_aaldev_pfme(pdev))->ras_berror_mask.csr = preq->ahmreq.u.error_csr.ras_berror;
+          }
+
+          if(0 != preq->ahmreq.u.error_csr.ras_warnerror )   {
+             ccip_fme_gerr(cci_aaldev_pfme(pdev))->ras_warnerror_mask.csr = preq->ahmreq.u.error_csr.ras_warnerror;
+          }
+
+          //Success Event
+          Message->m_errcode = uid_errnumOK;
+
+        } break; // case ccipdrv_SetFMEErrorMask
+
+
+        AFU_COMMAND_CASE(ccipdrv_ClearFMEError) {
+
+           struct ccidrvreq *preq = (struct ccidrvreq *)pmsg->payload;
+           PVERBOSE("ccipdrv_fmeClearError \n");
+
+           if(NULL == preq) {
+              Message->m_errcode = uid_errnumBadParameter;
+              break;
+           }
+
+           PVERBOSE("error0:%llx \n",preq->ahmreq.u.error_csr.error0);
+           PVERBOSE("pcie0_err:%llx \n",preq->ahmreq.u.error_csr.pcie0_err);
+           PVERBOSE("pcie1_err:%llx \n",preq->ahmreq.u.error_csr.pcie1_err);
+
+           PVERBOSE("first_error:%llx \n",preq->ahmreq.u.error_csr.first_error);
+           PVERBOSE("next_error:%llx \n",preq->ahmreq.u.error_csr.next_error);
+
+           PVERBOSE("ras_gerr:%llx \n",preq->ahmreq.u.error_csr.ras_gerr);
+           PVERBOSE("ras_berror:%llx \n",preq->ahmreq.u.error_csr.ras_berror);
+           PVERBOSE("ras_warnerror:%llx \n",preq->ahmreq.u.error_csr.ras_warnerror);
+
+           if(0 != preq->ahmreq.u.error_csr.error0 )   {
+              ccip_fme_gerr(cci_aaldev_pfme(pdev))->fme_err.csr          = preq->ahmreq.u.error_csr.error0;
+           }
+
+           if(0 != preq->ahmreq.u.error_csr.pcie0_err )   {
+              ccip_fme_gerr(cci_aaldev_pfme(pdev))->pcie0_err.csr        = preq->ahmreq.u.error_csr.pcie0_err;
+           }
+           if(0 != preq->ahmreq.u.error_csr.pcie1_err )   {
+              ccip_fme_gerr(cci_aaldev_pfme(pdev))->pcie1_err.csr        = preq->ahmreq.u.error_csr.pcie1_err;
+           }
+
+           if(0 != preq->ahmreq.u.error_csr.first_error )   {
+              ccip_fme_gerr(cci_aaldev_pfme(pdev))->fme_first_err.csr    = preq->ahmreq.u.error_csr.first_error;
+           }
+
+           if(0 != preq->ahmreq.u.error_csr.next_error )   {
+              ccip_fme_gerr(cci_aaldev_pfme(pdev))->fme_next_err.csr     = preq->ahmreq.u.error_csr.next_error;
+           }
+
+           if(0 != preq->ahmreq.u.error_csr.ras_gerr )   {
+              ccip_fme_gerr(cci_aaldev_pfme(pdev))->ras_gerr.csr         = preq->ahmreq.u.error_csr.ras_gerr;
+           }
+
+           if(0 != preq->ahmreq.u.error_csr.ras_berror )   {
+              ccip_fme_gerr(cci_aaldev_pfme(pdev))->ras_berror.csr       = preq->ahmreq.u.error_csr.ras_berror;
+           }
+
+           if(0 != preq->ahmreq.u.error_csr.ras_warnerror )   {
+              ccip_fme_gerr(cci_aaldev_pfme(pdev))->ras_warnerror.csr    = preq->ahmreq.u.error_csr.ras_warnerror;
+           }
+
+           //Success Event
+           Message->m_errcode = uid_errnumOK;
+
+         } break; // case ccipdrv_ClearFMEError
+
+        AFU_COMMAND_CASE(ccipdrv_ClearAllFMEErrors) {
+
+           PVERBOSE("ccipdrv_ClearAllFMEError \n");
+
+           // 1) Set FME mask to all 1's to mask errors
+           // 2) Clear all errors
+           // 3) Set FME mask to all 0's to enable errors.
+           // 4) All errors starts capturing new errors
+
+            // Set FME mask to all 1's to mask errors
+           ccip_fme_gerr(cci_aaldev_pfme(pdev))->fme_err_mask.csr         = CLEAR_ALL_ERRORS;
+           ccip_fme_gerr(cci_aaldev_pfme(pdev))->pcie0_err_mask.csr       = CLEAR_ALL_ERRORS;
+           ccip_fme_gerr(cci_aaldev_pfme(pdev))->pcie1_err_mask.csr       = CLEAR_ALL_ERRORS;
+           ccip_fme_gerr(cci_aaldev_pfme(pdev))->ras_gerr_mask.csr        = CLEAR_ALL_ERRORS;
+           ccip_fme_gerr(cci_aaldev_pfme(pdev))->ras_berror_mask.csr      = CLEAR_ALL_ERRORS;
+           ccip_fme_gerr(cci_aaldev_pfme(pdev))->ras_warnerror_mask.csr   = CLEAR_ALL_ERRORS;
+
+           //Clear all errors
+           ccip_fme_gerr(cci_aaldev_pfme(pdev))->fme_err.csr              = CLEAR_ALL_ERRORS;
+           ccip_fme_gerr(cci_aaldev_pfme(pdev))->pcie0_err.csr            = CLEAR_ALL_ERRORS;
+           ccip_fme_gerr(cci_aaldev_pfme(pdev))->pcie1_err.csr            = CLEAR_ALL_ERRORS;
+
+           ccip_fme_gerr(cci_aaldev_pfme(pdev))->fme_first_err.csr        = CLEAR_ALL_ERRORS;
+           ccip_fme_gerr(cci_aaldev_pfme(pdev))->fme_next_err.csr         = CLEAR_ALL_ERRORS;
+
+           ccip_fme_gerr(cci_aaldev_pfme(pdev))->ras_gerr.csr             = CLEAR_ALL_ERRORS;
+           ccip_fme_gerr(cci_aaldev_pfme(pdev))->ras_berror.csr           = CLEAR_ALL_ERRORS;
+           ccip_fme_gerr(cci_aaldev_pfme(pdev))->ras_warnerror.csr        = CLEAR_ALL_ERRORS;
+
+           // Set FME mask to all 0's to enable errors.
+           ccip_fme_gerr(cci_aaldev_pfme(pdev))->fme_err_mask.csr         = 0x0;
+           ccip_fme_gerr(cci_aaldev_pfme(pdev))->pcie0_err_mask.csr       = 0x0;
+           ccip_fme_gerr(cci_aaldev_pfme(pdev))->pcie1_err_mask.csr       = 0x0;
+           ccip_fme_gerr(cci_aaldev_pfme(pdev))->ras_gerr_mask.csr        = 0x0;
+           ccip_fme_gerr(cci_aaldev_pfme(pdev))->ras_berror_mask.csr      = 0x0;
+           ccip_fme_gerr(cci_aaldev_pfme(pdev))->ras_warnerror_mask.csr   = 0x0;
+
+           //Success Event
+           Message->m_errcode = uid_errnumOK;
+
+       } break; // case ccipdrv_ClearAllFMEErrors
+
+       AFU_COMMAND_CASE(ccipdrv_getPower) {
+
+          bt32bitInt res                        = 0;
+          struct CCIP_THERMAL_PWR thermal_power = {0};
+          PVERBOSE("ccipdrv_getPower \n");
+
+          res= get_fme_power(cci_aaldev_pfme(pdev) ,&thermal_power);
+          if(0 != res ) {
+              Message->m_errcode = uid_errnumBadParameter;
+              break;
+          }
+
+          if(respBufSize >= sizeof(struct CCIP_THERMAL_PWR)){
+             PVERBOSE("ccipdrv_getPower  Valid Buffer\n");
+             *((struct CCIP_THERMAL_PWR*)Message->m_response) = thermal_power;
+             Message->m_respbufSize = sizeof(struct CCIP_THERMAL_PWR);
+          }
+
+          //Success Event
+          Message->m_errcode = uid_errnumOK;
+
+        } break; // case ccipdrv_getPower
+
+        AFU_COMMAND_CASE(ccipdrv_gertThermal) {
+
+          bt32bitInt res                        = 0;
+          struct CCIP_THERMAL_PWR thermal_power = {0};
+          PVERBOSE("ccipdrv_gertThermal \n");
+
+          res= get_fme_thermal(cci_aaldev_pfme(pdev) ,&thermal_power);
+          if(0 != res ) {
+             Message->m_errcode = uid_errnumBadParameter;
+             break;
+          }
+
+          if(respBufSize >= sizeof(struct CCIP_THERMAL_PWR)){
+            PVERBOSE("ccipdrv_gertThrermal  Valid Buffer\n");
+            *((struct CCIP_THERMAL_PWR*)Message->m_response) = thermal_power;
+            Message->m_respbufSize = sizeof(struct CCIP_THERMAL_PWR);
+          }
+
+          //Success Event
+          Message->m_errcode = uid_errnumOK;
+
+         } break; // case ccipdrv_gertThrermal
+
+   default: {
+
+      PDEBUG("Unrecognized command %" PRIu64 " or 0x%" PRIx64 " in AFUCommand\n", pmsg->cmd, pmsg->cmd);
+      Message->m_errcode = request_error;
+      retval = -EINVAL;
+   } break;
+   } // switch (pmsg->cmd)
+
+   ASSERT(0 == retval);
+
+ERROR:
+   return retval;
+}
+
+///////////////////////////////////////////////////////////////////////////////
+///////////////////////////////////////////////////////////////////////////////
+////////////////////                                     //////////////////////
+/////////////////           GENERIC FME FUNCTIONS           ///////////////////
+////////////////////                                     //////////////////////
+///////////////////////////////////////////////////////////////////////////////
+///////////////////////////////////////////////////////////////////////////////
+
+
+///============================================================================
+/// Name: write_ccip_csr64
+/// @brief   Writes 64 bit control and status registers.
+///
+/// @param[in]  baseAddress base CSR address.
+/// @param[in]  offset offset of CSR  .
+/// @param[in]  value value  going to be write in CSR.
+/// @return   void
+///============================================================================
+int write_ccip_csr64( btVirtAddr baseAddress, 
+                      btUnsigned64bitInt offset, 
+                      bt64bitCSR value )
+{
+
+   ASSERT(baseAddress);
+   if( baseAddress ) {
+      btVirtAddr  p  = (btVirtAddr)baseAddress + offset; // offset is in bytes
+      bt64bitCSR *up = (bt64bitCSR *)p;
+      *up            = value;
+   } else {
+      //PERR("baseAddress is NULL, could not write CSR 0x%X with value 0x%X\n",offset, value);
+      return 0;
+   }
+   return 1;
+}
+
+///============================================================================
+/// Name: read_ccip_csr64
+/// @brief   read 64 bit control and status registers.
+///
+/// @param[in]  baseAddress base CSR address.
+/// @param[in]  offset offset of CSR  .
+/// @return    64 bit CSR value
+///============================================================================
+bt64bitCSR read_ccip_csr64( btVirtAddr baseAddress, btUnsigned64bitInt offset )
+{
+   if(baseAddress)
+   {
+      char       volatile *p  = ((char volatile *) baseAddress) + offset; // offset is in bytes
+      bt64bitCSR volatile  u;
+      bt64bitCSR volatile *up = (bt64bitCSR volatile *)p;
+      u = *up;
+      return u;
+   } else {
+
+      PERR("baseAddress is NULL, \n");
+
+      return  ( bt64bitCSR )- 1;          // typical value for undefined CSR
+   }
+
+}
+
+///============================================================================
+/// Name:get_fme_mmio_dev
+/// @brief Construct the FME MMIO object.
+///
+/// @param[in] fme_device fme device object .
+/// @param[in] pkvp_fme_mmio fme mmio virtual address
+/// @return    error code
+///============================================================================
+struct fme_device * get_fme_mmio_dev(btVirtAddr pkvp_fme_mmio )
+{
+   bt32bitInt            res        = 0;
+   struct fme_device    *pfme_dev   = NULL;
+   PTRACEIN;
+
+
+   // Validate inputs parameters
+   ASSERT(pkvp_fme_mmio);
+   if(NULL ==  pkvp_fme_mmio){
+      return NULL;
+   }
+
+   // Construct the new object
+   pfme_dev =(struct fme_device*) kosal_kmalloc(sizeof(struct fme_device));
+   ASSERT(pfme_dev);
+   if(NULL == pfme_dev){
+      return NULL;
+   }
+
+   // Get the FPGA Management Engine Header
+   ccip_fme_hdr(pfme_dev) =  get_fme_dev_header(pkvp_fme_mmio );
+   if(NULL == ccip_fme_hdr(pfme_dev)){
+      PERR("Error reading FME header %d \n" ,res);
+      goto ERR;
+   }
+
+   // Get the FPGA Management Engine Device feature list
+   res =  get_fme_dev_featurelist(pfme_dev,pkvp_fme_mmio );
+   if(0 != res ){
+      PERR("Error reading FME feature list %d \n", res);
+      goto ERR;
+   }
+
+   PTRACEOUT_INT(res);
+   return pfme_dev;
+
+   ERR:
+      kosal_kfree(pfme_dev,sizeof(struct fme_device));
+      PTRACEOUT_INT(res);
+      return NULL;
+}
+
+///============================================================================
+/// ccip_destroy_fme_mmio_dev
+/// @brief Destroy the FME MMIO object.
+///
+/// @param[in] fme_device fme device object .
+/// @return    None
+///============================================================================
+void ccip_destroy_fme_mmio_dev(struct fme_device *pfme_dev)
+{
+   PVERBOSE("Destroying fme_device");
+   kosal_kfree(pfme_dev,sizeof(struct fme_device));
+}
+
+///============================================================================
+/// Name: get_fme_dev_header
+/// @brief   reads FME header from MMIO.
+///
+/// @param[in] fme_device fme device .
+/// @param[in] pkvp_fme_mmio fme mmio virtual address
+/// @return    error code
+///============================================================================
+struct CCIP_FME_HDR* get_fme_dev_header(btVirtAddr pkvp_fme_mmio )
+{
+
+   // FME registers are mapped into the PF MMIO address space. FME DFH will
+   //   be the first register at address offset 0
+   return (struct CCIP_FME_HDR* )pkvp_fme_mmio;
+}
+
+///============================================================================
+/// Name: get_fme_dev_featurelist
+/// @brief Enumerates the FME features.
+///
+/// @param[in] fme_device fme device .
+/// @param[in] pkvp_fme_mmio fme mmio virtual address
+/// @return    error code
+bt32bitInt get_fme_dev_featurelist( struct fme_device *pfme_dev,
+                                    btVirtAddr pkvp_fme_mmio )
+{
+
+   bt32bitInt res       = 0;
+   btVirtAddr pkvp_fme  = NULL;
+   struct CCIP_DFH fme_dfh;
+
+   PTRACEIN;
+
+   PDEBUG(" get_fme_dev_featurelist ENTER \n");
+
+   // if Device feature list is 0  , NO FME  features list
+   if( 0 == ccip_fme_hdr(pfme_dev)->dfh.next_DFH_offset ){
+      PERR("NO FME features are available \n");
+      res = -EINVAL;
+      goto ERR;
+   }
+
+   // Start at the first Device Feature Header
+   pkvp_fme = pkvp_fme_mmio + ccip_fme_hdr(pfme_dev)->dfh.next_DFH_offset;
+
+   // Walk the Feature list storing the pointer to each feature header
+   do {
+
+      // Peek at the Header
+      fme_dfh.csr = read_ccip_csr64(pkvp_fme,0);
+
+      // check for Device type
+      // Type == CCIP_DFType_private
+      if(fme_dfh.Type  != CCIP_DFType_private ){
+         PERR(" invalid FME Feature Type \n");
+         res = -EINVAL;
+         goto ERR;
+      }
+
+      // FIXME  PR DFH Revisions version changes to 1.
+      // Invalid feature if revision is not zero, except PR DFH.
+      if ((0 != fme_dfh.Feature_rev)  &&
+         (CCIP_FME_DFLID_PR != fme_dfh.Feature_ID)) {
+
+         PVERBOSE("Found FME feature with invalid revision %d. IGNORING!\n",fme_dfh.Feature_rev);
+         continue;
+      }
+
+      // Feature ID
+      switch(fme_dfh.Feature_ID)
+      {
+         // Thermal Management
+         case CCIP_FME_DFLID_THERM:
+         {
+            ccip_fme_therm(pfme_dev) = (struct CCIP_FME_DFL_THERM *)pkvp_fme;
+         }
+         break;
+
+         // Power Management
+         case CCIP_FME_DFLID_POWER:
+         {
+            ccip_fme_power(pfme_dev) = (struct CCIP_FME_DFL_PM *)pkvp_fme;
+         }
+         break;
+
+         // Global Performance
+         case CCIP_FME_DFLID_GPERF:
+         {
+            ccip_fme_perf(pfme_dev) = (struct CCIP_FME_DFL_FPMON *)pkvp_fme;
+         }
+         break;
+
+         // Global Error
+         case CCIP_FME_DFLID_GERR:
+         {
+            ccip_fme_gerr(pfme_dev) = (struct CCIP_FME_DFL_GERROR *)pkvp_fme;
+         }
+         break;
+
+         // FME Partial Reconfiguration Management
+         case CCIP_FME_DFLID_PR:
+         {
+            ccip_fme_pr(pfme_dev) = (struct CCIP_FME_DFL_PR *)pkvp_fme;
+         }
+         break;
+
+         default :
+         {
+            PWARN(" Invalid FME Feature ID %d  0x%X \n",fme_dfh.Feature_ID,fme_dfh.Feature_ID);
+         }
+         break ;
+      } // end switch
+
+      // Point at next feature header.
+      pkvp_fme = pkvp_fme + fme_dfh.next_DFH_offset;
+
+   }while(0 != fme_dfh.next_DFH_offset );  // end while
+
+   PINFO(" get_fme_dev_featurelist EXIT \n");
+ ERR:
+   PTRACEOUT_INT(res);
+   return res;
+}
+
+
+///============================================================================
+/// Name:    get_fme_error
+/// @brief   get fpga global error
+///
+/// @param[in] pfme_dev fme device pointer.
+/// @param[in] pfme_error ccip error structure  pointer
+/// @return    error code
+///============================================================================
+bt32bitInt get_fme_error(struct fme_device  *pfme_dev,
+                         struct CCIP_ERROR  *pfme_error)
+{
+   int res = 0;
+
+   PTRACEIN;
+
+   if( (NULL == pfme_dev) || (NULL == pfme_error))  {
+      PERR("Invalid input pointers \n");
+      res =-EINVAL;
+      goto ERR;
+   }
+
+   memset(pfme_error,0,sizeof(struct CCIP_ERROR));
+
+   pfme_error->error0_mask              = ccip_fme_gerr(pfme_dev)->fme_err_mask.csr;
+   pfme_error->error0                   = ccip_fme_gerr(pfme_dev)->fme_err.csr;
+
+   pfme_error->pcie0_error_mask         = ccip_fme_gerr(pfme_dev)->pcie0_err_mask.csr;
+   pfme_error->pcie0_error              = ccip_fme_gerr(pfme_dev)->pcie0_err.csr;
+
+   pfme_error->pcie1_error_mask         = ccip_fme_gerr(pfme_dev)->pcie1_err_mask.csr;
+   pfme_error->pcie1_error              = ccip_fme_gerr(pfme_dev)->pcie1_err.csr;
+
+   pfme_error->first_error              = ccip_fme_gerr(pfme_dev)->fme_first_err.csr;
+   pfme_error->next_error               = ccip_fme_gerr(pfme_dev)->fme_next_err.csr;
+
+   pfme_error->ras_gerr                 =  ccip_fme_gerr(pfme_dev)->ras_gerr.csr;
+   pfme_error->ras_gerr_mask            =  ccip_fme_gerr(pfme_dev)->ras_gerr_mask.csr;
+
+   pfme_error->ras_berror               =  ccip_fme_gerr(pfme_dev)->ras_berror.csr;
+   pfme_error->ras_berror_mask          =  ccip_fme_gerr(pfme_dev)->ras_berror_mask.csr;
+
+   pfme_error->ras_warnerror            =  ccip_fme_gerr(pfme_dev)->ras_warnerror.csr;
+   pfme_error->ras_warnerror_mask       =  ccip_fme_gerr(pfme_dev)->ras_warnerror_mask.csr;
+
+   PTRACEOUT_INT(res);
+   return res;
+
+ERR:
+   PTRACEOUT_INT(res);
+   return  res;
+}
+
+///============================================================================
+/// Name:    get_fme_power
+/// @brief   power consumed values
+///
+/// @param[in] pfme_dev fme device pointer.
+/// @param[in] pfme_power ccip power structure  pointer
+/// @return    error code
+///============================================================================
+bt32bitInt get_fme_power(struct fme_device       *pfme_dev,
+                         struct CCIP_THERMAL_PWR *pthermal_power)
+{
+   int res = 0;
+
+   PTRACEIN;
+
+   if( (NULL == pfme_dev) || (NULL == pthermal_power))  {
+      PERR("Invalid input pointers \n");
+      res =-EINVAL;
+      goto ERR;
+   }
+
+   memset(pthermal_power,0,sizeof(struct CCIP_THERMAL_PWR));
+
+   pthermal_power->pwr_status    = ccip_fme_power(pfme_dev)->pm_status.csr;
+
+   PTRACEOUT_INT(res);
+   return res;
+
+ERR:
+   PTRACEOUT_INT(res);
+   return  res;
+}
+
+///============================================================================
+/// Name:    get_fme_thermal
+/// @brief   get  fpga  thermal values
+///
+/// @param[in] pfme_dev fme device pointer.
+/// @param[in] pPerf ccip thermal structure  pointer
+/// @return    error code
+///============================================================================
+bt32bitInt get_fme_thermal(struct fme_device        *pfme_dev,
+                           struct CCIP_THERMAL_PWR  *pthermal_power)
+{
+   int res = 0;
+
+   PTRACEIN;
+
+   if( (NULL == pfme_dev) || (NULL == pthermal_power))  {
+      PERR("Invalid input pointers \n");
+      res =-EINVAL;
+      goto ERR;
+   }
+
+   memset(pthermal_power,0,sizeof(struct CCIP_THERMAL_PWR));
+
+   pthermal_power->tmp_threshold    = ccip_fme_therm(pfme_dev)->ccip_tmp_threshold.csr;
+   pthermal_power->tmp_rdsensor1    = ccip_fme_therm(pfme_dev)->ccip_tmp_rdssensor_fm1.csr;
+   pthermal_power->tmp_rdsensor2    = ccip_fme_therm(pfme_dev)->ccip_tmp_rdssensor_fm2.csr;
+
+   PTRACEOUT_INT(res);
+   return res;
+
+ERR:
+   PTRACEOUT_INT(res);
+   return  res;
+}
+
+///============================================================================
+/// Name:    ccip_links_status
+/// @brief   get  PCIe0,PCIe1,UPI link status
+///
+/// @param[in] pfme_dev fme device pointer.
+/// @return    true if links are up or false if links are down.
+///============================================================================
+btBool ccip_links_status(struct fme_device *pfme_dev)
+{
+   btBool res = false ;
+   PTRACEIN;
+
+   if( NULL == pfme_dev) {
+      return res;
+   }
+
+   // checking PCIe0,PCIe1,UPI link status
+   // UPI link up status    - 0xE -> b1110
+   // Ignore  upilink_satus[0] bit KTI_ERROR
+   // PCIe0 link up status  - 0x1
+   // PCIe1 link up status  - 0x1
+
+   if( ((0xE == ccip_fme_hdr(pfme_dev)->fab_status.upilink_status  ) ||
+        (0xF == ccip_fme_hdr(pfme_dev)->fab_status.upilink_status  )) &&
+        (0x1 == ccip_fme_hdr(pfme_dev)->fab_status.pcie0link_status ) &&
+        (0x1 == ccip_fme_hdr(pfme_dev)->fab_status.pcie1link_status ) ) {
+
+      //PCIe0,PCIe1,UPI links are up
+      res = true ;
+   }
+
+   PTRACEOUT;
+   return res;
+}
diff --git a/drivers/fpga/aal/cci/ccip_fme.h b/drivers/fpga/aal/cci/ccip_fme.h
new file mode 100644
index 000000000000..0d3d75c72c2c
--- /dev/null
+++ b/drivers/fpga/aal/cci/ccip_fme.h
@@ -0,0 +1,251 @@
+//******************************************************************************
+// This  file  is  provided  under  a  dual BSD/GPLv2  license.  When using or
+//         redistributing this file, you may do so under either license.
+//
+//                            GPL LICENSE SUMMARY
+//
+//  Copyright(c) 2015-2017, Intel Corporation.
+//
+//  This program  is  free software;  you  can redistribute it  and/or  modify
+//  it  under  the  terms of  version 2 of  the GNU General Public License  as
+//  published by the Free Software Foundation.
+//
+//  This  program  is distributed  in the  hope that it  will  be useful,  but
+//  WITHOUT   ANY   WARRANTY;   without   even  the   implied   warranty    of
+//  MERCHANTABILITY  or  FITNESS  FOR  A  PARTICULAR  PURPOSE.  See  the   GNU
+//  General Public License for more details.
+//
+//  The  full  GNU  General Public License is  included in  this  distribution
+//  in the file called README.GPLV2-LICENSE.TXT.
+//
+//  Contact Information:
+//  Henry Mitchel, henry.mitchel at intel.com
+//  77 Reed Rd., Hudson, MA  01749
+//
+//                                BSD LICENSE
+//
+//  Copyright(c) 2015-2017, Intel Corporation.
+//
+//  Redistribution and  use  in source  and  binary  forms,  with  or  without
+//  modification,  are   permitted  provided  that  the  following  conditions
+//  are met:
+//
+//    * Redistributions  of  source  code  must  retain  the  above  copyright
+//      notice, this list of conditions and the following disclaimer.
+//    * Redistributions in  binary form  must  reproduce  the  above copyright
+//      notice,  this  list of  conditions  and  the  following disclaimer  in
+//      the   documentation   and/or   other   materials   provided  with  the
+//      distribution.
+//    * Neither   the  name   of  Intel  Corporation  nor  the  names  of  its
+//      contributors  may  be  used  to  endorse  or promote  products derived
+//      from this software without specific prior written permission.
+//
+//  THIS  SOFTWARE  IS  PROVIDED  BY  THE  COPYRIGHT HOLDERS  AND CONTRIBUTORS
+//  "AS IS"  AND  ANY  EXPRESS  OR  IMPLIED  WARRANTIES,  INCLUDING,  BUT  NOT
+//  LIMITED  TO, THE  IMPLIED WARRANTIES OF  MERCHANTABILITY  AND FITNESS  FOR
+//  A  PARTICULAR  PURPOSE  ARE  DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT
+//  OWNER OR CONTRIBUTORS BE LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,
+//  SPECIAL,  EXEMPLARY,  OR  CONSEQUENTIAL   DAMAGES  (INCLUDING,   BUT   NOT
+//  LIMITED  TO,  PROCUREMENT  OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF USE,
+//  DATA,  OR PROFITS;  OR BUSINESS INTERRUPTION)  HOWEVER  CAUSED  AND ON ANY
+//  THEORY  OF  LIABILITY,  WHETHER  IN  CONTRACT,  STRICT LIABILITY,  OR TORT
+//  (INCLUDING  NEGLIGENCE  OR OTHERWISE) ARISING  IN ANY WAY  OUT  OF THE USE
+//  OF  THIS  SOFTWARE, EVEN IF ADVISED  OF  THE  POSSIBILITY  OF SUCH DAMAGE.
+//******************************************************************************
+//****************************************************************************
+/// @file ccip_def.h
+/// @brief  Definitions for ccip.
+/// @ingroup aalkernel_ccip
+/// @verbatim
+//        FILE: ccip_fme_mmio.h
+//     CREATED: Sept 24, 2015
+//      AUTHOR: Ananda Ravuri, Intel <ananda.ravuri@intel.com>
+//              Joseph Grecco, Intel <joe.grecco@intel.com>
+//
+// PURPOSE:   This file contains the defintions of the CCIP FME
+//             Device Feature List and CSR.
+// HISTORY:
+// COMMENTS:
+// WHEN:          WHO:     WHAT:
+//****************************************************************************///
+#ifndef __AALKERNEL_CCIP_FME_DEF_H_
+#define __AALKERNEL_CCIP_FME_DEF_H_
+#include <aalsdk/kernel/kosal.h>
+
+#include <aalsdk/kernel/aaltypes.h>
+#include "cci_pcie_driver_internal.h"
+#include "aalsdk/kernel/ccipdriver.h"
+#include "aalsdk/kernel/ccip_defs.h"
+#include "ccip_pr.h"
+
+BEGIN_NAMESPACE(AAL)
+
+///============================================================================
+/// Name: fme_device
+/// @brief   FPGA Management engine device struct
+///============================================================================
+struct fme_device
+{
+
+   struct CCIP_FME_HDR        *m_pHDR;          // FME Header
+   struct CCIP_FME_DFL_THERM  *m_pThermmgmt;    // FME  Thermal Management DFL
+   struct CCIP_FME_DFL_PM     *m_pPowermgmt;    // FME  Power Management DFL
+   struct CCIP_FME_DFL_FPMON  *m_pPerf;         // FME  Global Performance  DFL
+   struct CCIP_FME_DFL_GERROR *m_pGerror;       // FME  Global Error  DFL
+   struct CCIP_FME_DFL_PR     *m_pPRmgmt;       // FME  PR Management  DFL
+
+
+   kosal_pci_dev            *m_pcidev;         // Linux pci_dev pointer (or NULL if manual)
+
+   // Private semaphore
+   kosal_semaphore            m_sem;
+
+   // struct ccip_PIPsession   *m_pPIPSession;     // PIP session object
+
+   // btUnsignedInt              m_flags;
+
+   // struct aal_device         m_aal_dev;         // AAL Device from which this is derived
+   struct CCIP_FME_DFL_GERROR   m_lastGerror;
+   struct CCIP_FME_DFL_THERM    m_lastThermmgmt;
+
+
+   struct pr_program_context    *m_pr_program_context;
+   struct cci_aal_device        *m_power_aaldev;
+
+}; // end struct fme_device
+
+#define ccip_fme_dev_board_type(pdev)         ((pdev)->m_boardtype)
+
+
+#define ccip_fme_dev_pci_dev(pdev)           ((pdev)->m_pcidev)
+
+#define ccip_fme_aal_dev(pdev)               ((pdev)->m_aal_dev)
+#define ccip_fme_hdr(pdev)                   ((pdev)->m_pHDR)
+#define ccip_fme_therm(pdev)                 ((pdev)->m_pThermmgmt)
+#define ccip_fme_power(pdev)                 ((pdev)->m_pPowermgmt)
+#define ccip_fme_perf(pdev)                  ((pdev)->m_pPerf)
+#define ccip_fme_gerr(pdev)                  ((pdev)->m_pGerror)
+#define ccip_fme_pr(pdev)                    ((pdev)->m_pPRmgmt)
+
+#define ccip_fme_lastgerr(pdev)               ((pdev)->m_lastGerror)
+#define ccip_fme_lasttherm(pdev)              ((pdev)->m_lastThermmgmt)
+
+#define ccip_fme_mem_sessionp(pdev)              ((pdev)->m_pmem_session)
+
+#define ccip_dev_fme_phys_mmio(pdev)              ((pdev)->m_phys_fme_mmio)
+#define ccip_dev_fme_kvp_mmio(pdev)               ((pdev)->m_kvp_fme_mmio)
+#define ccip_dev_fme_len_mmio(pdev)               ((pdev)->m_len_fme_mmio)
+
+#define ccip_dev_fme_to_pci_dev(pdev)            ((pdev)->m_pcidev)
+#define ccip_dev_fme_to_aaldev(pdev)             ((pdev)->m_aal_dev)
+
+#define ccip_dev_fme_to_PIPsessionp(pdev)        ((pdev)->m_pPIPSession)
+#define ccip_dev_fme_psem(pdev)                  (&(pdev)->m_sem)
+
+#define ccip_dev_fme_pwraal_dev(pdev)            ((pdev)->m_power_aaldev)
+
+/// @brief   Get the FPGA Management Engine Device Object.
+///
+/// @param[in] fme_device fme device pointer.
+/// @param[in] pkvp_fme_mmio fme mmio virtual address
+/// @return    Device object; NULL == failure
+struct fme_device * get_fme_mmio_dev(btVirtAddr pkvp_fme_mmio );
+
+/// @brief Destroy the FME MMIO object.
+///
+/// @param[in] fme_device fme device object .
+/// @return    None
+void ccip_destroy_fme_mmio_dev(struct fme_device *);
+
+/// @brief   reads FME header from MMIO.
+///
+/// @param[in] pkvp_fme_mmio fme mmio virtual address
+/// @return    FME Header object; NULL ==failure
+struct CCIP_FME_HDR* get_fme_dev_header(btVirtAddr pkvp_fme_mmio );
+
+
+/// @brief   reads FME header from MMIO.
+///
+/// @param[in] fme_device fme device pointer.
+/// @param[in] pkvp_fme_mmio fme mmio virtual address
+/// @return    error code
+bt32bitInt get_fme_dev_featurelist(struct fme_device *pfme_dev,btVirtAddr pkvp_fme_mmio );
+
+/// @brief   reads FME Temperature Management CSR
+///
+/// @param[in] fme_device fme device pointer.
+/// @param[in] pkvp_fme_mmio fme mmio virtual address
+/// @return    error code
+bt32bitInt get_fme_dev_tmp_rev0(struct fme_device *pfme_dev,btVirtAddr pkvp_fme_mmio );;
+
+/// @brief   reads FME Power Management CSR
+///
+/// @param[in] fme_device fme device pointer.
+/// @param[in] pkvp_fme_mmio fme mmio virtual address
+/// @return    error code
+bt32bitInt get_fme_dev_pm_rev0(struct fme_device *pfme_dev,btVirtAddr pkvp_fme_mmio );
+
+/// @brief   reads FME Global performance CSR
+///
+/// @param[in] fme_device fme device pointer.
+/// @param[in] pkvp_fme_mmio fme mmio virtual address
+/// @return    error code
+bt32bitInt get_fme_dev_fpmon_rev0(struct fme_device *pfme_dev,btVirtAddr pkvp_fme_mmio );
+
+/// @brief   reads FME Global error CSR
+///
+/// @param[in] fme_device fme device pointer.
+/// @param[in] pkvp_fme_mmio fme mmio virtual address
+/// @return    error code
+bt32bitInt get_fme_dev_gerr_rev0(struct fme_device *pfme_dev,btVirtAddr pkvp_fme_mmio );
+
+/// @brief   reads FME PR CSR
+///
+/// @param[in] fme_device fme device pointer.
+/// @param[in] pkvp_fme_mmio fme mmio virtual address
+/// @return    error code
+bt32bitInt get_fme_dev_pr_rev0(struct fme_device *pfme_dev,btVirtAddr pkvp_fme_mmio );
+
+/// @brief   freee FME Device feature list memory
+///
+/// @param[in] fme_device fme device pointer .
+/// @return    void
+void ccip_fme_mem_free(struct fme_device *pfme_dev );
+
+/// @brief   get global error
+///
+/// @param[in] pfme_dev fme device pointer.
+/// @param[in] pfme_error ccip error structure  pointer
+/// @return    error code
+bt32bitInt get_fme_error(struct fme_device   *pfme_dev,
+                         struct CCIP_ERROR   *pfme_error);
+
+/// @brief   get fpga power consumed values.
+///
+/// @param[in] pfme_dev fme device pointer.
+/// @param[in] pfme_power ccip power structure  pointer
+/// @return    error code
+bt32bitInt get_fme_power(struct fme_device         *pfme_dev,
+                         struct CCIP_THERMAL_PWR   *pthermal_power);
+
+/// @brief   get fpga thermal values
+///
+/// @param[in] pfme_dev fme device pointer.
+/// @param[in] pPerf ccip thermal structure  pointer
+/// @return    error code
+bt32bitInt get_fme_thermal(struct fme_device        *pfme_dev,
+                           struct CCIP_THERMAL_PWR  *pthermal_power);
+
+/// Name:    ccip_links_status
+/// @brief   get  PCIe0,PCIe1,UPI link status
+///
+/// @param[in] pfme_dev fme device pointer.
+/// @return    true if links are up or false if links are down.
+btBool ccip_links_status(struct fme_device *pfme_dev);
+
+
+extern struct aal_ipip cci_FMEpip;
+
+END_NAMESPACE(AAL)
+
+#endif /* __AALKERNEL_CCIP_FME_DEF_H_ */
diff --git a/drivers/fpga/aal/cci/ccip_fme_mmap_linux.c b/drivers/fpga/aal/cci/ccip_fme_mmap_linux.c
new file mode 100644
index 000000000000..740809564674
--- /dev/null
+++ b/drivers/fpga/aal/cci/ccip_fme_mmap_linux.c
@@ -0,0 +1,307 @@
+//******************************************************************************
+// This  file  is  provided  under  a  dual BSD/GPLv2  license.  When using or
+//         redistributing this file, you may do so under either license.
+//
+//                            GPL LICENSE SUMMARY
+//
+//  Copyright(c) 2015-2017, Intel Corporation.
+//
+//  This program  is  free software;  you  can redistribute it  and/or  modify
+//  it  under  the  terms of  version 2 of  the GNU General Public License  as
+//  published by the Free Software Foundation.
+//
+//  This  program  is distributed  in the  hope that it  will  be useful,  but
+//  WITHOUT   ANY   WARRANTY;   without   even  the   implied   warranty    of
+//  MERCHANTABILITY  or  FITNESS  FOR  A  PARTICULAR  PURPOSE.  See  the   GNU
+//  General Public License for more details.
+//
+//  The  full  GNU  General Public License is  included in  this  distribution
+//  in the file called README.GPLV2-LICENSE.TXT.
+//
+//  Contact Information:
+//  Henry Mitchel, henry.mitchel at intel.com
+//  77 Reed Rd., Hudson, MA  01749
+//
+//                                BSD LICENSE
+//
+//  Copyright(c) 2015-2017, Intel Corporation.
+//
+//  Redistribution and  use  in source  and  binary  forms,  with  or  without
+//  modification,  are   permitted  provided  that  the  following  conditions
+//  are met:
+//
+//    * Redistributions  of  source  code  must  retain  the  above  copyright
+//      notice, this list of conditions and the following disclaimer.
+//    * Redistributions in  binary form  must  reproduce  the  above copyright
+//      notice,  this  list of  conditions  and  the  following disclaimer  in
+//      the   documentation   and/or   other   materials   provided  with  the
+//      distribution.
+//    * Neither   the  name   of  Intel  Corporation  nor  the  names  of  its
+//      contributors  may  be  used  to  endorse  or promote  products derived
+//      from this software without specific prior written permission.
+//
+//  THIS  SOFTWARE  IS  PROVIDED  BY  THE  COPYRIGHT HOLDERS  AND CONTRIBUTORS
+//  "AS IS"  AND  ANY  EXPRESS  OR  IMPLIED  WARRANTIES,  INCLUDING,  BUT  NOT
+//  LIMITED  TO, THE  IMPLIED WARRANTIES OF  MERCHANTABILITY  AND FITNESS  FOR
+//  A  PARTICULAR  PURPOSE  ARE  DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT
+//  OWNER OR CONTRIBUTORS BE LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,
+//  SPECIAL,  EXEMPLARY,  OR  CONSEQUENTIAL   DAMAGES  (INCLUDING,   BUT   NOT
+//  LIMITED  TO,  PROCUREMENT  OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF USE,
+//  DATA,  OR PROFITS;  OR BUSINESS INTERRUPTION)  HOWEVER  CAUSED  AND ON ANY
+//  THEORY  OF  LIABILITY,  WHETHER  IN  CONTRACT,  STRICT LIABILITY,  OR TORT
+//  (INCLUDING  NEGLIGENCE  OR OTHERWISE) ARISING  IN ANY WAY  OUT  OF THE USE
+//  OF  THIS  SOFTWARE, EVEN IF ADVISED  OF  THE  POSSIBILITY  OF SUCH DAMAGE.
+//******************************************************************************
+//****************************************************************************
+/// @file ccip_fme_mmap_linux.c
+/// @brief  Implements the FPGA Management Engine (FME) MMap capability.
+/// @ingroup aalkernel_ccip
+/// @verbatim
+//        FILE: ccip_fme_mmap_linux.c
+//     CREATED: Sept 24, 2015
+//      AUTHOR: Joseph Grecco, Intel <joe.grecco@intel.com>
+//
+// PURPOSE:   This file contains the definations of the CCIP FME
+//             Device Feature List and CSR.
+// HISTORY:
+// COMMENTS:
+// WHEN:          WHO:     WHAT:
+//****************************************************************************///
+#include "aalsdk/kernel/kosal.h"
+
+#define MODULE_FLAGS CCIPCIE_DBG_MOD // Prints all
+
+#include "aalsdk/kernel/AALTransactionID_s.h"
+#include "aalsdk/kernel/aalbus-ipip.h"
+
+#include "aalsdk/kernel/ccipdriver.h"
+#include "ccipdrv-events.h"
+#include "ccip_perfmon.h"
+#include "aalsdk/kernel/ccip_defs.h"
+#include "ccip_fme.h"
+#include "cci_pcie_driver_PIPsession.h"
+
+// TODO ARE ALL MAPS CREATED EQUAL?  If so only have 1
+
+
+///////////////////////////////////////////////////////////////////////////////
+///////////////////////////////////////////////////////////////////////////////
+////////////////////                                     //////////////////////
+/////////////////              PIP MMAP                    ////////////////////
+////////////////////                                     //////////////////////
+///////////////////////////////////////////////////////////////////////////////
+///////////////////////////////////////////////////////////////////////////////
+//=============================================================================
+//=============================================================================
+
+//=============================================================================
+// Name: csr_vmaopen
+// Description: Called when the vma is mapped
+// Interface: public
+// Inputs: none.
+// Outputs: none.
+// Comments:
+//=============================================================================
+#ifdef NOT_USED
+static void csr_vmaopen(struct vm_area_struct *pvma)
+{
+   PINFO("CSR VMA OPEN.\n" );
+}
+#endif
+
+
+//=============================================================================
+// Name: wksp_vmaclose
+// Description: called when vma is unmapped
+// Interface: public
+// Inputs: none.
+// Outputs: none.
+// Comments:
+//=============================================================================
+#ifdef NOT_USED
+static void csr_vmaclose(struct vm_area_struct *pvma)
+{
+   PINFO("CSR VMA CLOSE.\n" );
+}
+#endif
+
+#ifdef NOT_USED
+static struct vm_operations_struct csr_vm_ops =
+{
+   .open    = csr_vmaopen,
+   .close   = csr_vmaclose,
+};
+#endif
+
+
+//=============================================================================
+// Name: cci_mmap
+// Description: Method used for mapping kernel memory to user space. Called by
+//              uidrv.
+// Interface: public
+// Inputs: none.
+// Outputs: none.
+// Comments: This method front ends all operations that require mapping shared
+//           memory. It examines the wsid to determine the appropriate service
+//           to perform the map operation.
+//=============================================================================
+int
+cci_mmap(struct aaldev_ownerSession *pownerSess,
+               struct aal_wsid *wsidp,
+               btAny os_specific)
+{
+
+   struct vm_area_struct     *pvma = (struct vm_area_struct *) os_specific;
+
+   struct cci_PIPsession   *pSess = NULL;
+   struct cci_aal_device       *pdev = NULL;
+   unsigned long              max_length = 0; // mmap length requested by user
+   int                        res = -EINVAL;
+
+   ASSERT(pownerSess);
+   ASSERT(wsidp);
+
+   // Get the aal_device and the memory manager session
+   pSess = (struct cci_PIPsession *) aalsess_pipHandle(pownerSess);
+   ASSERT(pSess);
+   if ( NULL == pSess ) {
+      PDEBUG("CCI mmap: no Session");
+      goto ERROR;
+   }
+
+   pdev = cci_PIPsessionp_to_ccidev(pSess);
+   ASSERT(pdev);
+   if ( NULL == pdev ) {
+      PDEBUG("CCI mmap: no device");
+      goto ERROR;
+   }
+
+   PINFO("WS ID = 0x%llx.\n", wsidp->m_id);
+
+   pvma->vm_ops = NULL;
+
+   // Special case - check the wsid type for WSM_TYPE_CSR. If this is a request to map the
+   // CSR region, then satisfy the request by mapping PCIe BAR 0.
+   if ( WSM_TYPE_MMIO == wsidp->m_type ) {
+      void *ptr;
+      size_t size;
+      switch ( wsidp->m_id )
+      {
+            case WSID_CSRMAP_WRITEAREA:
+            case WSID_CSRMAP_READAREA:
+            case WSID_MAP_MMIOR:
+            case WSID_MAP_UMSG:
+            break;
+         default:
+            PERR("Attempt to map invalid WSID type %d\n", (int) wsidp->m_id);
+            goto ERROR;
+      }
+
+      // Verify that we can fulfill the request - we set flags at create time.
+      if ( WSID_CSRMAP_WRITEAREA == wsidp->m_id ) {
+         ASSERT(cci_aaldev_allow_map_csr_write_space(pdev));
+
+         if ( !cci_aaldev_allow_map_csr_write_space(pdev) ) {
+            PERR("Denying request to map CSR Write space for device 0x%p.\n", pdev);
+            goto ERROR;
+         }
+      }
+
+      if ( WSID_CSRMAP_READAREA == wsidp->m_id ) {
+         ASSERT(cci_aaldev_allow_map_csr_read_space(pdev));
+
+         if ( !cci_aaldev_allow_map_csr_read_space(pdev) ) {
+            PERR("Denying request to map CSR Read space for device 0x%p.\n", pdev);
+            goto ERROR;
+         }
+      }
+
+      if ( WSID_MAP_MMIOR == wsidp->m_id )
+      {
+         if ( !cci_aaldev_allow_map_mmior_space(pdev) ) {
+            PERR("Denying request to map cci_aaldev_allow_map_mmior_space Read space for device 0x%p.\n", pdev);
+            goto ERROR;
+         }
+
+         ptr = (void *) cci_aaldev_phys_afu_mmio(pdev);
+         size = cci_aaldev_len_afu_mmio(pdev);
+
+         PVERBOSE("Mapping CSR %s Aperture Physical=0x%p size=%" PRIuSIZE_T " at uvp=0x%p\n",
+            ((WSID_CSRMAP_WRITEAREA == wsidp->m_id) ? "write" : "read"),
+            ptr,
+            size,
+            (void *)pvma->vm_start);
+
+         // Map the region to user VM
+         res = remap_pfn_range(pvma,               // Virtual Memory Area
+            pvma->vm_start,                        // Start address of virtual mapping
+            ((unsigned long) ptr) >> PAGE_SHIFT,   // Pointer in Pages (Page Frame Number)
+            size,
+            pvma->vm_page_prot);
+
+         if ( unlikely(0 != res) ) {
+            PERR("remap_pfn_range error at CSR mmap %d\n", res);
+            goto ERROR;
+         }
+
+         // Successfully mapped MMR region.
+         return 0;
+      }
+
+      if ( WSID_MAP_UMSG == wsidp->m_id )
+      {
+         if ( !cci_aaldev_allow_map_umsg_space(pdev) ) {
+            PERR("Denying request to map cci_aaldev_allow_map_umsg_space Read space for device 0x%p.\n", pdev);
+            goto ERROR;
+         }
+
+         ptr = (void *) cci_aaldev_phys_afu_umsg(pdev);
+         size = cci_aaldev_len_afu_umsg(pdev);
+
+         PVERBOSE("Mapping CSR %s Aperture Physical=0x%p size=%" PRIuSIZE_T " at uvp=0x%p\n",
+            ((WSID_CSRMAP_WRITEAREA == wsidp->m_id) ? "write" : "read"),
+            ptr,
+            size,
+            (void *)pvma->vm_start);
+
+         // Map the region to user VM
+         res = remap_pfn_range(pvma,                             // Virtual Memory Area
+            pvma->vm_start,                   // Start address of virtual mapping
+            ((unsigned long) ptr) >> PAGE_SHIFT, // Pointer in Pages (Page Frame Number)
+            size,
+            pvma->vm_page_prot);
+
+         if ( unlikely(0 != res) ) {
+            PERR("remap_pfn_range error at CSR mmap %d\n", res);
+            goto ERROR;
+         }
+
+         PERR("Unrecognized MMIO region ID %d\n", (btInt)wsidp->m_id);
+         return res;
+      }
+
+      goto ERROR;
+   }
+
+   //------------------------
+   // Map normal workspace
+   //------------------------
+
+   max_length = min(wsidp->m_size, (btWSSize)(pvma->vm_end - pvma->vm_start));
+
+   PVERBOSE( "MMAP: start 0x%lx, end 0x%lx, KVP 0x%p, size=%" PRIu64 " 0x%" PRIx64 " max_length=%ld flags=0x%lx\n",
+      pvma->vm_start, pvma->vm_end, (btVirtAddr)wsidp->m_id, wsidp->m_size, wsidp->m_size, max_length, pvma->vm_flags);
+
+   res = remap_pfn_range(pvma,                              // Virtual Memory Area
+      pvma->vm_start,                    // Start address of virtual mapping, from OS
+      (kosal_virt_to_phys((btVirtAddr) wsidp->m_id) >> PAGE_SHIFT),   // physical memory backing store in pfn
+      max_length,                        // size in bytes
+      pvma->vm_page_prot);               // provided by OS
+   if ( unlikely(0 != res) ) {
+      PERR("remap_pfn_range error at workspace mmap %d\n", res);
+      goto ERROR;
+   }
+
+   ERROR:
+   return res;
+}
diff --git a/drivers/fpga/aal/cci/ccip_logging.c b/drivers/fpga/aal/cci/ccip_logging.c
new file mode 100644
index 000000000000..7ce8f9247fa3
--- /dev/null
+++ b/drivers/fpga/aal/cci/ccip_logging.c
@@ -0,0 +1,1173 @@
+//******************************************************************************
+// This  file  is  provided  under  a  dual BSD/GPLv2  license.  When using or
+//         redistributing this file, you may do so under either license.
+//
+//                            GPL LICENSE SUMMARY
+//
+//  Copyright(c) 2015-2017, Intel Corporation.
+//
+//  This program  is  free software;  you  can redistribute it  and/or  modify
+//  it  under  the  terms of  version 2 of  the GNU General Public License  as
+//  published by the Free Software Foundation.
+//
+//  This  program  is distributed  in the  hope that it  will  be useful,  but
+//  WITHOUT   ANY   WARRANTY;   without   even  the   implied   warranty    of
+//  MERCHANTABILITY  or  FITNESS  FOR  A  PARTICULAR  PURPOSE.  See  the   GNU
+//  General Public License for more details.
+//
+//  The  full  GNU  General Public License is  included in  this  distribution
+//  in the file called README.GPLV2-LICENSE.TXT.
+//
+//  Contact Information:
+//  Henry Mitchel, henry.mitchel at intel.com
+//  77 Reed Rd., Hudson, MA  01749
+//
+//                                BSD LICENSE
+//
+//  Copyright(c) 2015-2017, Intel Corporation.
+//
+//  Redistribution and  use  in source  and  binary  forms,  with  or  without
+//  modification,  are   permitted  provided  that  the  following  conditions
+//  are met:
+//
+//    * Redistributions  of  source  code  must  retain  the  above  copyright
+//      notice, this list of conditions and the following disclaimer.
+//    * Redistributions in  binary form  must  reproduce  the  above copyright
+//      notice,  this  list of  conditions  and  the  following disclaimer  in
+//      the   documentation   and/or   other   materials   provided  with  the
+//      distribution.
+//    * Neither   the  name   of  Intel  Corporation  nor  the  names  of  its
+//      contributors  may  be  used  to  endorse  or promote  products derived
+//      from this software without specific prior written permission.
+//
+//  THIS  SOFTWARE  IS  PROVIDED  BY  THE  COPYRIGHT HOLDERS  AND CONTRIBUTORS
+//  "AS IS"  AND  ANY  EXPRESS  OR  IMPLIED  WARRANTIES,  INCLUDING,  BUT  NOT
+//  LIMITED  TO, THE  IMPLIED WARRANTIES OF  MERCHANTABILITY  AND FITNESS  FOR
+//  A  PARTICULAR  PURPOSE  ARE  DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT
+//  OWNER OR CONTRIBUTORS BE LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,
+//  SPECIAL,  EXEMPLARY,  OR  CONSEQUENTIAL   DAMAGES  (INCLUDING,   BUT   NOT
+//  LIMITED  TO,  PROCUREMENT  OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF USE,
+//  DATA,  OR PROFITS;  OR BUSINESS INTERRUPTION)  HOWEVER  CAUSED  AND ON ANY
+//  THEORY  OF  LIABILITY,  WHETHER  IN  CONTRACT,  STRICT LIABILITY,  OR TORT
+//  (INCLUDING  NEGLIGENCE  OR OTHERWISE) ARISING  IN ANY WAY  OUT  OF THE USE
+//  OF  THIS  SOFTWARE, EVEN IF ADVISED  OF  THE  POSSIBILITY  OF SUCH DAMAGE.
+//******************************************************************************
+//****************************************************************************
+/// @file ccip_logging.h
+/// @brief  Definitions for ccip logging.
+/// @ingroup aalkernel_ccip
+/// @verbatim
+//        FILE: ccip_logging.h
+//     CREATED: June 07, 2016
+//      AUTHOR: , Intel Corporation
+//
+//
+// PURPOSE:
+// HISTORY:
+// COMMENTS:
+// WHEN:          WHO:     WHAT:
+//****************************************************************************///
+#include "aalsdk/kernel/kosal.h"
+#define MODULE_FLAGS CCIPCIE_DBG_MOD
+
+#include "cci_pcie_driver_internal.h"
+#include "aalsdk/kernel/ccip_defs.h"
+#include "ccip_fme.h"
+#include "ccip_port.h"
+#include "ccip_logging.h"
+
+BEGIN_NAMESPACE(AAL)
+
+
+// ccip board device list
+extern kosal_list_head g_device_list;
+extern kosal_semaphore g_dev_list_sem;
+
+// logging timer struct
+struct logging_msg   g_logging_msg;
+
+// Logging Timer value in milliseconds
+#define  CCIP_LOGGGING_TIMER_VALUE  1000
+
+///============================================================================
+/// Name:    create_logging_timer
+/// @brief   creates ccip logging polling time.
+///
+/// @return    error code
+///============================================================================
+int create_logging_timer(void)
+{
+   int res = 0;
+   PTRACEIN;
+
+   logging_msg_wq(g_logging_msg) = kosal_create_workqueue( "LoggingTimer",NULL);
+   if(NULL ==  logging_msg_wq(g_logging_msg)) {
+      res= -ENOMEM;
+      return res;
+   }
+
+   kosal_mutex_init(logging_msg_sem(g_logging_msg));
+   logging_msg_time(g_logging_msg) = CCIP_LOGGGING_TIMER_VALUE;
+
+
+   PTRACEOUT;
+   return  res;
+}
+
+///============================================================================
+/// Name:    start_logging_timer
+/// @brief   starts logging timer.
+///
+/// @return    error code
+///============================================================================
+int start_logging_timer(void)
+{
+   int res = 0;
+   PTRACEIN;
+
+   //  if work queue failed to initialize,no need to start work queue
+   if( NULL == logging_msg_wq(g_logging_msg)) {
+
+      res= -EFAULT;
+      return res;
+   }
+
+   kosal_sem_get_krnl(logging_msg_sem(g_logging_msg) );
+
+   // checking for  work queue is  running /started
+   if(logging_timer_Running == logging_msg_wq_status(g_logging_msg) )  {
+
+      kosal_sem_put( logging_msg_sem(g_logging_msg));
+      res = -EBUSY ;
+      return res;
+   }
+
+
+   // Start logging timer work queue.
+   KOSAL_INIT_WORK(&(logging_msg_wobj(g_logging_msg)),error_logging_callback);
+
+   kosal_queue_delayed_work( logging_msg_wq(g_logging_msg),
+                             &(logging_msg_wobj(g_logging_msg)),
+                             logging_msg_time(g_logging_msg));
+
+   logging_msg_wq_status(g_logging_msg) = logging_timer_Running;
+
+
+   kosal_sem_put( logging_msg_sem(g_logging_msg));
+
+   PTRACEOUT;
+   return  res;
+}
+
+///============================================================================
+/// Name:    stop_logging_timer
+/// @brief   stops logging timer.
+///
+/// @return    error code
+///============================================================================
+int stop_logging_timer(void)
+{
+   int res = 0;
+   PTRACEIN;
+
+   kosal_sem_get_krnl( logging_msg_sem(g_logging_msg));
+
+   logging_msg_wq_status(g_logging_msg) = logging_timer_Stopped;
+
+
+   // Stop logging timer work queue.
+   if(NULL != logging_msg_wq(g_logging_msg)) {
+         kosal_cancel_workqueue( &(logging_msg_wobj(g_logging_msg).workobj));
+     }
+
+   kosal_sem_put( logging_msg_sem(g_logging_msg));
+
+   PTRACEOUT;
+   return  res;
+}
+
+///============================================================================
+/// Name:    remove_logging_timer
+/// @brief   remove ccip logging polling timer.
+///
+/// @return    error code
+///============================================================================
+int remove_logging_timer(void)
+{
+   int res = 0;
+   PTRACEIN;
+
+   //lock
+   kosal_sem_get_krnl( logging_msg_sem(g_logging_msg));
+
+   if(NULL != logging_msg_wq(g_logging_msg)) {
+
+      kosal_cancel_workqueue( &(logging_msg_wobj(g_logging_msg).workobj));
+      kosal_destroy_workqueue(logging_msg_wq(g_logging_msg));
+   }
+
+   kosal_sem_put( logging_msg_sem(g_logging_msg));
+
+   // unlock
+   PTRACEOUT;
+   return res;
+}
+
+///============================================================================
+/// Name:    error_logging_callback
+/// @brief   Worker queue logging timer callback.
+///
+/// @param[in] pwork  work queue object pointer.
+/// @return    no return value
+///============================================================================
+void error_logging_callback(struct kosal_work_object *pwork)
+{
+   struct ccip_device   *pccidev    = NULL;
+   struct list_head     *This       = NULL;
+   struct list_head     *tmp        = NULL;
+
+   //lock g_device_list
+   //kosal_sem_get_krnl(&g_dev_list_sem);
+
+   // Search through our list of devices to find the one matching pcidev
+   if ( !kosal_list_is_empty(&g_device_list) ) {
+
+      // Run through list of devices.  Use safe variant
+      //  as we will be deleting entries
+      kosal_list_for_each_safe(This, tmp, &g_device_list) {
+
+         pccidev = ccip_list_to_ccip_device(This);
+         if(NULL != ccip_list_to_ccip_device(This)) {
+            ccip_check_for_error(pccidev);
+         }
+      }
+   }
+   //unlock g_device_list
+   //kosal_sem_put(&g_dev_list_sem);
+
+   kosal_sem_get_krnl( logging_msg_sem(g_logging_msg));
+
+   // Worker Queue
+   KOSAL_INIT_WORK(&(logging_msg_wobj(g_logging_msg)),error_logging_callback);
+
+   kosal_queue_delayed_work( logging_msg_wq(g_logging_msg),
+                             &(logging_msg_wobj(g_logging_msg)),
+                             logging_msg_time(g_logging_msg));
+
+   kosal_sem_put( logging_msg_sem(g_logging_msg));
+
+}
+
+///============================================================================
+/// Name:    ccip_check_for_error
+/// @brief   enumerates fpga device list.
+///
+/// @param[in] pccipdev  ccip device pointer.
+/// @return    no return value
+///============================================================================
+void ccip_check_for_error(struct ccip_device *pccipdev)
+{
+   struct port_device *pportdev        = NULL;
+   struct list_head     *This          = NULL;
+   struct list_head     *tmp           = NULL;
+
+   if(NULL == pccipdev) {
+      return ;
+   }
+
+   if( NULL != pccipdev->m_pfme_dev) {
+      // logs fme errors
+      ccip_log_fme_error(pccipdev ,pccipdev->m_pfme_dev);
+      ccip_log_fme_ras_error(pccipdev ,pccipdev->m_pfme_dev);
+      //ccip_log_fme_ap_state(pccipdev ,pccipdev->m_pfme_dev);
+   }
+
+
+   // Search through our list of devices to find the one matching pcidev
+   if ( !kosal_list_is_empty(&(pccipdev->m_portlisthead) )) {
+
+      // Run through list of devices.  Use safe variant
+      //  as we will be deleting entries
+      kosal_list_for_each_safe(This, tmp, &pccipdev->m_portlisthead) {
+
+          pportdev = cci_list_to_cci_port_device(This);
+
+          if(NULL != cci_list_to_cci_port_device(This)) {
+             ccip_log_port_apstates(pccipdev,pportdev);
+             ccip_log_port_error(pccipdev,pportdev);
+          }
+      }
+   }
+
+}
+
+///============================================================================
+/// Name:    ccip_log_fme_ap_state
+/// @brief   logs fme app state change status to kernel logger.
+///
+/// @param[in] pccipdev  ccip device  pointer.
+/// @param[in] pfme_dev  fme device  pointer.
+/// @return    no return value
+///============================================================================
+void ccip_log_fme_ap_state(struct ccip_device *pccipdev,
+                           struct fme_device *pfme_dev)
+{
+
+   if((ccip_fme_lasttherm(pfme_dev).ccip_tmp_threshold.thshold1_status != ccip_fme_therm(pfme_dev)->ccip_tmp_threshold.thshold1_status )) {
+
+      if(0x0 == ccip_fme_therm(pfme_dev)->ccip_tmp_threshold.thshold_policy ) {
+
+         PERR(" FPGA Trigger AP2 state : %s for B:D.F = %x:%x.%x  \n", kosal_gettimestamp(),
+                                                                       ccip_dev_pcie_busnum(pccipdev),
+                                                                       ccip_dev_pcie_devnum(pccipdev),
+                                                                       ccip_dev_pcie_fcnnum(pccipdev));
+      } else {
+
+         PERR(" FPGA Trigger AP1 state : %s for B:D.F = %x:%x.%x  \n", kosal_gettimestamp(),
+                                                                       ccip_dev_pcie_busnum(pccipdev),
+                                                                       ccip_dev_pcie_devnum(pccipdev),
+                                                                       ccip_dev_pcie_fcnnum(pccipdev));
+      }
+   }
+
+   if( (ccip_fme_lasttherm(pfme_dev).ccip_tmp_threshold.thshold2_status != ccip_fme_therm(pfme_dev)->ccip_tmp_threshold.thshold2_status )){
+
+      if(0x1 == ccip_fme_therm(pfme_dev)->ccip_tmp_threshold.thshold_policy ) {
+
+         PERR(" FPGA Trigger AP6 state :%s for B:D.F = %x:%x.%x  \n", kosal_gettimestamp(),
+                                                                      ccip_dev_pcie_busnum(pccipdev),
+                                                                      ccip_dev_pcie_devnum(pccipdev),
+                                                                      ccip_dev_pcie_fcnnum(pccipdev));
+      }
+
+      // PR with null bit stream
+   }
+
+   ccip_fme_lasttherm(pfme_dev).ccip_tmp_threshold.thshold1_status = ccip_fme_therm(pfme_dev)->ccip_tmp_threshold.thshold1_status ;
+   ccip_fme_lasttherm(pfme_dev).ccip_tmp_threshold.thshold2_status = ccip_fme_therm(pfme_dev)->ccip_tmp_threshold.thshold2_status ;
+}
+
+///============================================================================
+/// Name:    ccip_log_fme_error
+/// @brief   logs fme errors to kernel logger.
+///
+/// @param[in] pccipdev  ccip device pointer.
+/// @param[in] pfme_dev  fme device  pointer.
+/// @return    no return value
+///============================================================================
+void ccip_log_fme_error(struct ccip_device *pccipdev ,struct fme_device *pfme_dev)
+{
+
+   // FME Error0
+   if((0x00 != ccip_fme_gerr(pfme_dev)->fme_err.csr) &&
+      (ccip_fme_lastgerr(pfme_dev).fme_err.csr != ccip_fme_gerr(pfme_dev)->fme_err.csr )) {
+
+      PERR(" FME Error occurred:%s B:D.F = %x:%x.%x FME Error0 CSR: 0x%llx \n",kosal_gettimestamp(),
+                                                                               ccip_dev_pcie_busnum(pccipdev),
+                                                                               ccip_dev_pcie_devnum(pccipdev),
+                                                                               ccip_dev_pcie_fcnnum(pccipdev),
+                                                                               ccip_fme_gerr(pfme_dev)->fme_err.csr);
+      log_verbose_fme_error(pfme_dev);
+   }
+
+   // FME PCIe0 Error
+   if((0x00 != ccip_fme_gerr(pfme_dev)->pcie0_err.csr) &&
+      (ccip_fme_lastgerr(pfme_dev).pcie0_err.csr != ccip_fme_gerr(pfme_dev)->pcie0_err.csr )) {
+
+      PERR(" FME Error occurred:%s B:D.F = %x:%x.%x PCIe0 Error CSR:  0x%llx \n",kosal_gettimestamp(),
+                                                                                 ccip_dev_pcie_busnum(pccipdev),
+                                                                                 ccip_dev_pcie_devnum(pccipdev),
+                                                                                 ccip_dev_pcie_fcnnum(pccipdev),
+                                                                                 ccip_fme_gerr(pfme_dev)->pcie0_err.csr);
+      log_verbose_fme_pcie0error(pfme_dev);
+   }
+
+   // FME PCIe1 Error
+   if((0x00 != ccip_fme_gerr(pfme_dev)->pcie1_err.csr) &&
+      (ccip_fme_lastgerr(pfme_dev).pcie1_err.csr != ccip_fme_gerr(pfme_dev)->pcie1_err.csr )) {
+
+      PERR(" FME Error occurred:%s B:D.F = %x:%x.%x PCIe1 Error CSR:  0x%llx \n",kosal_gettimestamp(),
+                                                                                 ccip_dev_pcie_busnum(pccipdev),
+                                                                                 ccip_dev_pcie_devnum(pccipdev),
+                                                                                 ccip_dev_pcie_fcnnum(pccipdev),
+                                                                                 ccip_fme_gerr(pfme_dev)->pcie1_err.csr);
+      log_verbose_fme_pcie1error(pfme_dev);
+   }
+
+   // FME first error
+   if((0x00 != ccip_fme_gerr(pfme_dev)->fme_first_err.csr) &&
+      (ccip_fme_lastgerr(pfme_dev).fme_first_err.csr != ccip_fme_gerr(pfme_dev)->fme_first_err.csr )) {
+
+      PERR(" FME Error occurred:%s B:D.F = %x:%x.%x FME First Error CSR:  0x%llx \n",kosal_gettimestamp(),
+                                                                                     ccip_dev_pcie_busnum(pccipdev),
+                                                                                     ccip_dev_pcie_devnum(pccipdev),
+                                                                                     ccip_dev_pcie_fcnnum(pccipdev),
+                                                                                     ccip_fme_gerr(pfme_dev)->fme_first_err.csr);
+   }
+
+   // FME next error
+   if((0x00 != ccip_fme_gerr(pfme_dev)->fme_next_err.csr) &&
+      (ccip_fme_lastgerr(pfme_dev).fme_next_err.csr != ccip_fme_gerr(pfme_dev)->fme_next_err.csr )) {
+
+      PERR(" FME Error occurred:%s B:D.F = %x:%x.%x FME Next Error CSR:  0x%llx \n",kosal_gettimestamp(),
+                                                                                    ccip_dev_pcie_busnum(pccipdev),
+                                                                                    ccip_dev_pcie_devnum(pccipdev),
+                                                                                    ccip_dev_pcie_fcnnum(pccipdev),
+                                                                                    ccip_fme_gerr(pfme_dev)->fme_next_err.csr);
+   }
+
+
+   ccip_fme_lastgerr(pfme_dev).fme_err.csr = ccip_fme_gerr(pfme_dev)->fme_err.csr ;
+   ccip_fme_lastgerr(pfme_dev).pcie0_err.csr = ccip_fme_gerr(pfme_dev)->pcie0_err.csr;
+   ccip_fme_lastgerr(pfme_dev).pcie1_err.csr = ccip_fme_gerr(pfme_dev)->pcie1_err.csr ;
+
+   ccip_fme_lastgerr(pfme_dev).fme_first_err.csr = ccip_fme_gerr(pfme_dev)->fme_first_err.csr ;
+   ccip_fme_lastgerr(pfme_dev).fme_next_err.csr  = ccip_fme_gerr(pfme_dev)->fme_next_err.csr ;
+
+}
+
+
+///============================================================================
+/// Name:    ccip_log_fme_ras_error
+/// @brief   logs fme RAS errors to kernel logger.
+///
+/// @param[in] pccipdev  ccip device pointer.
+/// @param[in] pfme_dev  fme device  pointer.
+/// @return    no return value
+///============================================================================
+void ccip_log_fme_ras_error(struct ccip_device *pccipdev ,struct fme_device *pfme_dev)
+{
+
+   // RAS Green bitstream Error
+   if((0x00 != ccip_fme_gerr(pfme_dev)->ras_gerr.csr) &&
+      (ccip_fme_lastgerr(pfme_dev).ras_gerr.csr != ccip_fme_gerr(pfme_dev)->ras_gerr.csr )) {
+
+      PERR(" RAS Green bitstream Error occurred:%s B:D.F = %x:%x.%x RAS GBS Error CSR: 0x%llx \n",kosal_gettimestamp(),
+                                                                                                  ccip_dev_pcie_busnum(pccipdev),
+                                                                                                  ccip_dev_pcie_devnum(pccipdev),
+                                                                                                  ccip_dev_pcie_fcnnum(pccipdev),
+                                                                                                  ccip_fme_gerr(pfme_dev)->ras_gerr.csr);
+      log_verbose_fme_rasgbserror(pfme_dev);
+   }
+
+   // RAS Blue bitstream Error
+   if((0x00 != ccip_fme_gerr(pfme_dev)->ras_berror.csr) &&
+      (ccip_fme_lastgerr(pfme_dev).ras_berror.csr != ccip_fme_gerr(pfme_dev)->ras_berror.csr )) {
+
+      PERR(" RAS Blue bitstream Error occurred:%s B:D.F = %x:%x.%x RAS BBS Error CSR:  0x%llx \n",kosal_gettimestamp(),
+                                                                                                  ccip_dev_pcie_busnum(pccipdev),
+                                                                                                  ccip_dev_pcie_devnum(pccipdev),
+                                                                                                  ccip_dev_pcie_fcnnum(pccipdev),
+                                                                                                  ccip_fme_gerr(pfme_dev)->ras_berror.csr);
+      log_verbose_fme_rasbbserror(pfme_dev);
+   }
+
+   // FME Warning
+   if((0x00 != ccip_fme_gerr(pfme_dev)->ras_warnerror.csr) &&
+      (ccip_fme_lastgerr(pfme_dev).ras_warnerror.csr != ccip_fme_gerr(pfme_dev)->ras_warnerror.csr )) {
+
+      PERR(" RAS Warning Error occurred:%s B:D.F = %x:%x.%x RAS Warning CSR:  0x%llx \n",kosal_gettimestamp(),
+                                                                                         ccip_dev_pcie_busnum(pccipdev),
+                                                                                         ccip_dev_pcie_devnum(pccipdev),
+                                                                                         ccip_dev_pcie_fcnnum(pccipdev),
+                                                                                         ccip_fme_gerr(pfme_dev)->ras_warnerror.csr);
+      log_verbose_fme_raswarnerror(pfme_dev);
+   }
+
+
+
+   ccip_fme_lastgerr(pfme_dev).ras_gerr.csr = ccip_fme_gerr(pfme_dev)->ras_gerr.csr ;
+   ccip_fme_lastgerr(pfme_dev).ras_berror.csr = ccip_fme_gerr(pfme_dev)->ras_berror.csr;
+   ccip_fme_lastgerr(pfme_dev).ras_warnerror.csr = ccip_fme_gerr(pfme_dev)->ras_warnerror.csr ;
+
+}
+
+///============================================================================
+/// Name:    ccip_log_port_apstates
+/// @brief   logs AP states to kernel logger.
+///
+/// @param[in] pccipdev  ccip device pointer.
+/// @param[in] pport_dev  port device pointer.
+/// @return    no return value
+///============================================================================
+void ccip_log_port_apstates(struct ccip_device *pccipdev ,struct port_device *pport_dev)
+{
+
+   // Trigger AP6 State
+   if((0x00 != ccip_port_err(pport_dev)->ccip_port_error.csr) &&
+      (ccip_port_lasterr(pport_dev).ccip_port_error.ap6_event != ccip_port_err(pport_dev)->ccip_port_error.ap6_event )) {
+
+      PERR(" FPGA Trigger AP6 state :%s for B:D.F = %x:%x.%x  \n", kosal_gettimestamp(),
+                                                                   ccip_dev_pcie_busnum(pccipdev),
+                                                                   ccip_dev_pcie_devnum(pccipdev),
+                                                                   ccip_dev_pcie_fcnnum(pccipdev));
+   }
+
+   // Trigger AP1 State
+   if((0x00 != ccip_port_hdr(pport_dev)->ccip_port_status.csr) &&
+      (ccip_port_laststatus(pport_dev).ap1_event != ccip_port_hdr(pport_dev)->ccip_port_status.ap1_event )) {
+
+      PERR(" FPGA Trigger AP1 state :%s for B:D.F = %x:%x.%x  \n", kosal_gettimestamp(),
+                                                                   ccip_dev_pcie_busnum(pccipdev),
+                                                                   ccip_dev_pcie_devnum(pccipdev),
+                                                                   ccip_dev_pcie_fcnnum(pccipdev));
+   }
+
+   // Trigger AP2 State
+   if((0x00 != ccip_port_hdr(pport_dev)->ccip_port_status.csr) &&
+      (ccip_port_laststatus(pport_dev).ap2_event != ccip_port_hdr(pport_dev)->ccip_port_status.ap2_event )) {
+
+      PERR(" FPGA Trigger AP2 state :%s for B:D.F = %x:%x.%x  \n", kosal_gettimestamp(),
+                                                                   ccip_dev_pcie_busnum(pccipdev),
+                                                                   ccip_dev_pcie_devnum(pccipdev),
+                                                                   ccip_dev_pcie_fcnnum(pccipdev));
+   }
+
+   // Save Port Error and Status CSR
+   ccip_port_lasterr(pport_dev).ccip_port_error.csr       = ccip_port_err(pport_dev)->ccip_port_error.csr ;
+   ccip_port_laststatus(pport_dev).csr                    = ccip_port_hdr(pport_dev)->ccip_port_status.csr ;
+
+
+}
+///============================================================================
+/// Name:    ccip_log_port_error
+/// @brief   logs port errors to kernel logger.
+///
+/// @param[in] pccipdev  ccip device pointer.
+/// @param[in] pport_dev  port device pointer.
+/// @return    no return value
+///============================================================================
+void ccip_log_port_error(struct ccip_device *pccipdev ,struct port_device *pport_dev)
+{
+
+   // Port Error
+   if((0x00 != ccip_port_err(pport_dev)->ccip_port_error.csr) &&
+      (ccip_port_lasterr(pport_dev).ccip_port_error.csr != ccip_port_err(pport_dev)->ccip_port_error.csr )) {
+
+      PERR(" PORT Error occurred:%s B:D.F = %x:%x.%x  PORT Error CSR: 0x%llx \n", kosal_gettimestamp(),
+                                                                                  ccip_dev_pcie_busnum(pccipdev),
+                                                                                  ccip_dev_pcie_devnum(pccipdev),
+                                                                                  ccip_dev_pcie_fcnnum(pccipdev),
+                                                                                  ccip_port_err(pport_dev)->ccip_port_error.csr);
+      log_verbose_port_error(pport_dev);
+   }
+
+   // Port First Error
+   if((0x00 != ccip_port_err(pport_dev)->ccip_port_first_error.csr) &&
+      (ccip_port_lasterr(pport_dev).ccip_port_first_error.csr != ccip_port_err(pport_dev)->ccip_port_first_error.csr )) {
+
+      PERR(" PORT Error occurred%s B:D.F = %x:%x.%x  PORT First Error CSR: 0x%llx \n",kosal_gettimestamp(),
+                                                                                      ccip_dev_pcie_busnum(pccipdev),
+                                                                                      ccip_dev_pcie_devnum(pccipdev),
+                                                                                      ccip_dev_pcie_fcnnum(pccipdev),
+                                                                                      ccip_port_err(pport_dev)->ccip_port_first_error.csr);
+   }
+
+   if( 0x00 != ccip_port_err(pport_dev)->ccip_port_error.csr)  {
+
+      // Port malformed request
+      if((0x00 != ( ccip_port_err(pport_dev)->ccip_port_malformed_req_0.csr) + ( ccip_port_err(pport_dev)->ccip_port_malformed_req_1.csr)) &&
+         ((ccip_port_lasterr(pport_dev).ccip_port_malformed_req_0.csr  + ccip_port_lasterr(pport_dev).ccip_port_malformed_req_1.csr ) !=
+           ccip_port_err(pport_dev)->ccip_port_malformed_req_0.csr + ccip_port_err(pport_dev)->ccip_port_malformed_req_1.csr ))  {
+
+         PERR(" PORT Error occurred;%s B:D.F = %x:%x.%x PORT Malfromed req lsb CSR:0x%llx  msb CSR:0x%llx \n",kosal_gettimestamp(),
+                                                                                                              ccip_dev_pcie_busnum(pccipdev),
+                                                                                                              ccip_dev_pcie_devnum(pccipdev),
+                                                                                                              ccip_dev_pcie_fcnnum(pccipdev),
+                                                                                                              ccip_port_err(pport_dev)->ccip_port_malformed_req_0.csr ,
+                                                                                                              ccip_port_err(pport_dev)->ccip_port_malformed_req_1.csr);
+
+
+      }
+
+   }
+
+   ccip_port_lasterr(pport_dev).ccip_port_error.csr       = ccip_port_err(pport_dev)->ccip_port_error.csr ;
+   ccip_port_lasterr(pport_dev).ccip_port_first_error.csr = ccip_port_err(pport_dev)->ccip_port_first_error.csr ;
+
+   ccip_port_lasterr(pport_dev).ccip_port_malformed_req_0.csr = ccip_port_err(pport_dev)->ccip_port_malformed_req_0.csr ;
+   ccip_port_lasterr(pport_dev).ccip_port_malformed_req_1.csr = ccip_port_err(pport_dev)->ccip_port_malformed_req_1.csr ;
+
+}
+
+///============================================================================
+/// Name:    ccip_log_pr_error
+/// @brief   logs pr errors to kernel logger.
+///
+/// @param[in] pfme_dev  fme device pointer.
+/// @return    no return value
+///============================================================================
+void ccip_log_pr_error(struct fme_device *pfme_dev )
+{
+   struct CCIP_FME_DFL_PR   *pPR_DFH  = NULL;
+
+   PTRACEIN;
+
+   if(NULL == pfme_dev) {
+       return ;
+   }
+
+   pPR_DFH   = ccip_fme_pr(pfme_dev);
+
+   // PR status bit set
+   if(0x1 == pPR_DFH->ccip_fme_pr_status.pr_status)  {
+
+      // Logging PR Host Status
+      switch( pPR_DFH->ccip_fme_pr_status.pr_host_status)
+      {
+        case  CCIP_PORT_PR_Idle:
+           PERR(" PR Host Status: Idle,Waiting for PR start.\n");
+           break;
+
+        case  CCIP_PORT_PR_RecStart:
+           PERR(" PR Host Status: Received PR Start, Checking initial condition. \n");
+           break;
+
+        case  CCIP_PORT_PR_ReSet:
+           PERR(" PR Host Status: Reset and Freeze port. \n");
+           break;
+
+        case  CCIP_PORT_WaitFreeze:
+           PERR(" PR Host Status: Wait for Freeze Propagation. \n");
+           break;
+
+        case  CCIP_PORT_WaitPR:
+           PERR(" PR Host Status: Wait for PR data \n");
+           break;
+
+        case  CCIP_PORT_SendFrst_Data:
+           PERR(" PR Host Status: Send First data to PR. \n");
+           break;
+
+        case  CCIP_PORT_WaitPRReady:
+           PERR(" PR Host Status: Wait for PR IP Ready.\n");
+           break;
+
+        case  CCIP_PORT_PushFIFO_IP:
+           PERR(" PR Host Status: Push Data from FIFO to IP. \n");
+           break;
+
+        case  CCIP_PORT_WaitPR_Resp:
+           PERR(" PR Host Status: Wait for PE IP Response. \n");
+           break;
+
+        case  CCIP_PORT_PR_Complete:
+           PERR(" PR Host Status: Completion State. \n");
+           break;
+
+        case  CCIP_PORT_PR_UnFreeze:
+           PERR(" PR Host Status: UnFreeze AFU .\n");
+           break;
+
+        case  CCIP_PORT_PR_DeAssert:
+           PERR(" PR Host Status: De-Assert PR request bit. \n");
+           break;
+
+      }
+
+      // Logging PR Controller Block Status
+      switch( pPR_DFH->ccip_fme_pr_status.pr_contoller_status)
+      {
+        case  CCIP_PR_CLB_pwrup:
+           PERR(" PR Controller Block: Power-up or nreset asserted\n");
+           break;
+        case  CCIP_PR_CLB_error:
+           PERR(" PR Controller Block: Error was triggered \n");
+           break;
+
+        case  CCIP_PR_CLB_crc_err:
+           PERR(" PR Controller Block: CRC error triggered \n");
+           break;
+
+        case  CCIP_PR_CLB_Incomp_bts_err:
+           PERR(" PR Controller Block: Incompatible bitstream error detected \n");
+           break;
+
+        case  CCIP_PR_CLB_opr_inPros:
+           PERR(" PR Controller Block: PR Operation passed. \n");
+           break;
+      }
+
+      // Logging PR Errors
+      if(0x1 == pPR_DFH->ccip_fme_pr_err.PR_operation_err ) {
+         PERR(" PR PR Operation Error  Detected \n");
+      }
+
+      if(0x1 == pPR_DFH->ccip_fme_pr_err.PR_CRC_err ) {
+         PERR(" PR CRC Error Detected \n");
+      }
+
+      if(0x1 == pPR_DFH->ccip_fme_pr_err.PR_bitstream_err ) {
+         PERR(" PR Incomparable bitstream Error  Detected \n");
+      }
+
+      if(0x1 == pPR_DFH->ccip_fme_pr_err.PR_IP_err ) {
+         PERR(" PR IP Protocol Error Detected \n");
+      }
+
+      if(0x1 == pPR_DFH->ccip_fme_pr_err.PR_FIFIO_err ) {
+         PERR(" PR  FIFO Overflow Error Detected \n");
+      }
+
+      if(0x1 == pPR_DFH->ccip_fme_pr_err.PR_timeout_err ) {
+         PERR(" PR Timeout  Error Detected \n");
+      }
+
+   }
+
+   PTRACEOUT;
+}
+
+///============================================================================
+/// Name:    log_verbose_fme_error
+/// @brief   logs fme errors description to kernel logger.
+///
+/// @param[in] pfme_dev  fme device pointer.
+/// @return    no return value
+///============================================================================
+void log_verbose_fme_error(struct fme_device *pfme_dev)
+{
+   struct CCIP_FME_ERROR0  fme_error0  ;
+   if(NULL == pfme_dev){
+      return ;
+   }
+
+   fme_error0.csr  = (ccip_fme_gerr(pfme_dev)->fme_err.csr ) &
+                     (~ccip_fme_lastgerr(pfme_dev).fme_err.csr);
+
+   // FME Error
+   if(fme_error0.fabric_err) {
+      PERR(" FME Error: %s \n",AAL_ERR_FME_FAB);
+   }
+
+   if(fme_error0.fabFifo_uoflow) {
+      PERR(" FME Error: %s \n",AAL_ERR_FME_FAB_UNDEROVERFLOW);
+   }
+
+   if(fme_error0.pcie0_poison_detected) {
+      PERR(" FME Error: %s \n",AAL_ERR_FME_PCIE0_POISON_DETECT);
+   }
+
+   if(fme_error0.pcie1_poison_detected) {
+      PERR(" FME Error: %s \n",AAL_ERR_FME_PCIE1_POISON_DETECT);
+   }
+
+   if(fme_error0.iommu_parity_error) {
+      PERR(" FME Error: %s \n",AAL_ERR_FME_IOMMU_PARITY);
+   }
+
+   if(fme_error0.afuerr_access_mismatch) {
+      PERR(" FME Error: %s \n",AAL_ERR_FME_AFUMISMATCH_DETECT);
+   }
+
+   if(fme_error0.mbp_event) {
+      PERR(" FME Error: %s \n",AAL_ERR_FME_MBPEVENT);
+   }
+}
+
+///============================================================================
+/// Name:    log_verbose_fme_pcie0error
+/// @brief   logs pcie0 errors description to kernel logger.
+///
+/// @param[in] pfme_dev  fme device pointer.
+/// @return    no return value
+///============================================================================
+void log_verbose_fme_pcie0error(struct fme_device *pfme_dev)
+{
+   struct CCIP_FME_PCIE0_ERROR pcie0_error ;
+   if(NULL == pfme_dev){
+      return ;
+   }
+
+   pcie0_error.csr  = (ccip_fme_gerr(pfme_dev)->pcie0_err.csr ) &
+                      (~ccip_fme_lastgerr(pfme_dev).pcie0_err.csr);
+
+   // PCIe0 Error
+   if(pcie0_error.formattype_err) {
+      PERR(" PCIe0 Error: %s \n",AAL_ERR_PCIE0_FORMAT);
+   }
+
+   if(pcie0_error.MWAddr_err) {
+      PERR(" PCIe0 Error: %s \n",AAL_ERR_PCIE0_MWADDR);
+   }
+
+   if(pcie0_error.MWAddrLength_err) {
+      PERR(" PCIe0 Error: %s \n",AAL_ERR_PCIE0_MWLEN);
+   }
+
+   if(pcie0_error.MRAddr_err) {
+      PERR(" PCIe0 Error: %s \n",AAL_ERR_PCIE0_MRADDR);
+   }
+
+   if(pcie0_error.MRAddrLength_err) {
+      PERR(" PCIe0 Error: %s \n",AAL_ERR_PCIE0_MRLEN);
+   }
+
+   if(pcie0_error.cpl_tag_err) {
+      PERR(" PCIe0 Error: %s \n",AAL_ERR_PCIE0_COMPTAG);
+   }
+
+   if(pcie0_error.cpl_status_err) {
+      PERR(" PCIe0 Error: %s \n",AAL_ERR_PCIE0_COMPSTAT);
+   }
+
+   if(pcie0_error.cpl_timeout_err) {
+      PERR(" PCIe0 Error: %s \n",AAL_ERR_PCIE0_TIMEOUT);
+   }
+
+}
+
+///============================================================================
+/// Name:    log_verbose_fme_pcie1error
+/// @brief   logs pcie1 errors description to kernel logger.
+///
+/// @param[in] pfme_dev  fme device pointer.
+/// @return    no return value
+///============================================================================
+void log_verbose_fme_pcie1error(struct fme_device *pfme_dev)
+{
+   struct CCIP_FME_PCIE1_ERROR pcie1_error ;
+   if(NULL == pfme_dev){
+      return ;
+   }
+
+   pcie1_error.csr  = (ccip_fme_gerr(pfme_dev)->pcie1_err.csr ) &
+                      (~ccip_fme_lastgerr(pfme_dev).pcie1_err.csr);
+
+   // PCIe1 Error
+   if(pcie1_error.formattype_err) {
+      PERR(" PCIe1 Error: %s \n",AAL_ERR_PCIE1_FORMAT);
+   }
+
+   if(pcie1_error.MWAddr_err) {
+      PERR(" PCIe1 Error: %s \n",AAL_ERR_PCIE1_MWADDR);
+   }
+
+   if(pcie1_error.MWAddrLength_err) {
+      PERR(" PCIe1 Error: %s \n",AAL_ERR_PCIE1_MWLEN);
+   }
+
+   if(pcie1_error.MRAddr_err) {
+      PERR(" PCIe1 Error: %s \n",AAL_ERR_PCIE1_MRADDR);
+   }
+
+   if(pcie1_error.MRAddrLength_err) {
+      PERR(" PCIe1 Error: %s \n",AAL_ERR_PCIE1_MRLEN);
+   }
+
+   if(pcie1_error.cpl_tag_err) {
+      PERR(" PCIe1 Error: %s \n",AAL_ERR_PCIE1_COMPTAG);
+   }
+
+   if(pcie1_error.cpl_status_err) {
+      PERR(" PCIe1 Error: %s \n",AAL_ERR_PCIE1_COMPSTAT);
+   }
+
+}
+
+///============================================================================
+/// Name:    log_verbose_fme_rasgbserror
+/// @brief   logs ras gbs errors description to kernel logger.
+///
+/// @param[in] pfme_dev  fme device pointer.
+/// @return    no return value
+///============================================================================
+void log_verbose_fme_rasgbserror(struct fme_device *pfme_dev)
+{
+   struct CCIP_FME_RAS_GERROR  ras_gerr ;
+   if(NULL == pfme_dev){
+      return ;
+   }
+
+   ras_gerr.csr  = (ccip_fme_gerr(pfme_dev)->ras_gerr.csr ) &
+                   (~ccip_fme_lastgerr(pfme_dev).ras_gerr.csr);
+
+   // RAS Green bitstream
+   if(ras_gerr.temp_trash_ap1) {
+      PERR(" RAS GBS Error: %s \n",AAL_ERR_RAS_TEMPAP1);
+   }
+
+   if(ras_gerr.temp_trash_ap2) {
+      PERR(" RAS GBS Error: %s \n",AAL_ERR_RAS_TEMPAP2);
+   }
+
+   if(ras_gerr.pcie_error) {
+      PERR(" RAS GBS Error: %s \n",AAL_ERR_RAS_PCIE);
+   }
+
+   if(ras_gerr.afufatal_error) {
+      PERR(" RAS GBS Error: %s \n",AAL_ERR_RAS_AFUFATAL);
+   }
+
+   if(ras_gerr.afu_access_mismatch) {
+      PERR(" RAS GBS Error: %s \n",AAL_ERR_RAS_AFUACCESS_MODE);
+   }
+
+   if(ras_gerr.pcie_poison_error) {
+      PERR(" RAS GBS Error: %s \n",AAL_ERR_RAS_PCIEPOISON);
+   }
+
+   if(ras_gerr.gb_crc_err) {
+      PERR(" RAS GBS Error: %s \n",AAL_ERR_RAS_GBCRC);
+   }
+
+   if(ras_gerr.temp_trash_ap6) {
+      PERR(" RAS GBS Error: %s \n",AAL_ERR_RAS_TEMPAP6);
+   }
+
+   if(ras_gerr.power_trash_ap1) {
+      PERR(" RAS GBS Error: %s \n",AAL_ERR_RAS_POWERAP1);
+   }
+
+   if(ras_gerr.power_trash_ap2) {
+      PERR(" RAS GBS Error: %s \n",AAL_ERR_RAS_POWERAP2);
+   }
+
+   if(ras_gerr.mbp_error) {
+      PERR(" RAS GBS Error: %s \n",AAL_ERR_RAS_MDP);
+   }
+
+
+}
+
+///============================================================================
+/// Name:    log_verbose_fme_rasbbserror
+/// @brief   logs ras bbs errors description to kernel logger.
+///
+/// @param[in] pfme_dev  fme device pointer.
+/// @return    no return value
+///============================================================================
+void log_verbose_fme_rasbbserror(struct fme_device *pfme_dev)
+{
+   struct CCIP_FME_RAS_BERROR ras_berror ;
+   if(NULL == pfme_dev){
+      return ;
+   }
+
+   ras_berror.csr  = (ccip_fme_gerr(pfme_dev)->ras_berror.csr ) &
+                     (~ccip_fme_lastgerr(pfme_dev).ras_berror.csr);
+
+
+   // RAS Blue bitstream Error
+   if(ras_berror.ktilink_fatal_err) {
+      PERR(" RAS BBS Error: %s \n",AAL_ERR_RAS_KTILINK_FATAL);
+   }
+
+   if(ras_berror.tagcch_fatal_err) {
+      PERR(" RAS BBS Error: %s \n",AAL_ERR_RAS_TAGCCH_FATAL);
+   }
+
+   if(ras_berror.cci_fatal_err) {
+      PERR(" RAS BBS Error: %s \n",AAL_ERR_RAS_CCI_FATAL);
+   }
+
+   if(ras_berror.ktiprpto_fatal_err) {
+      PERR(" RAS BBS Error: %s \n",AAL_ERR_RAS_KTIPROTO_FATAL);
+   }
+
+   if(ras_berror.dma_fatal_err) {
+      PERR(" RAS BBS Error: %s \n",AAL_ERR_RAS_DMA_FATAL);
+   }
+
+   if(ras_berror.iommu_fatal_err) {
+      PERR(" RAS BBS Error: %s \n",AAL_ERR_RAS_IOMMU_FATAL);
+   }
+
+   if(ras_berror.iommu_catast_err) {
+      PERR(" RAS BBS Error: %s \n",AAL_ERR_RAS_IOMMU_CATAS);
+   }
+
+   if(ras_berror.crc_catast_err) {
+      PERR(" RAS BBS Error: %s \n",AAL_ERR_RAS_CRC_CATAS);
+   }
+
+   if(ras_berror.therm_catast_err) {
+      PERR(" RAS BBS Error: %s \n",AAL_ERR_PCIE1_COMPSTAT);
+   }
+
+}
+
+///============================================================================
+/// Name:    log_verbose_fme_raswarnerror
+/// @brief   logs ras warning errors description to kernel logger.
+///
+/// @param[in] pfme_dev  fme device pointer.
+/// @return    no return value
+///============================================================================
+void log_verbose_fme_raswarnerror(struct fme_device *pfme_dev)
+{
+   struct CCIP_FME_RAS_WARNERROR ras_warnerror;
+   if(NULL == pfme_dev){
+      return ;
+   }
+
+   ras_warnerror.csr  = (ccip_fme_gerr(pfme_dev)->ras_warnerror.csr ) &
+                        (~ccip_fme_lastgerr(pfme_dev).ras_warnerror.csr);
+
+   if(ras_warnerror.event_warn_err) {
+      PERR(" RAS Warning  Error: %s \n",AAL_ERR_RAS_WARNING);
+   }
+
+}
+
+///============================================================================
+/// Name:    log_verbose_port_error
+/// @brief   logs port errors description to kernel logger.
+///
+/// @param[in] pport_dev  port device pointer.
+/// @return    no return value
+///============================================================================
+void log_verbose_port_error(struct port_device *pport_dev)
+{
+   struct CCIP_PORT_ERROR port_error ;
+   if(NULL == pport_dev){
+      return ;
+   }
+
+   port_error.csr  = (~ccip_port_lasterr(pport_dev).ccip_port_error.csr ) &
+                     ( ccip_port_err(pport_dev)->ccip_port_error.csr);
+
+   if(port_error.tx_ch0_overflow) {
+      PERR(" PORT Error: %s \n",AAL_ERR_PORT_TX_CH0_OVERFLOW);
+   }
+
+   if(port_error.tx_ch0_invalidreq) {
+      PERR(" PORT Error: %s \n",AAL_ERR_PORT_TX_CH0_INVALIDREQ);
+   }
+
+   if(port_error.tx_ch0_req_cl_len3) {
+      PERR(" PORT Error: %s \n",AAL_ERR_PORT_TX_CH0_REQ_CL_LEN3);
+   }
+
+   if(port_error.tx_ch0_req_cl_len2) {
+      PERR(" PORT Error: %s \n",AAL_ERR_PORT_TX_CH0_REQ_CL_LEN2);
+   }
+
+   if(port_error.afummio_rdrecv_portreset) {
+      PERR(" PORT Error: %s \n",AAL_ERR_PORT_AFUMMIO_RDRECV_PORTRESET);
+   }
+
+   if(port_error.afummio_wrrecv_portreset) {
+      PERR(" PORT Error: %s \n",AAL_ERR_PORT_AFUMMIO_WRRECV_PORTRESET);
+   }
+
+   if(port_error.tx_ch0_req_cl_len4) {
+      PERR(" PORT Error: %s \n",AAL_ERR_PORT_TX_CH0_REQ_CL_LEN4);
+   }
+
+   if(port_error.tx_ch1_overflow) {
+      PERR(" PORT Error: %s \n",AAL_ERR_PORT_TX_CH1_OVERFLOW);
+   }
+
+   if(port_error.tx_ch1_invalidreq) {
+      PERR(" PORT Error: %s \n",AAL_ERR_PORT_TX_CH1_INVALIDREQ);
+   }
+
+   if(port_error.tx_ch1_req_cl_len3) {
+      PERR(" PORT Error: %s \n",AAL_ERR_PORT_TX_CH1_REQ_CL_LEN3);
+   }
+
+   if(port_error.tx_ch1_req_cl_len2) {
+      PERR(" PORT Error: %s \n",AAL_ERR_PORT_TX_CH1_REQ_CL_LEN2);
+   }
+
+   if(port_error.tx_ch1_req_cl_len4) {
+      PERR(" PORT Error: %s \n",AAL_ERR_PORT_TX_CH1_REQ_CL_LEN4);
+   }
+
+   if(port_error.tx_ch1_insuff_datapayload) {
+      PERR(" PORT Error: %s \n",AAL_ERR_PORT_TX_CH1_INSUFF_DATAPYL);
+   }
+
+   if(port_error.tx_ch1_datapayload_overrun) {
+      PERR(" PORT Error: %s \n",AAL_ERR_PORT_TX_CH1_DATAPYL_OVERRUN);
+   }
+
+   if(port_error.tx_ch1_incorr_addr) {
+      PERR(" PORT Error: %s \n",AAL_ERR_PORT_TX_CH1_INCORR_ADDR);
+   }
+
+   if(port_error.tx_ch1_sop_detcted) {
+      PERR(" PORT Error: %s \n",AAL_ERR_PORT_TX_CH1_SOP_DETECTED);
+   }
+
+   if(port_error.mmioread_timeout) {
+      PERR(" PORT Error: %s \n",AAL_ERR_PORT_MMIOREAD_TIMEOUT);
+   }
+
+   if(port_error.tx_ch2_fifo_overflow) {
+      PERR(" PORT Error: %s \n",AAL_ERR_PORT_TX_CH2_FIFO_OVERFLOW);
+   }
+
+   if(port_error.unexp_mmio_resp) {
+      PERR(" PORT Error: %s \n",AAL_ERR_PORT_UNEXP_MMIORESP);
+   }
+
+   if(port_error.num_pending_req_overflow) {
+      PERR(" PORT Error: %s \n",AAL_ERR_PORT_NUM_PENDREQ_OVERFLOW);
+   }
+
+   if(port_error.llpr_smrr_err) {
+      PERR(" PORT Error: %s \n",AAL_ERR_PORT_LLPR_SMRR);
+   }
+
+   if(port_error.llpr_smrr2_err) {
+      PERR(" PORT Error: %s \n",AAL_ERR_PORT_LLPR_SMRR2);
+   }
+
+   if(port_error.llpr_mesg_err) {
+      PERR(" PORT Error: %s \n",AAL_ERR_PORT_LLPR_MSG);
+   }
+
+   if(port_error.genport_range_err) {
+      PERR(" PORT Error: %s \n",AAL_ERR_PORT_GENPORT_RANGE);
+   }
+
+   if(port_error.legrange_low_err) {
+      PERR(" PORT Error: %s \n",AAL_ERR_PORT_LEGRANGE_LOW);
+   }
+
+   if(port_error.legrange_hight_err) {
+      PERR(" PORT Error: %s \n",AAL_ERR_PORT_LEGRANGE_HIGH);
+   }
+
+   if(port_error.vgmem_range_err) {
+      PERR(" PORT Error: %s \n",AAL_ERR_PORT_VGAMEM_RANGE);
+   }
+
+   if(port_error.page_fault_err) {
+      PERR(" PORT Error: %s \n",AAL_ERR_PORT_PAGEFAULT);
+   }
+
+   if(port_error.pmr_err) {
+      PERR(" PORT Error: %s \n",AAL_ERR_PORT_PMRERROR);
+   }
+
+   if(port_error.ap6_event) {
+      PERR(" PORT Error: %s \n",AAL_ERR_PORT_AP6EVENT);
+   }
+
+   if(port_error.vfflr_accesseror) {
+      PERR(" PORT Error: %s \n",AAL_ERR_PORT_VFFLR_ACCESS);
+   }
+
+}
+
+///============================================================================
+/// Name:    ccip_log_bad_vkey
+/// @brief   logs bad v-key value.
+///
+/// @param[in] no input parameter.
+/// @return    no return value
+///============================================================================
+void ccip_log_bad_vkey(void)
+{
+
+   PTRACEIN;
+
+
+   PTRACEOUT;
+}
+
+
+END_NAMESPACE(AAL)
diff --git a/drivers/fpga/aal/cci/ccip_logging.h b/drivers/fpga/aal/cci/ccip_logging.h
new file mode 100644
index 000000000000..1d1a8674505b
--- /dev/null
+++ b/drivers/fpga/aal/cci/ccip_logging.h
@@ -0,0 +1,357 @@
+//******************************************************************************
+// This  file  is  provided  under  a  dual BSD/GPLv2  license.  When using or
+//         redistributing this file, you may do so under either license.
+//
+//                            GPL LICENSE SUMMARY
+//
+//  Copyright(c) 2015-2017, Intel Corporation.
+//
+//  This program  is  free software;  you  can redistribute it  and/or  modify
+//  it  under  the  terms of  version 2 of  the GNU General Public License  as
+//  published by the Free Software Foundation.
+//
+//  This  program  is distributed  in the  hope that it  will  be useful,  but
+//  WITHOUT   ANY   WARRANTY;   without   even  the   implied   warranty    of
+//  MERCHANTABILITY  or  FITNESS  FOR  A  PARTICULAR  PURPOSE.  See  the   GNU
+//  General Public License for more details.
+//
+//  The  full  GNU  General Public License is  included in  this  distribution
+//  in the file called README.GPLV2-LICENSE.TXT.
+//
+//  Contact Information:
+//  Henry Mitchel, henry.mitchel at intel.com
+//  77 Reed Rd., Hudson, MA  01749
+//
+//                                BSD LICENSE
+//
+//  Copyright(c) 2015-2017, Intel Corporation.
+//
+//  Redistribution and  use  in source  and  binary  forms,  with  or  without
+//  modification,  are   permitted  provided  that  the  following  conditions
+//  are met:
+//
+//    * Redistributions  of  source  code  must  retain  the  above  copyright
+//      notice, this list of conditions and the following disclaimer.
+//    * Redistributions in  binary form  must  reproduce  the  above copyright
+//      notice,  this  list of  conditions  and  the  following disclaimer  in
+//      the   documentation   and/or   other   materials   provided  with  the
+//      distribution.
+//    * Neither   the  name   of  Intel  Corporation  nor  the  names  of  its
+//      contributors  may  be  used  to  endorse  or promote  products derived
+//      from this software without specific prior written permission.
+//
+//  THIS  SOFTWARE  IS  PROVIDED  BY  THE  COPYRIGHT HOLDERS  AND CONTRIBUTORS
+//  "AS IS"  AND  ANY  EXPRESS  OR  IMPLIED  WARRANTIES,  INCLUDING,  BUT  NOT
+//  LIMITED  TO, THE  IMPLIED WARRANTIES OF  MERCHANTABILITY  AND FITNESS  FOR
+//  A  PARTICULAR  PURPOSE  ARE  DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT
+//  OWNER OR CONTRIBUTORS BE LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,
+//  SPECIAL,  EXEMPLARY,  OR  CONSEQUENTIAL   DAMAGES  (INCLUDING,   BUT   NOT
+//  LIMITED  TO,  PROCUREMENT  OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF USE,
+//  DATA,  OR PROFITS;  OR BUSINESS INTERRUPTION)  HOWEVER  CAUSED  AND ON ANY
+//  THEORY  OF  LIABILITY,  WHETHER  IN  CONTRACT,  STRICT LIABILITY,  OR TORT
+//  (INCLUDING  NEGLIGENCE  OR OTHERWISE) ARISING  IN ANY WAY  OUT  OF THE USE
+//  OF  THIS  SOFTWARE, EVEN IF ADVISED  OF  THE  POSSIBILITY  OF SUCH DAMAGE.
+//******************************************************************************
+//****************************************************************************
+/// @file ccip_logging.h
+/// @brief  Definitions for ccip logging.
+/// @ingroup aalkernel_ccip
+/// @verbatim
+//        FILE: ccip_logging.h
+//     CREATED: June 07, 2016
+//      AUTHOR: , Intel Corporation
+//
+//
+// PURPOSE:
+// HISTORY:
+// COMMENTS:
+// WHEN:          WHO:     WHAT:
+//****************************************************************************///
+
+
+#ifndef __AALKERNEL_CCIP_LOOGING_DEF_H_
+#define __AALKERNEL_CCIP_LOOGING_DEF_H_
+
+#include <aalsdk/kernel/aaltypes.h>
+#include <aalsdk/kernel/ccip_defs.h>
+#include "cci_pcie_driver_internal.h"
+
+
+BEGIN_NAMESPACE(AAL)
+
+// logging work queue status.
+typedef enum
+{
+   logging_timer_idle = 0x0,
+   logging_timer_Running,
+   logging_timer_Stopped
+
+} logging_wq_status_e;
+
+struct logging_msg
+{
+   // Logging worker queue
+   kosal_work_queue                 m_workq_logging;
+
+   // Logging work object
+   struct kosal_work_object         m_workobject;
+
+   // logging timer value
+   unsigned long                    m_logging_timer_value;
+   // semaphore
+   kosal_semaphore                  m_logging_sem;
+
+   logging_wq_status_e              m_logginf_wq_status;
+};
+
+#define logging_msg_wq(pdev)            ((pdev).m_workq_logging)
+#define logging_msg_wobj(pdev)          ((pdev).m_workobject)
+#define logging_msg_time(pdev)          ((pdev).m_logging_timer_value)
+#define logging_msg_sem(pdev)           (&(pdev).m_logging_sem)
+#define logging_msg_wq_status(pdev)     ((pdev).m_logginf_wq_status)
+
+// FME Error definitions
+#define AAL_ERR_FME_FAB                        "Fabric Error"
+#define AAL_ERR_FME_FAB_UNDEROVERFLOW          "Fabric FIFO Under / Overflow error"
+#define AAL_ERR_FME_PCIE0_POISON_DETECT        "PCIe0 Poison Detected"
+#define AAL_ERR_FME_PCIE1_POISON_DETECT        "PCIe1 Poison Detected"
+#define AAL_ERR_FME_IOMMU_PARITY               "IOMMU Parity Error"
+#define AAL_ERR_FME_AFUMISMATCH_DETECT         "AFU PF/VF Access Mismatch detected"
+#define AAL_ERR_FME_MBPEVENT                   "MBP error event"
+
+
+#define AAL_ERR_PCIE0_FORMAT                   "PCIe0 TLP Format/type error"
+#define AAL_ERR_PCIE0_MWADDR                   "PCIe0 TLP MW Address error"
+#define AAL_ERR_PCIE0_MWLEN                    "PCIe0 TLP MW Length error"
+#define AAL_ERR_PCIE0_MRADDR                   "PCIe0 TLP MR Address error"
+#define AAL_ERR_PCIE0_MRLEN                    "PCIe0 TLP MR Length error"
+#define AAL_ERR_PCIE0_COMPTAG                  "PCIe0 TLP CPL TAP error"
+#define AAL_ERR_PCIE0_COMPSTAT                 "PCIe0 TLP CPL Status error"
+#define AAL_ERR_PCIE0_TIMEOUT                  "PCIe0 TLP CPL Timeout error"
+
+
+#define AAL_ERR_PCIE1_FORMAT                   "PCIe1 TLP Format/type error"
+#define AAL_ERR_PCIE1_MWADDR                   "PCIe1 TLP MW Address error"
+#define AAL_ERR_PCIE1_MWLEN                    "PCIe1 TLP MW Length error"
+#define AAL_ERR_PCIE1_MRADDR                   "PCIe1 TLP MR Address error"
+#define AAL_ERR_PCIE1_MRLEN                    "PCIe1 TLP MR Length error"
+#define AAL_ERR_PCIE1_COMPTAG                  "PCIe1 TLP CPL TAP error"
+#define AAL_ERR_PCIE1_COMPSTAT                 "PCIe1 TLP CPL Status error"
+#define AAL_ERR_PCIE1_TIMEOUT                  "PCIe1 TLP CPL Timeout error"
+
+#define AAL_ERR_PCIE_PHYFUNCERROR              "Physical function error"
+#define AAL_ERR_PCIE_VIRTFUNCERROR             "Virtual function error"
+
+#define AAL_ERR_RAS_TEMPAP1                    "Thermal threshold Triggered AP1"
+#define AAL_ERR_RAS_TEMPAP2                    "Thermal threshold Triggered AP2"
+#define AAL_ERR_RAS_PCIE                       "PCIe Fatal Error"
+#define AAL_ERR_RAS_AFUFATAL                   "AFU Fatal error has occurred in AFU port"
+#define AAL_ERR_RAS_PROCHOT                    "Indicates A Proc Hot event"
+#define AAL_ERR_RAS_AFUACCESS_MODE             "AFU PF/VF access mode mismatch"
+#define AAL_ERR_RAS_PCIEPOISON                 "PCIe poison port  error"
+#define AAL_ERR_RAS_GBCRC                      "Green bitstream CRC Error"
+#define AAL_ERR_RAS_TEMPAP6                    "Thremal threshold Triggered AP6"
+#define AAL_ERR_RAS_POWERAP1                   "Power threshold Triggered AP1"
+#define AAL_ERR_RAS_POWERAP2                   "Power threshold Triggered AP2"
+#define AAL_ERR_RAS_MDP                        "MBP error event "
+
+#define AAL_ERR_RAS_KTILINK_FATAL              "KTI Link layer Fatal error"
+#define AAL_ERR_RAS_TAGCCH_FATAL               "tag-n-cache Fatal error"
+#define AAL_ERR_RAS_CCI_FATAL                  "CCI Fatal error"
+#define AAL_ERR_RAS_KTIPROTO_FATAL             "KTI Protocal Fatal error"
+#define AAL_ERR_RAS_DMA_FATAL                  "DMA Fatal error"
+#define AAL_ERR_RAS_INJ_FATAL                  "Injected Fatal error"
+#define AAL_ERR_RAS_IOMMU_FATAL                "IOMMU Fatal error"
+#define AAL_ERR_RAS_IOMMU_CATAS                "Catastrophic IOMMU Error"
+#define AAL_ERR_RAS_CRC_CATAS                  "Catastrophic CRC Error"
+#define AAL_ERR_RAS_THER_CATAS                 "Catastrophic Thermal Error"
+#define AAL_ERR_RAS_GB_FATAL                   "Green bitstream fatal event Error"
+#define AAL_ERR_RAS_INJ_CATAS                  "Injected Catastrophic error"
+
+#define AAL_ERR_RAS_WARNING                    "RAS Warning error"
+// Port Error definitions
+#define AAL_ERR_PORT_TX_CH0_OVERFLOW           "Tx Channel0: Overflow"
+#define AAL_ERR_PORT_TX_CH0_INVALIDREQ         "Tx Channel0: Invalid request encoding"
+#define AAL_ERR_PORT_TX_CH0_REQ_CL_LEN3        "Tx Channel0: Request with cl_len3"
+#define AAL_ERR_PORT_TX_CH0_REQ_CL_LEN2        "Tx Channel0: Request with cl_len2"
+#define AAL_ERR_PORT_TX_CH0_REQ_CL_LEN4        "Tx Channel0: Request with cl_len4"
+
+#define AAL_ERR_PORT_AFUMMIO_RDRECV_PORTRESET  "AFU MMIO RD received while PORT is in reset"
+#define AAL_ERR_PORT_AFUMMIO_WRRECV_PORTRESET  "AFU MMIO WR received while PORT is in reset"
+
+#define AAL_ERR_PORT_TX_CH1_OVERFLOW           "Tx Channel1: Overflow"
+#define AAL_ERR_PORT_TX_CH1_INVALIDREQ         "Tx Channel1: Invalid request encoding"
+#define AAL_ERR_PORT_TX_CH1_REQ_CL_LEN3        "Tx Channel1: Request with cl_len3"
+#define AAL_ERR_PORT_TX_CH1_REQ_CL_LEN2        "Tx Channel1: Request with cl_len2"
+#define AAL_ERR_PORT_TX_CH1_REQ_CL_LEN4        "Tx Channel1: Request with cl_len4"
+#define AAL_ERR_PORT_TX_CH1_INSUFF_DATAPYL     "Tx Channel1: Insufficient data payload"
+#define AAL_ERR_PORT_TX_CH1_DATAPYL_OVERRUN    "Tx Channel1: Data payload overrun"
+#define AAL_ERR_PORT_TX_CH1_INCORR_ADDR        "Tx Channel1: Incorrect address"
+#define AAL_ERR_PORT_TX_CH1_SOP_DETECTED       "Tx Channel1: NON-Zero SOP Detected"
+#define AAL_ERR_PORT_TX_CH1_ATOMIC_REQ         "Tx Channel1: Illegal VC_SEL, atomic request VLO"
+
+#define AAL_ERR_PORT_MMIOREAD_TIMEOUT          "MMIO Read Timeout in AFU"
+#define AAL_ERR_PORT_TX_CH2_FIFO_OVERFLOW      "Tx Channel2: FIFO overflow"
+#define AAL_ERR_PORT_UNEXP_MMIORESP            "MMIO read response received, with no matching pending request"
+#define AAL_ERR_PORT_NUM_PENDREQ_OVERFLOW      "Number of pending Requests: counter overflow"
+
+#define AAL_ERR_PORT_LLPR_SMRR                 "Request with Address violating SMM Range"
+#define AAL_ERR_PORT_LLPR_SMRR2                "Request with Address violating second SMM Range"
+#define AAL_ERR_PORT_LLPR_MSG                  "Request with Address violating ME Stolen message"
+#define AAL_ERR_PORT_GENPORT_RANGE             "Request with Address violating Generic protect range"
+#define AAL_ERR_PORT_LEGRANGE_LOW              "Request with Address violating Legacy Range Low"
+#define AAL_ERR_PORT_LEGRANGE_HIGH             "Request with Address violating Legacy Range High"
+#define AAL_ERR_PORT_VGAMEM_RANGE              "Request with Address violating VGA memory range"
+#define AAL_ERR_PORT_PAGEFAULT                 "Page fault"
+#define AAL_ERR_PORT_PMRERROR                  "PMR Error"
+#define AAL_ERR_PORT_AP6EVENT                  "AP6 Event"
+#define AAL_ERR_PORT_VFFLR_ACCESS              "VF FLR detected on Port with PF access control"
+
+/// Name:    create_logging_timer
+/// @brief   creates ccip logging polling time.
+///
+/// @return    error code
+int create_logging_timer(void);
+
+/// Name:    remove_logging_timer
+/// @brief   remove ccip logging polling timer.
+///
+/// @return    error code
+int remove_logging_timer(void);
+
+/// Name:    start_logging_timer
+/// @brief   starts logging timer.
+///
+/// @return    error code
+int start_logging_timer(void);
+
+/// Name:    stop_logging_timer
+/// @brief   stops logging timer.
+///
+/// @return    error code
+int stop_logging_timer(void);
+
+/// Name:    error_logging_callback
+/// @brief   Worker queue logging timer callback.
+///
+/// @param[in] pwork  work queue object pointer.
+/// @return    no return value
+void error_logging_callback(struct kosal_work_object *pwork);
+
+/// Name:    ccip_log_error
+/// @brief   enumerates fpga device list.
+///
+/// @param[in] pccipdev  ccip device pointer.
+/// @return    no return value
+void ccip_check_for_error(struct ccip_device *pccipdev);
+
+/// Name:    ccip_log_fme_ap_state
+/// @brief   logs fme app state change status to kernel logger.
+///
+/// @param[in] pccipdev  ccip device  pointer.
+/// @param[in] pfme_dev  fme device  pointer.
+/// @return    no return value
+void ccip_log_fme_ap_state(struct ccip_device *pccipdev,
+                           struct fme_device *pfme_dev);
+
+/// Name:    ccip_log_fme_error
+/// @brief   logs fme errors to kernel logger.
+///
+/// @param[in] pccipdev  ccip device pointer.
+/// @param[in] pfme_dev  fme device  pointer.
+/// @return    no return value
+void ccip_log_fme_error(struct ccip_device *pccipdev,
+                        struct fme_device *pfme_dev);
+
+/// Name:    ccip_log_fme_ras_error
+/// @brief   logs fme RAS errors to kernel logger.
+///
+/// @param[in] pccipdev  ccip device pointer.
+/// @param[in] pfme_dev  fme device  pointer.
+/// @return    no return value
+void ccip_log_fme_ras_error(struct ccip_device *pccipdev ,
+                           struct fme_device *pfme_dev);
+
+/// Name:    ccip_log_port_error
+/// @brief   logs port errors to kernel logger.
+///
+/// @param[in] pccipdev  ccip device pointer.
+/// @param[in] pport_dev  port device pointer.
+/// @return    no return value
+void ccip_log_port_error(struct ccip_device *pccipdev,
+                         struct port_device *pport_dev);
+
+/// Name:    ccip_log_pr_error
+/// @brief   logs pr errors to kernel logger.
+///
+/// @param[in] pfme_dev  fme device pointer.
+/// @return    no return value
+void ccip_log_pr_error(struct fme_device   *pfme_dev );
+
+/// Name:    ccip_log_port_apstates
+/// @brief   logs AP states to kernel logger.
+///
+/// @param[in] pccipdev  ccip device pointer.
+/// @param[in] pport_dev  port device pointer.
+/// @return    no return value
+void ccip_log_port_apstates(struct ccip_device *pccipdev ,struct port_device *pport_dev);
+
+/// Name:    log_verbose_fme_error
+/// @brief   logs fme errors description to kernel logger.
+///
+/// @param[in] pfme_dev  fme device pointer.
+/// @return    no return value
+void log_verbose_fme_error(struct fme_device *pfme_dev);
+
+/// Name:    log_verbose_fme_pcie0error
+/// @brief   logs pcie0 errors description to kernel logger.
+///
+/// @param[in] pfme_dev  fme device pointer.
+/// @return    no return value
+void log_verbose_fme_pcie0error(struct fme_device *pfme_dev);
+
+/// Name:    verbose_log_fme_pcie1error
+/// @brief   logs pcie1 errors description to kernel logger.
+///
+/// @param[in] pfme_dev  fme device pointer.
+/// @return    no return value
+void log_verbose_fme_pcie1error(struct fme_device *pfme_dev);
+
+/// Name:    log_verbose_fme_rasgbserror
+/// @brief   logs ras gbs errors description to kernel logger.
+///
+/// @param[in] pfme_dev  fme device pointer.
+/// @return    no return value
+void log_verbose_fme_rasgbserror(struct fme_device *pfme_dev);
+
+/// Name:    log_verbose_fme_rasbbserror
+/// @brief   logs ras bbs errors description to kernel logger.
+///
+/// @param[in] pfme_dev  fme device pointer.
+/// @return    no return value
+void log_verbose_fme_rasbbserror(struct fme_device *pfme_dev);
+
+/// Name:    log_verbose_fme_raswarnerror
+/// @brief   logs ras warning errors description to kernel logger.
+///
+/// @param[in] pfme_dev  fme device pointer.
+/// @return    no return value
+void log_verbose_fme_raswarnerror(struct fme_device *pfme_dev);
+
+/// Name:    log_verbose_port_error
+/// @brief   logs port errors description to kernel logger.
+///
+/// @param[in] pport_dev  port device pointer.
+/// @return    no return value
+void log_verbose_port_error(struct port_device *pport_dev);
+
+/// Name:    ccip_log_bad_vkey
+/// @brief   logs bad v-key value.
+///
+/// @param[in] no input parameter.
+/// @return    no return value
+void ccip_log_bad_vkey(void);
+
+END_NAMESPACE(AAL)
+
+#endif /* __AALKERNEL_CCIP_LOOGING_DEF_H_ */
diff --git a/drivers/fpga/aal/cci/ccip_logging_linux.c b/drivers/fpga/aal/cci/ccip_logging_linux.c
new file mode 100644
index 000000000000..f8e4847bacda
--- /dev/null
+++ b/drivers/fpga/aal/cci/ccip_logging_linux.c
@@ -0,0 +1,181 @@
+//******************************************************************************
+// This  file  is  provided  under  a  dual BSD/GPLv2  license.  When using or
+//         redistributing this file, you may do so under either license.
+//
+//                            GPL LICENSE SUMMARY
+//
+//  Copyright(c) 2015-2017, Intel Corporation.
+//
+//  This program  is  free software;  you  can redistribute it  and/or  modify
+//  it  under  the  terms of  version 2 of  the GNU General Public License  as
+//  published by the Free Software Foundation.
+//
+//  This  program  is distributed  in the  hope that it  will  be useful,  but
+//  WITHOUT   ANY   WARRANTY;   without   even  the   implied   warranty    of
+//  MERCHANTABILITY  or  FITNESS  FOR  A  PARTICULAR  PURPOSE.  See  the   GNU
+//  General Public License for more details.
+//
+//  The  full  GNU  General Public License is  included in  this  distribution
+//  in the file called README.GPLV2-LICENSE.TXT.
+//
+//  Contact Information:
+//  Henry Mitchel, henry.mitchel at intel.com
+//  77 Reed Rd., Hudson, MA  01749
+//
+//                                BSD LICENSE
+//
+//  Copyright(c) 2015-2017, Intel Corporation.
+//
+//  Redistribution and  use  in source  and  binary  forms,  with  or  without
+//  modification,  are   permitted  provided  that  the  following  conditions
+//  are met:
+//
+//    * Redistributions  of  source  code  must  retain  the  above  copyright
+//      notice, this list of conditions and the following disclaimer.
+//    * Redistributions in  binary form  must  reproduce  the  above copyright
+//      notice,  this  list of  conditions  and  the  following disclaimer  in
+//      the   documentation   and/or   other   materials   provided  with  the
+//      distribution.
+//    * Neither   the  name   of  Intel  Corporation  nor  the  names  of  its
+//      contributors  may  be  used  to  endorse  or promote  products derived
+//      from this software without specific prior written permission.
+//
+//  THIS  SOFTWARE  IS  PROVIDED  BY  THE  COPYRIGHT HOLDERS  AND CONTRIBUTORS
+//  "AS IS"  AND  ANY  EXPRESS  OR  IMPLIED  WARRANTIES,  INCLUDING,  BUT  NOT
+//  LIMITED  TO, THE  IMPLIED WARRANTIES OF  MERCHANTABILITY  AND FITNESS  FOR
+//  A  PARTICULAR  PURPOSE  ARE  DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT
+//  OWNER OR CONTRIBUTORS BE LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,
+//  SPECIAL,  EXEMPLARY,  OR  CONSEQUENTIAL   DAMAGES  (INCLUDING,   BUT   NOT
+//  LIMITED  TO,  PROCUREMENT  OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF USE,
+//  DATA,  OR PROFITS;  OR BUSINESS INTERRUPTION)  HOWEVER  CAUSED  AND ON ANY
+//  THEORY  OF  LIABILITY,  WHETHER  IN  CONTRACT,  STRICT LIABILITY,  OR TORT
+//  (INCLUDING  NEGLIGENCE  OR OTHERWISE) ARISING  IN ANY WAY  OUT  OF THE USE
+//  OF  THIS  SOFTWARE, EVEN IF ADVISED  OF  THE  POSSIBILITY  OF SUCH DAMAGE.
+//******************************************************************************
+//****************************************************************************
+/// @file ccip_logging_linux.c
+/// @brief  Definitions for ccip logging.
+/// @ingroup aalkernel_ccip
+/// @verbatim
+//        FILE: ccip_logging_linux.c
+//     CREATED: June 07, 2016
+//      AUTHOR: , Intel Corporation
+//
+//
+// PURPOSE:
+// HISTORY:
+// COMMENTS:
+// WHEN:          WHO:     WHAT:
+//****************************************************************************///
+
+#include "aalsdk/kernel/kosal.h"
+#define MODULE_FLAGS CCIPCIE_DBG_MOD
+#include "aalsdk/kernel/ccip_defs.h"
+#include "ccip_logging_linux.h"
+#include "ccip_logging.h"
+
+BEGIN_NAMESPACE(AAL)
+
+// Logging Timer struct
+extern struct logging_msg   g_logging_msg;
+
+///============================================================================
+/// Name: ccip_logging_timervalue_attrib_show
+/// @brief Writes ccip logging timer values  to sysfs
+///
+/// @param[in] pdriver - driver pointer
+/// @param[in] buf     - char buffer.
+/// @return    size of buffer
+///============================================================================
+static ssize_t ccip_logging_timervalue_attrib_show(struct device_driver *pdriver,
+                                                   char *buf)
+{
+   kosal_sem_get_krnl(logging_msg_sem(g_logging_msg) );
+
+   printk( "g_logging_timer_value = %ld\n",logging_msg_time(g_logging_msg));
+
+   kosal_sem_put(logging_msg_sem(g_logging_msg) );
+
+   return (snprintf(buf,PAGE_SIZE,   "%lu\n",(unsigned long int)g_logging_msg.m_logging_timer_value ));
+
+}
+
+///============================================================================
+/// Name: ccip_logging_timervalue_attrib_store_debug
+/// @brief Reads ccip logging timer values  from sysfs.
+///
+/// @param[in] pdriver - driver pointer
+/// @param[in] buf     - char buffer.
+/// @return    size of buffer
+///============================================================================
+static ssize_t ccip_logging_timervalue_attrib_store_debug(struct device_driver *pdriver,
+                                                          const char *buf,
+                                                          size_t size)
+{
+   kosal_sem_get_krnl(logging_msg_sem(g_logging_msg) );
+
+   sscanf(buf,"%lu", &logging_msg_time(g_logging_msg));
+   printk("g_logging_timer_value= %lu\n", g_logging_msg.m_logging_timer_value);
+
+   kosal_sem_put( logging_msg_sem(g_logging_msg));
+   return size;
+}
+
+DRIVER_ATTR(logging_timer,S_IRUGO|S_IWUSR|S_IWGRP, ccip_logging_timervalue_attrib_show,ccip_logging_timervalue_attrib_store_debug);
+
+
+///============================================================================
+/// Name: create_logging_timervalue_sysfs
+/// @brief create logging timer entry in sysfs
+///
+/// @param[in] pdriver - pci driver pointer
+/// @return    error code
+///============================================================================
+bt32bitInt create_logging_timervalue_sysfs(struct device_driver *pdriver)
+{
+   int res = 0;
+
+   PTRACEIN;
+   if((NULL == pdriver))  {
+
+       PERR("Invalid input pointers \n");
+       res = -EINVAL;
+       goto ERR;
+    }
+
+   res = driver_create_file( pdriver, &driver_attr_logging_timer );
+
+ERR:
+   PTRACEOUT_INT(res);
+   return  res;
+}
+
+///============================================================================
+/// Name: remove_logging_timervalue_syfs
+/// @brief remove logging timer entry in sysfs
+///
+/// @param[in] ppcidev  pci device pointer.
+/// @return    error code
+///============================================================================
+bt32bitInt remove_logging_timervalue_syfs(struct device_driver *pdriver)
+{
+   int res = 0;
+
+   PTRACEIN;
+   if((NULL == pdriver)) {
+
+       PERR("Invalid input pointers \n");
+       res = -EINVAL;
+       goto ERR;
+    }
+
+   driver_remove_file(pdriver,&driver_attr_logging_timer);
+
+   PTRACEOUT_INT(res);
+   return res;
+ERR:
+   PTRACEOUT_INT(res);
+   return  res;
+}
+
+END_NAMESPACE(AAL)
diff --git a/drivers/fpga/aal/cci/ccip_logging_linux.h b/drivers/fpga/aal/cci/ccip_logging_linux.h
new file mode 100644
index 000000000000..0191371952d2
--- /dev/null
+++ b/drivers/fpga/aal/cci/ccip_logging_linux.h
@@ -0,0 +1,94 @@
+//******************************************************************************
+// This  file  is  provided  under  a  dual BSD/GPLv2  license.  When using or
+//         redistributing this file, you may do so under either license.
+//
+//                            GPL LICENSE SUMMARY
+//
+//  Copyright(c) 2011-2017, Intel Corporation.
+//
+//  This program  is  free software;  you  can redistribute it  and/or  modify
+//  it  under  the  terms of  version 2 of  the GNU General Public License  as
+//  published by the Free Software Foundation.
+//
+//  This  program  is distributed  in the  hope that it  will  be useful,  but
+//  WITHOUT   ANY   WARRANTY;   without   even  the   implied   warranty    of
+//  MERCHANTABILITY  or  FITNESS  FOR  A  PARTICULAR  PURPOSE.  See  the   GNU
+//  General Public License for more details.
+//
+//  The  full  GNU  General Public License is  included in  this  distribution
+//  in the file called README.GPLV2-LICENSE.TXT.
+//
+//  Contact Information:
+//  Henry Mitchel, henry.mitchel at intel.com
+//  77 Reed Rd., Hudson, MA  01749
+//
+//                                BSD LICENSE
+//
+//  Copyright(c) 2011-2017, Intel Corporation.
+//
+//  Redistribution and  use  in source  and  binary  forms,  with  or  without
+//  modification,  are   permitted  provided  that  the  following  conditions
+//  are met:
+//
+//    * Redistributions  of  source  code  must  retain  the  above  copyright
+//      notice, this list of conditions and the following disclaimer.
+//    * Redistributions in  binary form  must  reproduce  the  above copyright
+//      notice,  this  list of  conditions  and  the  following disclaimer  in
+//      the   documentation   and/or   other   materials   provided  with  the
+//      distribution.
+//    * Neither   the  name   of  Intel  Corporation  nor  the  names  of  its
+//      contributors  may  be  used  to  endorse  or promote  products derived
+//      from this software without specific prior written permission.
+//
+//  THIS  SOFTWARE  IS  PROVIDED  BY  THE  COPYRIGHT HOLDERS  AND CONTRIBUTORS
+//  "AS IS"  AND  ANY  EXPRESS  OR  IMPLIED  WARRANTIES,  INCLUDING,  BUT  NOT
+//  LIMITED  TO, THE  IMPLIED WARRANTIES OF  MERCHANTABILITY  AND FITNESS  FOR
+//  A  PARTICULAR  PURPOSE  ARE  DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT
+//  OWNER OR CONTRIBUTORS BE LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,
+//  SPECIAL,  EXEMPLARY,  OR  CONSEQUENTIAL   DAMAGES  (INCLUDING,   BUT   NOT
+//  LIMITED  TO,  PROCUREMENT  OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF USE,
+//  DATA,  OR PROFITS;  OR BUSINESS INTERRUPTION)  HOWEVER  CAUSED  AND ON ANY
+//  THEORY  OF  LIABILITY,  WHETHER  IN  CONTRACT,  STRICT LIABILITY,  OR TORT
+//  (INCLUDING  NEGLIGENCE  OR OTHERWISE) ARISING  IN ANY WAY  OUT  OF THE USE
+//  OF  THIS  SOFTWARE, EVEN IF ADVISED  OF  THE  POSSIBILITY  OF SUCH DAMAGE.
+//******************************************************************************
+//****************************************************************************
+/// @file ccip_logging_linux.h
+/// @brief  Definitions for ccip logging timer in sysfs.
+/// @ingroup aalkernel_ccip
+/// @verbatim
+//        FILE: ccip_logging_linux.h
+//     CREATED: June 07, 2016
+//      AUTHOR: , Intel Corporation
+//
+// 
+// PURPOSE:
+// HISTORY:
+// COMMENTS:
+// WHEN:          WHO:     WHAT:
+//****************************************************************************///
+#ifndef __AALKERNEL_CCIP_LOGGING_LINUX_H_
+#define __AALKERNEL_CCIP_LOGGING_LINUX_H_
+
+#include <aalsdk/kernel/kosal.h>
+#include <aalsdk/kernel/aaltypes.h>
+
+BEGIN_NAMESPACE(AAL)
+
+/// Name:    create_logging_timervalue_sysfs
+/// @brief   creates logging timer in sysfs.
+///
+/// @param[in] pdriver  pci driver  pointer.
+/// @return    error code
+bt32bitInt create_logging_timervalue_sysfs(struct device_driver *pdriver);
+
+/// Name:    remove_logging_timervalue_syfs
+/// @brief   removes logging timer in sysfs.
+///
+/// @param[in] pdriver  pci driver  pointer.
+/// @return    error code
+bt32bitInt remove_logging_timervalue_syfs(struct device_driver *pdriver);
+
+END_NAMESPACE(AAL)
+
+#endif //__AALKERNEL_CCIP_LOGGING_LINUX_H_
diff --git a/drivers/fpga/aal/cci/ccip_perfmon.c b/drivers/fpga/aal/cci/ccip_perfmon.c
new file mode 100644
index 000000000000..bce1821f9549
--- /dev/null
+++ b/drivers/fpga/aal/cci/ccip_perfmon.c
@@ -0,0 +1,625 @@
+//******************************************************************************
+// This  file  is  provided  under  a  dual BSD/GPLv2  license.  When using or
+//         redistributing this file, you may do so under either license.
+//
+//                            GPL LICENSE SUMMARY
+//
+//  Copyright(c) 2011-2017, Intel Corporation.
+//
+//  This program  is  free software;  you  can redistribute it  and/or  modify
+//  it  under  the  terms of  version 2 of  the GNU General Public License  as
+//  published by the Free Software Foundation.
+//
+//  This  program  is distributed  in the  hope that it  will  be useful,  but
+//  WITHOUT   ANY   WARRANTY;   without   even  the   implied   warranty    of
+//  MERCHANTABILITY  or  FITNESS  FOR  A  PARTICULAR  PURPOSE.  See  the   GNU
+//  General Public License for more details.
+//
+//  The  full  GNU  General Public License is  included in  this  distribution
+//  in the file called README.GPLV2-LICENSE.TXT.
+//
+//  Contact Information:
+//  Henry Mitchel, henry.mitchel at intel.com
+//  77 Reed Rd., Hudson, MA  01749
+//
+//                                BSD LICENSE
+//
+//  Copyright(c) 2011-2017, Intel Corporation.
+//
+//  Redistribution and  use  in source  and  binary  forms,  with  or  without
+//  modification,  are   permitted  provided  that  the  following  conditions
+//  are met:
+//
+//    * Redistributions  of  source  code  must  retain  the  above  copyright
+//      notice, this list of conditions and the following disclaimer.
+//    * Redistributions in  binary form  must  reproduce  the  above copyright
+//      notice,  this  list of  conditions  and  the  following disclaimer  in
+//      the   documentation   and/or   other   materials   provided  with  the
+//      distribution.
+//    * Neither   the  name   of  Intel  Corporation  nor  the  names  of  its
+//      contributors  may  be  used  to  endorse  or promote  products derived
+//      from this software without specific prior written permission.
+//
+//  THIS  SOFTWARE  IS  PROVIDED  BY  THE  COPYRIGHT HOLDERS  AND CONTRIBUTORS
+//  "AS IS"  AND  ANY  EXPRESS  OR  IMPLIED  WARRANTIES,  INCLUDING,  BUT  NOT
+//  LIMITED  TO, THE  IMPLIED WARRANTIES OF  MERCHANTABILITY  AND FITNESS  FOR
+//  A  PARTICULAR  PURPOSE  ARE  DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT
+//  OWNER OR CONTRIBUTORS BE LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,
+//  SPECIAL,  EXEMPLARY,  OR  CONSEQUENTIAL   DAMAGES  (INCLUDING,   BUT   NOT
+//  LIMITED  TO,  PROCUREMENT  OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF USE,
+//  DATA,  OR PROFITS;  OR BUSINESS INTERRUPTION)  HOWEVER  CAUSED  AND ON ANY
+//  THEORY  OF  LIABILITY,  WHETHER  IN  CONTRACT,  STRICT LIABILITY,  OR TORT
+//  (INCLUDING  NEGLIGENCE  OR OTHERWISE) ARISING  IN ANY WAY  OUT  OF THE USE
+//  OF  THIS  SOFTWARE, EVEN IF ADVISED  OF  THE  POSSIBILITY  OF SUCH DAMAGE.
+//******************************************************************************
+//****************************************************************************
+/// @file ccip_perfmon.c
+/// @brief  CCI-P FME performance counters.
+/// @ingroup aalkernel_ccip
+/// @verbatim
+//        FILE: ccip_perfmon.c
+//     CREATED: Sept 24, 2015
+//      AUTHOR: Ananda Ravuri, Intel Corporation
+//              Joseph Grecco, Intel Corporation
+//
+// PURPOSE:   This file contains the implementation of the CCIP FME
+//            performance counters
+// HISTORY:
+// COMMENTS:
+// WHEN:          WHO:     WHAT:
+//****************************************************************************///
+
+#include "aalsdk/kernel/kosal.h"
+#define MODULE_FLAGS CCIPCIE_DBG_MOD
+#include "aalsdk/kernel/ccip_defs.h"
+
+#include "ccip_perfmon.h"
+#include "ccip_fme.h"
+
+
+///============================================================================
+/// Name: get_perfmonitor_snapshot
+/// @brief get snap shot of Performance counters
+///
+/// @param[in] pfme_dev - fme device pointer
+/// @param[in] pPerf - Performance counters pointer.
+/// @return    error code
+///============================================================================
+bt32bitInt get_perfmonitor_snapshot(struct fme_device *pfme_dev,
+                                    struct CCIP_PERF_COUNTERS* pPerf)
+{
+  
+   bt32bitInt res                   = 0;
+   volatile struct fme_device *pfme = pfme_dev;
+
+   PTRACEIN;
+
+   if((NULL == pfme_dev) || (NULL == pPerf))  {
+      PERR("Invalid Input pointers  \n");
+      res= -EINVAL;
+      goto ERR;
+   }
+   pPerf->version.value = PERF_MONITOR_VERSION;
+   pPerf->num_counters.value = PERF_MONITOR_COUNT;
+
+   // freeze Cache
+   ccip_fme_perf(pfme)->ccip_fpmon_ch_ctl.freeze = 0x1;
+
+   // freeze Fabric
+   ccip_fme_perf(pfme)->ccip_fpmon_fab_ctl.freeze = 0x1;
+
+   // Freeze VTD
+   ccip_fme_perf(pfme)->ccip_fpmon_vtd_ctl.freeze = 0x1;
+
+
+   //Cache_Read_Hit
+   update_cache_event_counters(Cache_Read_Hit,pfme_dev,pPerf);
+
+   // Cache_Write_Hit
+   update_cache_event_counters(Cache_Write_Hit,pfme_dev,pPerf);
+
+   // Cache_Read_Miss
+   update_cache_event_counters(Cache_Read_Miss,pfme_dev,pPerf);
+
+   // Cache_Write_Miss
+   update_cache_event_counters(Cache_Write_Miss,pfme_dev,pPerf);
+
+   //Cache_Evictions
+   update_cache_event_counters(Cache_Evictions,pfme_dev,pPerf);
+
+   //pcie0 Read
+   update_fabric_event_counters(Fabric_PCIe0_Read,pfme_dev,pPerf);
+
+   // pcie0 write
+   update_fabric_event_counters(Fabric_PCIe0_Write,pfme_dev,pPerf);
+
+   // pcie1 Read
+   update_fabric_event_counters(Fabric_PCIe1_Read,pfme_dev,pPerf);
+
+   // pcie1 write
+   update_fabric_event_counters(Fabric_PCIe1_Write,pfme_dev,pPerf);
+
+   //UPI Read
+   update_fabric_event_counters(Fabric_UPI_Read,pfme_dev,pPerf);
+
+   //UPI Write
+   update_fabric_event_counters(Fabric_UPI_Write,pfme_dev,pPerf);
+
+   if( 0x1 == ccip_fme_hdr(pfme_dev)->fab_capability.iommu_support ) {
+
+      //AFU0 Memory Read Transaction count
+      update_vtd_event_counters(AFU0_MemRead_Trans,pfme_dev,pPerf);
+
+      //AFU0 Memory Write Transaction count
+      update_vtd_event_counters(AFU0_MemWrite_Trans,pfme_dev,pPerf);
+
+      //AFU0  DevTLB  Read Hit count
+      update_vtd_event_counters(AFU0_DevTLBRead_Hit,pfme_dev,pPerf);
+
+      //AFU0 DevTLB Write Hit count
+      update_vtd_event_counters(AFU0_DevTLBWrite_Hit,pfme_dev,pPerf);
+
+   }
+
+   //un Freeze VTD
+   ccip_fme_perf(pfme)->ccip_fpmon_vtd_ctl.freeze = 0x0;
+
+   //un freeze fabric
+   ccip_fme_perf(pfme)->ccip_fpmon_fab_ctl.freeze = 0x0;
+
+   //un freeze cache
+   ccip_fme_perf(pfme)->ccip_fpmon_ch_ctl.freeze = 0x0;
+
+   PTRACEOUT_INT(res);
+   return res;
+ERR:
+   PTRACEOUT_INT(res);
+   return  res;
+}
+
+///============================================================================
+/// Name: update_fabric_event_counters
+/// @brief get snap shot of fabric Performance counters
+///
+/// @param[in] event_code - fabric counters code.
+/// @param[in] pfme_dev - fme device pointer
+/// @param[in] pPerf - Performance counters pointer.
+/// @return    0 = success
+///============================================================================
+
+bt32bitInt update_fabric_event_counters(bt32bitInt event_code ,
+                                       struct fme_device *pfme_dev,
+                                       struct CCIP_PERF_COUNTERS* pPerf)
+{
+   bt32bitInt res                   = 0;
+   bt32bitInt counter               = 0;
+   btTime delay                     = PERFMON_POLLING_SLEEP;
+   volatile struct fme_device *pfme = pfme_dev;
+
+   PTRACEIN;
+
+   ccip_fme_perf(pfme)->ccip_fpmon_fab_ctl.fabric_evt_code =event_code;
+
+   while (event_code != ccip_fme_perf(pfme)->ccip_fpmon_fab_ctr.event_code)  {
+
+      counter++;
+
+      // Sleep
+      kosal_udelay(delay);
+
+      if (counter > CACHE_EVENT_COUNTER_MAX_TRY)    {
+         PERR("Max Try \n");
+         res = 1;
+         goto ERR;
+      }
+
+   } // end while
+
+   switch (event_code)
+   {
+
+      case  Fabric_PCIe0_Read:
+      {
+         pPerf->pcie0_read.value= ccip_fme_perf(pfme_dev)->ccip_fpmon_fab_ctr.fabric_counter;
+      }
+      break;
+
+      case  Fabric_PCIe0_Write:
+      {
+         pPerf->pcie0_write.value = ccip_fme_perf(pfme_dev)->ccip_fpmon_fab_ctr.fabric_counter;
+      }
+      break;
+
+      case  Fabric_PCIe1_Read:
+      {
+         pPerf->pcie1_read.value = ccip_fme_perf(pfme_dev)->ccip_fpmon_fab_ctr.fabric_counter;
+      }
+      break;
+
+
+      case  Fabric_PCIe1_Write:
+      {
+         pPerf->pcie1_write.value = ccip_fme_perf(pfme_dev)->ccip_fpmon_fab_ctr.fabric_counter;
+      }
+      break;
+
+      case  Fabric_UPI_Read:
+      {
+         pPerf->upi_read.value = ccip_fme_perf(pfme_dev)->ccip_fpmon_fab_ctr.fabric_counter;
+      }
+      break;
+
+      case  Fabric_UPI_Write:
+      {
+         pPerf->upi_write.value = ccip_fme_perf(pfme_dev)->ccip_fpmon_fab_ctr.fabric_counter;
+      }
+      break;
+
+      default:
+      {
+         // Error
+         PERR("Invalid Cache Event code  \n");
+         res= -EINVAL;
+      }
+      break;
+
+   }
+
+   PTRACEOUT_INT(res);
+   return res;
+ERR:
+   PTRACEOUT_INT(res);
+   return  res;
+
+}
+
+///============================================================================
+/// Name: read_cache_event_counters
+/// @brief reads cache Performance counters
+///
+/// @param[in] event_code - cache counters code.
+/// @param[in] pfme_dev - fme device pointer
+/// @param[in] countervalue - counter value.
+/// @return    0 = success
+///============================================================================
+bt32bitInt read_cache_event_counters(bt32bitInt event_code ,
+                                     struct fme_device *pfme_dev,
+                                     btUnsigned64bitInt* countervalue)
+{
+   bt32bitInt res                   = 0;
+   btTime delay                     = PERFMON_POLLING_SLEEP;
+   bt32bitInt counter               = 0;
+   volatile struct fme_device *pfme = pfme_dev;
+   PTRACEIN;
+
+   ccip_fme_perf(pfme)->ccip_fpmon_ch_ctl.cache_event = event_code;
+
+   while (event_code != ccip_fme_perf(pfme)->ccip_fpmon_ch_ctr_0.event_code)   {
+
+     counter++;
+     // Sleep
+     kosal_udelay(delay);
+
+     if (counter > CACHE_EVENT_COUNTER_MAX_TRY)   {
+        PERR("Max Try \n");
+        res = 1;
+        goto ERR;
+     }
+
+   } // end while
+
+   *countervalue= ccip_fme_perf(pfme)->ccip_fpmon_ch_ctr_0.cache_counter + ccip_fme_perf(pfme)->ccip_fpmon_ch_ctr_1.cache_counter;
+
+   PTRACEOUT_INT(res);
+   return res;
+ERR:
+   PTRACEOUT_INT(res);
+   return  res;
+
+}
+
+///============================================================================
+/// Name: update_cache_event_counters
+/// @brief get snap shot of cache Performance counters
+///
+/// @param[in] event_code - cache counters code.
+/// @param[in] pfme_dev - fme device pointer
+/// @param[in] pPerf - Performance counters pointer.
+/// @return    0 = success
+///============================================================================
+bt32bitInt update_cache_event_counters(bt32bitInt event_code ,
+                                       struct fme_device *pfme_dev,
+                                       struct CCIP_PERF_COUNTERS* pPerf)
+{
+   bt32bitInt res                   = 0;
+   btUnsigned64bitInt total         = 0;
+   btUnsigned64bitInt evictions     = 0;
+   volatile struct fme_device *pfme = pfme_dev;
+
+   PTRACEIN;
+
+   switch (event_code)
+   {
+
+      case  Cache_Read_Hit:
+      {
+         // Select RD Channel
+         ccip_fme_perf(pfme)->ccip_fpmon_ch_ctl.cci_chsel = 0x0;
+
+         // Read Cache Hit Counters
+         res = read_cache_event_counters(event_code,pfme_dev,&total);
+         if (0 != res) {
+            goto ERR;
+         }
+
+         pPerf->read_hit.value = total;
+      }
+      break;
+
+      case  Cache_Write_Hit:
+      {
+         // Select WR Channel
+         ccip_fme_perf(pfme)->ccip_fpmon_ch_ctl.cci_chsel = 0x1;
+
+         // Write Cache Hit Counters
+         res = read_cache_event_counters(event_code,pfme_dev,&total);
+         if (0 != res) {
+            goto ERR;
+         }
+
+         pPerf->write_hit.value = total;
+      }
+      break;
+
+      case  Cache_Read_Miss:
+      {
+         // Select RD Channel
+         ccip_fme_perf(pfme)->ccip_fpmon_ch_ctl.cci_chsel = 0x0;
+
+         // Read Cache Miss Counters
+         res = read_cache_event_counters(event_code,pfme_dev,&total);
+         if (0 != res) {
+            goto ERR;
+         }
+         pPerf->read_miss.value = total;
+      }
+      break;
+
+      case  Cache_Write_Miss:
+      {
+         // Select WR Channel
+         ccip_fme_perf(pfme)->ccip_fpmon_ch_ctl.cci_chsel = 0x1;
+
+         // Write Cache Miss Counters
+         res = read_cache_event_counters(event_code,pfme_dev,&total);
+         if (0 != res) {
+            goto ERR;
+         }
+         pPerf->write_miss.value = total;
+      }
+      break;
+
+      case  Cache_Evictions:
+      {
+
+         // Select RD Channel
+         ccip_fme_perf(pfme)->ccip_fpmon_ch_ctl.cci_chsel = 0x0;
+
+         // Cache Evictions Counters
+         res = read_cache_event_counters(event_code,pfme_dev,&evictions);
+         if (0 != res) {
+            goto ERR;
+         }
+
+         total       = evictions ;
+         evictions   = 0;
+
+         // Select WR Channel
+         ccip_fme_perf(pfme)->ccip_fpmon_ch_ctl.cci_chsel = 0x1;
+
+         // Cache Evictions Counters
+         res = read_cache_event_counters(event_code,pfme_dev,&evictions);
+         if (0 != res) {
+            goto ERR;
+         }
+
+         total = total + evictions;
+
+         pPerf->evictions.value = total;
+      }
+      break;
+
+      default:
+      {
+         // Error
+         PERR("Invalid Cache Event code  \n");
+         res= -EINVAL;
+      }
+      break;
+
+   }
+
+   PTRACEOUT_INT(res);
+   return res;
+ERR:
+   PTRACEOUT_INT(res);
+   return  res;
+
+}
+
+///============================================================================
+/// Name:    update_vtd_event_counters
+/// @brief   get VT-D performance counters
+///
+/// @param[in] event_code VTD event code.
+/// @param[in] pfme_dev fme device pointer.
+/// @param[in] pPerf performance counters pointer
+/// @return    error code
+/// @return    0 = success
+///============================================================================
+
+bt32bitInt update_vtd_event_counters(bt32bitInt event_code,
+                                     struct fme_device *pfme_dev,
+                                     struct CCIP_PERF_COUNTERS* pPerf)
+
+{
+   bt32bitInt res                   = 0;
+   bt32bitInt counter               = 0;
+   btTime delay                     = PERFMON_POLLING_SLEEP;
+   btUnsigned64bitInt total         = 0;
+   volatile struct fme_device *pfme = pfme_dev;
+
+   PTRACEIN;
+
+   ccip_fme_perf(pfme)->ccip_fpmon_vtd_ctl.vtd_evtcode = event_code;
+
+   while (event_code != ccip_fme_perf(pfme)->ccip_fpmon_vtd_ctr.event_code)   {
+
+      counter++;
+      // Sleep
+      kosal_udelay(delay);
+
+      if (counter > CACHE_EVENT_COUNTER_MAX_TRY)   {
+         PERR("Max Try \n");
+         res = 1;
+         goto ERR;
+      }
+
+   } // end while
+
+   total = ccip_fme_perf(pfme)->ccip_fpmon_vtd_ctr.vtd_counter ;
+
+   switch (event_code)
+   {
+
+      case  AFU0_MemRead_Trans:
+      {
+         pPerf->AFU0_MemRead_Trans.value= total;
+      }
+      break;
+
+      case  AFU0_MemWrite_Trans:
+      {
+         pPerf->AFU0_MemWrite_Trans.value = total;
+      }
+      break;
+
+      case  AFU0_DevTLBRead_Hit:
+      {
+         pPerf->AFU0_DevTLBRead_Hit.value = total;
+      }
+      break;
+
+      case  AFU0_DevTLBWrite_Hit:
+      {
+         pPerf->AFU0_MemWrite_Trans.value= total;
+      }
+      break;
+
+      default:
+      {
+         // Error
+         PERR("Invalid VTD Event code  \n");
+         res= -EINVAL;
+      }
+      break;
+
+   } // end of switch
+
+   PTRACEOUT_INT(res);
+   return res;
+ERR:
+   PTRACEOUT_INT(res);
+   return  res;
+}
+
+///============================================================================
+/// Name:    get_perfmon_counters
+/// @brief   get  performance counters
+///
+/// @param[in] pfme_dev fme device pointer.
+/// @param[in] pPerf performance counters pointer
+/// @return    error code
+///============================================================================
+bt32bitInt get_perfmon_counters(struct fme_device* pfme_dev,
+                                struct CCIP_PERF_COUNTERS* pPerfCounter)
+{
+   int res =0;
+
+   PTRACEIN;
+
+   if( (NULL == pfme_dev) || (NULL == pPerfCounter))  {
+      PERR("Invalid input pointers \n");
+      res =-EINVAL;
+      goto ERR;
+   }
+
+   memset(pPerfCounter,0,sizeof(struct CCIP_PERF_COUNTERS));
+
+   strncpy(pPerfCounter->num_counters.name ,NUM_COUNTERS,sizeof(NUM_COUNTERS));
+   strncpy(pPerfCounter->version.name ,PMONITOR_VERSION,sizeof(PMONITOR_VERSION));
+
+   strncpy(pPerfCounter->read_hit.name ,CACHE_READ_HIT,sizeof(CACHE_READ_HIT));
+   strncpy(pPerfCounter->write_hit.name ,CACHE_WRITE_HIT,sizeof(CACHE_WRITE_HIT));
+
+   strncpy(pPerfCounter->read_miss.name ,CACHE_READ_MISS,sizeof(CACHE_READ_MISS));
+   strncpy(pPerfCounter->write_miss.name ,CACHE_WRITE_MISS,sizeof(CACHE_WRITE_MISS));
+
+   strncpy(pPerfCounter->evictions.name ,CACHE_EVICTIONS,sizeof(CACHE_EVICTIONS));
+
+   strncpy(pPerfCounter->pcie0_read.name ,FABRIC_PCIE0_READ,sizeof(FABRIC_PCIE0_READ));
+   strncpy(pPerfCounter->pcie0_write.name ,FABRIC_PCIE0_WRITE,sizeof(FABRIC_PCIE0_WRITE));
+
+   strncpy(pPerfCounter->pcie1_read.name ,FABRIC_PCIE1_READ,sizeof(FABRIC_PCIE1_READ));
+   strncpy(pPerfCounter->pcie1_write.name ,FABRIC_PCIE1_WRITE,sizeof(FABRIC_PCIE1_WRITE));
+
+   strncpy(pPerfCounter->upi_read.name ,FABRIC_UPI_READ,sizeof(FABRIC_UPI_READ));
+   strncpy(pPerfCounter->upi_write.name ,FABRIC_UPI_WRITE,sizeof(FABRIC_UPI_WRITE));
+
+   strncpy(pPerfCounter->AFU0_MemRead_Trans.name ,VTD_AFU_MEMREAD_TRANS,sizeof(VTD_AFU_MEMREAD_TRANS));
+   strncpy(pPerfCounter->AFU0_MemWrite_Trans.name ,VTD_AFU_MEMWRITE_TRANS,sizeof(VTD_AFU_MEMWRITE_TRANS));
+
+   strncpy(pPerfCounter->AFU0_DevTLBRead_Hit.name ,VTD_AFU_DEVTLBREAD_HIT,sizeof(VTD_AFU_DEVTLBREAD_HIT));
+   strncpy(pPerfCounter->AFU0_DevTLBWrite_Hit.name ,VTD_AFU_DEVTLBWRITE_HIT,sizeof(VTD_AFU_DEVTLBWRITE_HIT));
+
+   pPerfCounter->num_counters.value=PERF_MONITOR_COUNT;
+   pPerfCounter->num_counters.value=PERF_MONITOR_VERSION;
+
+   res= get_perfmonitor_snapshot(pfme_dev,pPerfCounter);
+
+   PTRACEOUT_INT(res);
+   return res;
+
+ERR:
+   PTRACEOUT_INT(res);
+   return  res;
+
+}
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
diff --git a/drivers/fpga/aal/cci/ccip_perfmon.h b/drivers/fpga/aal/cci/ccip_perfmon.h
new file mode 100644
index 000000000000..0a0588729302
--- /dev/null
+++ b/drivers/fpga/aal/cci/ccip_perfmon.h
@@ -0,0 +1,161 @@
+//******************************************************************************
+// This  file  is  provided  under  a  dual BSD/GPLv2  license.  When using or
+//         redistributing this file, you may do so under either license.
+//
+//                            GPL LICENSE SUMMARY
+//
+//  Copyright(c) 2011-2017, Intel Corporation.
+//
+//  This program  is  free software;  you  can redistribute it  and/or  modify
+//  it  under  the  terms of  version 2 of  the GNU General Public License  as
+//  published by the Free Software Foundation.
+//
+//  This  program  is distributed  in the  hope that it  will  be useful,  but
+//  WITHOUT   ANY   WARRANTY;   without   even  the   implied   warranty    of
+//  MERCHANTABILITY  or  FITNESS  FOR  A  PARTICULAR  PURPOSE.  See  the   GNU
+//  General Public License for more details.
+//
+//  The  full  GNU  General Public License is  included in  this  distribution
+//  in the file called README.GPLV2-LICENSE.TXT.
+//
+//  Contact Information:
+//  Henry Mitchel, henry.mitchel at intel.com
+//  77 Reed Rd., Hudson, MA  01749
+//
+//                                BSD LICENSE
+//
+//  Copyright(c) 2011-2017, Intel Corporation.
+//
+//  Redistribution and  use  in source  and  binary  forms,  with  or  without
+//  modification,  are   permitted  provided  that  the  following  conditions
+//  are met:
+//
+//    * Redistributions  of  source  code  must  retain  the  above  copyright
+//      notice, this list of conditions and the following disclaimer.
+//    * Redistributions in  binary form  must  reproduce  the  above copyright
+//      notice,  this  list of  conditions  and  the  following disclaimer  in
+//      the   documentation   and/or   other   materials   provided  with  the
+//      distribution.
+//    * Neither   the  name   of  Intel  Corporation  nor  the  names  of  its
+//      contributors  may  be  used  to  endorse  or promote  products derived
+//      from this software without specific prior written permission.
+//
+//  THIS  SOFTWARE  IS  PROVIDED  BY  THE  COPYRIGHT HOLDERS  AND CONTRIBUTORS
+//  "AS IS"  AND  ANY  EXPRESS  OR  IMPLIED  WARRANTIES,  INCLUDING,  BUT  NOT
+//  LIMITED  TO, THE  IMPLIED WARRANTIES OF  MERCHANTABILITY  AND FITNESS  FOR
+//  A  PARTICULAR  PURPOSE  ARE  DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT
+//  OWNER OR CONTRIBUTORS BE LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,
+//  SPECIAL,  EXEMPLARY,  OR  CONSEQUENTIAL   DAMAGES  (INCLUDING,   BUT   NOT
+//  LIMITED  TO,  PROCUREMENT  OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF USE,
+//  DATA,  OR PROFITS;  OR BUSINESS INTERRUPTION)  HOWEVER  CAUSED  AND ON ANY
+//  THEORY  OF  LIABILITY,  WHETHER  IN  CONTRACT,  STRICT LIABILITY,  OR TORT
+//  (INCLUDING  NEGLIGENCE  OR OTHERWISE) ARISING  IN ANY WAY  OUT  OF THE USE
+//  OF  THIS  SOFTWARE, EVEN IF ADVISED  OF  THE  POSSIBILITY  OF SUCH DAMAGE.
+//******************************************************************************
+//****************************************************************************
+/// @file ccip_perfmon.h
+/// @brief  Definitions for ccip performance counter.
+/// @ingroup aalkernel_ccip
+/// @verbatim
+//        FILE: ccip_perfmon.h
+//     CREATED: Sept 24, 2015
+//      AUTHOR: Ananda Ravuri, Intel Corporation
+//              Joseph Grecco, Intel Corporation
+// 
+// PURPOSE:
+// HISTORY:
+// COMMENTS:
+// WHEN:          WHO:     WHAT:
+// 02/19/2016     JG       Refactored OS specific portion
+//****************************************************************************///
+#ifndef __AALKERNEL_CCIP_PERFMON_H_
+#define __AALKERNEL_CCIP_PERFMON_H_
+
+#include <aalsdk/kernel/aaltypes.h>
+#include <aalsdk/kernel/ccipdriver.h>
+#include <aalsdk/kernel/ccip_defs.h>
+#include "cci_pcie_driver_internal.h"
+
+BEGIN_NAMESPACE(AAL)
+
+#define CACHE_EVENT_COUNTER_MAX_TRY 30
+#define PERFMON_POLLING_SLEEP       10
+
+#define PERF_MONITOR_VERSION 1
+#define PERF_MONITOR_COUNT 15
+
+#define PMONITOR_VERSION               "version"
+#define NUM_COUNTERS                   "number of counters"
+#define CACHE_READ_HIT                 "Read_Hit"
+#define CACHE_WRITE_HIT                "Write_Hit"
+#define CACHE_READ_MISS                "Read_Miss"
+#define CACHE_WRITE_MISS               "Write_Miss"
+#define CACHE_EVICTIONS                "Evictions"
+#define FABRIC_PCIE0_READ              "PCIe0 Read"
+#define FABRIC_PCIE0_WRITE             "PCIe0 Write"
+#define FABRIC_PCIE1_READ              "PCIe1 Read"
+#define FABRIC_PCIE1_WRITE             "PCIe1 Write"
+#define FABRIC_UPI_READ                "UPI Read"
+#define FABRIC_UPI_WRITE               "UPI Write"
+
+#define VTD_AFU_MEMREAD_TRANS          "VT-d AFU Memory Read Transaction"
+#define VTD_AFU_MEMWRITE_TRANS         "VT-d AFU Memory Write Transaction"
+#define VTD_AFU_DEVTLBREAD_HIT         "VT-d AFU DevTLB Read Hit"
+#define VTD_AFU_DEVTLBWRITE_HIT        "VT-d AFU DevTLB Write Hit"
+
+
+
+/// Name:    get_perfmonitor_counters
+/// @brief   get snapshot of performance counters
+///
+/// @param[in] pfme_dev fme device pointer.
+/// @param[in] pPerf performance counters pointer
+/// @return    error code
+bt32bitInt get_perfmonitor_snapshot(struct fme_device *pfme_dev,
+                                    struct CCIP_PERF_COUNTERS* pPerf);
+
+/// Name:    update_fabric_event_counters
+/// @brief   get Fabric performance counters
+///
+/// @param[in] event_code performance counters event device pointer.
+/// @param[in] pfme_dev fme device pointer.
+/// @param[in] pPerf performance counters pointer
+/// @return    error code
+bt32bitInt update_fabric_event_counters(bt32bitInt event_code ,
+                                       struct fme_device *pfme_dev,
+                                       struct CCIP_PERF_COUNTERS* pPerf);
+
+/// Name:    update_cache_event_counters
+/// @brief   get cache performance counters
+///
+/// @param[in] event_code performance counters event device pointer.
+/// @param[in] pfme_dev fme device pointer.
+/// @param[in] pPerf performance counters pointer
+/// @return    error code
+bt32bitInt update_cache_event_counters(bt32bitInt event_code ,
+                                       struct fme_device *pfme_dev,
+                                       struct CCIP_PERF_COUNTERS* pPerf);
+
+/// Name:    get_perfmon_counters
+/// @brief   get  performance counters
+///
+/// @param[in] pfme_dev fme device pointer.
+/// @param[in] pPerf performance counters pointer
+/// @return    error code
+bt32bitInt get_perfmon_counters(struct fme_device* pfme_dev,
+                                struct CCIP_PERF_COUNTERS* pPerfCounter);
+
+/// Name:    update_vtd_event_counters
+/// @brief   get VT-D performance counters
+///
+/// @param[in] event_code VTD event code.
+/// @param[in] pfme_dev fme device pointer.
+/// @param[in] pPerf performance counters pointer
+/// @return    error code
+bt32bitInt update_vtd_event_counters(bt32bitInt event_code,
+                                     struct fme_device *pfme_dev,
+                                     struct CCIP_PERF_COUNTERS* pPerf);
+
+END_NAMESPACE(AAL)
+
+#endif //__AALKERNEL_CCIP_PERFMON_H_
diff --git a/drivers/fpga/aal/cci/ccip_perfmon_linux.c b/drivers/fpga/aal/cci/ccip_perfmon_linux.c
new file mode 100644
index 000000000000..9e9e6dff9d54
--- /dev/null
+++ b/drivers/fpga/aal/cci/ccip_perfmon_linux.c
@@ -0,0 +1,294 @@
+//******************************************************************************
+// This  file  is  provided  under  a  dual BSD/GPLv2  license.  When using or
+//         redistributing this file, you may do so under either license.
+//
+//                            GPL LICENSE SUMMARY
+//
+//  Copyright(c) 2015-2017, Intel Corporation.
+//
+//  This program  is  free software;  you  can redistribute it  and/or  modify
+//  it  under  the  terms of  version 2 of  the GNU General Public License  as
+//  published by the Free Software Foundation.
+//
+//  This  program  is distributed  in the  hope that it  will  be useful,  but
+//  WITHOUT   ANY   WARRANTY;   without   even  the   implied   warranty    of
+//  MERCHANTABILITY  or  FITNESS  FOR  A  PARTICULAR  PURPOSE.  See  the   GNU
+//  General Public License for more details.
+//
+//  The  full  GNU  General Public License is  included in  this  distribution
+//  in the file called README.GPLV2-LICENSE.TXT.
+//
+//  Contact Information:
+//  Henry Mitchel, henry.mitchel at intel.com
+//  77 Reed Rd., Hudson, MA  01749
+//
+//                                BSD LICENSE
+//
+//  Copyright(c) 2015-2017, Intel Corporation.
+//
+//  Redistribution and  use  in source  and  binary  forms,  with  or  without
+//  modification,  are   permitted  provided  that  the  following  conditions
+//  are met:
+//
+//    * Redistributions  of  source  code  must  retain  the  above  copyright
+//      notice, this list of conditions and the following disclaimer.
+//    * Redistributions in  binary form  must  reproduce  the  above copyright
+//      notice,  this  list of  conditions  and  the  following disclaimer  in
+//      the   documentation   and/or   other   materials   provided  with  the
+//      distribution.
+//    * Neither   the  name   of  Intel  Corporation  nor  the  names  of  its
+//      contributors  may  be  used  to  endorse  or promote  products derived
+//      from this software without specific prior written permission.
+//
+//  THIS  SOFTWARE  IS  PROVIDED  BY  THE  COPYRIGHT HOLDERS  AND CONTRIBUTORS
+//  "AS IS"  AND  ANY  EXPRESS  OR  IMPLIED  WARRANTIES,  INCLUDING,  BUT  NOT
+//  LIMITED  TO, THE  IMPLIED WARRANTIES OF  MERCHANTABILITY  AND FITNESS  FOR
+//  A  PARTICULAR  PURPOSE  ARE  DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT
+//  OWNER OR CONTRIBUTORS BE LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,
+//  SPECIAL,  EXEMPLARY,  OR  CONSEQUENTIAL   DAMAGES  (INCLUDING,   BUT   NOT
+//  LIMITED  TO,  PROCUREMENT  OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF USE,
+//  DATA,  OR PROFITS;  OR BUSINESS INTERRUPTION)  HOWEVER  CAUSED  AND ON ANY
+//  THEORY  OF  LIABILITY,  WHETHER  IN  CONTRACT,  STRICT LIABILITY,  OR TORT
+//  (INCLUDING  NEGLIGENCE  OR OTHERWISE) ARISING  IN ANY WAY  OUT  OF THE USE
+//  OF  THIS  SOFTWARE, EVEN IF ADVISED  OF  THE  POSSIBILITY  OF SUCH DAMAGE.
+//******************************************************************************
+//****************************************************************************
+/// @file ccip_perfmon_linux.c
+/// @brief  Definitions for ccip performance monitor sysfs support.
+/// @ingroup aalkernel_ccip
+/// @verbatim
+//        FILE: ccip_perfmon_linux.c
+//     CREATED: Sept 24, 2015
+//      AUTHOR: Ananda Ravuri, Intel Corporation
+//              Joseph Grecco, Intel Corporation
+// HISTORY:
+// COMMENTS:
+// WHEN:          WHO:     WHAT:
+//****************************************************************************///
+
+#include "aalsdk/kernel/kosal.h"
+#define MODULE_FLAGS CCIPCIE_DBG_MOD
+#include "aalsdk/kernel/ccip_defs.h"
+
+#include "ccip_perfmon_linux.h"
+#include "ccip_fme.h"
+
+
+///============================================================================
+/// Name: perf_monitor_attrib_show_hr
+/// @brief Writes and show CCIP Performance counters to sysfs
+///
+/// @param[in] pdev - device pointer
+/// @param[in] attr - device attribute.
+/// @param[in] buf - char buffer.
+/// @return    size of buffer
+///============================================================================
+static ssize_t perf_monitor_attrib_show_hr(struct device *pdev,
+                                           struct device_attribute *attr,
+                                           char *buf)
+{
+   struct CCIP_PERF_COUNTERS perf_mon;
+   struct fme_device* pfme_dev = dev_get_drvdata(pdev);
+
+   if(NULL == pfme_dev )  {
+     return (snprintf(buf,PAGE_SIZE,"%d\n",0));
+   }
+
+   get_perfmonitor_snapshot(pfme_dev, &perf_mon);
+
+   return (snprintf(buf,PAGE_SIZE,   "%s : %lu \n"
+                                     "%s : %lu \n"
+                                     "%s : %lu \n"
+                                     "%s : %lu \n"
+                                     "%s : %lu \n"
+                                     "%s : %lu \n"
+                                     "%s : %lu \n"
+                                     "%s : %lu \n"
+                                     "%s : %lu \n"
+                                     "%s : %lu \n"
+                                     "%s : %lu \n"
+                                     "%s : %lu \n"
+                                     "%s : %lu \n"
+                                     "%s : %lu \n"
+                                     "%s : %lu \n"
+                                     "%s : %lu \n"
+                                     "%s : %lu \n",
+                                     NUM_COUNTERS,               (unsigned long int) perf_mon.num_counters.value ,
+                                     PMONITOR_VERSION,           (unsigned long int) perf_mon.version.value ,
+                                     CACHE_READ_HIT,             (unsigned long int) perf_mon.read_hit.value ,
+                                     CACHE_WRITE_HIT,            (unsigned long int) perf_mon.write_hit.value ,
+                                     CACHE_READ_MISS,            (unsigned long int) perf_mon.read_miss.value,
+                                     CACHE_WRITE_MISS,           (unsigned long int) perf_mon.write_miss.value,
+                                     CACHE_EVICTIONS,            (unsigned long int) perf_mon.evictions.value,
+                                     FABRIC_PCIE0_READ,          (unsigned long int) perf_mon.pcie0_read.value ,
+                                     FABRIC_PCIE0_WRITE,         (unsigned long int) perf_mon.pcie0_write.value ,
+                                     FABRIC_PCIE1_READ,          (unsigned long int) perf_mon.pcie1_read.value ,
+                                     FABRIC_PCIE1_WRITE,         (unsigned long int) perf_mon.pcie1_write.value ,
+                                     FABRIC_UPI_READ,            (unsigned long int) perf_mon.upi_read.value ,
+                                     FABRIC_UPI_WRITE,           (unsigned long int) perf_mon.upi_write.value,
+                                     VTD_AFU_MEMREAD_TRANS,      (unsigned long int) perf_mon.AFU0_MemRead_Trans.value,
+                                     VTD_AFU_MEMWRITE_TRANS,     (unsigned long int) perf_mon.AFU0_MemWrite_Trans.value,
+                                     VTD_AFU_DEVTLBREAD_HIT,     (unsigned long int) perf_mon.AFU0_DevTLBRead_Hit.value,
+                                     VTD_AFU_DEVTLBWRITE_HIT,    (unsigned long int) perf_mon.AFU0_DevTLBWrite_Hit.value
+                                     ));
+
+}
+
+
+
+DEVICE_ATTR(perfmon_hr_0,0444, perf_monitor_attrib_show_hr,NULL);
+
+///============================================================================
+/// Name: perf_monitor_attrib_show_bin
+/// @brief shows CCIP Performance counters
+///
+/// @param[in] pdev - device pointer
+/// @param[in] attr - device attribute.
+/// @param[in] buf - char buffer.
+/// @return    size of buffer
+///============================================================================
+static ssize_t perf_monitor_attrib_show_bin(struct device *pdev,
+                                            struct device_attribute *bin_attr,
+                                            char *buf)
+{
+   struct CCIP_PERF_COUNTERS perf_mon;
+   struct fme_device* pfme_dev= dev_get_drvdata(pdev);
+
+   if(NULL == pfme_dev )  {
+      return (snprintf(buf,PAGE_SIZE,"%d\n",0));
+   }
+
+   get_perfmonitor_snapshot(pfme_dev, &perf_mon);
+
+   return (snprintf(buf, PAGE_SIZE,  "%lu  "
+                                    "%lu  "
+                                    "%lu  "
+                                    "%lu  "
+                                    "%lu  "
+                                    "%lu  "
+                                    "%lu  "
+                                    "%lu  "
+                                    "%lu  "
+                                    "%lu  "
+                                    "%lu  "
+                                    "%lu  "
+                                    "%lu  "
+                                    "%lu  "
+                                    "%lu  "
+                                    "%lu  "
+                                    "%lu  ",
+                                     (unsigned long int) perf_mon.num_counters.value,
+                                     (unsigned long int) perf_mon.version.value ,
+                                     (unsigned long int) perf_mon.read_hit.value ,
+                                     (unsigned long int) perf_mon.write_hit.value,
+                                     (unsigned long int) perf_mon.read_miss.value ,
+                                     (unsigned long int) perf_mon.write_miss.value,
+                                     (unsigned long int) perf_mon.evictions.value ,
+                                     (unsigned long int) perf_mon.pcie0_read.value ,
+                                     (unsigned long int) perf_mon.pcie0_write.value,
+                                     (unsigned long int) perf_mon.pcie1_read.value ,
+                                     (unsigned long int) perf_mon.pcie1_write.value ,
+                                     (unsigned long int) perf_mon.upi_read.value ,
+                                     (unsigned long int) perf_mon.upi_write.value,
+                                     (unsigned long int) perf_mon.AFU0_MemRead_Trans.value,
+                                     (unsigned long int) perf_mon.AFU0_MemWrite_Trans.value,
+                                     (unsigned long int) perf_mon.AFU0_DevTLBRead_Hit.value,
+                                     (unsigned long int) perf_mon.AFU0_DevTLBWrite_Hit.value
+                                    ));
+
+ }
+
+
+DEVICE_ATTR(perfmon_bin_0,0444, perf_monitor_attrib_show_bin,NULL);
+
+
+
+///============================================================================
+/// Name: create_perfmonitor
+/// @brief create Performance counters
+///
+/// @param[in] ppcidev - pci device pointer
+/// @param[in] pfme_dev - fme device pointer
+/// @return    error code
+///============================================================================
+bt32bitInt create_perfmonitor(kosal_pci_dev* ppcidev,
+                              struct fme_device* pfme_dev)
+{
+   int res =0;
+
+   PTRACEIN;
+   if( (NULL == ppcidev) && (NULL == pfme_dev))  {
+
+       PERR("Invalid input pointers \n");
+       res = -EINVAL;
+       goto ERR;
+    }
+
+   device_create_file(&(ppcidev->dev),&dev_attr_perfmon_hr_0);
+   device_create_file(&(ppcidev->dev),&dev_attr_perfmon_bin_0);
+
+   dev_set_drvdata(&(ppcidev->dev),pfme_dev);
+
+   PTRACEOUT_INT(res);
+   return res;
+ERR:
+   PTRACEOUT_INT(res);
+   return  res;
+}
+
+///============================================================================
+/// Name: remove_perfmonitor
+/// @brief remove Performance counters
+///
+/// @param[in] ppcidev  pci device pointer.
+/// @return    error code
+///============================================================================
+bt32bitInt remove_perfmonitor(kosal_pci_dev* ppcidev)
+{
+   int res =0;
+
+   PTRACEIN;
+
+   if( (NULL == ppcidev) ) {
+       PERR("Invalid input pointers \n");
+       res = -EINVAL;
+       goto ERR;
+    }
+
+   device_remove_file(&(ppcidev->dev),&dev_attr_perfmon_hr_0);
+   device_remove_file(&(ppcidev->dev),&dev_attr_perfmon_bin_0);
+
+   PTRACEOUT_INT(res);
+   return res;
+ERR:
+   PTRACEOUT_INT(res);
+   return  res;
+}
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
diff --git a/drivers/fpga/aal/cci/ccip_perfmon_linux.h b/drivers/fpga/aal/cci/ccip_perfmon_linux.h
new file mode 100644
index 000000000000..ade6fb39b27d
--- /dev/null
+++ b/drivers/fpga/aal/cci/ccip_perfmon_linux.h
@@ -0,0 +1,95 @@
+//******************************************************************************
+// This  file  is  provided  under  a  dual BSD/GPLv2  license.  When using or
+//         redistributing this file, you may do so under either license.
+//
+//                            GPL LICENSE SUMMARY
+//
+//  Copyright(c) 2011-2017, Intel Corporation.
+//
+//  This program  is  free software;  you  can redistribute it  and/or  modify
+//  it  under  the  terms of  version 2 of  the GNU General Public License  as
+//  published by the Free Software Foundation.
+//
+//  This  program  is distributed  in the  hope that it  will  be useful,  but
+//  WITHOUT   ANY   WARRANTY;   without   even  the   implied   warranty    of
+//  MERCHANTABILITY  or  FITNESS  FOR  A  PARTICULAR  PURPOSE.  See  the   GNU
+//  General Public License for more details.
+//
+//  The  full  GNU  General Public License is  included in  this  distribution
+//  in the file called README.GPLV2-LICENSE.TXT.
+//
+//  Contact Information:
+//  Henry Mitchel, henry.mitchel at intel.com
+//  77 Reed Rd., Hudson, MA  01749
+//
+//                                BSD LICENSE
+//
+//  Copyright(c) 2011-2017, Intel Corporation.
+//
+//  Redistribution and  use  in source  and  binary  forms,  with  or  without
+//  modification,  are   permitted  provided  that  the  following  conditions
+//  are met:
+//
+//    * Redistributions  of  source  code  must  retain  the  above  copyright
+//      notice, this list of conditions and the following disclaimer.
+//    * Redistributions in  binary form  must  reproduce  the  above copyright
+//      notice,  this  list of  conditions  and  the  following disclaimer  in
+//      the   documentation   and/or   other   materials   provided  with  the
+//      distribution.
+//    * Neither   the  name   of  Intel  Corporation  nor  the  names  of  its
+//      contributors  may  be  used  to  endorse  or promote  products derived
+//      from this software without specific prior written permission.
+//
+//  THIS  SOFTWARE  IS  PROVIDED  BY  THE  COPYRIGHT HOLDERS  AND CONTRIBUTORS
+//  "AS IS"  AND  ANY  EXPRESS  OR  IMPLIED  WARRANTIES,  INCLUDING,  BUT  NOT
+//  LIMITED  TO, THE  IMPLIED WARRANTIES OF  MERCHANTABILITY  AND FITNESS  FOR
+//  A  PARTICULAR  PURPOSE  ARE  DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT
+//  OWNER OR CONTRIBUTORS BE LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,
+//  SPECIAL,  EXEMPLARY,  OR  CONSEQUENTIAL   DAMAGES  (INCLUDING,   BUT   NOT
+//  LIMITED  TO,  PROCUREMENT  OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF USE,
+//  DATA,  OR PROFITS;  OR BUSINESS INTERRUPTION)  HOWEVER  CAUSED  AND ON ANY
+//  THEORY  OF  LIABILITY,  WHETHER  IN  CONTRACT,  STRICT LIABILITY,  OR TORT
+//  (INCLUDING  NEGLIGENCE  OR OTHERWISE) ARISING  IN ANY WAY  OUT  OF THE USE
+//  OF  THIS  SOFTWARE, EVEN IF ADVISED  OF  THE  POSSIBILITY  OF SUCH DAMAGE.
+//******************************************************************************
+//****************************************************************************
+/// @file ccip_perfmon_linux.h
+/// @brief  Definitions for ccip performance counter.
+/// @ingroup aalkernel_ccip
+/// @verbatim
+//        FILE: ccip_perfmon.h
+//     CREATED: Sept 24, 2015
+//      AUTHOR: Ananda Ravuri, Intel Corporation
+//              Joseph Grecco, Intel Corporation
+// 
+// PURPOSE:
+// HISTORY:
+// COMMENTS:
+// WHEN:          WHO:     WHAT:
+// 02/19/2016     JG       Refactored OS specific portion
+//****************************************************************************///
+#ifndef __AALKERNEL_CCIP_PERFMON_LINUX_H_
+#define __AALKERNEL_CCIP_PERFMON_LINUX_H_
+
+#include <ccip_perfmon.h>
+
+
+/// Name:    create_perfmonitor
+/// @brief   creates performance monitor
+///
+/// @param[in] ppcidev  pci device  pointer.
+/// @param[in] pfme_dev fme device pointer.
+/// @return    error code
+bt32bitInt create_perfmonitor(kosal_pci_dev* ppcidev,
+                              struct fme_device* pfme_dev);
+
+/// Name:    remove_perfmonitor
+/// @brief   removes perfoemanceee counters
+///
+/// @param[in] ppcidev  pci device  pointer.
+/// @return    error code
+bt32bitInt remove_perfmonitor(kosal_pci_dev* ppcidev);
+
+
+
+#endif //__AALKERNEL_CCIP_PERFMON_LINUX_H_
diff --git a/drivers/fpga/aal/cci/ccip_port.c b/drivers/fpga/aal/cci/ccip_port.c
new file mode 100644
index 000000000000..9f73cfe5ab26
--- /dev/null
+++ b/drivers/fpga/aal/cci/ccip_port.c
@@ -0,0 +1,1022 @@
+//******************************************************************************
+// This  file  is  provided  under  a  dual BSD/GPLv2  license.  When using or
+//         redistributing this file, you may do so under either license.
+//
+//                            GPL LICENSE SUMMARY
+//
+//  Copyright(c) 2015-2017, Intel Corporation.
+//
+//  This program  is  free software;  you  can redistribute it  and/or  modify
+//  it  under  the  terms of  version 2 of  the GNU General Public License  as
+//  published by the Free Software Foundation.
+//
+//  This  program  is distributed  in the  hope that it  will  be useful,  but
+//  WITHOUT   ANY   WARRANTY;   without   even  the   implied   warranty    of
+//  MERCHANTABILITY  or  FITNESS  FOR  A  PARTICULAR  PURPOSE.  See  the   GNU
+//  General Public License for more details.
+//
+//  The  full  GNU  General Public License is  included in  this  distribution
+//  in the file called README.GPLV2-LICENSE.TXT.
+//
+//  Contact Information:
+//  Henry Mitchel, henry.mitchel at intel.com
+//  77 Reed Rd., Hudson, MA  01749
+//
+//                                BSD LICENSE
+//
+//  Copyright(c) 2015-2017, Intel Corporation.
+//
+//  Redistribution and  use  in source  and  binary  forms,  with  or  without
+//  modification,  are   permitted  provided  that  the  following  conditions
+//  are met:
+//
+//    * Redistributions  of  source  code  must  retain  the  above  copyright
+//      notice, this list of conditions and the following disclaimer.
+//    * Redistributions in  binary form  must  reproduce  the  above copyright
+//      notice,  this  list of  conditions  and  the  following disclaimer  in
+//      the   documentation   and/or   other   materials   provided  with  the
+//      distribution.
+//    * Neither   the  name   of  Intel  Corporation  nor  the  names  of  its
+//      contributors  may  be  used  to  endorse  or promote  products derived
+//      from this software without specific prior written permission.
+//
+//  THIS  SOFTWARE  IS  PROVIDED  BY  THE  COPYRIGHT HOLDERS  AND CONTRIBUTORS
+//  "AS IS"  AND  ANY  EXPRESS  OR  IMPLIED  WARRANTIES,  INCLUDING,  BUT  NOT
+//  LIMITED  TO, THE  IMPLIED WARRANTIES OF  MERCHANTABILITY  AND FITNESS  FOR
+//  A  PARTICULAR  PURPOSE  ARE  DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT
+//  OWNER OR CONTRIBUTORS BE LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,
+//  SPECIAL,  EXEMPLARY,  OR  CONSEQUENTIAL   DAMAGES  (INCLUDING,   BUT   NOT
+//  LIMITED  TO,  PROCUREMENT  OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF USE,
+//  DATA,  OR PROFITS;  OR BUSINESS INTERRUPTION)  HOWEVER  CAUSED  AND ON ANY
+//  THEORY  OF  LIABILITY,  WHETHER  IN  CONTRACT,  STRICT LIABILITY,  OR TORT
+//  (INCLUDING  NEGLIGENCE  OR OTHERWISE) ARISING  IN ANY WAY  OUT  OF THE USE
+//  OF  THIS  SOFTWARE, EVEN IF ADVISED  OF  THE  POSSIBILITY  OF SUCH DAMAGE.
+//******************************************************************************
+//****************************************************************************
+/// @file ccip_port.c
+/// @brief  Implementation of the ccip Port object.
+/// @ingroup aalkernel_ccip
+/// @verbatim
+//        FILE: ccip_port.c
+//     CREATED: Sept 24, 2015
+//      AUTHOR:
+//
+// PURPOSE:   This file contains the implementation of the CCIP port
+//             low-level function (i.e., Physical Interface Protocol driver).
+// HISTORY:
+// COMMENTS:
+// WHEN:          WHO:     WHAT:
+//****************************************************************************///
+#include "aalsdk/kernel/kosal.h"
+#define MODULE_FLAGS CCIPCIE_DBG_MOD
+
+#include "aalsdk/kernel/aalbus.h"
+#include "aalsdk/kernel/AALTransactionID_s.h"
+#include "aalsdk/kernel/aalbus-ipip.h"
+#include "aalsdk/kernel/ccip_defs.h"
+
+#include "aalsdk/kernel/ccipdriver.h"
+#include "ccipdrv-events.h"
+
+#include "ccip_port.h"
+#include "cci_pcie_driver_PIPsession.h"
+
+#define  CCIP_PORT_OUTSTADREQ_TIMEOUT   100
+#define  CCIP_PORT_OUTSTADREQ_COMPLETE  0x1
+
+///////////////////////////////////////////////////////////////////////////////
+///////////////////////////////////////////////////////////////////////////////
+////////////////////                                     //////////////////////
+/////////////////           AAL SUPPORT FUNCTIONS          ////////////////////
+////////////////////                                     //////////////////////
+///////////////////////////////////////////////////////////////////////////////
+///////////////////////////////////////////////////////////////////////////////
+
+static int CommandHandler( struct aaldev_ownerSession *,
+                           struct aal_pipmessage*);
+
+// TODO going to try and use a common mmapper for all obkects
+extern int cci_mmap( struct aaldev_ownerSession *pownerSess,
+                     struct aal_wsid *wsidp,
+                     btAny os_specific );
+
+//=============================================================================
+// Name: cci_FMEpip
+// @brief Physical Interface Protocol Interface for the CCIP Port device
+//=============================================================================
+struct aal_ipip cci_Portpip = {
+   .m_messageHandler = {
+      .sendMessage   = CommandHandler,       // Command Handler
+      .bindSession   = BindSession,          // Session binder
+      .unBindSession = UnbindSession,        // Session unbinder
+   },
+
+   .m_fops = {
+     .mmap = cci_mmap,
+   },
+
+   // Methods for binding and unbinding PIP to generic aal_device
+   //  Unused in this PIP
+   .binddevice    = NULL,      // Binds the PIP to the device
+   .unbinddevice  = NULL,      // Binds the PIP to the device
+};
+
+
+///============================================================================
+/// Name: cci_create_AAL_Port_Device
+/// @brief Creates and registers PR objects (resources) we want to
+///        expose through AAL.
+///
+/// @param[in] pportdev - Port device
+/// @param[in] devnum - Port number
+/// @param[in] paalid - Base AAL ID for this device.
+/// @return    AAL Device pointer
+///============================================================================
+struct cci_aal_device   *
+               cci_create_AAL_Port_Device( struct port_device   *pportdev,
+                                           btUnsigned16bitInt    devnum,
+                                           struct aal_device_id *paalid)
+{
+   struct cci_aal_device   *pcci_aaldev = NULL;
+   int                      ret         = 0;
+   PTRACEIN;
+
+   //=====================================================================
+   // Create the Port AAL device. The Port AAL device is the class
+   //   is registered with AAL Bus to enable it to be allocated by an
+   //   application. AAL device objects represent the application usable
+   //   devices. AAL device objects have their own low level communication
+   //   function called the Physical Interface Protocol (PIP). This enables
+   //   us to easily create object specific interfaces in a single driver.
+
+   // Construct the cci_aal_device object
+   pcci_aaldev = cci_create_aal_device();
+
+   ASSERT(NULL != pcci_aaldev);
+   if(NULL == pcci_aaldev ) {
+      return NULL;
+   }
+
+
+   // Make it an Port by setting the type field and giving a pointer to the
+   //  Port device object of the CCIP board device
+   cci_aaldev_type(pcci_aaldev)  = cci_dev_Port;
+   cci_aaldev_pport(pcci_aaldev) = pportdev;
+   cci_aaldev_pfme(pcci_aaldev)  = ccip_port_dev_fme(pportdev);
+
+   // Save the PCI device handle
+   cci_aaldev_pci_dev(pcci_aaldev) = ccip_dev_to_pci_dev( ccip_port_to_ccidev(pportdev) );
+
+
+   // Setup the AAL device's ID. This is the collection of attributes
+   //  that uniquely identifies the AAL device, usually for the purpose
+   //  of allocation through Resource Management
+   //------------------------------------------------------------------
+   aaldevid_devaddr_bustype(*paalid)     =   ccip_port_bustype(pportdev);
+
+   // The AAL address maps to the PCIe address. The Subdevice number is
+   //  vendor defined and in this case the FME object has the value CCIP_DEV_FME_SUBDEV
+   aaldevid_devaddr_busnum(*paalid)          = ccip_port_busnum(pportdev);
+   aaldevid_devaddr_devnum(*paalid)          = ccip_port_devnum(pportdev);
+   aaldevid_devaddr_fcnnum(*paalid)          = ccip_port_fcnnum(pportdev);
+   aaldevid_devaddr_subdevnum(*paalid)       = devnum;
+   aaldevid_devaddr_instanceNum(*paalid)     = 0;
+   aaldevid_devaddr_socketnum(*paalid)       = ccip_port_socketnum(pportdev);
+
+   // The following attributes describe the interfaces supported by the device
+   aaldevid_afuguidl(*paalid)            = CCIP_PORT_GUIDL;
+   aaldevid_afuguidh(*paalid)            = CCIP_PORT_GUIDH;
+   aaldevid_devtype(*paalid)             = aal_devtypeAFU;
+   aaldevid_pipguid(*paalid)             = CCIP_PORT_PIPIID;
+   aaldevid_vendorid(*paalid)            = AAL_vendINTC;
+
+   cci_aaldev_phys_afu_mmio(pcci_aaldev)    = ccip_port_phys_mmio(pportdev);
+   cci_aaldev_kvp_afu_mmio(pcci_aaldev)     = ccip_port_kvp_mmio(pportdev);
+   cci_aaldev_len_afu_mmio(pcci_aaldev)     = ccip_port_mmio_len(pportdev);
+
+
+   // Set the interface permissions
+   // Enable MMIO-R
+   cci_aaldev_set_allow_map_mmior_space(pcci_aaldev);
+
+
+   // Create the AAL device and attach it to the CCI device object
+   cci_aaldev_to_aaldev(pcci_aaldev)  =  aaldev_create( "CCIPPORT",           // AAL device base name
+                                                        &*paalid,             // AAL ID
+                                                        &cci_Portpip);
+   //CCI device object create fails, delete Port AAL device
+   if( NULL == cci_aaldev_to_aaldev(pcci_aaldev)) {
+      cci_destroy_aal_device(pcci_aaldev);
+      return NULL;
+   }
+
+   //===========================================================
+   // Set up the optional aal_device attributes
+   //
+
+   // Set how many owners are allowed access to this device simultaneously
+   cci_aaldev_to_aaldev(pcci_aaldev)->m_maxowners = 1;
+
+   // Set the config space mapping permissions
+   cci_aaldev_to_aaldev(pcci_aaldev)->m_mappableAPI = AAL_DEV_APIMAP_NONE;
+   if( cci_aaldev_allow_map_csr_read_space(pcci_aaldev) ){
+      cci_aaldev_to_aaldev(pcci_aaldev)->m_mappableAPI |= AAL_DEV_APIMAP_CSRWRITE;
+   }
+
+   if( cci_aaldev_allow_map_csr_write_space(pcci_aaldev) ){
+      cci_aaldev_to_aaldev(pcci_aaldev)->m_mappableAPI |= AAL_DEV_APIMAP_CSRREAD;
+   }
+
+   if( cci_aaldev_allow_map_mmior_space(pcci_aaldev) ){
+      cci_aaldev_to_aaldev(pcci_aaldev)->m_mappableAPI |= AAL_DEV_APIMAP_MMIOR;
+   }
+
+   if( cci_aaldev_allow_map_umsg_space(pcci_aaldev) ){
+      cci_aaldev_to_aaldev(pcci_aaldev)->m_mappableAPI |= AAL_DEV_APIMAP_UMSG;
+   }
+
+   // The PIP uses the PIP context to get a handle to the CCI Device from the generic device.
+   aaldev_pip_context(cci_aaldev_to_aaldev(pcci_aaldev)) = (void*)pcci_aaldev;
+
+   // Method called when the device is released (i.e., its destructor)
+   //  The canonical release device calls the user's release method.
+   //  If NULL is provided then only the canonical behavior is done
+   dev_setrelease(cci_aaldev_to_aaldev(pcci_aaldev), cci_release_device);
+
+      // Device is ready for use.  Publish it with the Configuration Management Subsystem
+   ret = cci_publish_aaldevice(pcci_aaldev);
+   ASSERT(ret == 0);
+   if(0> ret){
+      PERR("Failed to initialize AAL Device for FME[%d:%d:%d:%x:%d]",aaldevid_devaddr_busnum(*paalid),
+                                                                     aaldevid_devaddr_devnum(*paalid),
+                                                                     aaldevid_devaddr_fcnnum(*paalid),
+                                                                     aaldevid_devaddr_subdevnum(*paalid),
+																     aaldevid_devaddr_instanceNum(*paalid));
+      cci_destroy_aal_device(pcci_aaldev);
+      return NULL;
+   }
+   PTRACEOUT;
+   return pcci_aaldev;
+}
+
+//=============================================================================
+// Name: CommandHandler
+// Description: Implements the PIP command handler
+// Interface: public
+// Inputs: pownerSess - Session between App and device
+//         Message - Message to process
+// Outputs: none.
+// Comments:
+//=============================================================================
+int
+CommandHandler(struct aaldev_ownerSession *pownerSess,
+               struct aal_pipmessage      *Message)
+{
+#if (1 == ENABLE_DEBUG)
+#define AFU_COMMAND_CASE(x) case x : PDEBUG("%s\n", #x);
+#else
+#define AFU_COMMAND_CASE(x) case x :
+#endif // ENABLE_DEBUG
+
+   // Private session object set at session bind time (i.e., when object allocated)
+   struct cci_PIPsession *pSess = (struct cci_PIPsession *)aalsess_pipHandle(pownerSess);
+   struct cci_aal_device  *pdev  = NULL;
+
+   // Overall return value for this function. Set before exiting if there is an error.
+   //    retval = 0 means good return.
+   int retval = 0;
+
+   // if we return a request error, return this.  usually it's an invalid request error.
+   uid_errnum_e request_error = uid_errnumInvalidRequest;
+
+   // UI Driver message
+   struct aalui_CCIdrvMessage *pmsg = (struct aalui_CCIdrvMessage *) Message->m_message;
+
+   // Save original response buffer size in case we return something
+   btWSSize         respBufSize     = Message->m_respbufSize;
+
+   // Assume returning nothing. By setting the response buffer size to 0
+   //   we tell the upstream side that there is no payload to copy back.
+   //   Setting it here means we don't have to set it (or forget to) in each
+   //   command.  We've recorded the payload buffer size above if we do need
+   //   intend to send a payload.
+   Message->m_respbufSize          = 0;
+
+   PTRACEIN;
+
+   // Perform some basic checks while assigning the pdev
+   ASSERT(NULL != pSess );
+   if ( NULL == pSess ) {
+      PDEBUG("Error: No PIP session\n");
+      return -EIO;
+   }
+
+   // Get the cci device
+   pdev = cci_PIPsessionp_to_ccidev(pSess);
+   if ( NULL == pdev ) {
+      PDEBUG("Error: No device\n");
+      return -EIO;
+   }
+
+   //=====================
+   // Message processor
+   //=====================
+   switch ( pmsg->cmd ) {
+
+      // Returns a workspace ID for the Config Space
+      AFU_COMMAND_CASE(ccipdrv_getMMIORmap) {
+         struct aal_wsid  *wsidp = NULL;
+         struct ccidrvreq *preq = (struct ccidrvreq *)pmsg->payload;
+         struct aalui_WSMEvent WSID;
+
+         // clear WSID structure
+         memset(&WSID, 0, sizeof(struct aalui_WSMEvent));
+
+         if ( !cci_aaldev_allow_map_mmior_space(pdev) ) {
+            PERR("Failed ccipdrv_getMMIOR map Permission\n");
+            PERR("Direct API access not permitted on this device\n");
+            Message->m_errcode = uid_errnumPermission;
+            break;
+         }
+
+         //------------------------------------------------------------
+         // Create the WSID object and add to the list for this session
+         //------------------------------------------------------------
+         if ( WSID_MAP_MMIOR != preq->ahmreq.u.wksp.m_wsid ) {
+            PERR("Failed ccipdrv_getMMIOR map Parameter\n");
+
+            PERR("Bad WSID on ccipdrv_getMMIORmap\n");
+            Message->m_errcode = uid_errnumBadParameter;
+            break;
+         }
+
+         wsidp = ccidrv_getwsid(pownerSess->m_device, preq->ahmreq.u.wksp.m_wsid);
+         if ( NULL == wsidp ) {
+            PERR("Could not allocate workspace\n");
+            retval = -ENOMEM;
+            /* generate a failure event back to the caller? */
+            goto ERROR;
+         }
+
+         wsidp->m_type = WSM_TYPE_MMIO;
+         PDEBUG("Getting CSR %s Aperature WSID %p using id %llx .\n",
+                   ((WSID_CSRMAP_WRITEAREA == preq->ahmreq.u.wksp.m_wsid) ? "Write" : "Read"),
+                   wsidp,
+                   preq->ahmreq.u.wksp.m_wsid);
+
+         PDEBUG("Apt = %" PRIxPHYS_ADDR " Len = %d.\n",cci_aaldev_phys_afu_mmio(pdev), (int)cci_aaldev_len_afu_mmio(pdev));
+
+         // Set up the return payload
+         WSID.evtID           = uid_wseventMMIOMap;
+         WSID.wsParms.wsid    = pwsid_to_wsidHandle(wsidp);
+         WSID.wsParms.physptr = cci_aaldev_phys_afu_mmio(pdev);
+         WSID.wsParms.size    = cci_aaldev_len_afu_mmio(pdev);
+
+         // Make this atomic. Check the original response buffer size for room
+         if(respBufSize >= sizeof(struct aalui_WSMEvent)){
+            *((struct aalui_WSMEvent*)Message->m_response) = WSID;
+            Message->m_respbufSize = sizeof(struct aalui_WSMEvent);
+         }
+         PDEBUG("Buf size =  %u Returning WSID %llx\n",(unsigned int)Message->m_respbufSize, WSID.wsParms.wsid  );
+         Message->m_errcode = uid_errnumOK;
+
+         // Add the new wsid onto the session
+         aalsess_add_ws(pownerSess, wsidp->m_list);
+
+      } break;
+
+
+      AFU_COMMAND_CASE(ccipdrv_getFeatureRegion) {
+         struct aal_wsid  *wsidp          = NULL;
+         struct ccidrvreq     *preq       = (struct ccidrvreq *)pmsg->payload;
+         struct aalui_WSMEvent WSID;
+         btWSID                featurenum = preq->ahmreq.u.wksp.m_wsid;
+         btPhysAddr            pFeature   = 0;
+         btVirtAddr            pvFeature  = 0;
+
+         // clear WSID structure
+         memset(&WSID, 0, sizeof(struct aalui_WSMEvent));
+
+         PVERBOSE("Getting feature ID %u\n",(unsigned int)featurenum);
+
+          if( true != get_port_feature(cci_aaldev_pport(pdev),featurenum, &pFeature, &pvFeature)){
+            Message->m_errcode = uid_errnumBadParameter;
+            PTRACEOUT;
+            return 0;
+         }
+
+         wsidp = ccidrv_getwsid(pownerSess->m_device, preq->ahmreq.u.wksp.m_wsid);
+         if ( NULL == wsidp ) {
+            PERR("Could not allocate workspace ID\n");
+            retval = -ENOMEM;
+            /* generate a failure event back to the caller? */
+            goto ERROR;
+         }
+
+         wsidp->m_type = WSM_TYPE_MMIO;
+
+         WSID.evtID           = uid_wseventMMIOMap;
+         WSID.wsParms.wsid    = pwsid_to_wsidHandle(wsidp);
+         WSID.wsParms.physptr = cci_aaldev_phys_afu_mmio(pdev);
+         WSID.wsParms.size    = cci_aaldev_len_afu_mmio(pdev);
+
+         // Make this atomic. Check the orignal response buffer size for room
+         if(respBufSize >= sizeof(struct aalui_WSMEvent)){
+            *((struct aalui_WSMEvent*)Message->m_response) = WSID;
+            Message->m_respbufSize = sizeof(struct aalui_WSMEvent);
+         }
+      } break;
+
+      AFU_COMMAND_CASE(ccipdrv_getPortError) {
+
+          bt32bitInt res               = 0;
+          struct CCIP_ERROR port_error = {0};
+          PVERBOSE("ccipdrv_getPortError \n");
+
+          res= get_port_error(cci_aaldev_pport(pdev) ,&port_error);
+          if(0 != res ) {
+             Message->m_errcode = uid_errnumBadParameter;
+             break;
+          }
+
+         if(respBufSize >= sizeof(struct CCIP_ERROR)){
+             PVERBOSE("ccipdrv_getPortError  Valid Buffer\n");
+            *((struct CCIP_ERROR*)Message->m_response) = port_error;
+            Message->m_respbufSize = sizeof(struct CCIP_ERROR);
+         }
+
+         // Success Event
+         Message->m_errcode = uid_errnumOK;
+
+       } break; // case ccipdrv_getPortError
+
+       AFU_COMMAND_CASE(ccipdrv_ClearAllPortErrors) {
+
+          // Clear ALL Port errors
+          // 1) Check for AP6 State
+          // 2) Reset Port
+          // 3) Set PORT mask to all 1's to mask errors
+          // 4) Clear all errors
+          // 5) Set PORT mask to all 0's to enable errors.
+          // 6) All errors starts capturing new errors
+          // 7) Enable port
+
+          struct CCIP_PORT_STATUS local_port_status ;
+          Get64CSR(&cci_aaldev_pport(pdev)->m_pport_hdr->ccip_port_status.csr,&local_port_status.csr);
+
+          // if Device in AP6 state don't clear any PORT errors
+          if( AFU_Power_AP6 == local_port_status.afu_pwr_state  ) {
+
+             PERR("Could not clear all errors, device in AP6 state. \n");
+             Message->m_errcode = uid_errnumAP6Detected;
+             break;
+          }
+
+          // Reset PORT if AP6 event detected.
+          if( 0x1 == ccip_port_err(cci_aaldev_pport(pdev))->ccip_port_error.ap6_event) {
+             // Soft Reset PORT before Clearing AP6 Error
+             if(0 != port_afu_quiesce_and_halt( cci_aaldev_pport(pdev) )){
+                // Failure
+                PERR(" Port Reset Timeout error. \n");
+                Message->m_errcode = uid_errnumTimeout;
+                break;
+             }
+
+          }
+
+          //Set PORT mask to all 1's to mask errors
+          ccip_port_err(cci_aaldev_pport(pdev))->ccip_port_error_mask.csr        = CLEAR_ALL_ERRORS;
+
+          //Clear all errors
+          ccip_port_err(cci_aaldev_pport(pdev))->ccip_port_error.csr             = CLEAR_ALL_ERRORS;
+          ccip_port_err(cci_aaldev_pport(pdev))->ccip_port_first_error.csr       = CLEAR_ALL_ERRORS;
+
+          //Set PORT mask to all 0's to enable errors.
+          ccip_port_err(cci_aaldev_pport(pdev))->ccip_port_error_mask.csr        = 0x0;
+
+          // Enable Port after clearing Errors.
+          if(0 != port_afu_Enable( cci_aaldev_pport(pdev) )){
+             PERR(" Port Enable timeout error. \n");
+             // Failure event
+             Message->m_errcode = uid_errnumTimeout;
+             break;
+          }
+
+          // Success Event
+          Message->m_errcode = uid_errnumOK;
+
+        } break; // case ccipdrv_ClearAllPortErrors
+
+       AFU_COMMAND_CASE(ccipdrv_ClearPortError) {
+
+          // Clear Port errors
+          // 1) Check for AP6 State
+          // 2) Reset Port
+          // 3) Clear errors
+          // 4) Port errors starts capturing new errors
+          // 5) Enable port
+
+          struct CCIP_PORT_ERROR  local_port_error;
+          struct CCIP_PORT_STATUS local_port_status ;
+          struct ccidrvreq *preq = (struct ccidrvreq *)pmsg->payload;
+
+          if(NULL == preq) {
+             Message->m_errcode = uid_errnumBadParameter;
+             break;
+          }
+
+          PVERBOSE("Port Error  CSR:%llX \n",ccip_port_err(cci_aaldev_pport(pdev))->ccip_port_error.csr);
+          PVERBOSE("New Port Error  CSR:%llX \n",preq->ahmreq.u.error_csr.error0);
+
+          // Port error to local CSR
+          local_port_error.csr = preq->ahmreq.u.error_csr.error0 ;
+
+          // Checking for AP6 Error
+          if(0x1 == local_port_error.ap6_event) {
+
+             Get64CSR(&cci_aaldev_pport(pdev)->m_pport_hdr->ccip_port_status.csr,&local_port_status.csr);
+
+             if( AFU_Power_AP6 == local_port_status.afu_pwr_state  ) {
+                PERR("Could not clear error, device in AP6 state. \n");
+                Message->m_errcode = uid_errnumAP6Detected;
+                break;
+             }
+
+             // Reset PORT if AP6 event detected.
+             if( 0x1 == ccip_port_err(cci_aaldev_pport(pdev))->ccip_port_error.ap6_event) {
+                // Soft Reset PORT before Clearing AP6 Error
+                if(0 != port_afu_quiesce_and_halt( cci_aaldev_pport(pdev) )){
+                   // Failure
+                   PERR(" Port Reset Timeout error. \n");
+                   Message->m_errcode = uid_errnumTimeout;
+                   break;
+                }
+
+             }
+          }
+
+          //Clear  errors
+          ccip_port_err(cci_aaldev_pport(pdev))->ccip_port_error.csr             = preq->ahmreq.u.error_csr.error0;
+          ccip_port_err(cci_aaldev_pport(pdev))->ccip_port_first_error.csr       = preq->ahmreq.u.error_csr.error0;
+
+          // Enable PORT after clearing AP6 Error
+          if(0x1 == local_port_error.ap6_event) {
+
+             // Enable Port after clearing Errors.
+             if(0 != port_afu_Enable( cci_aaldev_pport(pdev) )){
+                PERR(" Port Enable Timeout error. \n");
+                // Failure event
+                Message->m_errcode = uid_errnumTimeout;
+                break;
+             }
+
+          }
+
+          // Success Event
+          Message->m_errcode = uid_errnumOK;
+
+        } break; // case ccipdrv_ClearPortError
+
+
+        AFU_COMMAND_CASE(ccipdrv_SetPortErrorMask) {
+
+           struct ccidrvreq *preq = (struct ccidrvreq *)pmsg->payload;
+
+           if(NULL == preq) {
+              Message->m_errcode = uid_errnumBadParameter;
+              break;
+           }
+
+           PVERBOSE("Port mask CSR:%llX \n",cci_aaldev_pport(pdev)->m_pport_err->ccip_port_error_mask.csr);
+           PVERBOSE("New Port Mask CSR:%llX \n",preq->ahmreq.u.error_csr.error0);
+
+           ccip_port_err(cci_aaldev_pport(pdev))->ccip_port_error_mask.csr =preq->ahmreq.u.error_csr.error0;
+
+           // Success Event
+           Message->m_errcode = uid_errnumOK;
+
+         } break; // case ccipdrv_SetPortErrorMask
+
+   default: {
+
+      PDEBUG("Unrecognized command %" PRIu64 " or 0x%" PRIx64 " in AFUCommand\n", pmsg->cmd, pmsg->cmd);
+      Message->m_errcode = request_error;
+      retval = -EINVAL;
+
+   } break;
+   } // switch (pmsg->cmd)
+
+   ASSERT(0 == retval);
+
+ERROR:
+   return retval;
+}
+
+///////////////////////////////////////////////////////////////////////////////
+///////////////////////////////////////////////////////////////////////////////
+////////////////////                                     //////////////////////
+/////////////////          GENERIC PORT FUNCTIONS          ////////////////////
+////////////////////                                     //////////////////////
+///////////////////////////////////////////////////////////////////////////////
+///////////////////////////////////////////////////////////////////////////////
+
+
+///============================================================================
+/// Name: get_port_device
+/// @brief   Creates a Port device.
+///
+/// @param[in] pkvp_port_mmio - Port MMIO region
+/// @return    error code
+///============================================================================
+struct port_device  *get_port_device( btPhysAddr pphys_port_mmio,
+                                      btVirtAddr pkvp_port_mmio,
+                                      btWSSize   port_mmio_len)
+{
+   struct port_device      *pportdev   = NULL;
+   bt32bitInt               res         = 0;
+
+   PTRACEIN;
+
+   // Validate inputs parameters
+   ASSERT(pkvp_port_mmio);
+   if( NULL ==  pkvp_port_mmio ) {
+      return NULL;
+   }
+
+   // Construct the new object
+   pportdev =(struct port_device*) kosal_kzmalloc(sizeof(struct port_device));
+   ASSERT(pportdev);
+   if(NULL == pportdev){
+      PERR("Error allocating Port device\n");
+      return NULL;
+   }
+
+   // Initialize the list head
+   kosal_list_init(&ccip_port_list_head(pportdev));
+
+   // Initialize uAFU pointer
+   ccip_port_uafu_dev(pportdev) = NULL;
+
+   ccip_port_kvp_mmio(pportdev)    = pkvp_port_mmio;
+   ccip_port_phys_mmio(pportdev)   = pphys_port_mmio;
+   ccip_port_mmio_len(pportdev)    = port_mmio_len;
+
+   // Get Port header
+   ccip_port_hdr(pportdev) = get_port_header(pkvp_port_mmio );
+   if(NULL == ccip_port_hdr(pportdev)) {
+      PERR("Error reading Port Header\n");
+      goto ERR;
+   }
+
+   // get port feature list
+   res =  get_port_featurelist(pportdev,pkvp_port_mmio );
+   if(res !=0) {
+      PERR("Port device feature list Error %d \n",res);
+      goto ERR;
+   }
+
+   PINFO(" get_port_mmio EXIT \n");
+   return pportdev;
+
+ERR:
+   kosal_kfree(pportdev, sizeof(struct port_device));
+
+   PERR("Error getting Port device\n");
+   PTRACEOUT;
+   return NULL;
+}
+
+///============================================================================
+/// Name: destroy_port_device
+/// @brief   Destroys a Port device.
+///
+/// @param[in] pkvp_port_mmio - Port MMIO region
+/// @return    error code
+///============================================================================
+void destroy_port_device( struct port_device  * pport_dev)
+{
+   kosal_kfree(pport_dev, sizeof(struct port_device));
+   return;
+}
+
+///============================================================================
+/// Name: get_port_header
+/// @brief   reads PORT Header
+///
+/// @param[in] pport_dev port device pointer.
+/// @param[in] pkvp_port_mmio port mmio virtual address
+/// @return    Pointer to port header
+///============================================================================
+struct CCIP_PORT_HDR *get_port_header( btVirtAddr pkvp_port_mmio )
+{
+   return (struct CCIP_PORT_HDR *)(pkvp_port_mmio);
+}
+
+///============================================================================
+/// Name: get_port_feature
+/// @brief   Gets the pointer to a Port Feature
+///
+/// @param[in] pport_dev port device pointer.
+/// @param[in] Feature_ID - Feature ID to search for
+/// @return    NULL = failure
+///============================================================================
+btBool get_port_feature( struct port_device *pport_dev,
+                             btUnsigned64bitInt Feature_ID,
+                             btPhysAddr *pPhysAddr,
+                             btVirtAddr *pVirtAddr)
+{
+   struct CCIP_DFH         port_dfh;
+   btVirtAddr              pkvp_port   = NULL;
+   btPhysAddr              pphys_port  = 0;
+
+   PTRACEIN;
+
+   if( ccip_port_hdr(pport_dev)->ccip_port_dfh.next_DFH_offset ==0)   {
+      PERR("NO PORT features are available \n");
+      return false;
+   }
+   // read PORT Device feature Header
+   pkvp_port = ((btVirtAddr)ccip_port_hdr(pport_dev)) + ccip_port_hdr(pport_dev)->ccip_port_dfh.next_DFH_offset;
+   port_dfh.csr = ccip_port_hdr(pport_dev)->ccip_port_dfh.csr;
+
+   // Track the physical address as we walk the list
+   pphys_port = ccip_port_phys_mmio(pport_dev) + ccip_port_hdr(pport_dev)->ccip_port_dfh.next_DFH_offset;
+
+   do {
+      // sanity check
+      if (pkvp_port >= ((btVirtAddr)ccip_port_hdr(pport_dev)) + pport_dev->m_port_mmio_len) {
+         PERR("Next DFH offset points beyond BAR!\n");
+         PERR("   next_DFH_offset: 0x%x\n", port_dfh.next_DFH_offset);
+         PERR("   DFH            : 0x%0llx\n", port_dfh.csr);
+         return false;
+      }
+      // Peek at the Header
+      port_dfh.csr = read_ccip_csr64(pkvp_port,0);
+
+     // Device feature ID
+      if(Feature_ID == port_dfh.Feature_ID){
+         PVERBOSE("Feature found.\n");
+         if(NULL!= pPhysAddr){
+            *pPhysAddr = pphys_port;
+         }
+         if(NULL!= pVirtAddr){
+            *pVirtAddr = pkvp_port;
+         }
+         PTRACEOUT;
+
+         return true;
+      }
+
+      // Point at next feature header.
+      pkvp_port = pkvp_port + port_dfh.next_DFH_offset;
+      pphys_port = pphys_port + port_dfh.next_DFH_offset;
+
+   }while(0 != port_dfh.next_DFH_offset ); // end while
+
+   PVERBOSE("Feature not found\n");
+   PTRACEOUT;
+   return false;
+}
+
+///============================================================================
+/// Name: get_port_featurelist
+/// @brief   reads PORT feature list
+///
+/// @param[in] pport_dev port device pointer.
+/// @param[in] pkvp_port_mmio port mmio virtual address
+/// @return    error code
+///============================================================================
+bt32bitInt get_port_featurelist( struct port_device *pport_dev,
+                                 btVirtAddr pkvp_port_mmio )
+{
+
+   bt32bitInt              res =0;
+   struct CCIP_DFH         port_dfh;
+   btVirtAddr              pkvp_port = NULL;
+
+
+   PTRACEIN;
+   PINFO(" get_port_featurelist ENTER\n");
+
+   if( ccip_port_hdr(pport_dev)->ccip_port_dfh.next_DFH_offset ==0)   {
+      PERR("NO PORT features are available \n");
+      res = -EINVAL;
+      goto ERR;
+   }
+   // read PORT Device feature Header
+   pkvp_port = pkvp_port_mmio + ccip_port_hdr(pport_dev)->ccip_port_dfh.next_DFH_offset;
+
+   do {
+      // Peek at the Header
+      port_dfh.csr = read_ccip_csr64(pkvp_port,0);
+
+      // check for Device type
+      // Type == CCIP_DFType_private
+      if(port_dfh.Type  != CCIP_DFType_private ) {
+         PERR(" invalid PORT Feature Type \n");
+         res = -EINVAL;
+         goto ERR;
+
+      }
+
+      if(0 != port_dfh.Feature_rev){
+         PVERBOSE("Found Port feature with invalid revision %d. IGNORING!\n",port_dfh.Feature_rev);
+         continue;
+      }
+
+      // Device feature ID
+      switch(port_dfh.Feature_ID)
+      {
+
+         case CCIP_PORT_DFLID_ERROR:
+         {
+            ccip_port_err(pport_dev) = (struct CCIP_PORT_DFL_ERR *)pkvp_port;
+         }
+         break;
+
+         case CCIP_PORT_DFLID_USMG:
+         {
+            ccip_port_umsg(pport_dev) = (struct CCIP_PORT_DFL_UMSG *)pkvp_port;
+         }
+         break;
+
+         case CCIP_PORT_DFLID_PR:
+         {
+            ccip_port_pr(pport_dev) = (struct CCIP_PORT_DFL_PR *)pkvp_port;
+         }
+         break;
+
+         case CCIP_PORT_DFLID_STP:
+         {
+            ccip_port_stap(pport_dev) = (struct CCIP_PORT_DFL_STAP *)pkvp_port;
+         }
+         break;
+
+         default :
+         {
+            PERR(" invalid PORT Feature ID\n");
+            res = -EINVAL;
+            goto ERR;
+         }
+         break ;
+      } // end switch
+
+      // Point at next feature header.
+      pkvp_port = pkvp_port + port_dfh.next_DFH_offset;
+
+   }while(0 != port_dfh.next_DFH_offset ); // end while
+
+ERR:
+   PINFO(" get_port_featurelist EXIT \n");
+   PTRACEOUT_INT(res);
+   return res;
+}
+
+///============================================================================
+/// Name: port_afu_Enable
+/// @brief   Port Enable
+///
+/// @param[in] pport_dev port device pointer
+/// @return    error code
+///============================================================================
+bt32bitInt port_afu_Enable(struct port_device *pport_dev)
+{
+
+   bt32bitInt res = 0;
+
+   PTRACEIN;
+
+   if (NULL == ccip_port_hdr(pport_dev))
+   {
+      res = -EINVAL;
+      return  res;
+   }
+   ccip_port_hdr(pport_dev)->ccip_port_control.port_sftreset_control = 0x0;
+
+   PTRACEOUT_INT(res);
+
+   return res;
+}
+///============================================================================
+/// Name: port_afu_reset
+/// @brief   Reset port
+///
+/// @param[in] pport_dev port device pointer
+/// @return    error code
+///============================================================================
+bt32bitInt port_afu_reset(struct port_device *pport_dev)
+{
+   bt32bitInt res = 0;
+
+   PTRACEIN;
+
+   if (NULL == ccip_port_hdr(pport_dev))  {
+      res = -EINVAL;
+      return  res;
+   }
+
+   // afu/port Quiesce reset
+   res = port_afu_quiesce_and_halt(pport_dev);
+   if (0 != res) {
+      goto ERR;
+   }
+
+   // afu/port enable
+   res = port_afu_Enable(pport_dev);
+   if (0 != res) {
+      goto ERR;
+   }
+
+ERR:
+   PTRACEOUT_INT(res);
+   return res;
+}
+
+///============================================================================
+/// Name: port_afu_quiesce_and_halt
+/// @brief   Port Quiesce Reset
+///
+/// @param[in] pport_dev port device pointer
+/// @return    0 = success
+///============================================================================
+bt32bitInt port_afu_quiesce_and_halt(struct port_device *pport_dev)
+{
+   bt32bitInt res = 0;
+   btTime delay = 10;
+   btTime totaldelay = 0;
+
+   PTRACEIN;
+
+   if (NULL == ccip_port_hdr(pport_dev))  {
+      res = 1;
+      goto ERR;
+   }
+
+   // Reset Port
+   ccip_port_hdr(pport_dev)->ccip_port_control.port_sftreset_control = 0x1;
+
+   // All CCI-P request at port complete
+   // Set to 1 When all outstanding requests initiated by this port have been drained
+   while (CCIP_PORT_OUTSTADREQ_COMPLETE != ccip_port_hdr(pport_dev)->ccip_port_control.ccip_outstanding_request)
+   {
+      // Sleep
+      kosal_udelay(delay);
+
+      // total delay
+      totaldelay = totaldelay + delay;
+
+      // if total delay is more then 1 millisecond , return error
+      if (totaldelay > CCIP_PORT_OUTSTADREQ_TIMEOUT)   {
+         PERR("Timed out tryin to quiesce AFU");
+         res = 1;
+         goto ERR;
+      }
+
+   }
+
+ERR:
+   PTRACEOUT_INT(res);
+   return  res;
+}
+
+
+///============================================================================
+/// Name:    get_port_error
+/// @brief   get fpga global error
+///
+/// @param[in] pport_dev port device pointer.
+/// @param[in] pport_error ccip error structure  pointer
+/// @return    error code
+///============================================================================
+bt32bitInt get_port_error(struct port_device* pport_dev,
+                          struct CCIP_ERROR*  pport_error)
+{
+   int res = 0;
+
+   PTRACEIN;
+
+   if( (NULL == pport_dev) || (NULL == pport_error))  {
+         PERR("Invalid input pointers \n");
+         res =-EINVAL;
+         goto ERR;
+      }
+
+   memset(pport_error,0,sizeof(struct CCIP_ERROR));
+
+   pport_error->error0_mask    = ccip_port_err(pport_dev)->ccip_port_error_mask.csr;
+   pport_error->error0         = ccip_port_err(pport_dev)->ccip_port_error.csr;
+   pport_error->first_error    = ccip_port_err(pport_dev)->ccip_port_first_error.csr;
+
+   pport_error->malreq0        = ccip_port_err(pport_dev)->ccip_port_malformed_req_0.csr;
+   pport_error->malreq1        = ccip_port_err(pport_dev)->ccip_port_malformed_req_1.csr;
+
+   PTRACEOUT_INT(res);
+   return res;
+
+ERR:
+   PTRACEOUT_INT(res);
+   return  res;
+
+}
+
+
diff --git a/drivers/fpga/aal/cci/ccip_port.h b/drivers/fpga/aal/cci/ccip_port.h
new file mode 100644
index 000000000000..201bd1e41c3d
--- /dev/null
+++ b/drivers/fpga/aal/cci/ccip_port.h
@@ -0,0 +1,218 @@
+//******************************************************************************
+// This  file  is  provided  under  a  dual BSD/GPLv2  license.  When using or
+//         redistributing this file, you may do so under either license.
+//
+//                            GPL LICENSE SUMMARY
+//
+//  Copyright(c) 2015-2017, Intel Corporation.
+//
+//  This program  is  free software;  you  can redistribute it  and/or  modify
+//  it  under  the  terms of  version 2 of  the GNU General Public License  as
+//  published by the Free Software Foundation.
+//
+//  This  program  is distributed  in the  hope that it  will  be useful,  but
+//  WITHOUT   ANY   WARRANTY;   without   even  the   implied   warranty    of
+//  MERCHANTABILITY  or  FITNESS  FOR  A  PARTICULAR  PURPOSE.  See  the   GNU
+//  General Public License for more details.
+//
+//  The  full  GNU  General Public License is  included in  this  distribution
+//  in the file called README.GPLV2-LICENSE.TXT.
+//
+//  Contact Information:
+//  Henry Mitchel, henry.mitchel at intel.com
+//  77 Reed Rd., Hudson, MA  01749
+//
+//                                BSD LICENSE
+//
+//  Copyright(c) 2015-2017, Intel Corporation.
+//
+//  Redistribution and  use  in source  and  binary  forms,  with  or  without
+//  modification,  are   permitted  provided  that  the  following  conditions
+//  are met:
+//
+//    * Redistributions  of  source  code  must  retain  the  above  copyright
+//      notice, this list of conditions and the following disclaimer.
+//    * Redistributions in  binary form  must  reproduce  the  above copyright
+//      notice,  this  list of  conditions  and  the  following disclaimer  in
+//      the   documentation   and/or   other   materials   provided  with  the
+//      distribution.
+//    * Neither   the  name   of  Intel  Corporation  nor  the  names  of  its
+//      contributors  may  be  used  to  endorse  or promote  products derived
+//      from this software without specific prior written permission.
+//
+//  THIS  SOFTWARE  IS  PROVIDED  BY  THE  COPYRIGHT HOLDERS  AND CONTRIBUTORS
+//  "AS IS"  AND  ANY  EXPRESS  OR  IMPLIED  WARRANTIES,  INCLUDING,  BUT  NOT
+//  LIMITED  TO, THE  IMPLIED WARRANTIES OF  MERCHANTABILITY  AND FITNESS  FOR
+//  A  PARTICULAR  PURPOSE  ARE  DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT
+//  OWNER OR CONTRIBUTORS BE LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,
+//  SPECIAL,  EXEMPLARY,  OR  CONSEQUENTIAL   DAMAGES  (INCLUDING,   BUT   NOT
+//  LIMITED  TO,  PROCUREMENT  OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF USE,
+//  DATA,  OR PROFITS;  OR BUSINESS INTERRUPTION)  HOWEVER  CAUSED  AND ON ANY
+//  THEORY  OF  LIABILITY,  WHETHER  IN  CONTRACT,  STRICT LIABILITY,  OR TORT
+//  (INCLUDING  NEGLIGENCE  OR OTHERWISE) ARISING  IN ANY WAY  OUT  OF THE USE
+//  OF  THIS  SOFTWARE, EVEN IF ADVISED  OF  THE  POSSIBILITY  OF SUCH DAMAGE.
+//******************************************************************************
+//****************************************************************************
+/// @file ccip_port.h
+/// @brief  Definitions for CCI Port.
+/// @ingroup aalkernel_ccip
+/// @verbatim
+//        FILE: ccip_port.h
+//     CREATED: Sept 24, 2015
+//      AUTHOR: Ananda Ravuri, Intel <ananda.ravuri@intel.com>
+//              Joseph Grecco, Intel <joe.grecco@intel.com>
+//
+// PURPOSE:   This file contains the definations of the CCIP Port
+//             Device Feature List and CSR.
+// HISTORY:
+// COMMENTS:
+// WHEN:          WHO:     WHAT:
+//****************************************************************************///
+#ifndef __AALKERNEL_CCIP_PORT_DEF_H_
+#define __AALKERNEL_CCIP_PORT_DEF_H_
+
+#include <aalsdk/kernel/aaltypes.h>
+#include <aalsdk/kernel/ccip_defs.h>
+#include "cci_pcie_driver_internal.h"
+
+
+BEGIN_NAMESPACE(AAL)
+
+
+///============================================================================
+/// Name: port_device
+/// @brief  Port device struct
+///============================================================================
+struct port_device
+{
+   struct CCIP_PORT_HDR         *m_pport_hdr;         // PORRT Header
+   struct CCIP_PORT_DFL_ERR     *m_pport_err;         // PORT Error DFL
+   struct CCIP_PORT_DFL_UMSG    *m_pport_umsg;        // PORT USMG DFL
+   struct CCIP_PORT_DFL_PR      *m_pport_pr;          // PORT PR DFL
+   struct CCIP_PORT_DFL_STAP    *m_pport_stap;        // PORT Signal tap DFL
+
+   btPhysAddr                    m_phys_port_mmio;    // Base physical address
+   btVirtAddr                    m_kvp_port_mmio;     // Base kernel virtual address
+   btWSSize                      m_port_mmio_len;     // Base Workspace length
+   struct ccip_device           *m_ccipdev;           // Parent board
+
+   struct fme_device            *m_fme;               // Parent FME
+
+   // Used for being added to the list of devices.
+   kosal_list_head               m_list;
+
+   // Private semaphore
+   kosal_semaphore              m_sem;
+
+   enum aal_bus_types_e          m_bustype;
+   btUnsigned16bitInt            m_busNum;
+   btUnsigned16bitInt            m_devicenum;   // device number
+   btUnsigned16bitInt            m_functnum;    // function number
+   btUnsigned16bitInt            m_socketnum;   // socket number
+   btUnsigned16bitInt            m_subdevnum;
+
+   // The User AFU in this port
+   struct cci_aal_device        *m_uafu;
+   // Signal tap aal device
+   struct cci_aal_device        *m_sigtap;
+   struct CCIP_PORT_DFL_ERR      m_last_porterr;         // PORT last Error DFL
+   struct CCIP_PORT_STATUS       m_last_portstatus;         // PORRT Header
+
+
+}; // end struct port_device
+
+#define ccip_port_dev_pci_dev(pdev)          ((pdev)->m_pcidev)
+
+#define afu_dev_to_cci_dev(ptr)              cci_container_of(ptr, struct afu_device, m_afu, struct port_device)
+
+#define ccip_port_uafu_dev(pdev)              ((pdev)->m_uafu)
+#define ccip_port_hdr(pdev)                   ((pdev)->m_pport_hdr)
+#define ccip_port_err(pdev)                   ((pdev)->m_pport_err)
+#define ccip_port_umsg(pdev)                  ((pdev)->m_pport_umsg)
+#define ccip_port_pr(pdev)                    ((pdev)->m_pport_pr)
+#define ccip_port_stap(pdev)                  ((pdev)->m_pport_stap)
+
+#define ccip_port_lasterr(pdev)               ((pdev)->m_last_porterr)
+#define ccip_port_laststatus(pdev)            ((pdev)->m_last_portstatus)
+
+
+#define ccip_port_bustype(pdev)               ((pdev)->m_bustype)
+#define ccip_port_busnum(pdev)                ((pdev)->m_busNum)
+#define ccip_port_devnum(pdev)                ((pdev)->m_devicenum)
+#define ccip_port_fcnnum(pdev)                ((pdev)->m_functnum)
+#define ccip_port_socketnum(pdev)             ((pdev)->m_socketnum)
+#define ccip_port_subdevnum(pdev)             ((pdev)->m_subdevnum)
+
+
+#define ccip_port_mem_sessionp(pdev)          ((pdev)->m_pmem_session)
+
+#define ccip_port_kvp_mmio(pdev)              ((pdev)->m_kvp_port_mmio)
+#define ccip_port_phys_mmio(pdev)             ((pdev)->m_phys_port_mmio)
+#define ccip_port_mmio_len(pdev)              ((pdev)->m_port_mmio_len)
+
+#define ccip_port_to_ccidev(pdev)             ((pdev)->m_ccipdev)
+
+#define ccip_port_list_head(pdev)             ((pdev)->m_list)
+#define cci_list_to_cci_port_device(plist)     kosal_list_entry(plist, struct port_device, m_list)
+
+
+#define aaldev_to_ccip_port_device(plist)         kosal_list_entry(plist, struct port_device, m_list)
+#define ccip_port_to_PIPsessionp(pdev)        ((pdev)->m_pPIPSession)
+#define ccip_port_psem(pdev)                  (&(pdev)->m_sem)
+
+#define ccip_port_dev_fme(pdev)               ((pdev)->m_fme)
+#define ccip_port_stap_dev(pdev)              ((pdev)->m_sigtap)
+
+/// @brief creates a Port Device
+///
+/// @param[in] pphys_port_mmio port mmio physical address
+/// @param[in] pkvp_port_mmio port mmio virtual address
+/// @return    port_device code
+struct port_device  *get_port_device(  btPhysAddr pphys_port_mmio,
+                                       btVirtAddr pkvp_port_mmio,
+                                       btWSSize   port_mmio_len);
+
+/// @brief  destroys a Port Device
+///
+/// @param[in] pkvp_port_mmio port mmio virtual address
+/// @return    port_device code
+void destroy_port_device( struct port_device  *);
+
+
+/// @brief   reads PORT Header
+///
+/// @param[in] pport_dev port device pointer.
+/// @param[in] pkvp_port_mmio port mmio virtual address
+/// @return    error code
+struct CCIP_PORT_HDR * get_port_header( btVirtAddr );
+
+/// @brief   reads PORT feature list
+///
+/// @param[in] pport_dev port device pointer.
+/// @param[in] pkvp_port_mmio port mmio virtual address
+/// @return    error code
+bt32bitInt get_port_featurelist(struct port_device *,btVirtAddr );
+
+btBool get_port_feature( struct port_device *,
+                             btUnsigned64bitInt ,
+                             btPhysAddr *,
+                             btVirtAddr *);
+
+/// @brief   get port error
+///
+/// @param[in] pport_dev port device pointer.
+/// @param[in] pport_error ccip error structure  pointer
+/// @return    error code
+bt32bitInt get_port_error(struct port_device* pport_dev,
+                          struct CCIP_ERROR*  pport_error);
+
+extern struct aal_ipip cci_Portpip;
+extern struct aal_ipip cci_AFUpip;
+
+extern bt32bitInt port_afu_Enable(struct port_device *);
+extern bt32bitInt port_afu_reset(struct port_device *);
+extern bt32bitInt port_afu_quiesce_and_halt(struct port_device *);
+
+END_NAMESPACE(AAL)
+
+#endif /* __AALKERNEL_CCIP_PORT_DEF_H_ */
diff --git a/drivers/fpga/aal/cci/ccip_pr.c b/drivers/fpga/aal/cci/ccip_pr.c
new file mode 100644
index 000000000000..1ad24bd0127a
--- /dev/null
+++ b/drivers/fpga/aal/cci/ccip_pr.c
@@ -0,0 +1,2639 @@
+//******************************************************************************
+// This  file  is  provided  under  a  dual BSD/GPLv2  license.  When using or
+//         redistributing this file, you may do so under either license.
+//
+//                            GPL LICENSE SUMMARY
+//
+//  Copyright(c) 2015-2017, Intel Corporation.
+//
+//  This program  is  free software;  you  can redistribute it  and/or  modify
+//  it  under  the  terms of  version 2 of  the GNU General Public License  as
+//  published by the Free Software Foundation.
+//
+//  This  program  is distributed  in the  hope that it  will  be useful,  but
+//  WITHOUT   ANY   WARRANTY;   without   even  the   implied   warranty    of
+//  MERCHANTABILITY  or  FITNESS  FOR  A  PARTICULAR  PURPOSE.  See  the   GNU
+//  General Public License for more details.
+//
+//  The  full  GNU  General Public License is  included in  this  distribution
+//  in the file called README.GPLV2-LICENSE.TXT.
+//
+//  Contact Information:
+//  Henry Mitchel, henry.mitchel at intel.com
+//  77 Reed Rd., Hudson, MA  01749
+//
+//                                BSD LICENSE
+//
+//  Copyright(c) 2015-2017, Intel Corporation.
+//
+//  Redistribution and  use  in source  and  binary  forms,  with  or  without
+//  modification,  are   permitted  provided  that  the  following  conditions
+//  are met:
+//
+//    * Redistributions  of  source  code  must  retain  the  above  copyright
+//      notice, this list of conditions and the following disclaimer.
+//    * Redistributions in  binary form  must  reproduce  the  above copyright
+//      notice,  this  list of  conditions  and  the  following disclaimer  in
+//      the   documentation   and/or   other   materials   provided  with  the
+//      distribution.
+//    * Neither   the  name   of  Intel  Corporation  nor  the  names  of  its
+//      contributors  may  be  used  to  endorse  or promote  products derived
+//      from this software without specific prior written permission.
+//
+//  THIS  SOFTWARE  IS  PROVIDED  BY  THE  COPYRIGHT HOLDERS  AND CONTRIBUTORS
+//  "AS IS"  AND  ANY  EXPRESS  OR  IMPLIED  WARRANTIES,  INCLUDING,  BUT  NOT
+//  LIMITED  TO, THE  IMPLIED WARRANTIES OF  MERCHANTABILITY  AND FITNESS  FOR
+//  A  PARTICULAR  PURPOSE  ARE  DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT
+//  OWNER OR CONTRIBUTORS BE LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,
+//  SPECIAL,  EXEMPLARY,  OR  CONSEQUENTIAL   DAMAGES  (INCLUDING,   BUT   NOT
+//  LIMITED  TO,  PROCUREMENT  OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF USE,
+//  DATA,  OR PROFITS;  OR BUSINESS INTERRUPTION)  HOWEVER  CAUSED  AND ON ANY
+//  THEORY  OF  LIABILITY,  WHETHER  IN  CONTRACT,  STRICT LIABILITY,  OR TORT
+//  (INCLUDING  NEGLIGENCE  OR OTHERWISE) ARISING  IN ANY WAY  OUT  OF THE USE
+//  OF  THIS  SOFTWARE, EVEN IF ADVISED  OF  THE  POSSIBILITY  OF SUCH DAMAGE.
+//******************************************************************************
+//****************************************************************************
+/// @file ccip_pr.c
+/// @brief  Definitions for ccip Partial Reconfiguration AAL device.
+/// @ingroup aalkernel_ccip
+/// @verbatim
+//        FILE: ccip_port_mmio.c
+//     CREATED: Nov 11, 2015
+//      AUTHOR:
+//
+// PURPOSE:   This file contains the implementation of the CCIP PR
+//             low-level function (i.e., Physical Interface Protocol driver).
+// HISTORY:
+// COMMENTS:
+// WHEN:          WHO:     WHAT:
+//****************************************************************************///
+#include "aalsdk/kernel/kosal.h"
+#define MODULE_FLAGS CCIPCIE_DBG_MOD
+
+#include "aalsdk/kernel/AALTransactionID_s.h"
+#include "aalsdk/kernel/aalbus-ipip.h"
+#include "aalsdk/kernel/ccip_defs.h"
+
+#include "aalsdk/kernel/ccipdriver.h"
+#include "ccipdrv-events.h"
+
+#include "ccip_port.h"
+#include "ccip_fme.h"
+#include "ccip_pr.h"
+#include "ccip_pwr.h"
+
+#include "cci_pcie_driver_PIPsession.h"
+
+#define BS_WRITE_CSR_LEN  4
+
+extern btUnsigned32bitInt sim;
+extern kosal_list_head g_device_list;
+extern kosal_semaphore g_dev_list_sem;
+
+
+extern struct cci_aal_device   *
+                       cci_create_AAL_UAFU_Device( struct port_device  *,
+                                                   btPhysAddr,
+                                                   struct CCIP_AFU_Header *,
+                                                   struct aal_device_id *);
+
+///////////////////////////////////////////////////////////////////////////////
+///////////////////////////////////////////////////////////////////////////////
+////////////////////                                     //////////////////////
+/////////////////           AAL SUPPORT FUNCTIONS          ////////////////////
+////////////////////                                     //////////////////////
+///////////////////////////////////////////////////////////////////////////////
+///////////////////////////////////////////////////////////////////////////////
+
+static int CommandHandler( struct aaldev_ownerSession *,
+                           struct aal_pipmessage*);
+extern int cci_mmap( struct aaldev_ownerSession *pownerSess,
+                     struct aal_wsid *wsidp,
+                     btAny os_specific );
+
+
+
+///=============================================================================
+/// Name: cci_PRpip
+/// @brief Physical Interface Protocol Interface for the PR AFU
+///              kernel based AFU engine.
+///=============================================================================
+struct aal_ipip cci_PRpip = {
+   .m_messageHandler = {
+      .sendMessage   = CommandHandler,       // Command Handler
+      .bindSession   = BindSession,          // Session binder
+      .unBindSession = UnbindSession,        // Session unbinder
+   },
+
+   .m_fops = {
+     .mmap = cci_mmap,
+   },
+
+   // Methods for binding and unbinding PIP to generic aal_device
+   //  Unused in this PIP
+   .binddevice    = NULL,      // Binds the PIP to the device
+   .unbinddevice  = NULL,      // Binds the PIP to the device
+};
+
+
+
+
+inline void GetCSR(btUnsigned64bitInt *ptr, bt32bitCSR *pcsrval){
+
+   volatile bt32bitCSR *p32 = (bt32bitCSR *)ptr;
+   *pcsrval = *p32;
+}
+
+inline void SetCSR(btUnsigned64bitInt *ptr, bt32bitCSR *csrval) {
+
+   volatile bt32bitCSR *p32 = (bt32bitCSR *)ptr;
+   *p32 = *csrval;
+}
+
+inline void Get64CSR(btUnsigned64bitInt *ptr, bt64bitCSR *pcsrval){
+
+   volatile bt64bitCSR *p64 = (bt64bitCSR *)ptr;
+   *pcsrval = *p64;
+}
+
+inline void Set64CSR(btUnsigned64bitInt *ptr, bt64bitCSR *csrval)
+{
+   volatile bt64bitCSR *p64 = (bt64bitCSR *)ptr;
+   *p64 = *csrval;
+}
+//=============================================================================
+// Name: program_afu
+// Description:
+// Interface: private
+// Returns: N/A
+// Inputs: none
+// Outputs: none.
+// Comments:
+//=============================================================================
+int program_afu( struct cci_aal_device *pdev,  btVirtAddr kptr, btWSSize len )
+{
+
+#if 0
+   struct cci_aal_device *pdev = kosal_get_object_containing( pwork,
+                                                              struct cci_aal_device,
+                                                              task_handler );
+#endif
+   struct fme_device *pfme_dev = cci_aaldev_pfme(pdev);
+   struct CCIP_FME_DFL_PR     *pr_dev = ccip_fme_pr(pfme_dev);
+   bt32bitCSR csr = 0;
+   btBool bPR_Ready = 0;
+
+   PDEBUG("kptr =%p", kptr);
+   PDEBUG("len =%d\n", (unsigned)len);
+
+   // Don't do anything under simulation
+   if(0 != sim){
+      PDEBUG("Simulated reprogram\n");
+      return 0;
+   }
+
+   // Program the AFU
+   // For BDX-P only FME initiated PR is supported. So, CSR_FME_PR_CONTROL[0] = 0
+   // ---------------------------------------------------------------------------
+
+
+  csr=0;
+  // WILL THIS WORK??
+  // pr_dev->ccip_fme_pr_control.pr_port_access = 1;
+
+  GetCSR(&pr_dev->ccip_fme_pr_control.csr, &csr);
+
+  csr &=0xFFFFFFFE;
+  PVERBOSE("Setting up PR access mode to FME initiated PR");
+  SetCSR(&pr_dev->ccip_fme_pr_control.csr, &csr);
+
+
+  // Step 1 - Check FME_PR_STATUS[27:24] == 4'h0
+  // -------------------------------------------
+  // Both Initially as well as after PR, HW updates PR status to this state
+  {
+
+
+     PVERBOSE("Waiting for PR Resource in HW to be initialized and ready");
+     do {
+        csr=0;
+        GetCSR(&pr_dev->ccip_fme_pr_status.csr,&csr);
+        bPR_Ready = ( (csr>>24 & 0xF) == 0x0 );
+     }
+     while(!bPR_Ready);
+     PVERBOSE("HW is ready for PR");
+  }
+
+
+  // Step 2 - Check FME_PR_STATUS[16] for any previous PR errors
+  // --------------------------------------------------------------
+  // FME_PR_STATUS[16] is PR PASS or FAIL bit. Different from SAS.
+  // FME_PR_STATUS[16] is RO from SW point of view.
+  // TODO : Update SAS
+  {
+     bt32bitCSR PR_Timeout_err = 0;
+     bt32bitCSR PR_FIFO_err = 0;
+     bt32bitCSR PR_IP_err = 0;
+     bt32bitCSR PR_bitstream_err = 0;
+     bt32bitCSR PR_CRC_err = 0;
+     bt32bitCSR PR_clear_status_err = 0;
+
+     csr=0;
+     PVERBOSE("Checking for errors in previous PR operation");
+     GetCSR(&pr_dev->ccip_fme_pr_status.csr,&csr);
+
+     // Step 3 - Clear FME_PR_ERROR[5:0] - if needed based on Step - 2
+     // -----------------------------------------------------------------
+     // Upon failure, FME_PR_ERROR[5:0] gives additional error info.
+     // FME_PR_ERROR[5:0] - All 6 bits are RW1CS - HW writes 1 upon error to set the bit. SW writes 1 to clear the bit
+     // Once All error bits set in FME_PR_ERROR[5:0] are cleared by SW, HW will clear FME_PR_STATUS[16]
+     // TODO: This step is different from SAS flow. Update SAS
+     // NOTE: Error Logging and propagation might change based on SKX RAS
+
+     if ((csr>>16 & 0x1) == 0x1){
+        csr=0;
+        PVERBOSE("Errors found: Collecting error info ...");
+        GetCSR(&pr_dev->ccip_fme_pr_err.csr,&csr);
+        PR_Timeout_err = csr;
+        PR_FIFO_err = csr >> 1;
+        PR_IP_err =  csr >> 2;
+        PR_bitstream_err = csr >> 3;
+        PR_CRC_err = csr >> 4;
+        PR_clear_status_err = csr >> 5;
+
+        if((PR_Timeout_err & 0x1) == 0x1) PVERBOSE("\tPR Timeout Error Detected");
+        if((PR_FIFO_err & 0x1) == 0x1)    PVERBOSE("\tPR FIFO Error Detected");
+        if((PR_IP_err & 0x1) == 0x1)   PVERBOSE("\tPR IP Error Detected");
+        if((PR_bitstream_err & 0x1) == 0x1) PVERBOSE("\tPR incompatible bitstream Error Detected");
+        if((PR_CRC_err & 0x1) == 0x1) PVERBOSE("\tPR CRC Error Detected");
+        if((PR_clear_status_err & 0x1) == 0x1)  PVERBOSE("\tPrevious PR clean-up Error Detected");
+
+        // Clearing all Errors
+        csr |= 0x0000003F;
+        SetCSR(&pr_dev->ccip_fme_pr_err.csr,&csr);
+        PVERBOSE("Previous PR errors cleared");
+     }else{
+        PVERBOSE("No previous PR errors Detected");
+     }
+
+     // Step 4 - Write PR Region ID to FME_PR_CONTROL[9:8]
+     // --------------------------------------------------
+     // NOTE: For BDX-P only 1 AFU is supported in HW. So, CSR_FME_PR_CONTROL[9:8] should always be 0
+     // This will change for SKX
+
+     csr=0;
+     GetCSR(&pr_dev->ccip_fme_pr_control.csr, &csr);
+     csr &=0xFFFFFCFF;
+     PVERBOSE("Writing PR region ID = 0");
+     SetCSR(&pr_dev->ccip_fme_pr_control.csr, &csr);
+
+     // TODO: SW Driver is expected to hold the Port undergoing PR in Reset before initiating PR.
+     // SW has to bring back the port out of reset after successful PR and discover the AFU behind that PORT
+     // Ignored here
+
+     // Step 5 - Initiate PR - Write 1 to FME_PR_CONTROL[12]
+     // ---------------------------------------------------
+     // SW can only initiate PR. HW will auto clear this bit upon failure or success or timeout
+     PDEBUG("Initiate PR");
+     csr=0;
+     GetCSR(&pr_dev->ccip_fme_pr_control.csr, &csr);
+     csr |=0x00001000;
+    
+     SetCSR(&pr_dev->ccip_fme_pr_control.csr, &csr);
+
+
+     // Sanity check - Make sure that PR request from SW has reached HW
+     // ---------------------------------------------------------------
+     // Strictly speaking, the following step is neither required nor has any impact from HW point of view.
+     // But if no SW requests are reaching the HW, there is no way for the HW to notify the SW and might result in false PR PASS info in SW.
+     // So, Read the PR Start bit (FME_PR_CONTROL[12]) after writing to it and make sure that it is set.
+     // Once this bit is set, HW will make sure that it returns PR PASS / PR FAIL / PR timeout and notify the SW
+
+     csr=0;
+     GetCSR(&pr_dev->ccip_fme_pr_control.csr, &csr);
+     if ((csr >> 12 & 0x1) != 0x1)
+     {
+        PVERBOSE("PR requests from SW did not reach HW. Try again..");
+        return 1;
+     }
+
+     // Step 6 - Check available credits: FME_PR_STATUS[8:0] for PR data push and push Data to FME_PR_DATA[31:0]
+     // -------------------------------------------------------------------------------------------------------
+     // For instance,
+     // if FME_PR_STATUS[8:0] read yields 511, SW can perform 511 32-bit writes from rbf file to FME_PR_DATA[31:0] and check credits again
+     {
+        bt32bitCSR PR_FIFO_credits = 0;
+        btUnsigned32bitInt  *byteRead = (btUnsigned32bitInt  *)kptr;
+        csr=0;
+        GetCSR(&pr_dev->ccip_fme_pr_status.csr, &csr);
+        PR_FIFO_credits = csr & 0x000001FF;
+
+        PDEBUG("Pushing Data from rbf to HW \n");
+
+
+        while(len >0) {
+             if (PR_FIFO_credits <= 1)
+             {
+               do {
+               csr = 0;
+               PR_FIFO_credits = 0;
+               GetCSR(&pr_dev->ccip_fme_pr_status.csr, &csr);
+               PR_FIFO_credits = csr & 0x000001FF;
+               }
+               while (PR_FIFO_credits <=1);
+             }
+
+             SetCSR(&pr_dev->ccip_fme_pr_data.csr, byteRead);
+             PR_FIFO_credits --;
+             byteRead++;
+             len -= 4;
+        }
+     }
+     // Step 7 - Notify the HW that bitstream push is complete
+     // ------------------------------------------------------
+     // Write 1 to CSR_FME_PR_CONTROL[13]. This bit is RW1S. SW writes 1 to set this bit.
+     // Hardware will auto clear this bit upon PR completion
+     // TODO: This step is currently not defined in SAS. Update SAS
+
+     csr=0;
+     GetCSR(&pr_dev->ccip_fme_pr_control.csr, &csr);
+     csr |=0x00002000;
+     SetCSR(&pr_dev->ccip_fme_pr_control.csr, &csr);
+
+     PVERBOSE("Green bitstream push complete \n");
+
+     // Step 8 - Once all data is pushed from rbf file, wait for PR completion
+     // ----------------------------------------------------------------------
+     // Check FME_PR_CONTROL[12] == 0.
+     // Note: PR status bits are valid only when FME_PR_CONTROL[12] == 0.
+     // FME_PR_CONTROL[12] is an atomic status check bit for initiating PR and also checking for PR completion
+     // This bit set to 0 essentially means that HW has released the PR resource either due to PR PASS or PR FAIL.
+
+     PVERBOSE("Waiting for HW to release PR resource");
+     kosal_mdelay(10);        // Workaround for potential HW timing issue
+     bPR_Ready = 0;
+     do {
+     csr=0;
+     GetCSR(&pr_dev->ccip_fme_pr_control.csr, &csr);
+     bPR_Ready = ( (csr>>12 & 0x1) == 0x0);
+     }
+     while(!bPR_Ready);
+     PVERBOSE("PR operation complete, checking Status ...");
+
+     // Step 9 - Check PR PASS / FAIL
+     // -----------------------------
+     // Read the FME_PR_STATUS[16] to check PR success / fail
+     // FME_PR_STATUS[16] = 0 implies PR Passed
+     // FME_PR_STATUS[16] = 1 implies PR Failed. Read FME_PR_ERROR for more info upon failure
+     // TODO: This step is different from SAS. Update SAS
+     // NOTE: Error Register updating/ clearing may change based on SKX RAS requirement
+
+     csr=0;
+     GetCSR(&pr_dev->ccip_fme_pr_status.csr, &csr);
+
+     if (csr >> 16)
+     {
+        PVERBOSE("PR FAILED with following Errors:");
+        csr=0;
+        GetCSR(&pr_dev->ccip_fme_pr_err.csr,&csr);
+        PR_Timeout_err = csr;
+        PR_FIFO_err = csr >> 1;
+        PR_IP_err =  csr >> 2;
+        PR_bitstream_err = csr >> 3;
+        PR_CRC_err = csr >> 4;
+        PR_clear_status_err = csr >> 5;
+
+        if((PR_Timeout_err & 0x1) == 0x1) PVERBOSE("\tPR Timeout Error Detected");
+        if((PR_FIFO_err & 0x1) == 0x1) PVERBOSE("\tPR FIFO Error Detected");
+        if((PR_IP_err & 0x1) == 0x1) PVERBOSE("\tPR Engine Error Detected");
+        if((PR_bitstream_err & 0x1) == 0x1) PVERBOSE("\tPR incompatible bitstream Error Detected");
+        if((PR_CRC_err & 0x1) == 0x1) PVERBOSE("\tPR CRC Error Detected");
+        if((PR_clear_status_err & 0x1) == 0x1) PVERBOSE("\tPR Engine clean-up Error Detected");
+     }
+
+     else
+     {
+        PVERBOSE("PR PASSED\n");
+     }
+
+  }
+  return 0;
+}
+
+
+
+///============================================================================
+/// Name: ccipdrv_event_afu_aysnc_pr_release_send
+/// @brief sends event to application
+///
+/// @param[in] pr_context - pr program context
+/// @param[in] pr_context - pr program context
+/// @param[in] respID - pr response ID
+/// @param[in] devhandle - device handle
+/// @param[in] tranID -  transaction  ID
+/// @param[in] context -  application context
+/// @param[in] eno - pr error
+/// @return    void
+///============================================================================
+void ccipdrv_event_afu_aysnc_pr_release_send(struct pr_program_context *ppr_program_ctx,
+                                             uid_errnum_e  eno)
+{
+   struct ccipdrv_event_afu_response_event *pafuws_evt      = NULL;
+   PTRACEIN;
+   // return if PR program context is NULL
+   ASSERT(NULL != ppr_program_ctx);
+   if(NULL == ppr_program_ctx) {
+      return ;
+   }
+
+#ifdef PWRMGR
+   //PR failed, Movning Idle cores to online
+   if ((ppr_program_ctx->m_cmd == ccipdrv_configureAFU) &&
+      (uid_errnumOK != eno)) {
+      send_pr_power_event(ppr_program_ctx, 0);
+   }
+#endif
+
+   pafuws_evt = ccipdrv_event_afu_aysnc_pr_release_create( ppr_program_ctx->m_respID,
+                                                           ppr_program_ctx->m_pownerSess->m_device,
+                                                           ppr_program_ctx->m_pownerSess->m_ownerContext,
+                                                           eno);
+
+   ccidrv_sendevent(ppr_program_ctx->m_pownerSess,
+                    AALQIP(pafuws_evt));
+
+ 
+   if((ppr_program_ctx->m_cmd == ccipdrv_configureAFU) &&
+        (NULL != ppr_program_ctx->m_kbufferptr)) {
+        kosal_free_user_buffer(ppr_program_ctx->m_kbufferptr, ppr_program_ctx->m_bufferlen);
+        ppr_program_ctx->m_kbufferptr = NULL;
+     }
+
+
+   kosal_sem_put(cci_dev_pr_sem(ppr_program_ctx->m_pPR_dev));
+   PDEBUG("UN-LOCK RECONF \n");
+
+   if(NULL != ppr_program_ctx){
+      PDEBUG(" Free PR PRogram context \n");
+      kosal_kfree(ppr_program_ctx, sizeof(struct pr_program_context));
+   }
+
+   PTRACEOUT;
+}
+
+///============================================================================
+/// Name: ccipdrv_event_reconfig_event_create_send
+/// @brief sends event to application
+///
+/// @param[in] pr_context - pr program context
+/// @param[in] respID - pr response ID
+/// @param[in] devhandle - device handle
+/// @param[in] tranID -  transaction  ID
+/// @param[in] context -  application context
+/// @param[in] eno - pr error
+/// @return    void
+///============================================================================
+void ccipdrv_event_reconfig_event_create_send( struct pr_program_context *ppr_program_ctx,
+                                               uid_afurespID_e            respID,
+                                               btObjectType               devhandle,
+                                               stTransactionID_t          *tranID,
+                                               btObjectType               context,
+                                               uid_errnum_e               errnum)
+{
+   struct ccipdrv_event_afu_response_event *pafuws_evt      = NULL;
+   PTRACEIN;
+   // return if PR program context is NULL
+   ASSERT(NULL != ppr_program_ctx);
+   if(NULL == ppr_program_ctx) {
+      return ;
+   }
+
+#ifdef PWRMGR
+   //PR failed, Movning Idle cores to online
+   if ((ppr_program_ctx->m_cmd == ccipdrv_configureAFU) &&
+      (uid_errnumOK != errnum)) {
+      send_pr_power_event(ppr_program_ctx, 0);
+   }
+#endif
+
+   pafuws_evt = ccipdrv_event_reconfig_event_create(respID,
+                                                    devhandle,
+                                                    tranID,
+                                                    context,
+                                                    errnum);
+
+   ccidrv_sendevent(ppr_program_ctx->m_pownerSess,
+                    AALQIP(pafuws_evt));
+
+
+   if(NULL!= ppr_program_ctx->m_kbufferptr ) {
+      kosal_free_user_buffer(ppr_program_ctx->m_kbufferptr, ppr_program_ctx->m_bufferlen);
+   }
+
+   kosal_sem_put(cci_dev_pr_sem(ppr_program_ctx->m_pPR_dev));
+   PDEBUG("UN-LOCK RECONF \n");
+
+   if(NULL != ppr_program_ctx){
+      kosal_kfree(ppr_program_ctx, sizeof(struct pr_program_context));
+   }
+   PTRACEOUT;
+}
+
+///============================================================================
+/// Name: prprogram_ctx_free
+/// @brief frees PR program contxt
+///
+/// @param[in] pr_context - pr program context
+/// @return    void
+///============================================================================
+void prprogram_ctx_free( struct pr_program_context *ppr_program_ctx)
+{
+
+   PTRACEIN;
+
+   if( NULL == ppr_program_ctx) {
+      return ;
+   }
+
+   if(NULL!= ppr_program_ctx->m_kbufferptr ) {
+      kosal_free_user_buffer(ppr_program_ctx->m_kbufferptr, ppr_program_ctx->m_bufferlen);
+   }
+
+   kosal_sem_put(cci_dev_pr_sem(ppr_program_ctx->m_pPR_dev));
+   PDEBUG("UN-LOCK RECONF \n");
+
+   if(NULL != ppr_program_ctx){
+      kosal_kfree(ppr_program_ctx, sizeof(struct pr_program_context));
+   }
+   PTRACEOUT;
+}
+
+///============================================================================
+/// Name: ccipdrv_event_activationchange_event_create_send
+/// @brief sends event to application
+///
+/// @param[in] pr_context - pr program context
+/// @param[in] respID - pr response ID
+/// @param[in] devhandle - device handle
+/// @param[in] tranID -  transaction  ID
+/// @param[in] context -  application context
+/// @param[in] eno - pr error
+/// @return    void
+///============================================================================
+void  ccipdrv_event_activationchange_event_create_send( struct pr_program_context *ppr_program_ctx,
+                                                        uid_afurespID_e            respID,
+                                                        btObjectType               devhandle,
+                                                        stTransactionID_t          *tranID,
+                                                        btObjectType               context,
+                                                        uid_errnum_e               errnum)
+{
+
+   struct ccipdrv_event_afu_response_event *pafuws_evt      = NULL;
+   PTRACEIN;
+   // return if PR program context is NULL
+   ASSERT(NULL != ppr_program_ctx);
+   if(NULL == ppr_program_ctx) {
+      return ;
+   }
+
+   pafuws_evt = ccipdrv_event_activationchange_event_create(respID,
+                                                            devhandle,
+                                                            tranID,
+                                                            context,
+                                                            errnum);
+
+   ccidrv_sendevent(ppr_program_ctx->m_pownerSess,
+                    AALQIP(pafuws_evt));
+
+   kosal_sem_put(cci_dev_pr_sem(ppr_program_ctx->m_pPR_dev));
+   PDEBUG("UN-LOCK RECONF \n");
+
+   if(NULL != ppr_program_ctx){
+      kosal_kfree(ppr_program_ctx, sizeof(struct pr_program_context));
+   }
+   PTRACEOUT;
+}
+
+///============================================================================
+/// Name: program_afu_callback
+/// @brief Reconfigures  AFU with bitstream
+///
+///
+/// @param[in] pr_context - pr program context
+/// @return    void
+///============================================================================
+void program_afu_callback(struct kosal_work_object * pwork)
+{
+   btVirtAddr   kptr                         = NULL;
+   btWSSize   len                             = 0;
+   btUnsigned64bitInt   PR_FIFO_credits       = 0;
+   btUnsigned32bitInt   *byteRead             = NULL;
+   uid_errnum_e   errnum                      = uid_errnumOK;
+   btUnsigned64bitInt   counter               = 0;
+   struct fme_device   *pfme_dev              = NULL;
+   struct CCIP_FME_DFL_PR   *pr_dev           = NULL;
+   struct pr_program_context *ppr_program_ctx = NULL;
+
+   struct CCIP_FME_PR_CONTROL pr_control_local;
+   struct CCIP_FME_PR_STATUS  pr_status_local;
+   struct CCIP_FME_PR_ERROR  pr_err_local;
+   ktime_t timeout;
+
+
+   PTRACEIN;
+
+   ppr_program_ctx = (struct pr_program_context*) kosal_get_object_containing( pwork, struct pr_program_context, m_workobject );
+
+   if(NULL == ppr_program_ctx) {
+      PERR("Invalid PR Context\n");
+      return ;
+   }
+
+   pfme_dev = cci_aaldev_pfme(ppr_program_ctx->m_pPR_dev);
+   pr_dev   = ccip_fme_pr(pfme_dev);
+
+   kptr = ppr_program_ctx->m_kbufferptr;
+   len  = ppr_program_ctx->m_bufferlen;
+
+#ifdef PWRMGR
+    // Check Boundrys of bitstrem buffer TBD
+    kptr = kptr + sizeof(struct CCIP_GBS_HEADER);
+    len  = len - sizeof(struct CCIP_GBS_HEADER);
+#endif
+
+   PDEBUG("kptr =%p", kptr);
+   PDEBUG("len =%d\n", (unsigned)len);
+   PDEBUG("prregion_id =%d\n",ppr_program_ctx->m_prregion_id);
+
+   // Don't do anything under simulation
+   if(0 != sim){
+
+      PDEBUG("Simulated reprogram \n");
+
+      if(!ppr_program_ctx->m_leaveDeactivated){
+         reconfigure_activateAFU(ppr_program_ctx->m_pportdev,ppr_program_ctx->m_pPR_dev);
+      }
+
+      ccipdrv_event_afu_aysnc_pr_release_send(ppr_program_ctx,uid_errnumOK);
+      return ;
+   }
+   
+   // if BBS PR DFH revision is not 1 return InCompatiable bitstream error
+   if (0x1 != pr_dev->ccip_pr_dflhdr.Feature_rev) {
+   
+    PERR(" PR InCompatiable BBS bitstream \n");
+    errnum = uid_errnumIncompatibleBlueBitstream;
+    goto ERR;
+   }
+
+   // Program the AFU
+   // Reset PR Engine CSR_FME_PR_CONTROL[0] = 0x1 before Initiating PR
+   // ---------------------------------------------------------------------------
+   PVERBOSE("Resetting PR before initiated PR \n");
+   Get64CSR(&pr_dev->ccip_fme_pr_control.csr,&pr_control_local.csr);
+
+   //CSR_FME_PR_CONTROL[0] = 0x1 and wait for reset ack bit set CSR_FME_PR_CONTROL[4]
+   pr_control_local.pr_reset = 0x1;
+   Set64CSR(&pr_dev->ccip_fme_pr_control.csr,&pr_control_local.csr);
+
+   timeout = ktime_add_us(ktime_get(), PR_OUTSTADREQ_TIMEOUT);
+
+   do {
+      // Sleep
+      usleep_range((PR_OUTSTADREQ_DELAY >> 4) + 1, PR_OUTSTADREQ_DELAY);
+      Get64CSR(&pr_dev->ccip_fme_pr_control.csr,&pr_control_local.csr);
+
+      // if total delay is more then PR_OUTSTADREQ_TIMEOUT, returns  Timeout error
+      if (ktime_compare(ktime_get(), timeout) > 0) {
+          PERR("PR Reset Timeout Error  \n");
+          errnum=uid_errnumPRTimeout;
+          goto ERR;
+      }
+
+   } while( 0x1 != pr_control_local.pr_reset_ack);
+
+   // Clear reset reset bit
+   pr_control_local.pr_reset = 0x0;
+   Set64CSR(&pr_dev->ccip_fme_pr_control.csr,&pr_control_local.csr);
+  
+  
+   // Step 1 - Check FME_PR_STATUS[27:24] == 4'h0
+   // -------------------------------------------
+   // Both Initially as well as after PR, HW updates PR status to this state
+   PVERBOSE("Waiting for PR Resource in HW to be initialized and ready \n");
+
+   timeout = ktime_add_us(ktime_get(), PR_OUTSTADREQ_TIMEOUT);
+   do {
+      // Sleep
+      usleep_range((PR_OUTSTADREQ_DELAY >> 4) + 1, PR_OUTSTADREQ_DELAY);
+      Get64CSR(&pr_dev->ccip_fme_pr_status.csr,&pr_status_local.csr);
+
+      // if total delay is more then PR_OUTSTADREQ_TIMEOUT, returns  Timeout error
+      if (ktime_compare(ktime_get(), timeout) > 0) {
+          PERR("PR Status Timeout Error  \n");
+          errnum=uid_errnumPRTimeout;
+          goto ERR;
+      }
+
+   } while( CCIP_PORT_PR_Idle != pr_status_local.pr_host_status);
+
+   PVERBOSE("HW is ready for PR \n");
+
+   Get64CSR(&pr_dev->ccip_fme_pr_status.csr,&pr_status_local.csr);
+   // Step 2 - Check FME_PR_STATUS[16] for any previous PR errors
+   // --------------------------------------------------------------
+   // FME_PR_STATUS[16] is PR PASS or FAIL bit. Different from SAS.
+   // FME_PR_STATUS[16] is RO from SW point of view.
+   PVERBOSE("Checking for errors in previous PR operation");
+
+   if(0x1 == pr_status_local.pr_status)  {
+
+      // Step 3 - Clear FME_PR_ERROR[5:0] - if needed based on Step - 2
+      // -----------------------------------------------------------------
+      // Upon failure, FME_PR_ERROR[5:0] gives additional error info.
+      // FME_PR_ERROR[5:0] - All 6 bits are RW1CS - HW writes 1 upon error to set the bit. SW writes 1 to clear the bit
+      // Once All error bits set in FME_PR_ERROR[5:0] are cleared by SW, HW will clear FME_PR_STATUS[16]
+      // TODO: This step is different from SAS flow. Update SAS
+      // NOTE: Error Logging and propagation might change based on SKX RAS
+
+      Get64CSR(&pr_dev->ccip_fme_pr_err.csr,&pr_err_local.csr);
+
+      if(0x1 == pr_err_local.PR_operation_err ) {
+         pr_err_local.PR_operation_err =0x1;
+         PERR(" PR Previous PR Operation Error  Detected \n");
+      }
+
+      if(0x1 == pr_err_local.PR_CRC_err ) {
+         pr_err_local.PR_CRC_err =0x1;
+         PERR(" PR Previous CRC Error Detected \n");
+      }
+
+      if(0x1 == pr_err_local.PR_bitstream_err ) {
+         pr_err_local.PR_bitstream_err =0x1;
+         PERR(" PR Previous InCompatiable bitstream Error  Detected \n");
+      }
+
+      if(0x1 == pr_err_local.PR_IP_err ) {
+         pr_err_local.PR_IP_err =0x1;
+         PERR(" PR Previous IP Protocol Error Detected \n");
+      }
+
+      if(0x1 == pr_err_local.PR_FIFIO_err ) {
+         pr_err_local.PR_FIFIO_err =0x1;
+         PERR(" PR  Previous FIFO Overflow Error Detected \n");
+      }
+
+      if(0x1 == pr_err_local.PR_timeout_err ) {
+         pr_err_local.PR_timeout_err =0x1;
+         PERR(" PR Previous Timeout  Error Detected \n");
+      }
+
+      if(0x1 == pr_err_local.PR_secure_load_err ) {
+         pr_err_local.PR_secure_load_err =0x1;
+         PERR(" PR Previous Secure Load  Error Detected \n");
+      }
+      PVERBOSE("Previous PR errors cleared \n ");
+
+      Set64CSR(&pr_dev->ccip_fme_pr_err.csr,&pr_err_local.csr);
+
+   } else
+   {
+      PVERBOSE("NO Previous PR errors \n ");
+   }
+
+
+ 
+   // Step 4 - Write PR Region ID to FME_PR_CONTROL[9:8]
+   // --------------------------------------------------
+   // NOTE: For BDX-P only 1 AFU is supported in HW. So, CSR_FME_PR_CONTROL[9:8] should always be 0
+   // This will change for SKX
+
+   Get64CSR(&pr_dev->ccip_fme_pr_control.csr,&pr_control_local.csr);
+
+   // set PR Region ID
+   pr_control_local.pr_regionid = 0x0;
+
+
+   // Step 5 - Initiate PR - Write 1 to FME_PR_CONTROL[12]
+   // ---------------------------------------------------
+   // SW can only initiate PR. HW will auto clear this bit upon failure or success or timeout
+   PDEBUG("Initiate PR");
+   // PR Start Request
+   pr_control_local.pr_start_req = 0x1;
+
+   Set64CSR(&pr_dev->ccip_fme_pr_control.csr,&pr_control_local.csr);
+
+   // Step 6 - Check available credits: FME_PR_STATUS[8:0] for PR data push and push Data to FME_PR_DATA[31:0]
+   // -------------------------------------------------------------------------------------------------------
+   // For instance,
+   // if FME_PR_STATUS[8:0] read yields 511, SW can perform 511 32-bit writes from rbf file to FME_PR_DATA[31:0] and check credits again
+
+   Get64CSR(&pr_dev->ccip_fme_pr_status.csr,&pr_status_local.csr);
+   PR_FIFO_credits = pr_status_local.pr_credit;
+   byteRead = (btUnsigned32bitInt  *)kptr;
+   PDEBUG("Pushing Data from rbf to HW \n");
+
+
+   while(len >0) {
+
+      if (PR_FIFO_credits <= 1)  {
+         do {
+
+             Get64CSR(&pr_dev->ccip_fme_pr_status.csr,&pr_status_local.csr);
+             PR_FIFO_credits = pr_status_local.pr_credit;
+
+             // counter increment
+             counter ++;
+
+             // if counter value is more then PR_COUNTER_MAX_TRY,returns Timeout error.
+             if (counter > PR_COUNTER_MAX_TRY)   {
+                PERR("PR FIFI Credits Timeout Error \n");
+                errnum=uid_errnumPRTimeout;
+                goto ERR;
+             }
+
+          } while (PR_FIFO_credits <=1);
+      }
+      counter =0;
+      // set 4 bytes bitstream
+      if(len >=4) {
+         SetCSR(&pr_dev->ccip_fme_pr_data.csr, byteRead);
+         PR_FIFO_credits --;
+         byteRead++;
+         len -= 4;
+      }else {
+         // set remaining bits
+         PERR(" Wrong Bitstream Size \n");
+         errnum = uid_errnumPROperation;
+         goto ERR;
+      }
+   } // end while
+
+   // Step 7 - Notify the HW that bitstream push is complete
+   // ------------------------------------------------------
+   // Write 1 to CSR_FME_PR_CONTROL[13]. This bit is RW1S. SW writes 1 to set this bit.
+   // Hardware will auto clear this bit upon PR completion
+   // TODO: This step is currently not defined in SAS. Update SAS
+
+   Get64CSR(&pr_dev->ccip_fme_pr_control.csr,&pr_control_local.csr);
+
+   pr_control_local.pr_push_complete = 0x1;
+
+   Set64CSR(&pr_dev->ccip_fme_pr_control.csr,&pr_control_local.csr);
+
+   PVERBOSE("Green bitstream push complete \n");
+
+   // Step 8 - Once all data is pushed from rbf file, wait for PR completion
+   // ----------------------------------------------------------------------
+   // Check FME_PR_CONTROL[12] == 0.
+   // Note: PR status bits are valid only when FME_PR_CONTROL[12] == 0.
+   // FME_PR_CONTROL[12] is an atomic status check bit for initiating PR and also checking for PR completion
+   // This bit set to 0 essentially means that HW has released the PR resource either due to PR PASS or PR FAIL.
+
+   PVERBOSE("Waiting for HW to release PR resource \n");
+
+   timeout = ktime_add_us(ktime_get(), PR_OUTSTADREQ_TIMEOUT);
+
+   do {
+      // Sleep
+      usleep_range((PR_OUTSTADREQ_DELAY >> 4) + 1, PR_OUTSTADREQ_DELAY);
+      Get64CSR(&pr_dev->ccip_fme_pr_control.csr,&pr_control_local.csr);
+
+      // if total delay is more then PR_OUTSTADREQ_TIMEOUT, returns  Timeout error
+      if (ktime_compare(ktime_get(), timeout) > 0) {
+          PERR("PR Completion Timeout Error  \n");
+          errnum=uid_errnumPRTimeout;
+          goto ERR;
+      }
+
+   } while(0x0 != pr_control_local.pr_start_req);
+
+   PVERBOSE("PR operation complete, checking Status \n");
+
+
+   // Step 9 - Check PR PASS / FAIL
+   // -----------------------------
+   // Read the FME_PR_STATUS[16] to check PR success / fail
+   // FME_PR_STATUS[16] = 0 implies PR Passed
+   // FME_PR_STATUS[16] = 1 implies PR Failed. Read FME_PR_ERROR for more info upon failure
+   // TODO: This step is different from SAS. Update SAS
+   // NOTE: Error Register updating/ clearing may change based on SKX RAS requirement
+
+   Get64CSR(&pr_dev->ccip_fme_pr_status.csr,&pr_status_local.csr);
+
+   if(0x1 == pr_status_local.pr_status)  {
+
+      Get64CSR(&pr_dev->ccip_fme_pr_err.csr,&pr_err_local.csr);
+
+      if(0x1 == pr_err_local.PR_operation_err ) {
+         PERR(" PR PR Operation Error  Detected \n");
+         errnum=uid_errnumPROperation;
+         goto ERR;
+      }
+
+      if(0x1 == pr_err_local.PR_CRC_err ) {
+         PERR(" PR CRC Error Detected \n");
+         errnum=uid_errnumPRCRC;
+         goto ERR;
+      }
+
+      if(0x1 == pr_err_local.PR_bitstream_err ) {
+         PERR(" PR Incomparable bitstream Error  Detected \n");
+         errnum=uid_errnumPRIncompatibleBitstream;
+         goto ERR;
+      }
+
+      if(0x1 == pr_err_local.PR_IP_err ) {
+         PERR(" PR IP Protocol Error Detected \n");
+         errnum=uid_errnumPRIPProtocal;
+         goto ERR;
+      }
+
+      if(0x1 == pr_err_local.PR_FIFIO_err ) {
+         PERR(" PR  FIFO Overflow Error Detected \n");
+         errnum=uid_errnumPRFIFO;
+         goto ERR;
+      }
+
+      if(0x1 == pr_err_local.PR_timeout_err ) {
+         PERR(" PR Timeout  Error Detected \n");
+         errnum=uid_errnumPRTimeout;
+         goto ERR;
+      }
+
+      if(0x1 == pr_err_local.PR_secure_load_err ) {
+         PERR(" PR Secure Load  Error Detected \n");
+         errnum=uid_errnumPRSecureLoad;
+         goto ERR;
+      }
+
+   } else  {
+
+      PVERBOSE("PR Done Successfully\n");
+   }
+
+   // No need to AFU ReActive
+   if( ppr_program_ctx->m_leaveDeactivated )   {
+
+      PVERBOSE( " Not Activated AFU \n");
+      ccipdrv_event_afu_aysnc_pr_release_send(ppr_program_ctx,uid_errnumOK);
+
+   } else if(reconfigure_activateAFU(ppr_program_ctx->m_pportdev,ppr_program_ctx->m_pPR_dev) ) {
+
+      PVERBOSE( " Activated AFU \n");
+      ccipdrv_event_afu_aysnc_pr_release_send(ppr_program_ctx,uid_errnumOK);
+
+   }
+   else
+   {
+      errnum=uid_errnumAFUActivationFail;
+      goto ERR;
+   }
+
+   PTRACEOUT;
+   return ;
+
+ ERR:
+
+   // PR Failed and send Error event to application
+   PVERBOSE( " PR Failed \n");
+   ccipdrv_event_afu_aysnc_pr_release_send(ppr_program_ctx,errnum);
+
+   PTRACEOUT;
+   return  ;
+}
+
+///============================================================================
+/// Name: reconfigure_activateAFU
+/// @brief Activates afu after reconfiguration
+///
+///
+/// @param[in] pportdev - Port device pointer
+/// @param[in] pdev - cci aal device pointer
+/// @return    AFU activate status
+///============================================================================
+btBool  reconfigure_activateAFU(struct port_device  *pportdev,struct cci_aal_device  *pdev )
+{
+
+    // Get the AFU header pointer by adding the offset to the port header address
+    struct cci_aal_device         *pcci_aaldev = NULL;
+    struct aal_device_id           aalid;
+    struct aal_device             *paaldevice = NULL;
+    struct CCIP_AFU_Header        *pafu_hdr = (struct CCIP_AFU_Header *)(((btVirtAddr)ccip_port_hdr(pportdev) ) + ccip_port_hdr(pportdev)->ccip_port_next_afu.afu_id_offset);
+    btPhysAddr                     pafu_phys = ccip_port_phys_mmio(pportdev) + ccip_port_hdr(pportdev)->ccip_port_next_afu.afu_id_offset;
+
+    PTRACEIN;
+
+    // Get the address of the PR. User AFU instance number always follows PR.
+    paaldevice = cci_aaldev_to_aaldev(pdev);
+    aalid = aaldev_devid(paaldevice);
+
+    // enable afu
+    port_afu_Enable(pportdev);
+    // If the device is present
+    if(~0ULL != pafu_hdr->ccip_dfh.csr){
+
+       aaldevid_devaddr_busnum(aalid) = ccip_port_busnum(pportdev);
+       aaldevid_devaddr_devnum(aalid) = ccip_port_devnum(pportdev);
+       aaldevid_devaddr_fcnnum(aalid) = ccip_port_fcnnum(pportdev);
+       aaldevid_devaddr_subdevnum(aalid) = ccip_port_subdevnum(pportdev);
+
+       // Instantiate it
+       aaldevid_devaddr_instanceNum(aalid)++;
+       pcci_aaldev = cci_create_AAL_UAFU_Device(  pportdev,
+                                                  pafu_phys,
+                                                  pafu_hdr,
+                                                 &aalid);
+       ASSERT(NULL != pcci_aaldev);
+
+       if(NULL == pcci_aaldev){
+          PDEBUG("ERROR: Creating User AFU device\n");
+          return false;     // TODO This is a BUG if we get here but should cleanup correctly.
+       }
+
+       // Add the device to the CCI Board device's device list
+       kosal_list_add( &cci_aaldev_list_head(pcci_aaldev), &ccip_aal_dev_list( ccip_port_to_ccidev(pportdev) ));
+
+    } // End if(~0ULL == pafu_hdr->ccip_dfh.csr){
+
+    PTRACEOUT;
+    return true;
+}
+
+
+///============================================================================
+/// Name: afu_request_release_sendevent
+/// @brief Sends Release event to Resource Owners
+///
+/// @param[in] pr_context -pr configuration context
+/// @return    void
+///============================================================================
+void afu_request_release_revoke_sendevent(void* pr_context, btBool releaseAFU)
+{
+   struct aal_device *pafu_aal_dev = NULL;
+   kosal_list_head *pitr           = NULL;
+   kosal_list_head *temp           = NULL;
+   struct aaldev_owner *pOwner     = NULL;
+
+   struct pr_program_context  *ppr_program_ctx          = NULL;
+   struct ccipdrv_event_afu_response_event *pafuws_evt  = NULL;
+
+   PTRACEIN;
+
+   ppr_program_ctx = (struct pr_program_context *)pr_context;
+   pafu_aal_dev = ppr_program_ctx->m_pAFU_dev->m_aaldev;
+
+
+   PVERBOSE( "AFU owners count= %d \n",pafu_aal_dev->m_numowners);
+
+   // Lock the list from any updates
+   if ( unlikely( kosal_sem_get_user_alertable(&pafu_aal_dev->m_sem) ) ) {
+      PDEBUG("kosal_sem_get_user_alertable interrupted \n");
+      return ;
+   }
+
+
+   // Send Release event to AFU owner application
+   if ( !kosal_list_is_empty(&pafu_aal_dev->m_ownerlist) )  {
+
+      // Loop through the list looking for a match
+      kosal_list_for_each_safe(pitr, temp, &pafu_aal_dev->m_ownerlist) {
+
+      // finds afu owner
+      pOwner = kosal_container_of(pitr, struct aaldev_owner, m_ownerlist);
+
+      PVERBOSE(  "AFU Owner pid= %d \n" , pOwner->m_pid);
+
+      if( true == releaseAFU) {
+
+      // Sends AFU Release Event to APP rspid_AFU_PR_Release_Request_Event
+      pafuws_evt =ccipdrv_event_afu_aysnc_pr_request_release_create( ppr_program_ctx->m_respID,
+                                                                     pOwner->m_sess.m_device,
+                                                                     pOwner->m_sess.m_ownerContext,
+                                                                     ppr_program_ctx->m_reconfAction,
+                                                                     ppr_program_ctx->m_reconfTimeout,
+                                                                     uid_errnumOK);
+      }  else {
+
+         pafuws_evt =ccipdrv_event_afu_aysnc_pr_revoke_create( ppr_program_ctx->m_respID,
+                                                               pOwner->m_sess.m_device,
+                                                               pOwner->m_sess.m_ownerContext,
+                                                               uid_errnumOK);
+
+      }
+      ccidrv_sendevent(&(pOwner->m_sess),
+                       AALQIP(pafuws_evt));
+      } // end list
+
+   }// endif
+
+    kosal_sem_put(&pafu_aal_dev->m_sem);
+
+   PTRACEOUT;
+   return;
+
+}
+
+///============================================================================
+/// Name: sigtap_revoke_sendevent
+/// @brief Sends Revoke event to Resource Owners
+///
+/// @param[in] pr_context -pr configuration context
+/// @return    void
+///============================================================================
+void sigtap_revoke_sendevent(void* pr_context)
+{
+   struct aal_device *psigtap_aal_dev = NULL;
+   kosal_list_head *pitr              = NULL;
+   kosal_list_head *temp              = NULL;
+   struct aaldev_owner *pOwner        = NULL;
+
+   struct pr_program_context  *ppr_program_ctx          = NULL;
+   struct ccipdrv_event_afu_response_event *pafuws_evt  = NULL;
+
+   PTRACEIN;
+
+   ppr_program_ctx = (struct pr_program_context *)pr_context;
+   psigtap_aal_dev = ccip_port_stap_dev(ppr_program_ctx->m_pportdev)->m_aaldev;
+
+   PVERBOSE( "sigtap_revoke_sendevent  owners count= %d \n",psigtap_aal_dev->m_numowners);
+
+
+   if ( unlikely( kosal_sem_get_user_alertable(&psigtap_aal_dev->m_sem) ) ) {
+      PDEBUG("kosal_sem_get_user_alertable interrupted \n");
+      return ;
+   }
+
+
+   // Send Release event to AFU owner application
+   if ( !kosal_list_is_empty(&psigtap_aal_dev->m_ownerlist) )  {
+
+      // Loop through the list looking for a match
+      kosal_list_for_each_safe(pitr, temp, &psigtap_aal_dev->m_ownerlist) {
+
+      // finds afu owner
+      pOwner = kosal_container_of(pitr, struct aaldev_owner, m_ownerlist);
+
+      PVERBOSE(  "AFU Owner pid= %d \n" , pOwner->m_pid);
+
+      // Sends AFU Release Event to APP rspid_AFU_PR_Release_Request_Event
+
+      pafuws_evt = ccipdrv_event_afu_aysnc_pr_revoke_create( ppr_program_ctx->m_respID,
+                                                             pOwner->m_sess.m_device,
+                                                             pOwner->m_sess.m_ownerContext,
+                                                             uid_errnumOK);
+      ccidrv_sendevent(&(pOwner->m_sess),
+                       AALQIP(pafuws_evt));
+      } // end list
+
+   }// endif
+
+   kosal_sem_put(&psigtap_aal_dev->m_sem);
+
+   PTRACEOUT;
+   return;
+
+}
+///============================================================================
+/// Name: deactiavted_afu_device
+/// @brief unpublish and deactivates AFU
+///
+/// @param[in] pportdev -port device pointer
+/// @return    void
+///============================================================================
+void deactiavted_afu_device(struct port_device  *pportdev)
+{
+   PTRACEIN;
+
+   port_afu_quiesce_and_halt(pportdev);
+   cci_unpublish_aaldevice(ccip_port_uafu_dev(pportdev));
+   cci_destroy_aal_device( ccip_port_uafu_dev(pportdev) );
+   ccip_port_uafu_dev(pportdev) = NULL;
+
+   PTRACEOUT;
+}
+
+
+///============================================================================
+/// Name: afu_revoke_callback
+/// @brief Revokes AFU from applications
+///
+/// @param[in] pr_context -pr configuration context
+/// @param[in] ptr - null pointer.
+/// @return    void
+///============================================================================
+void afu_revoke_callback(struct kosal_work_object *pwork)
+{
+   struct aal_device   *pafu_aal_dev                   = NULL;
+   struct pr_program_context  *ppr_program_ctx         = NULL;
+
+   PTRACEIN;
+   ppr_program_ctx = (struct pr_program_context*) kosal_get_object_containing( pwork, struct pr_program_context, m_workobject );
+
+   if(NULL == ppr_program_ctx) {
+      PERR("Invalid PR Context\n");
+      return ;
+   }
+
+   if( 0 == ppr_program_ctx->m_pPR_dev->m_aaldev->m_numowners) {
+      PVERBOSE(" No PR ALLDevice owners  \n" );
+      prprogram_ctx_free(ppr_program_ctx);
+      return ;
+   }
+
+   pafu_aal_dev = ppr_program_ctx->m_pAFU_dev->m_aaldev;
+
+   // AFU has no owner (AFU revoked from application),Deactivate and Reconfigure AFU.
+   if( 0 == pafu_aal_dev->m_numowners) {
+      deactiavted_afu_device(ppr_program_ctx->m_pportdev);
+
+      if(ppr_program_ctx->m_cmd == ccipdrv_configureAFU) {
+
+         program_afu_callback(&(ppr_program_ctx->m_workobject));
+         PTRACEOUT;
+         return;
+      }
+
+      ccipdrv_event_afu_aysnc_pr_release_send(ppr_program_ctx,uid_errnumOK);
+
+   } else if (ppr_program_ctx->m_afuRevokeCount < PR_AFU_REVOKE_MAX_TRY) {
+      // App Failed to release Resource with in timeout, try again.
+      ppr_program_ctx->m_afuRevokeCount ++;
+
+      KOSAL_INIT_WORK(&(ppr_program_ctx->m_workobject),afu_revoke_callback);
+      kosal_queue_delayed_work(cci_aaldev_workq_reconf(ppr_program_ctx->m_pPR_dev),
+                               &(ppr_program_ctx->m_workobject),
+                               PR_WQ_REVOKE_TIMEOUT);
+
+   } else {
+      PERR(" AFU Revoke Fail revoke_count=%lld  \n",ppr_program_ctx->m_afuRevokeCount );
+      goto ERR;
+   }
+
+   PTRACEOUT;
+   return ;
+ERR:
+
+   PVERBOSE(" AFU  Revoke Fail  \n" );
+   ccipdrv_event_afu_aysnc_pr_release_send(ppr_program_ctx,uid_errnumSigtapRevokeTimeout);
+
+   PTRACEOUT;
+   return;
+}
+
+///============================================================================
+/// Name: pwrmgr_timeout_callback
+/// @brief Power manager  timeout callback
+///
+/// @param[in] pr_context -pr configuration context
+/// @return    void
+///============================================================================
+void pwrmgr_timeout_callback(struct kosal_work_object * pwork)
+{
+   struct pr_program_context  *ppr_program_ctx  = NULL;
+   PTRACEIN;
+
+   ppr_program_ctx = (struct pr_program_context*) kosal_get_object_containing( pwork, struct pr_program_context, m_workobject );
+
+   if(NULL == ppr_program_ctx) {
+      PERR("Invalid PR Context\n");
+      return ;
+   }
+
+   if( 0 == ppr_program_ctx->m_pPR_dev->m_aaldev->m_numowners) {
+      PVERBOSE(" No PR ALLDevice owners  \n" );
+      prprogram_ctx_free(ppr_program_ctx);
+      return ;
+   }
+
+   cci_aaldev_pfme(ppr_program_ctx->m_pPR_dev)->m_pr_program_context = NULL;
+
+   ccipdrv_event_afu_aysnc_pr_release_send(ppr_program_ctx,uid_errnumPRPowerMgrTimeout);
+
+   PTRACEOUT;
+
+}
+
+///============================================================================
+/// Name: reconfigure_bitstream_cancelPwrmgrTimer
+/// @brief Core Idle is done Start PR
+///
+/// @param[in] pr_context -pr configuration context
+/// @param[in] pwr_status -Core Idle Status
+/// @return    void
+///============================================================================
+void  reconfigure_bitstream_cancelPwrmgrTimer(struct pr_program_context* ppr_program_ctx,
+                                              int pr_pwrmgmt_status)
+{
+   int isWQBusy =  0;
+
+   PTRACEIN;
+
+   if(NULL == ppr_program_ctx) {
+      PERR("Invalid PR Context\n");
+      return ;
+   }
+
+   PERR(" reconfigure_bitstream_cancelPwrmgrTimer Enter \n");
+
+   isWQBusy = work_busy(&(ppr_program_ctx->m_workobject.workobj.work));
+
+   PDEBUG("isWQBusy %d\n",isWQBusy);
+
+   // Cancel  Power Manager timer/ Work Queue
+   if(isWQBusy) {
+      PDEBUG("program_bs_callback CANCELED  \n");
+      kosal_cancel_workqueue( &(ppr_program_ctx->m_workobject.workobj));
+   }
+
+   // If PR APP got closed, stop PR
+   if( 0 == ppr_program_ctx->m_pPR_dev->m_aaldev->m_numowners) {
+      PVERBOSE(" No PR ALLDevice owners  \n" );
+      prprogram_ctx_free(ppr_program_ctx);
+      return ;
+   }
+
+   // if Power Managemt Fails send Error message
+   if(0 != pr_pwrmgmt_status) {
+
+      PERR( "PR Power Manager Error =%d\n", pr_pwrmgmt_status);
+      ccipdrv_event_afu_aysnc_pr_release_send(ppr_program_ctx,uid_errnumPRPowerMgrCoreIdleFail);
+      return ;
+   }
+
+
+   reconfigure_bitstream(ppr_program_ctx);
+
+}
+
+void  reconfigure_bitstream(struct pr_program_context* ppr_program_ctx)
+{
+   PTRACEIN;
+
+   // CASE 1
+   // if Signal tap object has owners.
+   // sends signal tap release event and Do pr in worker queue
+   // --------------------------------------------------------------------
+   if(ppr_program_ctx->m_pSigtap_dev->m_aaldev->m_numowners  !=0) {
+
+      PDEBUG("Signaltap Owners count %d \n",ppr_program_ctx->m_pSigtap_dev->m_aaldev->m_numowners);
+
+
+      // Send Revoke event to signal tap Service
+      sigtap_revoke_sendevent((void*)ppr_program_ctx);
+      KOSAL_INIT_WORK(&(ppr_program_ctx->m_workobject),sigtap_revoke_callback);
+
+      kosal_queue_delayed_work( cci_aaldev_workq_reconf(ppr_program_ctx->m_pPR_dev),
+                               &(ppr_program_ctx->m_workobject),
+                               AFU_RES_RELEASE_TIMEOUT);
+      PTRACEOUT;
+      return ;
+
+   } // if end
+
+   // CASE 2
+   // if afu device object is null or Deactivated .
+   // Do PR in worker queue
+   // --------------------------------------------------------------------
+   if(NULL == ccip_port_uafu_dev(ppr_program_ctx->m_pportdev)) {
+
+      // afu DeActivated  and  Reconfigure AFU with bitstream
+      PVERBOSE(" AFU is Deactivated  \n" );
+
+      if(ppr_program_ctx->m_cmd == ccipdrv_configureAFU) {
+
+         KOSAL_INIT_WORK(&(ppr_program_ctx->m_workobject),program_afu_callback);
+         kosal_queue_delayed_work(cci_aaldev_workq_reconf(ppr_program_ctx->m_pPR_dev),
+                                  &(ppr_program_ctx->m_workobject),
+                                  PR_WQ_TIMEOUT);
+         PTRACEOUT;
+         return;
+      }
+
+      ccipdrv_event_afu_aysnc_pr_release_send(ppr_program_ctx,uid_errnumOK);
+      PTRACEOUT;
+      return ;
+   } // if end
+
+   ppr_program_ctx->m_pAFU_dev = ccip_port_uafu_dev(ppr_program_ctx->m_pportdev);
+   PDEBUG(" paaldev->m_numowners=%d  \n",ppr_program_ctx->m_pAFU_dev->m_aaldev->m_numowners);
+
+   // CASE 3
+   // if afu has no owner.
+   // Do PR in worker queue
+   if( 0 == ppr_program_ctx->m_pAFU_dev->m_aaldev->m_numowners)  {
+
+      PDEBUG(" AFU has no owner. \n");
+      // if afu has no owner.
+      // Do PR in worker queue
+      // --------------------------------------------------------------------
+      // AFU has no owner , unpublish AFU  and Configure with bitstream
+      // AFU has no owner, DeActivate AFU ,Reconfigure AFU with bitstream
+      deactiavted_afu_device(ppr_program_ctx->m_pportdev);
+
+      if(ppr_program_ctx->m_cmd == ccipdrv_configureAFU)  {
+
+         KOSAL_INIT_WORK(&(ppr_program_ctx->m_workobject),program_afu_callback);
+         kosal_queue_delayed_work(cci_aaldev_workq_reconf(ppr_program_ctx->m_pPR_dev),
+                                  &(ppr_program_ctx->m_workobject),
+                                 PR_WQ_TIMEOUT);
+         PTRACEOUT;
+         return;
+      }
+
+      ccipdrv_event_afu_aysnc_pr_release_send(ppr_program_ctx,uid_errnumOK);
+      PTRACEOUT;
+      return ;
+
+      // CASE 4
+      // if afu has owner and reconfigure timeout is zero.
+      // Sends afu release event and Deactivated timeout error event.
+   } else if (( ppr_program_ctx->m_pAFU_dev->m_aaldev->m_numowners  >0) &&
+             (0 == ppr_program_ctx->m_reconfTimeout) ) {
+
+      // if afu has owner and reconfigure timeout is zero.
+      // Sends afu release event and Deactivated timeout error event.
+      // --------------------------------------------------------------------
+
+      // AFU has  owners and Reconfigure timeout is 0 seconds , send Error Message  Deactivate timeout
+
+      PDEBUG(" AFU has owner and reconfTimeout timeout. \n");
+      // Send release event to application and timeout
+      afu_request_release_revoke_sendevent((void*)ppr_program_ctx, true);
+      ccipdrv_event_afu_aysnc_pr_release_send(ppr_program_ctx,uid_errnumDeActiveTimeout);
+
+      PTRACEOUT;
+      return ;
+
+      // CASE 4
+      // if afu has owner and reconfigure timeout is greater then zero.
+      // Sends afu release event and wait for AFU release in worker queue
+   } else if ((ppr_program_ctx->m_pPR_dev->m_aaldev->m_numowners >0) &&
+             (ppr_program_ctx->m_reconfTimeout >0) ) {
+
+      // if afu has owner and reconfigure timeout is greater then zero.
+      // Sends afu release event and wait for AFU release in worker queue
+      // --------------------------------------------------------------------
+      // AFU has  owners , unpublish AFU and configure with bitstream in worker thread
+
+      PDEBUG(" AFU has owner and reconfTimeout timeout >0 \n");
+
+         // Send release event to application
+         afu_request_release_revoke_sendevent((void*)ppr_program_ctx, true);
+
+         // starts Reconfigure timer worker thread if Reconfigure timeout is more then 0 seconds
+         KOSAL_INIT_WORK(&(ppr_program_ctx->m_workobject),afu_release_timeout_callback);
+
+         kosal_queue_delayed_work(cci_aaldev_workq_reconf(ppr_program_ctx->m_pPR_dev),
+                                  &(ppr_program_ctx->m_workobject),
+                                  ppr_program_ctx->m_timeElapsed);
+
+
+      PTRACEOUT;
+      return ;
+   } else {
+
+      PERR(" PR Reconfiguration BadParameter \n");
+      ccipdrv_event_afu_aysnc_pr_release_send(ppr_program_ctx,uid_errnumBadParameter);
+
+
+      PTRACEOUT;
+      return ;
+   } // end if else loop
+
+   PTRACEOUT;
+   return ;
+
+}
+
+int send_event_to_pwrmgr(struct pr_program_context* ppr_context, int power_required)
+{
+   int res = 0;
+
+   PTRACEIN;
+
+   // Send event to
+   res = send_pr_power_event(ppr_context,power_required);
+   if( 0 != res) {
+      PERR(" No  Power device hasn't allocated \n");
+      ccipdrv_event_afu_aysnc_pr_release_send(ppr_context,uid_errnumNoPRPowerMgrDemon);
+      return res;
+   }
+
+   KOSAL_INIT_WORK(&(ppr_context->m_workobject),pwrmgr_timeout_callback);
+   kosal_queue_delayed_work(cci_aaldev_workq_reconf(ppr_context->m_pPR_dev),
+                            &(ppr_context->m_workobject),
+                            PWRMGR_RESPONSE_TIMEOUT);
+
+   PTRACEOUT_INT(res);
+
+   return res;
+}
+///============================================================================
+/// Name: sigtap_revoke_callback
+/// @brief Revokes AFU from applications
+///
+/// @param[in] pr_context -pr configuration context
+/// @return    void
+///============================================================================
+void sigtap_revoke_callback(struct kosal_work_object *pwork)
+{
+   struct aal_device          *psigtap_aal_dev          = NULL;
+   struct pr_program_context  *ppr_program_ctx          = NULL;
+
+   PTRACEIN;
+   ppr_program_ctx = (struct pr_program_context*) kosal_get_object_containing( pwork, struct pr_program_context, m_workobject );
+
+   if(NULL == ppr_program_ctx) {
+      PERR("Invalid PR Context\n");
+      return ;
+   }
+
+   if( 0 == ppr_program_ctx->m_pPR_dev->m_aaldev->m_numowners) {
+      PVERBOSE(" No PR ALLDevice owners  \n" );
+      prprogram_ctx_free(ppr_program_ctx);
+      PTRACEOUT;
+      return ;
+   }
+
+   psigtap_aal_dev = ccip_port_stap_dev(ppr_program_ctx->m_pportdev)->m_aaldev;
+   PVERBOSE(" psigtap_aal_dev->m_numowners %d = \n",psigtap_aal_dev->m_numowners );
+
+   // AFU has no owner (AFU revoked from application),Deactivate and Reconfigure AFU.
+   if( 0 == psigtap_aal_dev->m_numowners)  {
+
+      // NO Singal Tap owners
+      reconfigure_bitstream(ppr_program_ctx);
+
+      PVERBOSE(" AFU is Deactivated  \n" );
+
+   }else if(ppr_program_ctx->m_sigtapRevokeCount  < PR_AFU_REVOKE_MAX_TRY) {
+
+      // App Failed to release Resource with in timeout, try again.
+      ppr_program_ctx->m_sigtapRevokeCount ++ ;
+      KOSAL_INIT_WORK(&(ppr_program_ctx->m_workobject),sigtap_revoke_callback);
+
+      kosal_queue_delayed_work(cci_aaldev_workq_reconf(ppr_program_ctx->m_pPR_dev),
+                              &(ppr_program_ctx->m_workobject),
+                              PR_WQ_REVOKE_TIMEOUT);
+   } else {
+
+      PERR(" AFU Revoke Fail revoke_count=%lld  \n",ppr_program_ctx->m_sigtapRevokeCount  );
+      goto ERR;
+   }
+
+   PTRACEOUT;
+   return ;
+
+ERR:
+   ccipdrv_event_afu_aysnc_pr_release_send(ppr_program_ctx,uid_errnumDeActiveTimeout);
+   PTRACEOUT;
+   return;
+}
+
+///============================================================================
+/// Name: afu_release_timeout_callback
+/// @brief AFU Deactivate /reconfigure timeout callback
+///
+/// @param[in] pr_context -pr configuration context
+/// @return    void
+///============================================================================
+void afu_release_timeout_callback(struct kosal_work_object *pwork)
+{
+   struct aal_device          *pafu_aal_dev            = NULL;
+   struct aal_device          *ppr_aal_dev             = NULL;
+   struct pr_program_context  *ppr_program_ctx         = NULL;
+   btUnsigned64bitInt callbacktimeout                  = 0;
+
+  // PTRACEIN;
+   ppr_program_ctx = (struct pr_program_context*) kosal_get_object_containing( pwork, struct pr_program_context, m_workobject );
+
+   if(NULL == ppr_program_ctx) {
+      PERR("Invalid PR Context\n");
+      return ;
+   }
+
+   if( 0 == ppr_program_ctx->m_pPR_dev->m_aaldev->m_numowners) {
+
+      PVERBOSE(" No PR ALLDevice owners  \n" );
+      prprogram_ctx_free(ppr_program_ctx);
+      return ;
+   }
+
+   pafu_aal_dev = ppr_program_ctx->m_pAFU_dev->m_aaldev;
+   ppr_aal_dev =  ppr_program_ctx->m_pPR_dev->m_aaldev;
+
+   //PVERBOSE( "AFU count %d \n",pafu_aal_dev->m_numowners);
+
+   // AFU has no owner , Deactivate and Reconfigure AFU
+   if( 0 == pafu_aal_dev->m_numowners)  {
+
+      // Deactivate and Reconfigure AFU
+      deactiavted_afu_device(ppr_program_ctx->m_pportdev);
+
+      if(ppr_program_ctx->m_cmd == ccipdrv_configureAFU)  {
+         program_afu_callback(&(ppr_program_ctx->m_workobject));
+         PTRACEOUT;
+         return;
+      }
+
+      ccipdrv_event_afu_aysnc_pr_release_send(ppr_program_ctx,uid_errnumOK);
+      PVERBOSE(" AFU is Deactivated  \n" );
+
+      PTRACEOUT;
+      return ;
+
+    } // end if
+
+   // if total time elapsed is less then reconfigure timeout.
+   if(ppr_program_ctx->m_timeElapsed < ppr_program_ctx->m_reconfTimeout) {
+
+      //PVERBOSE(" Try again  \n" );
+
+      if((ppr_program_ctx->m_timeElapsed +AFU_RES_RELEASE_TIMEOUT) <= ppr_program_ctx->m_reconfTimeout) {
+
+         // workqueue callback called after AFU_RES_RELEASE_TIMEOUT
+         ppr_program_ctx->m_timeElapsed = ppr_program_ctx->m_timeElapsed +AFU_RES_RELEASE_TIMEOUT;
+         callbacktimeout =AFU_RES_RELEASE_TIMEOUT;
+      }
+      else {
+         // workqueue callback called after callbacktimeout
+         callbacktimeout = (ppr_program_ctx->m_reconfTimeout - ppr_program_ctx->m_timeElapsed);
+      }
+
+      KOSAL_INIT_WORK(&(ppr_program_ctx->m_workobject),afu_release_timeout_callback);
+      kosal_queue_delayed_work(cci_aaldev_workq_reconf(ppr_program_ctx->m_pPR_dev),
+                               &(ppr_program_ctx->m_workobject),
+                               callbacktimeout);
+
+     // PTRACEOUT;
+      return ;
+   }
+
+   // AFU has owner, Reconfigure action Honor Owner
+   // If we are told to honor then since owner did not relinquish AFU timeout request
+   if((pafu_aal_dev->m_numowners >0 ) &&
+      (ReConf_Action_Honor_Owner == ppr_program_ctx->m_reconfAction)) {
+
+      PVERBOSE("AFU  DeActiavated Timeout  \n" );
+      ccipdrv_event_afu_aysnc_pr_release_send(ppr_program_ctx,uid_errnumDeviceBusy);
+
+    } else {
+
+      PVERBOSE("Revoke AFU form Application  \n" );
+      // Reconfigure action Honor Request, sends Revoke event to AAL Service
+      // AAL Frame work failed to release AFU, driver send error event
+      afu_request_release_revoke_sendevent((void*)ppr_program_ctx,false);
+      afu_revoke_callback(&(ppr_program_ctx->m_workobject));
+
+    }
+   PTRACEOUT;
+   return;
+}
+
+///============================================================================
+/// Name: cci_create_AAL_PR_Device
+/// @brief Creates and registers PR objects (resources) we want to
+///        expose through AAL.
+///
+/// @param[in] pportdev - Port device
+/// @param[in] paalid - Base AAL ID for this device.
+/// @return    AAL Device pointer
+///============================================================================
+struct cci_aal_device   *
+               cci_create_AAL_PR_Device( struct fme_device  *pfmedev,
+                                          struct aal_device_id *paalid)
+{
+   struct cci_aal_device   *pcci_aaldev = NULL;
+   int ret;
+
+   PTRACEIN;
+
+   PVERBOSE("Creating Signal Tap device\n");
+
+   // Construct the cci_aal_device object
+   pcci_aaldev = cci_create_aal_device();
+
+   ASSERT(NULL != pcci_aaldev);
+   if( NULL == pcci_aaldev){
+      return NULL;
+   }
+
+   // Make it a User AFU
+   cci_aaldev_type(pcci_aaldev) = cci_dev_PR;
+
+   // Record parentage
+   cci_aaldev_pfme(pcci_aaldev)     = pfmedev;
+   cci_aaldev_pci_dev(pcci_aaldev)  = ccip_fme_dev_pci_dev(pfmedev) ;
+
+   // Device Address is the same as the Port. Set the AFU ID information
+   // The following attributes describe the interfaces supported by the device
+   aaldevid_afuguidl(*paalid)            = CCIP_PR_GUIDL;
+   aaldevid_afuguidh(*paalid)            = CCIP_PR_GUIDH;
+   aaldevid_pipguid(*paalid)             = CCIP_PR_PIPIID;
+
+   // Setup the MMIO region parameters
+   cci_aaldev_kvp_afu_mmio(pcci_aaldev)   = (btVirtAddr)ccip_fme_pr(pfmedev);
+   cci_aaldev_len_afu_mmio(pcci_aaldev)   = sizeof(struct CCIP_FME_DFL_PR);
+   cci_aaldev_phys_afu_mmio(pcci_aaldev)  = kosal_virt_to_phys((btVirtAddr)ccip_fme_pr(pfmedev));
+
+   // Create the AAL device and attach it to the CCI device object
+   cci_aaldev_to_aaldev(pcci_aaldev) =  aaldev_create( "CCIPPR",           // AAL device base name
+                                                       paalid,             // AAL ID
+                                                       &cci_PRpip);
+
+   //CCI device object create fails, delete PR AAL device
+   if(NULL == cci_aaldev_to_aaldev(pcci_aaldev) ){
+      cci_destroy_aal_device(pcci_aaldev);
+      return NULL;
+   }
+
+   // Set up reverse look up. Use aaldev_to_cci_aal_device() to access
+   aaldev_context(cci_aaldev_to_aaldev(pcci_aaldev)) = pcci_aaldev;
+
+   //===========================================================
+   // Set up the optional aal_device attributes
+   //
+
+   // Initialize the worker thread
+   cci_aaldev_workq_reconf( pcci_aaldev )        = kosal_create_workqueue( "ReconfWQ", cci_aaldev_to_aaldev( pcci_aaldev ) );
+
+   // Set how many owners are allowed access to this device simultaneously
+   cci_aaldev_to_aaldev(pcci_aaldev)->m_maxowners = 1;
+
+   // Set the config space mapping permissions
+   cci_aaldev_to_aaldev(pcci_aaldev)->m_mappableAPI = AAL_DEV_APIMAP_NONE;
+
+   if( cci_aaldev_allow_map_mmior_space(pcci_aaldev) ){
+      cci_aaldev_to_aaldev(pcci_aaldev)->m_mappableAPI |= AAL_DEV_APIMAP_MMIOR;
+   }
+
+   // The PIP uses the PIP context to get a handle to the CCI Device from the generic device.
+   aaldev_pip_context(cci_aaldev_to_aaldev(pcci_aaldev)) = (void*)pcci_aaldev;
+
+   // Method called when the device is released (i.e., its destructor)
+   //  The canonical release device calls the user's release method.
+   //  If NULL is provided then only the canonical behavior is done
+   dev_setrelease(cci_aaldev_to_aaldev(pcci_aaldev), cci_release_device);
+
+      // Device is ready for use.  Publish it with the Configuration Management Subsystem
+   ret = cci_publish_aaldevice(pcci_aaldev);
+   ASSERT(ret == 0);
+   if(0> ret){
+      PERR("Failed to initialize AAL Device for CCIPPR[%d:%d:%d:%d]",aaldevid_devaddr_busnum(*paalid),
+                                                                     aaldevid_devaddr_devnum(*paalid),
+                                                                     aaldevid_devaddr_fcnnum(*paalid),
+                                                                     aaldevid_devaddr_subdevnum(*paalid));
+      cci_destroy_aal_device(pcci_aaldev);
+      return NULL;
+   }
+   PTRACEOUT;
+   return pcci_aaldev;
+}
+
+
+//=============================================================================
+// Name: CommandHandler
+// Description: Implements the PIP command handler
+// Interface: public
+// Inputs: pownerSess - Session between App and device
+//         Message - Message to process
+// Outputs: none.
+// Comments:
+//=============================================================================
+int
+CommandHandler(struct aaldev_ownerSession *pownerSess,
+               struct aal_pipmessage       *Message)
+{
+#if (1 == ENABLE_DEBUG)
+#define AFU_COMMAND_CASE(x) case x : PDEBUG("%s\n", #x);
+#else
+#define AFU_COMMAND_CASE(x) case x :
+#endif // ENABLE_DEBUG
+
+   // Private session object set at session bind time (i.e., when object allocated)
+   struct cci_PIPsession *pSess = (struct cci_PIPsession *)aalsess_pipHandle(pownerSess);
+   struct cci_aal_device  *pdev  = NULL;
+
+   // Overall return value for this function. Set before exiting if there is an error.
+   //    retval = 0 means good return.
+   int retval = 0;
+
+   // UI Driver message
+   struct aalui_CCIdrvMessage *pmsg = (struct aalui_CCIdrvMessage *) Message->m_message;
+
+   // Save original response buffer size in case we return something
+   btWSSize         respBufSize     = Message->m_respbufSize;
+
+   // if we return a request error, return this.  usually it's an invalid request error.
+   uid_errnum_e request_error = uid_errnumInvalidRequest;
+
+   PVERBOSE("In CCI Command handler, AFUCommand().\n");
+
+   // Perform some basic checks while assigning the pdev
+   ASSERT(NULL != pSess );
+   if ( NULL == pSess ) {
+      PDEBUG("Error: No PIP session\n");
+      return -EIO;
+   }
+
+   // Get the cci device
+   pdev = cci_PIPsessionp_to_ccidev(pSess);
+   if ( NULL == pdev ) {
+      PDEBUG("Error: No device\n");
+      return -EIO;
+   }
+
+   if ( unlikely( kosal_sem_get_user_alertable(cci_dev_pr_sem(pdev)))) {
+         PDEBUG("kosal_sem_get_user_alertable interrupted \n");
+         return -EINVAL ;
+      }
+
+   PDEBUG("LOCK RECONF \n");
+
+   //=====================
+   // Message processor
+   //=====================
+   switch ( pmsg->cmd ) {
+
+
+      AFU_COMMAND_CASE(ccipdrv_deactivateAFU) {
+         struct ccipdrv_event_afu_response_event *pafuws_evt = NULL;
+         struct aal_device        *paaldev                   = NULL;
+         struct port_device       *pportdev                  = NULL;
+         btTime                   reconfTimeout              = 0;
+         btUnsigned64bitInt       reconfAction               = 0;
+         btBool                   leaveDeactivated           = 0;
+         struct pr_program_context* ppr_program_ctx          = NULL;
+         struct aal_device        *psigtapdev                = NULL;
+
+         struct ccidrvreq *preq = (struct ccidrvreq *)pmsg->payload;
+
+         // Extract arguments
+         reconfTimeout     = preq->ahmreq.u.pr_config.reconfTimeout;
+         reconfAction      = RECONF_ACTION_HONOR_PARAMETER(preq->ahmreq.u.pr_config.reconfAction);
+         leaveDeactivated  = RECONF_ACTION_ACTIVATE_PARAMETER(preq->ahmreq.u.pr_config.reconfAction);
+
+         PDEBUG("reconfTimeout=%lld\n",reconfTimeout);
+         PDEBUG("reconfAction=%lld\n",reconfAction);
+
+         // Port for this AAL PR object
+         //pportdev = cci_aaldev_pport(pdev);
+         pportdev = getport_device(pdev,0);
+
+         // Find the AFU device associated with this port
+         // Make sure device is not in use. If it is notify user and start time out timer.
+
+         // Case 1 - if AFU device object is null.
+         // Sends No afu error event
+         // --------------------------------------------------------------------
+         if(NULL == ccip_port_uafu_dev(pportdev)){
+
+            PDEBUG("No AFU Device \n");
+            pafuws_evt = ccipdrv_event_activationchange_event_create(uid_afurespDeactivateComplete,
+                                                                     pownerSess->m_device,
+                                                                     &Message->m_tranID,
+                                                                     Message->m_context,
+                                                                     uid_errnumNoAFU);
+
+            ccidrv_sendevent(pownerSess,
+                             AALQIP(pafuws_evt));
+
+            goto ERROR;
+
+         }
+
+         // Determine if applications currently have the AFU in use
+         paaldev = cci_aaldev_to_aaldev(ccip_port_uafu_dev(pportdev));
+
+         ppr_program_ctx = (struct pr_program_context*)kosal_kzmalloc( sizeof(struct pr_program_context) );
+
+
+         // Case 2 - if PR context Memory allocation filed.
+         // Sends  No Memory error event
+         // --------------------------------------------------------------------
+         if(NULL == ppr_program_ctx){
+            PERR("Unable to allocate system memory for pr context\n");
+
+            pafuws_evt = ccipdrv_event_activationchange_event_create(uid_afurespDeactivateComplete,
+                                                                     pownerSess->m_device,
+                                                                     &Message->m_tranID,
+                                                                     Message->m_context,
+                                                                     uid_errnumNoMem);
+             ccidrv_sendevent(pownerSess,
+                              AALQIP(pafuws_evt));
+             goto ERROR;
+         }
+
+         // Assign PR context
+         ppr_program_ctx->m_cmd               = ccipdrv_deactivateAFU;
+         ppr_program_ctx->m_pPR_dev           = pdev;
+         ppr_program_ctx->m_pAFU_dev          = ccip_port_uafu_dev(pportdev);
+         ppr_program_ctx->m_pportdev          = pportdev;
+         ppr_program_ctx->m_pownerSess        = pownerSess;
+         ppr_program_ctx->m_respID            = uid_afurespDeactivateComplete;
+         ppr_program_ctx->m_kbufferptr        = NULL;
+         ppr_program_ctx->m_bufferlen         = 0;
+         ppr_program_ctx->m_leaveDeactivated  = leaveDeactivated;
+         ppr_program_ctx->m_reconfTimeout     = reconfTimeout;
+         ppr_program_ctx->m_reconfAction      = reconfAction;
+         ppr_program_ctx->m_afuRevokeCount    = 0;
+         ppr_program_ctx->m_timeElapsed       = AFU_RES_RELEASE_TIMEOUT;
+         ppr_program_ctx->m_sigtapRevokeCount = 0;
+         ppr_program_ctx->m_afuRevokeCount    = 0;
+
+         // set timeout
+         if(reconfTimeout <= AFU_RES_RELEASE_TIMEOUT) {
+            ppr_program_ctx->m_timeElapsed =reconfTimeout;
+         }
+
+         // Signal Tap Resource
+         psigtapdev = ccip_port_stap_dev(pportdev)->m_aaldev;
+
+
+         // Case 3 - if Signal tap object has owners.
+         // sends signal tap release event and Do pr in worker queue
+         // --------------------------------------------------------------------
+         if(psigtapdev->m_numowners  !=0) {
+
+            PDEBUG("Signaltap Owners count %d \n",psigtapdev->m_numowners);
+            // Send Revoke event to signal tap Service
+            sigtap_revoke_sendevent((void*)ppr_program_ctx);
+            KOSAL_INIT_WORK(&(ppr_program_ctx->m_workobject),sigtap_revoke_callback);
+
+            kosal_queue_delayed_work( cci_aaldev_workq_reconf(pdev),
+                                     &(ppr_program_ctx->m_workobject),
+                                     AFU_RES_RELEASE_TIMEOUT);
+
+            return 0;
+
+         } // if end
+
+
+         // Case 4 - if AFU has no owner.
+         // Sends OK event
+         // --------------------------------------------------------------------
+         if( 0 == paaldev->m_numowners)  {
+
+            PDEBUG("AFU Owner Count=%d\n", paaldev->m_numowners);
+
+            // AFU is free so deactivate
+            //(TODO;  We need to make sure there are no races of something trying allocate this.  May need to lock the device
+            // from getting a bind request.)
+            deactiavted_afu_device(pportdev);
+            ccipdrv_event_activationchange_event_create_send(ppr_program_ctx,
+                                                             uid_afurespDeactivateComplete,
+                                                             pownerSess->m_device,
+                                                             &Message->m_tranID,
+                                                             Message->m_context,
+                                                             uid_errnumOK);
+            goto CLEANUP;
+
+         } else if (0 == reconfTimeout) {
+
+            // Case 5 - if AFU has owner and zero timeout.
+            // Sends deactivate timeout error event
+            // --------------------------------------------------------------------
+
+            // Number of owner is more then 0 but Reconfiguration timeout is 0 Seconds
+            //   We generate an event to the application to release (TODO) and time out the deactivate will timeout
+            PDEBUG("reconfTimeout is 0 \n");
+            // generate an event to the application to release AFU
+            // time out the deactivate will timeout
+            //afu_request_release_sendevent((void*)ppr_program_ctx);
+            afu_request_release_revoke_sendevent((void*)ppr_program_ctx, true);
+
+            ccipdrv_event_activationchange_event_create_send(ppr_program_ctx,
+                                                             uid_afurespDeactivateComplete,
+                                                             pownerSess->m_device,
+                                                             &Message->m_tranID,
+                                                             Message->m_context,
+                                                             uid_errnumDeActiveTimeout);
+
+            goto ERROR;
+
+          } else if(reconfTimeout >0) {
+
+             // Case 6 - if  AFU has owner and timeout.
+             // Deactivate afu in worker queue
+             // --------------------------------------------------------------------
+            // AFU in use and a timeout has been specified
+            // Number of owner is more then 0 but Reconfiguration timeout is more then Seconds
+            // Send Release Event to the application to release AFU and start deactivate timer
+
+            PDEBUG("Deactivate timeout thread \n");
+            afu_request_release_revoke_sendevent((void*)ppr_program_ctx, true);
+
+            // starts Reconfigure timer worker thread if Reconfigure timeout is more then 0 seconds
+            KOSAL_INIT_WORK(&(ppr_program_ctx->m_workobject),afu_release_timeout_callback);
+
+            kosal_queue_delayed_work( cci_aaldev_workq_reconf(pdev),
+                                   &(ppr_program_ctx->m_workobject),
+                                   ppr_program_ctx->m_timeElapsed);
+
+            return 0;
+          } else {
+
+             // Case 7 - Invalid parameter.
+             // sends Bad Parameter error event
+             // --------------------------------------------------------------------
+             PERR("Deactivate Bad Parameter \n");
+             ccipdrv_event_activationchange_event_create_send(ppr_program_ctx,
+                                                              uid_afurespDeactivateComplete,
+                                                              pownerSess->m_device,
+                                                              &Message->m_tranID,
+                                                              Message->m_context,
+                                                              uid_errnumBadParameter);
+
+             goto ERROR;
+
+          } // end of if else
+
+      } break;
+
+      AFU_COMMAND_CASE(ccipdrv_activateAFU) {
+
+         // Port for this AAL PR object
+         //struct port_device  *pportdev                         = cci_aaldev_pport(pdev);
+         struct port_device  *pportdev = getport_device(pdev,0);
+         struct ccipdrv_event_afu_response_event *pafuws_evt   = NULL;
+         // Find the AFU device associated with this port
+         if(NULL != ccip_port_uafu_dev(pportdev)){
+            pafuws_evt = ccipdrv_event_activationchange_event_create(uid_afurespActivateComplete,
+                                                                     pownerSess->m_device,
+                                                                     &Message->m_tranID,
+                                                                     Message->m_context,
+                                                                     uid_errnumAFUNotActivated);
+
+            ccidrv_sendevent(pownerSess,
+                             AALQIP(pafuws_evt));
+
+            goto ERROR;
+         }
+
+
+
+         if(!reconfigure_activateAFU(pportdev,pdev))
+         {
+
+            pafuws_evt = ccipdrv_event_activationchange_event_create(uid_afurespActivateComplete,
+                                                                     pownerSess->m_device,
+                                                                     &Message->m_tranID,
+                                                                     Message->m_context,
+                                                                     uid_errnumAFUNotActivated);
+
+            ccidrv_sendevent(pownerSess,
+                             AALQIP(pafuws_evt));
+            goto ERROR;
+         }
+
+
+         pafuws_evt = ccipdrv_event_activationchange_event_create(uid_afurespActivateComplete,
+                                                                  pownerSess->m_device,
+                                                                  &Message->m_tranID,
+                                                                  Message->m_context,
+                                                                  uid_errnumOK);
+
+         ccidrv_sendevent(pownerSess,
+                          AALQIP(pafuws_evt));
+
+         goto CLEANUP;
+
+      } break;
+
+      AFU_COMMAND_CASE(ccipdrv_configureAFU) {
+         struct ccipdrv_event_afu_response_event *pafuws_evt = NULL;
+         struct ccidrvreq *preq = (struct ccidrvreq *)pmsg->payload;
+
+         // Get a copy of the bitfile image from user space.
+         //  This function returns a safe pointer to the user data.
+         //  This may involve copying into kernel space.
+
+         //------------------------------------------------------------------------------------------------------
+         struct aal_device        *paaldev          = NULL;
+         struct port_device       *pportdev         = NULL;
+         btTime                   reconfTimeout     = 0;
+         btUnsigned64bitInt       reconfAction      = 0;
+         btBool                   leaveDeactivated  = 0;
+         btVirtAddr               kptr              = NULL;
+         struct aal_device        *psigtapdev       = NULL;
+         struct pr_program_context* ppr_program_ctx = NULL;
+
+         btWSSize buflen = preq->ahmreq.u.pr_config.size;
+         btVirtAddr uptr = preq->ahmreq.u.pr_config.vaddr;
+
+         // Extract arguments
+         reconfTimeout     = preq->ahmreq.u.pr_config.reconfTimeout;
+         reconfAction      = RECONF_ACTION_HONOR_PARAMETER(preq->ahmreq.u.pr_config.reconfAction);
+         leaveDeactivated  = RECONF_ACTION_ACTIVATE_PARAMETER(preq->ahmreq.u.pr_config.reconfAction);
+
+         PVERBOSE( "ccipdrv_configureAFU  \n");
+         PDEBUG("reconfTimeout=%lld\n",reconfTimeout);
+         PDEBUG("reconfAction=%lld\n" ,reconfAction);
+
+         //pportdev = cci_aaldev_pport(pdev);
+         pportdev = getport_device(pdev,0);
+
+         // Case 1 - if bitstream buffer is null or buffer length is zero.
+         // sends bad parameter error event .
+         // --------------------------------------------------------------------
+         if((NULL == uptr) || (0 == buflen)){
+
+            PERR("AFU reprogramming failed\n");
+            pafuws_evt = ccipdrv_event_reconfig_event_create(uid_afurespConfigureComplete,
+                                                             pownerSess->m_device,
+                                                             &Message->m_tranID,
+                                                             Message->m_context,
+                                                             uid_errnumBadParameter);
+
+            ccidrv_sendevent(pownerSess,
+                             AALQIP(pafuws_evt));
+            goto ERROR;
+         }
+
+         kptr = kosal_get_user_buffer(uptr, buflen);
+
+         // Case 2 - if kernel memory allocation for bitstream fails.
+         // sends no memory error event.
+         // --------------------------------------------------------------------
+         // Allocation Fails send No Memory error to application
+         if(NULL == kptr ){
+            PERR("kosal_get_user_buffer returned NULL");
+            pafuws_evt = ccipdrv_event_reconfig_event_create(uid_afurespConfigureComplete,
+                                                             pownerSess->m_device,
+                                                             &Message->m_tranID,
+                                                             Message->m_context,
+                                                             uid_errnumNoMem);
+            ccidrv_sendevent(pownerSess,
+                             AALQIP(pafuws_evt));
+            goto ERROR;
+         }
+
+         PVERBOSE( " PR BitStream Buffer allocated  \n");
+         ppr_program_ctx = (struct pr_program_context*) kosal_kzmalloc( sizeof(struct pr_program_context) );
+
+         // Case 3 - if kernel memory allocation for PR context fails.
+         // sends no memory error event.
+         // --------------------------------------------------------------------
+         if(NULL == ppr_program_ctx){
+
+            PERR("Unable to allocate system memory for pr context\n");
+            if(NULL != kptr)
+               kosal_free_user_buffer(kptr, buflen);
+
+            pafuws_evt = ccipdrv_event_reconfig_event_create(uid_afurespConfigureComplete,
+                                                            pownerSess->m_device,
+                                                            &Message->m_tranID,
+                                                            Message->m_context,
+                                                            uid_errnumNoMem);
+            ccidrv_sendevent(pownerSess,
+                            AALQIP(pafuws_evt));
+            goto ERROR;
+         }
+
+         // Assign PR context
+         ppr_program_ctx->m_cmd               = ccipdrv_configureAFU;
+         ppr_program_ctx->m_pPR_dev           = pdev;
+         ppr_program_ctx->m_pportdev          = pportdev;
+         ppr_program_ctx->m_pownerSess        = pownerSess;
+         ppr_program_ctx->m_respID            = uid_afurespConfigureComplete;
+         ppr_program_ctx->m_kbufferptr        = kptr;
+         ppr_program_ctx->m_bufferlen         = buflen;
+         ppr_program_ctx->m_leaveDeactivated  = leaveDeactivated;
+         ppr_program_ctx->m_reconfTimeout     = reconfTimeout;
+         ppr_program_ctx->m_reconfAction      = reconfAction;
+         ppr_program_ctx->m_afuRevokeCount    = 0;
+         ppr_program_ctx->m_timeElapsed       = AFU_RES_RELEASE_TIMEOUT;
+         ppr_program_ctx->m_sigtapRevokeCount = 0;
+         ppr_program_ctx->m_afuRevokeCount    = 0;
+         ppr_program_ctx->m_pSigtap_dev       = ccip_port_stap_dev(pportdev);
+         // Milliseconds
+         if(reconfTimeout <= AFU_RES_RELEASE_TIMEOUT)
+            ppr_program_ctx->m_timeElapsed =reconfTimeout;
+
+         // Signal Tap Resource
+         psigtapdev = ccip_port_stap_dev(pportdev)->m_aaldev;
+
+#ifdef PWRMGR
+         // Green bitstream Header
+         ppr_program_ctx->m_gbs_header = (struct CCIP_GBS_HEADER *) kptr;
+
+         PDEBUG("GBS Power %d \n",ppr_program_ctx->m_gbs_header->m_md_afu_power);
+         PDEBUG("GBS Clock %d \n",ppr_program_ctx->m_gbs_header->m_md_clknum);
+
+         // Sends Event to power Manger
+         send_event_to_pwrmgr(ppr_program_ctx,ppr_program_ctx->m_gbs_header->m_md_afu_power);
+         return 0;
+
+#else
+          // Case 4 - if Signal tap object has owners.
+         // sends signal tap release event and Do pr in worker queue
+         // --------------------------------------------------------------------
+         if(psigtapdev->m_numowners  !=0) {
+
+            PDEBUG("Signaltap Owners count %d \n",psigtapdev->m_numowners);
+            // Send Revoke event to signal tap Service
+            sigtap_revoke_sendevent((void*)ppr_program_ctx);
+            KOSAL_INIT_WORK(&(ppr_program_ctx->m_workobject),sigtap_revoke_callback);
+
+            kosal_queue_delayed_work( cci_aaldev_workq_reconf(pdev),
+                                     &(ppr_program_ctx->m_workobject),
+                                     AFU_RES_RELEASE_TIMEOUT);
+
+            return 0;
+
+         } // if end
+
+         // Case 5 - if afu device object is null or Deactivated .
+         // Do PR in worker queue
+         // --------------------------------------------------------------------
+         if(NULL == ccip_port_uafu_dev(pportdev)) {
+
+
+            PDEBUG("AFU Deactivated  \n");
+            // afu DeActivated  and  Reconfigure AFU with bitstream
+
+            KOSAL_INIT_WORK(&(ppr_program_ctx->m_workobject),program_afu_callback);
+
+            kosal_queue_delayed_work(cci_aaldev_workq_reconf(pdev),
+                                     &(ppr_program_ctx->m_workobject),
+                                     PR_WQ_TIMEOUT);
+
+            return 0;
+         } // if end
+
+
+         paaldev = cci_aaldev_to_aaldev(ccip_port_uafu_dev(pportdev));
+         ppr_program_ctx->m_pAFU_dev = ccip_port_uafu_dev(pportdev);
+
+         PDEBUG(" paaldev->m_numowners=%d  \n",paaldev->m_numowners);
+
+
+         if( 0 == paaldev->m_numowners)  {
+
+            // Case 6 - if afu has no owner.
+            // Do PR in worker queue
+            // --------------------------------------------------------------------
+            // AFU has no owner , unpublish AFU  and Configure with bitstream
+
+            // TODO FOR NOW JUST DO IT
+            // AFU has no owner, DeActivate AFU ,Reconfigure AFU with bitstream
+            deactiavted_afu_device(pportdev);
+
+            PDEBUG(" AFU has no owner. \n");
+
+            KOSAL_INIT_WORK(&(ppr_program_ctx->m_workobject),program_afu_callback);
+
+            kosal_queue_delayed_work(cci_aaldev_workq_reconf(pdev),
+                                    &(ppr_program_ctx->m_workobject),
+                                    PR_WQ_TIMEOUT);
+            return 0;
+
+         } else if (( paaldev->m_numowners  >0) &&
+                   (0 == reconfTimeout) ) {
+
+            // Case 7 - if afu has owner and reconfigure timeout is zero.
+            // Sends afu release event and Deactivated timeout error event.
+            // --------------------------------------------------------------------
+
+            // AFU has  owners and Reconfigure timeout is 0 seconds , send Error Message  Deactivate timeout
+
+            PDEBUG(" AFU has owner and reconfTimeout timeout. \n");
+            // Send release event to application and timeout
+            afu_request_release_revoke_sendevent((void*)ppr_program_ctx,false);
+
+            ccipdrv_event_reconfig_event_create_send(ppr_program_ctx,
+                                                     uid_afurespConfigureComplete,
+                                                     pownerSess->m_device,
+                                                     &Message->m_tranID,
+                                                     Message->m_context,
+                                                     uid_errnumDeActiveTimeout);
+            goto ERROR;
+
+         } else if ((paaldev->m_numowners >0) &&
+                   (reconfTimeout >0) ) {
+
+            // Case 8 - if afu has owner and reconfigure timeout is greater then zero.
+            // Sends afu release event and wait for AFU release in worker queue
+            // --------------------------------------------------------------------
+
+            // AFU has  owners , unpublish AFU and configure with bitstream in worker thread
+
+            PDEBUG(" AFU has owner and reconfTimeout timeout >0 \n");
+            // Send release event to application
+            afu_request_release_revoke_sendevent((void*)ppr_program_ctx,false);
+
+            // starts Reconfigure timer worker thread if Reconfigure timeout is more then 0 seconds
+            KOSAL_INIT_WORK(&(ppr_program_ctx->m_workobject),afu_release_timeout_callback);
+
+            kosal_queue_delayed_work(cci_aaldev_workq_reconf(pdev),
+                                  &(ppr_program_ctx->m_workobject),
+                                  ppr_program_ctx->m_timeElapsed);
+
+            return 0;
+         } else {
+
+            PERR(" PR Reconfiguration BadParameter \n");
+
+            // Case 9 - Invalid parameter.
+            // Sends bad parameter error event to app
+            // --------------------------------------------------------------------
+            ccipdrv_event_reconfig_event_create_send(ppr_program_ctx,
+                                                     uid_afurespConfigureComplete,
+                                                     pownerSess->m_device,
+                                                     &Message->m_tranID,
+                                                     Message->m_context,
+                                                     uid_errnumBadParameter);
+
+            goto ERROR;
+         } // end if else loop
+#endif
+        goto CLEANUP;
+
+      }break;
+
+      // Returns a workspace ID for the Config Space
+
+      AFU_COMMAND_CASE(ccipdrv_getMMIORmap) {
+         struct ccidrvreq *preq = (struct ccidrvreq *)pmsg->payload;
+         struct aalui_WSMEvent WSID;
+         struct aal_wsid   *wsidp            = NULL;
+
+         if ( !cci_aaldev_allow_map_mmior_space(pdev) ) {
+            PERR("Failed ccipdrv_getMMIOR map Permission\n");
+            PERR("Direct API access not permitted on this device\n");
+            Message->m_errcode = uid_errnumPermission;
+            break;
+         }
+
+         //------------------------------------------------------------
+         // Create the WSID object and add to the list for this session
+         //------------------------------------------------------------
+         if ( WSID_MAP_MMIOR != preq->ahmreq.u.wksp.m_wsid ) {
+            PERR("Failed ccipdrv_getMMIOR map Parameter\n");
+
+            PERR("Bad WSID on ccipdrv_getMMIORmap\n");
+            Message->m_errcode = uid_errnumBadParameter;
+            break;
+         }
+
+         wsidp = ccidrv_getwsid(pownerSess->m_device, preq->ahmreq.u.wksp.m_wsid);
+         if ( NULL == wsidp ) {
+            PERR("Could not allocate workspace\n");
+            retval = -ENOMEM;
+            /* generate a failure event back to the caller? */
+            goto ERROR;
+         }
+
+         wsidp->m_type = WSM_TYPE_MMIO;
+         PDEBUG("Getting CSR %s Aperature WSID %p using id %llx .\n",
+                   ((WSID_CSRMAP_WRITEAREA == preq->ahmreq.u.wksp.m_wsid) ? "Write" : "Read"),
+                   wsidp,
+                   preq->ahmreq.u.wksp.m_wsid);
+
+         PDEBUG("Apt = %" PRIxPHYS_ADDR " Len = %d.\n",cci_aaldev_phys_afu_mmio(pdev), (int)cci_aaldev_len_afu_mmio(pdev));
+
+         // Set up the return payload
+         WSID.evtID           = uid_wseventMMIOMap;
+         WSID.wsParms.wsid    = pwsid_to_wsidHandle(wsidp);
+         WSID.wsParms.physptr = cci_aaldev_phys_afu_mmio(pdev);
+         WSID.wsParms.size    = cci_aaldev_len_afu_mmio(pdev);
+
+         // Make this atomic. Check the original response buffer size for room
+         if(respBufSize >= sizeof(struct aalui_WSMEvent)){
+            *((struct aalui_WSMEvent*)Message->m_response) = WSID;
+            Message->m_respbufSize = sizeof(struct aalui_WSMEvent);
+         }
+         PDEBUG("Buf size =  %u Returning WSID %llx\n",(unsigned int)Message->m_respbufSize, WSID.wsParms.wsid  );
+         Message->m_errcode = uid_errnumOK;
+
+         // Add the new wsid onto the session
+         aalsess_add_ws(pownerSess, wsidp->m_list);
+
+         goto CLEANUP;
+      } break;
+
+      AFU_COMMAND_CASE(ccipdrv_afucmdWKSP_ALLOC)
+      {
+         struct ccipdrv_event_afu_response_event *pafuws_evt = NULL;
+         struct ccidrvreq    *preq        = (struct ccidrvreq *)pmsg->payload;
+         btVirtAddr           krnl_virt   = NULL;
+         struct aal_wsid     *wsidp       = NULL;
+
+         // Normal flow -- create the needed workspace.
+         krnl_virt = (btVirtAddr)kosal_alloc_contiguous_mem_nocache(preq->ahmreq.u.wksp.m_size);
+         if (NULL == krnl_virt) {
+            pafuws_evt = ccipdrv_event_afu_afuallocws_create(pownerSess->m_device,
+                                                           (btWSID) 0,
+                                                           NULL,
+                                                           (btPhysAddr)NULL,
+                                                           preq->ahmreq.u.wksp.m_size,
+                                                           Message->m_tranID,
+                                                           Message->m_context,
+                                                           uid_errnumNoMem);
+
+            ccidrv_sendevent(pownerSess,
+                             AALQIP(pafuws_evt));
+
+            retval = -ENOMEM;
+            goto ERROR;
+         }
+
+         //------------------------------------------------------------
+         // Create the WSID object and add to the list for this session
+         //------------------------------------------------------------
+
+         wsidp = ccidrv_getwsid(pownerSess->m_device, (btWSID)krnl_virt);
+         if ( NULL == wsidp ) {
+            PERR("Couldn't allocate task workspace\n");
+            retval = -ENOMEM;
+            /* send a failure event back to the caller? */
+            goto ERROR;
+         }
+
+         wsidp->m_size = preq->ahmreq.u.wksp.m_size;
+         wsidp->m_type = WSM_TYPE_VIRTUAL;
+         PDEBUG("Creating Physical WSID %p.\n", wsidp);
+
+         // Add the new wsid onto the session
+         aalsess_add_ws(pownerSess, wsidp->m_list);
+
+         PINFO("CCI WS alloc wsid=0x%" PRIx64 " phys=0x%" PRIxPHYS_ADDR  " kvp=0x%" PRIx64 " size=%" PRIu64 " success!\n",
+                  preq->ahmreq.u.wksp.m_wsid,
+                  kosal_virt_to_phys((btVirtAddr)wsidp->m_id),
+                  wsidp->m_id,
+                  wsidp->m_size);
+
+         // Create the event
+         pafuws_evt = ccipdrv_event_afu_afuallocws_create(
+                                               aalsess_aaldevicep(pownerSess),
+                                               pwsid_to_wsidHandle(wsidp), // make the wsid appear page aligned for mmap
+                                               NULL,
+                                               kosal_virt_to_phys((btVirtAddr)wsidp->m_id),
+                                               preq->ahmreq.u.wksp.m_size,
+                                               Message->m_tranID,
+                                               Message->m_context,
+                                               uid_errnumOK);
+
+         PVERBOSE("Sending the WKSP Alloc event.\n");
+         // Send the event
+         ccidrv_sendevent(pownerSess,
+                          AALQIP(pafuws_evt));
+         goto CLEANUP;
+
+      } break; // case fappip_afucmdWKSP_VALLOC
+
+
+      //============================
+      //  Free Workspace
+      //============================
+      AFU_COMMAND_CASE(ccipdrv_afucmdWKSP_FREE) {
+         struct ccipdrv_event_afu_response_event *pafuws_evt = NULL;
+         struct ccidrvreq    *preq        = (struct ccidrvreq *)pmsg->payload;
+         btVirtAddr           krnl_virt   = NULL;
+         struct aal_wsid     *wsidp       = NULL;
+
+         ASSERT(0 != preq->ahmreq.u.wksp.m_wsid);
+         if ( 0 == preq->ahmreq.u.wksp.m_wsid ) {
+            PDEBUG("WKSP_IOC_FREE: WS id can't be 0.\n");
+            // Create the exception event
+            pafuws_evt = ccipdrv_event_afu_afufreecws_create(pownerSess->m_device,
+                                                           Message->m_tranID,
+                                                           Message->m_context,
+                                                           uid_errnumBadParameter);
+
+            // Send the event
+            ccidrv_sendevent(pownerSess,
+                             AALQIP(pafuws_evt));
+            retval = -EFAULT;
+            goto ERROR;
+         }
+
+         // Get the workspace ID object
+         wsidp = ccidrv_valwsid(preq->ahmreq.u.wksp.m_wsid);
+
+         ASSERT(wsidp);
+         if ( NULL == wsidp ) {
+            // Create the exception event
+            pafuws_evt = ccipdrv_event_afu_afufreecws_create(pownerSess->m_device,
+                                                           Message->m_tranID,
+                                                           Message->m_context,
+                                                           uid_errnumBadParameter);
+
+            PDEBUG("Sending WKSP_FREE Exception\n");
+            // Send the event
+            ccidrv_sendevent(pownerSess,
+                             AALQIP(pafuws_evt));
+
+            retval = -EFAULT;
+            goto ERROR;
+         }
+
+         // Free the buffer
+         if(  WSM_TYPE_VIRTUAL != wsidp->m_type ) {
+            PDEBUG( "Workspace free failed due to bad WS type. Should be %d but received %d\n",WSM_TYPE_VIRTUAL,
+                  wsidp->m_type);
+
+            pafuws_evt = ccipdrv_event_afu_afufreecws_create(pownerSess->m_device,
+                                                           Message->m_tranID,
+                                                           Message->m_context,
+                                                           uid_errnumBadParameter);
+            ccidrv_sendevent(pownerSess,
+                             AALQIP(pafuws_evt));
+
+            retval = -EFAULT;
+            goto ERROR;
+         }
+
+         krnl_virt = (btVirtAddr)wsidp->m_id;
+
+         kosal_free_contiguous_mem(krnl_virt, wsidp->m_size);
+
+         // remove the wsid from the device and destroy
+         kosal_list_del_init(&wsidp->m_list);
+         ccidrv_freewsid(wsidp);
+
+         // Create the  event
+         pafuws_evt = ccipdrv_event_afu_afufreecws_create(pownerSess->m_device,
+                                                        Message->m_tranID,
+                                                        Message->m_context,
+                                                        uid_errnumOK);
+
+         PVERBOSE("Sending the WKSP Free event.\n");
+         // Send the event
+         ccidrv_sendevent(pownerSess,
+                          AALQIP(pafuws_evt));
+         goto CLEANUP;
+      } break; // case fappip_afucmdWKSP_FREE
+
+      default: {
+
+         PDEBUG("Unrecognized command %" PRIu64 " or 0x%" PRIx64 " in AFUCommand\n", pmsg->cmd, pmsg->cmd);
+         Message->m_errcode = request_error;
+         retval = -EINVAL;
+
+         kosal_sem_put(cci_dev_pr_sem(pdev));
+
+       return retval;
+      } break;
+   } // switch (pmsg->cmd)
+
+   ASSERT(0 == retval);
+
+CLEANUP:
+    kosal_sem_put(cci_dev_pr_sem(pdev));
+    PDEBUG("UN-LOCK RECONF \n");
+    return retval;
+
+ERROR:
+   kosal_sem_put(cci_dev_pr_sem(pdev));
+   PDEBUG("UN-LOCK RECONF \n");
+   return retval;
+}
+
+
+//=============================================================================
+/// Name: getport_device
+/// @brief get port device  pointer
+///
+/// @param[in] pdev    -aal device pointer
+/// @param[in] portId  -port index
+/// @return    port device pointer
+//=============================================================================
+struct port_device * getport_device(struct cci_aal_device  *pdev , int portId)
+{
+   struct ccip_device   *pccidev    = NULL;
+   struct list_head     *This       = NULL;
+   struct list_head     *tmp        = NULL;
+   struct port_device   *pport_dev = NULL;
+
+   PTRACEIN;
+
+   //lock g_device_list
+   //kosal_sem_get_krnl(&g_dev_list_sem);
+
+   // Search through our list of devices to find the one matching pcidev
+   if ( !kosal_list_is_empty(&g_device_list) ) {
+
+      // Run through list of devices.  Use safe variant
+      //  as we will be deleting entries
+      kosal_list_for_each_safe(This, tmp, &g_device_list) {
+
+         pccidev = ccip_list_to_ccip_device(This);
+
+         // get port device if matching Bus, Device, function of PCIe device
+         if (pdev->m_pcidev->bus->number == ccip_dev_pcie_busnum(pccidev) &&
+            PCI_SLOT(pdev->m_pcidev->devfn) == ccip_dev_pcie_devnum(pccidev) &&
+            PCI_FUNC(pdev->m_pcidev->devfn) == ccip_dev_pcie_fcnnum(pccidev)) {
+
+             pport_dev = pccidev->m_pport_dev[portId];
+         }
+         
+      }
+   }
+   //unlock g_device_list
+   //kosal_sem_put(&g_dev_list_sem);
+
+   PTRACEOUT;
+   return pport_dev;
+}
diff --git a/drivers/fpga/aal/cci/ccip_pr.h b/drivers/fpga/aal/cci/ccip_pr.h
new file mode 100644
index 000000000000..73731cb92655
--- /dev/null
+++ b/drivers/fpga/aal/cci/ccip_pr.h
@@ -0,0 +1,309 @@
+//******************************************************************************
+// This  file  is  provided  under  a  dual BSD/GPLv2  license.  When using or
+//         redistributing this file, you may do so under either license.
+//
+//                            GPL LICENSE SUMMARY
+//
+//  Copyright(c) 2015-2017, Intel Corporation.
+//
+//  This program  is  free software;  you  can redistribute it  and/or  modify
+//  it  under  the  terms of  version 2 of  the GNU General Public License  as
+//  published by the Free Software Foundation.
+//
+//  This  program  is distributed  in the  hope that it  will  be useful,  but
+//  WITHOUT   ANY   WARRANTY;   without   even  the   implied   warranty    of
+//  MERCHANTABILITY  or  FITNESS  FOR  A  PARTICULAR  PURPOSE.  See  the   GNU
+//  General Public License for more details.
+//
+//  The  full  GNU  General Public License is  included in  this  distribution
+//  in the file called README.GPLV2-LICENSE.TXT.
+//
+//  Contact Information:
+//  Henry Mitchel, henry.mitchel at intel.com
+//  77 Reed Rd., Hudson, MA  01749
+//
+//                                BSD LICENSE
+//
+//  Copyright(c) 2015-2017, Intel Corporation.
+//
+//  Redistribution and  use  in source  and  binary  forms,  with  or  without
+//  modification,  are   permitted  provided  that  the  following  conditions
+//  are met:
+//
+//    * Redistributions  of  source  code  must  retain  the  above  copyright
+//      notice, this list of conditions and the following disclaimer.
+//    * Redistributions in  binary form  must  reproduce  the  above copyright
+//      notice,  this  list of  conditions  and  the  following disclaimer  in
+//      the   documentation   and/or   other   materials   provided  with  the
+//      distribution.
+//    * Neither   the  name   of  Intel  Corporation  nor  the  names  of  its
+//      contributors  may  be  used  to  endorse  or promote  products derived
+//      from this software without specific prior written permission.
+//
+//  THIS  SOFTWARE  IS  PROVIDED  BY  THE  COPYRIGHT HOLDERS  AND CONTRIBUTORS
+//  "AS IS"  AND  ANY  EXPRESS  OR  IMPLIED  WARRANTIES,  INCLUDING,  BUT  NOT
+//  LIMITED  TO, THE  IMPLIED WARRANTIES OF  MERCHANTABILITY  AND FITNESS  FOR
+//  A  PARTICULAR  PURPOSE  ARE  DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT
+//  OWNER OR CONTRIBUTORS BE LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,
+//  SPECIAL,  EXEMPLARY,  OR  CONSEQUENTIAL   DAMAGES  (INCLUDING,   BUT   NOT
+//  LIMITED  TO,  PROCUREMENT  OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF USE,
+//  DATA,  OR PROFITS;  OR BUSINESS INTERRUPTION)  HOWEVER  CAUSED  AND ON ANY
+//  THEORY  OF  LIABILITY,  WHETHER  IN  CONTRACT,  STRICT LIABILITY,  OR TORT
+//  (INCLUDING  NEGLIGENCE  OR OTHERWISE) ARISING  IN ANY WAY  OUT  OF THE USE
+//  OF  THIS  SOFTWARE, EVEN IF ADVISED  OF  THE  POSSIBILITY  OF SUCH DAMAGE.
+//******************************************************************************
+//****************************************************************************
+/// @file ccip_port.h
+/// @brief  Definitions for CCI Port.
+/// @ingroup aalkernel_ccip
+/// @verbatim
+//        FILE: ccip_port.h
+//     CREATED: Sept 24, 2015
+//      AUTHOR: Ananda Ravuri, Intel <ananda.ravuri@intel.com>
+//              Joseph Grecco, Intel <joe.grecco@intel.com>
+//
+// PURPOSE:   This file contains the definations of the CCIP Port
+//             Device Feature List and CSR.
+// HISTORY:
+// COMMENTS:
+// WHEN:          WHO:     WHAT:
+//****************************************************************************///
+#ifndef __AALKERNEL_CCIP_PR_H_
+#define __AALKERNEL_CCIP_PR_H_
+
+#include <aalsdk/kernel/aaltypes.h>
+#include <aalsdk/kernel/ccip_defs.h>
+#include "cci_pcie_driver_internal.h"
+
+#include "aalsdk/kernel/ccipdriver.h"
+
+BEGIN_NAMESPACE(AAL)
+
+
+// Maximum  PR timeout  10 seconds
+#define  PR_OUTSTADREQ_TIMEOUT   8000000
+#define  PR_OUTSTADREQ_DELAY     1000
+#define  PR_COUNTER_MAX_TRY      0xFFFFFF
+
+// PR revoke Maximum try count
+#define PR_AFU_REVOKE_MAX_TRY 400
+
+// PR revoke work queue timeout in milliseconds
+#define PR_WQ_REVOKE_TIMEOUT 10
+
+// PR AFU Deactivated work queue timeout in milliseconds
+#define PR_WQ_TIMEOUT 0
+
+// AFU Resource Release queue timeout in milliseconds
+#define AFU_RES_RELEASE_TIMEOUT 5
+
+// Power Manager PR response  10 seconds
+#define PWRMGR_RESPONSE_TIMEOUT  1000000
+
+//#define PWRMGR   1;
+
+// Green Bit stream Header
+struct __attribute__((__packed__))  CCIP_GBS_HEADER {
+
+   btByte                          m_digst[256];                   // Digital signature
+   btByte                          m_mesgDist[32];                 // Message digest
+   btByte                          m_intelpub_key[260];            // Intel public key
+   btByte                          m_hash_pubkey[32];              // Hash of public key
+   btByte                          m_md_afu[16];                   // GB meta Data structure
+   btByte                          m_md_slot_type_uuid[16];        // Partial bitstream slot type UUID
+   btUnsigned32bitInt              m_md_afu_power;                 // Partial bitstream power
+   btByte                          m_md_port;                      // Partial bitstream port
+   btUnsigned16bitInt              m_md_latency;                   // Partial bitstream latency
+   btUnsigned32bitInt              m_md_clknum;                    // Partial bitstream clock number
+   btUnsigned32bitInt              m_md_btlength;                  // Partial bitstream length *
+
+};
+
+///============================================================================
+/// Name: pr_program_context
+/// @brief PR worker thread device context
+///
+///============================================================================
+struct pr_program_context
+{
+   struct kosal_work_object         m_workobject;
+   btUnsigned64bitInt               m_cmd;
+   struct port_device              *m_pportdev;
+   struct cci_aal_device           *m_pPR_dev;
+   struct cci_aal_device           *m_pAFU_dev;
+   struct cci_aal_device           *m_pSigtap_dev;
+   struct aaldev_ownerSession      *m_pownerSess;
+   btVirtAddr                       m_kbufferptr;
+   btWSSize                         m_bufferlen;
+   int                              m_prregion_id ;
+   btTime                           m_reconfTimeout;
+   btUnsigned64bitInt               m_reconfAction;
+   uid_afurespID_e                  m_respID;
+   btUnsigned64bitInt               m_evt_data;
+   uid_errnum_e                     m_eno;
+   btBool                           m_leaveDeactivated;
+   btUnsigned64bitInt               m_afuRevokeCount;
+   btUnsigned64bitInt               m_sigtapRevokeCount;
+   btUnsigned64bitInt               m_timeElapsed;
+   stTransactionID_t                m_pwrReqTranID;
+   struct CCIP_GBS_HEADER          *m_gbs_header;
+};
+
+
+
+/// Name: program_afu_callback
+/// @brief Reconfigures  AFU with bitstream
+///
+/// @param[in] pr_context - pr program context
+/// @return    void
+void program_afu_callback(struct kosal_work_object * pwork);
+
+/// Name: reconfigure_activateAFU
+/// @brief Activates afu after reconfiguration
+///
+///
+/// @param[in] pportdev - Port device pointer
+/// @param[in] pdev - cci aal device pointer
+/// @return    AFU activate status
+btBool  reconfigure_activateAFU(struct port_device  *pportdev,struct cci_aal_device  *pdev );
+
+/// Name: afu_request_release_revoke_sendevent
+/// @brief Sends Release and Revoke event to Resource Owners
+///
+/// @param[in] pr_context -pr configuration context
+/// @return    void
+void afu_request_release_revoke_sendevent(void* pr_context, btBool releaseAFU);
+
+/// Name: sigtap_revoke_sendevent
+/// @brief Sends Revoke event to Resource Owners
+///
+/// @param[in] pr_context -pr configuration context
+/// @return    void
+void sigtap_revoke_sendevent(void* pr_context);
+
+/// Name: deactiavted_afu_device
+/// @brief unpublish and deactivates AFU
+///
+/// @param[in] pportdev -port device pointer
+/// @return    void
+void deactiavted_afu_device(struct port_device  *pportdev);
+
+/// Name: afu_revoke_callback
+/// @brief Revokes AFU from applications
+///
+/// @param[in] pr_context -pr configuration context
+/// @param[in] ptr - null pointer.
+/// @return    void
+void afu_revoke_callback(struct kosal_work_object *pwork);
+
+/// Name: afu_release_siganltap
+/// @brief Releases AFU Resources and program afu
+///
+/// @param[in] pr_context -pr configuration context
+/// @return    void
+void afu_release_siganltap(void* pr_context);
+
+/// Name: sigtap_revoke_callback
+/// @brief Revokes AFU from applications
+///
+/// @param[in] pr_context -pr configuration context
+/// @return    void
+void sigtap_revoke_callback(struct kosal_work_object *pwork);
+
+/// Name: afu_release_timeout_callback
+/// @brief AFU Deactivate /reconfigure timeout callback
+///
+/// @param[in] pr_context -pr configuration context
+/// @return    void
+void afu_release_timeout_callback(struct kosal_work_object *pwork);
+
+/// Name: pwrmgr_timeout_callback
+/// @brief Power manager  timeout callback
+///
+/// @param[in] pr_context -pr configuration context
+/// @return    void
+void pwrmgr_timeout_callback(struct kosal_work_object * pwork);
+
+/// Name: reconfigure_bitstream
+/// @brief Core Idle is done Start PR
+///
+/// @param[in] pr_context -pr configuration context
+/// @return    void
+void reconfigure_bitstream(struct pr_program_context* ppr_context);
+
+
+/// Name: reconfigure_bitstream_cancelPwrmgrTimer
+/// @brief Core Idle is done Start PR
+///
+/// @param[in] pr_context -pr configuration context
+/// @param[in] pr_pwrmgmt_status -Core Idle Status
+/// @return    void
+void  reconfigure_bitstream_cancelPwrmgrTimer(struct pr_program_context* ppr_program_ctx,
+                                              int pr_pwrmgmt_status);
+
+/// Name: send_event_to_pwrmgr
+/// @brief Sends event ot power manager
+///
+/// @param[in] pr_context -pr configuration context
+/// @return    error code if fails , 0 if pass
+int send_event_to_pwrmgr(struct pr_program_context* ppr_context,int power_required);
+
+/// Name: getport_device
+/// @brief get port device  pointer
+///
+/// @param[in] pdev    -aal device pointer
+/// @param[in] portId  -port index
+/// @return    port device pointer
+struct port_device * getport_device(struct cci_aal_device  *pdev , int portId);
+
+/// Name: ccipdrv_event_afu_aysnc_pr_release_send
+/// @brief sends event to application
+///
+/// @param[in] pr_context - pr program context
+/// @param[in] pr_context - pr program context
+/// @param[in] respID - pr response ID
+/// @param[in] devhandle - device handle
+/// @param[in] tranID -  transaction  ID
+/// @param[in] context -  application context
+/// @param[in] eno - pr error
+/// @return    void
+void ccipdrv_event_afu_aysnc_pr_release_send(struct pr_program_context *ppr_program_ctx,
+                                             uid_errnum_e  eno);
+
+/// Name: ccipdrv_event_reconfig_event_create_send
+/// @brief sends event to application
+///
+/// @param[in] pr_context - pr program context
+/// @param[in] respID - pr response ID
+/// @param[in] devhandle - device handle
+/// @param[in] tranID -  transaction  ID
+/// @param[in] context -  application context
+/// @param[in] eno - pr error
+/// @return    void
+void ccipdrv_event_reconfig_event_create_send( struct pr_program_context *ppr_program_ctx,
+                                               uid_afurespID_e            respID,
+                                               btObjectType               devhandle,
+                                               stTransactionID_t          *tranID,
+                                               btObjectType               context,
+                                               uid_errnum_e               errnum);
+
+/// Name: ccipdrv_event_activationchange_event_create_send
+/// @brief sends event to application
+///
+/// @param[in] pr_context - pr program context
+/// @param[in] respID - pr response ID
+/// @param[in] devhandle - device handle
+/// @param[in] tranID -  transaction  ID
+/// @param[in] context -  application context
+/// @param[in] eno - pr error
+/// @return    void
+void  ccipdrv_event_activationchange_event_create_send( struct pr_program_context *ppr_program_ctx,
+                                                        uid_afurespID_e            respID,
+                                                        btObjectType               devhandle,
+                                                        stTransactionID_t          *tranID,
+                                                        btObjectType               context,
+                                                        uid_errnum_e               errnum);
+
+END_NAMESPACE(AAL)
+
+#endif /* __AALKERNEL_CCIP_PR_H_ */
diff --git a/drivers/fpga/aal/cci/ccip_pwr.c b/drivers/fpga/aal/cci/ccip_pwr.c
new file mode 100644
index 000000000000..ec17035bb32c
--- /dev/null
+++ b/drivers/fpga/aal/cci/ccip_pwr.c
@@ -0,0 +1,445 @@
+//******************************************************************************
+// This  file  is  provided  under  a  dual BSD/GPLv2  license.  When using or
+//         redistributing this file, you may do so under either license.
+//
+//                            GPL LICENSE SUMMARY
+//
+//  Copyright(c) 2015-2017, Intel Corporation.
+//
+//  This program  is  free software;  you  can redistribute it  and/or  modify
+//  it  under  the  terms of  version 2 of  the GNU General Public License  as
+//  published by the Free Software Foundation.
+//
+//  This  program  is distributed  in the  hope that it  will  be useful,  but
+//  WITHOUT   ANY   WARRANTY;   without   even  the   implied   warranty    of
+//  MERCHANTABILITY  or  FITNESS  FOR  A  PARTICULAR  PURPOSE.  See  the   GNU
+//  General Public License for more details.
+//
+//  The  full  GNU  General Public License is  included in  this  distribution
+//  in the file called README.GPLV2-LICENSE.TXT.
+//
+//  Contact Information:
+//  Henry Mitchel, henry.mitchel at intel.com
+//  77 Reed Rd., Hudson, MA  01749
+//
+//                                BSD LICENSE
+//
+//  Copyright(c) 2015-2017, Intel Corporation.
+//
+//  Redistribution and  use  in source  and  binary  forms,  with  or  without
+//  modification,  are   permitted  provided  that  the  following  conditions
+//  are met:
+//
+//    * Redistributions  of  source  code  must  retain  the  above  copyright
+//      notice, this list of conditions and the following disclaimer.
+//    * Redistributions in  binary form  must  reproduce  the  above copyright
+//      notice,  this  list of  conditions  and  the  following disclaimer  in
+//      the   documentation   and/or   other   materials   provided  with  the
+//      distribution.
+//    * Neither   the  name   of  Intel  Corporation  nor  the  names  of  its
+//      contributors  may  be  used  to  endorse  or promote  products derived
+//      from this software without specific prior written permission.
+//
+//  THIS  SOFTWARE  IS  PROVIDED  BY  THE  COPYRIGHT HOLDERS  AND CONTRIBUTORS
+//  "AS IS"  AND  ANY  EXPRESS  OR  IMPLIED  WARRANTIES,  INCLUDING,  BUT  NOT
+//  LIMITED  TO, THE  IMPLIED WARRANTIES OF  MERCHANTABILITY  AND FITNESS  FOR
+//  A  PARTICULAR  PURPOSE  ARE  DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT
+//  OWNER OR CONTRIBUTORS BE LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,
+//  SPECIAL,  EXEMPLARY,  OR  CONSEQUENTIAL   DAMAGES  (INCLUDING,   BUT   NOT
+//  LIMITED  TO,  PROCUREMENT  OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF USE,
+//  DATA,  OR PROFITS;  OR BUSINESS INTERRUPTION)  HOWEVER  CAUSED  AND ON ANY
+//  THEORY  OF  LIABILITY,  WHETHER  IN  CONTRACT,  STRICT LIABILITY,  OR TORT
+//  (INCLUDING  NEGLIGENCE  OR OTHERWISE) ARISING  IN ANY WAY  OUT  OF THE USE
+//  OF  THIS  SOFTWARE, EVEN IF ADVISED  OF  THE  POSSIBILITY  OF SUCH DAMAGE.
+//******************************************************************************
+//****************************************************************************
+/// @file ccip_pwr.c
+/// @brief  Definitions for ccip Power AAL device.
+/// @ingroup aalkernel_ccip
+/// @verbatim
+//        FILE: ccip_pwr.c
+//     CREATED: July 25, 2016
+//      AUTHOR:
+//
+// PURPOSE:   This file contains the implementation of the CCIP Signal Tap
+//             low-level function (i.e., Physical Interface Protocol driver).
+// HISTORY:
+// COMMENTS:
+// WHEN:          WHO:     WHAT:
+//****************************************************************************///
+#include "aalsdk/kernel/kosal.h"
+#define MODULE_FLAGS CCIPCIE_DBG_MOD
+
+#include "aalsdk/kernel/AALTransactionID_s.h"
+#include "aalsdk/kernel/aalbus-ipip.h"
+#include "aalsdk/kernel/ccip_defs.h"
+
+#include "aalsdk/kernel/ccipdriver.h"
+#include "ccipdrv-events.h"
+
+#include "ccip_port.h"
+#include "ccip_fme.h"
+#include "cci_pcie_driver_PIPsession.h"
+
+extern btUnsigned32bitInt sim;
+
+///////////////////////////////////////////////////////////////////////////////
+///////////////////////////////////////////////////////////////////////////////
+////////////////////                                     //////////////////////
+/////////////////              PIP INTERFACE               ////////////////////
+////////////////////                                     //////////////////////
+///////////////////////////////////////////////////////////////////////////////
+///////////////////////////////////////////////////////////////////////////////
+
+static int CommandHandler( struct aaldev_ownerSession *,
+                           struct aal_pipmessage*);
+
+// TODO going to try and use a common mmapper for all objects
+extern int cci_mmap( struct aaldev_ownerSession *pownerSess,
+                     struct aal_wsid *wsidp,
+                     btAny os_specific );
+
+
+///=============================================================================
+/// Name: cci_PWRpip
+/// @brief Physical Interface Protocol Interface for the power AFU
+///              kernel based AFU engine.
+///=============================================================================
+struct aal_ipip cci_PWRpip = {
+   .m_messageHandler = {
+      .sendMessage   = CommandHandler,       // Command Handler
+      .bindSession   = BindSession,          // Session binder
+      .unBindSession = UnbindSession,        // Session unbinder
+   },
+
+   .m_fops = {
+     .mmap = cci_mmap,
+   },
+
+   // Methods for binding and unbinding PIP to generic aal_device
+   //  Unused in this PIP
+   .binddevice    = NULL,      // Binds the PIP to the device
+   .unbinddevice  = NULL,      // Binds the PIP to the device
+};
+
+///============================================================================
+/// Name: cci_create_AAL_power_Device
+/// @brief Creates and registers Power objects (resources) we want to expose
+///        Through AAL.
+///
+/// @param[in] pccipdev - CCI Board object .
+/// @return    error code
+///============================================================================
+btBool cci_create_AAL_power_Device(struct ccip_device * pccipdev)
+{
+   struct cci_aal_device   *pcci_aaldev = NULL;
+   struct aal_device_id     aalid;
+   int ret;
+
+   PTRACEIN;
+
+   // Construct the cci_aal_device object
+   pcci_aaldev = cci_create_aal_device();
+
+   ASSERT(NULL != pcci_aaldev);
+   if( NULL == pcci_aaldev){
+      return false;
+   }
+
+
+   // Make it a User AFU
+   cci_aaldev_type(pcci_aaldev)     = cci_dev_PWR;
+
+   // Record parentage
+   cci_aaldev_pfme(pcci_aaldev) = ccip_dev_to_fme_dev(pccipdev);
+   cci_aaldev_pci_dev(pcci_aaldev) = ccip_dev_to_pci_dev(pccipdev);
+
+
+   // Device Address is the same as the Port. Set the AFU ID information
+   // The following attributes describe the interfaces supported by the device
+   aaldevid_afuguidl(aalid)            = CCIP_PWR_GUIDL;
+   aaldevid_afuguidh(aalid)            = CCIP_PWR_GUIDH;
+   aaldevid_pipguid(aalid)             = CCIP_PWR_PIPIID;
+
+   aaldevid_devaddr_bustype(aalid)     =  ccip_dev_pcie_bustype(pccipdev);
+
+   aaldevid_devaddr_busnum(aalid)      = ccip_dev_pcie_busnum(pccipdev);
+   aaldevid_devaddr_devnum(aalid)      = ccip_dev_pcie_devnum(pccipdev);
+   aaldevid_devaddr_fcnnum(aalid)      = ccip_dev_pcie_fcnnum(pccipdev);
+   aaldevid_devaddr_subdevnum(aalid)   = aaldevid_devaddr_fcnnum(aalid)++;  // PWR subdevice number is constant
+   aaldevid_devaddr_instanceNum(aalid) = 0;  // PWR is always instance 0
+   aaldevid_devaddr_socketnum(aalid)   = ccip_dev_pcie_socketnum(pccipdev);
+
+   aaldevid_devtype(aalid)             = aal_devtypeAFU;
+
+   // Setup the MMIO region parameters
+   // Create the AAL device and attach it to the CCI device object
+   cci_aaldev_to_aaldev(pcci_aaldev) =  aaldev_create( "CCIPPWR",         // AAL device base name
+                                                       &aalid,             // AAL ID
+                                                       &cci_PWRpip);
+
+   //CCI device object create fails, delete Power AAL device
+   if(NULL == cci_aaldev_to_aaldev(pcci_aaldev) ){
+      cci_destroy_aal_device(pcci_aaldev);
+      return false;
+   }
+
+   //===========================================================
+   // Set up the optional aal_device attributes
+   //
+
+   // Set how many owners are allowed access to this device simultaneously
+   cci_aaldev_to_aaldev(pcci_aaldev)->m_maxowners = 1;
+
+   // Set the config space mapping permissions
+   cci_aaldev_to_aaldev(pcci_aaldev)->m_mappableAPI = AAL_DEV_APIMAP_NONE;
+
+   // The PIP uses the PIP context to get a handle to the CCI Device from the generic device.
+   aaldev_pip_context(cci_aaldev_to_aaldev(pcci_aaldev)) = (void*)pcci_aaldev;
+
+   // Method called when the device is released (i.e., its destructor)
+   //  The canonical release device calls the user's release method.
+   //  If NULL is provided then only the canonical behavior is done
+   dev_setrelease(cci_aaldev_to_aaldev(pcci_aaldev), cci_release_device);
+
+      // Device is ready for use.  Publish it with the Configuration Management Subsystem
+   ret = cci_publish_aaldevice(pcci_aaldev);
+   ASSERT(ret == 0);
+   if(0> ret){
+      PERR("Failed to initialize AAL Device for CCIPPWR[%d:%d:%d:%d]",aaldevid_devaddr_busnum(aalid),
+                                                                       aaldevid_devaddr_devnum(aalid),
+                                                                       aaldevid_devaddr_fcnnum(aalid),
+                                                                       aaldevid_devaddr_subdevnum(aalid));
+      cci_destroy_aal_device(pcci_aaldev);
+      return false;
+   }
+
+   ccip_dev_to_fme_dev(pccipdev)->m_power_aaldev= pcci_aaldev;
+
+   kosal_list_add(&cci_aaldev_list_head(pcci_aaldev), &ccip_aal_dev_list(pccipdev));
+
+   return true;
+}
+
+
+//=============================================================================
+// Name: CommandHandler
+// Description: Implements the PIP command handler
+// Interface: public
+// Inputs: pownerSess - Session between App and device
+//         Message - Message to process
+// Outputs: none.
+// Comments:
+//=============================================================================
+int
+CommandHandler(struct aaldev_ownerSession *pownerSess,
+               struct aal_pipmessage       *Message)
+{
+#if (1 == ENABLE_DEBUG)
+#define AFU_COMMAND_CASE(x) case x : PDEBUG("%s\n", #x);
+#else
+#define AFU_COMMAND_CASE(x) case x :
+#endif // ENABLE_DEBUG
+
+
+   // Private session object set at session bind time (i.e., when object allocated)
+   struct cci_PIPsession *pSess = (struct cci_PIPsession *)aalsess_pipHandle(pownerSess);
+   struct cci_aal_device  *pdev  = NULL;
+
+   // Overall return value for this function. Set before exiting if there is an error.
+   //    retval = 0 means good return.
+   int retval = 0;
+
+   // UI Driver message
+   struct aalui_CCIdrvMessage *pmsg = (struct aalui_CCIdrvMessage *) Message->m_message;
+
+   // Save original response buffer size in case we return something
+   //btWSSize         respBufSize     = Message->m_respbufSize;
+
+   // Assume returning nothing. By setting the response buffer size to 0
+   //   we tell the upstream side that there is no payload to copy back.
+   //   Setting it here means we don't have to set it (or forget to) in each
+   //   command.  We've recorded the payload buffer size above if we do need
+   //   intend to send a payload.
+   Message->m_respbufSize          = 0;
+
+   PTRACEIN;
+
+   // Perform some basic checks while assigning the pdev
+   ASSERT(NULL != pSess );
+   if ( NULL == pSess ) {
+      PDEBUG("Error: No PIP session\n");
+      return -EIO;
+   }
+
+   // Get the cci device
+   pdev = cci_PIPsessionp_to_ccidev(pSess);
+   if ( NULL == pdev ) {
+      PDEBUG("Error: No device\n");
+      return -EIO;
+   }
+
+   //=====================
+   // Message processor
+   //=====================
+   switch ( pmsg->cmd ) {
+
+      AFU_COMMAND_CASE(ccipdrv_PwrMgrResponse) {
+
+         btInt  pr_pwrmgmt_status = 0;
+         struct ccidrvreq *preq = (struct ccidrvreq *)pmsg->payload;
+
+         if(NULL == preq) {
+            PERR("Invalid Input parameter \n");
+            Message->m_errcode = uid_errnumBadParameter;
+            break;
+         }
+         pr_pwrmgmt_status = preq->ahmreq.u.pr_pwrmgmt.pr_pwrmgmt_status;
+         if(0  == pr_pwrmgmt_status) {
+            PVERBOSE("Power Idle done.\n");
+         } else {
+            PVERBOSE("pr_pwrmgr_status:%d \n",pr_pwrmgmt_status);
+         }
+
+         // TBD check Trans ID ?
+
+
+         PVERBOSE("pSess->currTranID.m_intID:%lld \n",Message->m_tranID.m_intID);
+
+         PVERBOSE("preq->afutskTranID.m_intID:%lld \n",preq->afutskTranID.m_intID);
+
+         if(NULL != cci_aaldev_pfme(pdev)->m_pr_program_context) {
+            reconfigure_bitstream_cancelPwrmgrTimer(cci_aaldev_pfme(pdev)->m_pr_program_context,pr_pwrmgmt_status);
+         }
+         // Success Event
+         Message->m_errcode = uid_errnumOK;
+
+      } break;
+
+      default: {
+         // No payload
+         PDEBUG("Unrecognized command %" PRIu64 " or 0x%" PRIx64 " in AFUCommand\n", pmsg->cmd, pmsg->cmd);
+         Message->m_respbufSize          = 0;
+         Message->m_errcode = uid_errnumInvalidRequest;
+         retval = -EINVAL;
+      } break;
+   } // switch (pmsg->cmd)
+
+   ASSERT(0 == retval);
+
+   return retval;
+}
+
+///============================================================================
+/// Name: send_pr_power_event
+/// @brief   sends power request to power manager demon.
+///
+/// @param[in] pReconf_context AFU reconfiguration context
+/// @param[in] power_required  Power required
+/// @return    0 = success , non zero failure.
+///============================================================================
+bt32bitInt send_pr_power_event(struct pr_program_context* pReconf_context,
+                              int power_required)
+{
+   kosal_list_head *pitr              = NULL;
+   kosal_list_head *temp              = NULL;
+   struct aaldev_owner *pOwner        = NULL;
+   struct fme_device *pfme_dev        = NULL;
+   btInt socketID                     = 0;
+   btInt busID                        = 0;
+   btInt deviceID                     = 0;
+   btInt functionID                   = 0;
+   int res                            = 0;
+
+   struct ccipdrv_event_afu_response_event *pafuws_evt      = NULL;
+
+   PTRACEIN;
+
+   if( NULL == pReconf_context ) {
+      PERR("Invalid Input parameter \n");
+      res =-EINVAL;
+      return res;
+   }
+
+   // Storing PR Program Context
+   pfme_dev =cci_aaldev_pfme(pReconf_context->m_pPR_dev);
+   pfme_dev->m_pr_program_context = pReconf_context;
+
+   if (0 == pfme_dev->m_power_aaldev->m_aaldev->m_numowners ) {
+      PERR("Power AAL Resource   m_numowners 0 \n");
+      res =-EINVAL;
+      return res;
+   }
+
+   PVERBOSE( "Power owners count= %d \n", ccip_dev_fme_pwraal_dev(pfme_dev)->m_aaldev->m_numowners);
+
+   if ( unlikely( kosal_sem_get_user_alertable(&(ccip_dev_fme_pwraal_dev(pfme_dev)->m_aaldev->m_sem)) ) ) {
+      PDEBUG("kosal_sem_get_user_alertable interrupted \n");
+      res =-EINVAL;
+      return res;
+   }
+
+   // Send PR Power Request to owner application
+   if ( !kosal_list_is_empty(&(ccip_dev_fme_pwraal_dev(pfme_dev)->m_aaldev->m_ownerlist)) )  {
+
+      // Loop through the list looking for a match
+      kosal_list_for_each_safe(pitr, temp, &(pfme_dev->m_power_aaldev->m_aaldev->m_ownerlist)) {
+
+         // finds Power device owner
+         pOwner = kosal_container_of(pitr, struct aaldev_owner, m_ownerlist);
+         PVERBOSE(  "Power Owner pid= %d \n" , pOwner->m_pid);
+
+         pfme_dev->m_pr_program_context->m_pwrReqTranID.m_intID= 299;
+         // Sends Power Request to application
+         if(0 != sim){
+            pafuws_evt =ccipdrv_event_afu_aysnc_reconf_pwr_create( uid_afurespPwrMgrResponce,
+                                                                   pOwner->m_sess.m_device,
+                                                                   pOwner->m_sess.m_ownerContext,
+                                                                   1,
+                                                                   1,
+                                                                   1,
+                                                                   1,
+                                                                   25,
+                                                                   pfme_dev->m_pr_program_context->m_pwrReqTranID,
+                                                                   0);
+
+         } else {
+
+             busID        = ccip_dev_fme_pwraal_dev(pfme_dev)->m_pcidev->bus->number;
+             deviceID     = PCI_SLOT(ccip_dev_fme_pwraal_dev(pfme_dev)->m_pcidev->devfn);
+             functionID   = PCI_FUNC(ccip_dev_fme_pwraal_dev(pfme_dev)->m_pcidev->devfn);
+             socketID     = pfme_dev->m_pHDR->fab_capability.socket_id;
+
+             PDEBUG("busID %x\n", busID);
+             PDEBUG("deviceID %x\n", deviceID);
+             PDEBUG("functionID %x\n", functionID);
+             PDEBUG("socketID %x\n", socketID);
+             PDEBUG("power_required %d\n", power_required);
+
+             // get Power from GB
+             // Get Total Power  =  BB + SUM GB ?
+            pafuws_evt = ccipdrv_event_afu_aysnc_reconf_pwr_create( uid_afurespPwrMgrResponce,
+                                                                   pOwner->m_sess.m_device,
+                                                                   pOwner->m_sess.m_ownerContext,
+                                                                   socketID,
+                                                                   busID,
+                                                                   deviceID,
+                                                                   functionID,
+                                                                   power_required, // TDB
+                                                                   pfme_dev->m_pr_program_context->m_pwrReqTranID,
+                                                                   0);
+
+         }
+
+         ccidrv_sendevent(&(pOwner->m_sess),
+                          AALQIP(pafuws_evt));
+
+      } // end list
+
+   }// endif
+
+    kosal_sem_put(&pfme_dev->m_power_aaldev->m_aaldev->m_sem);
+
+   PTRACEOUT_INT(res);
+   return  res;
+}
diff --git a/drivers/fpga/aal/cci/ccip_pwr.h b/drivers/fpga/aal/cci/ccip_pwr.h
new file mode 100644
index 000000000000..d7c2b007dd92
--- /dev/null
+++ b/drivers/fpga/aal/cci/ccip_pwr.h
@@ -0,0 +1,92 @@
+//******************************************************************************
+// This  file  is  provided  under  a  dual BSD/GPLv2  license.  When using or
+//         redistributing this file, you may do so under either license.
+//
+//                            GPL LICENSE SUMMARY
+//
+//  Copyright(c) 2015-2017, Intel Corporation.
+//
+//  This program  is  free software;  you  can redistribute it  and/or  modify
+//  it  under  the  terms of  version 2 of  the GNU General Public License  as
+//  published by the Free Software Foundation.
+//
+//  This  program  is distributed  in the  hope that it  will  be useful,  but
+//  WITHOUT   ANY   WARRANTY;   without   even  the   implied   warranty    of
+//  MERCHANTABILITY  or  FITNESS  FOR  A  PARTICULAR  PURPOSE.  See  the   GNU
+//  General Public License for more details.
+//
+//  The  full  GNU  General Public License is  included in  this  distribution
+//  in the file called README.GPLV2-LICENSE.TXT.
+//
+//  Contact Information:
+//  Henry Mitchel, henry.mitchel at intel.com
+//  77 Reed Rd., Hudson, MA  01749
+//
+//                                BSD LICENSE
+//
+//  Copyright(c) 2015-2017, Intel Corporation.
+//
+//  Redistribution and  use  in source  and  binary  forms,  with  or  without
+//  modification,  are   permitted  provided  that  the  following  conditions
+//  are met:
+//
+//    * Redistributions  of  source  code  must  retain  the  above  copyright
+//      notice, this list of conditions and the following disclaimer.
+//    * Redistributions in  binary form  must  reproduce  the  above copyright
+//      notice,  this  list of  conditions  and  the  following disclaimer  in
+//      the   documentation   and/or   other   materials   provided  with  the
+//      distribution.
+//    * Neither   the  name   of  Intel  Corporation  nor  the  names  of  its
+//      contributors  may  be  used  to  endorse  or promote  products derived
+//      from this software without specific prior written permission.
+//
+//  THIS  SOFTWARE  IS  PROVIDED  BY  THE  COPYRIGHT HOLDERS  AND CONTRIBUTORS
+//  "AS IS"  AND  ANY  EXPRESS  OR  IMPLIED  WARRANTIES,  INCLUDING,  BUT  NOT
+//  LIMITED  TO, THE  IMPLIED WARRANTIES OF  MERCHANTABILITY  AND FITNESS  FOR
+//  A  PARTICULAR  PURPOSE  ARE  DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT
+//  OWNER OR CONTRIBUTORS BE LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,
+//  SPECIAL,  EXEMPLARY,  OR  CONSEQUENTIAL   DAMAGES  (INCLUDING,   BUT   NOT
+//  LIMITED  TO,  PROCUREMENT  OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF USE,
+//  DATA,  OR PROFITS;  OR BUSINESS INTERRUPTION)  HOWEVER  CAUSED  AND ON ANY
+//  THEORY  OF  LIABILITY,  WHETHER  IN  CONTRACT,  STRICT LIABILITY,  OR TORT
+//  (INCLUDING  NEGLIGENCE  OR OTHERWISE) ARISING  IN ANY WAY  OUT  OF THE USE
+//  OF  THIS  SOFTWARE, EVEN IF ADVISED  OF  THE  POSSIBILITY  OF SUCH DAMAGE.
+//******************************************************************************
+//****************************************************************************
+/// @file ccip_pwr.h
+/// @brief  Definitions for CCI Port.
+/// @ingroup aalkernel_ccip
+/// @verbatim
+//        FILE: ccip_pwr.h
+//     CREATED: July 25, 2016
+//      AUTHOR: Ananda Ravuri, Intel <ananda.ravuri@intel.com>
+//
+// PURPOSE:   This file contains the definations of the CCIP Port
+//             Device Feature List and CSR.
+// HISTORY:
+// COMMENTS:
+// WHEN:          WHO:     WHAT:
+//****************************************************************************///
+#ifndef __AALKERNEL_CCIP_PWR_H_
+#define __AALKERNEL_CCIP_PWR_H_
+
+#include <aalsdk/kernel/aaltypes.h>
+#include <aalsdk/kernel/ccip_defs.h>
+#include "cci_pcie_driver_internal.h"
+
+#include "aalsdk/kernel/ccipdriver.h"
+#include "ccip_pr.h"
+
+BEGIN_NAMESPACE(AAL)
+
+/// Name: send_pr_power_event
+/// @brief   sends power request to power manager demon.
+///
+/// @param[in] pReconf_context AFU reconfiguration context
+/// @param[in] power_required power consumed by green bitstream.
+/// @return    0 = success , non zero failure.
+bt32bitInt send_pr_power_event(struct pr_program_context* pReconf_context, int power_required);
+
+END_NAMESPACE(AAL)
+
+#endif /* __AALKERNEL_CCIP_PWR_H_ */
diff --git a/drivers/fpga/aal/cci/ccip_sim_mmio.c b/drivers/fpga/aal/cci/ccip_sim_mmio.c
new file mode 100644
index 000000000000..92c8a26b64a7
--- /dev/null
+++ b/drivers/fpga/aal/cci/ccip_sim_mmio.c
@@ -0,0 +1,1420 @@
+//******************************************************************************
+// This  file  is  provided  under  a  dual BSD/GPLv2  license.  When using or
+//         redistributing this file, you may do so under either license.
+//
+//                            GPL LICENSE SUMMARY
+//
+//  Copyright(c) 2015-2017, Intel Corporation.
+//
+//  This program  is  free software;  you  can redistribute it  and/or  modify
+//  it  under  the  terms of  version 2 of  the GNU General Public License  as
+//  published by the Free Software Foundation.
+//
+//  This  program  is distributed  in the  hope that it  will  be useful,  but
+//  WITHOUT   ANY   WARRANTY;   without   even  the   implied   warranty    of
+//  MERCHANTABILITY  or  FITNESS  FOR  A  PARTICULAR  PURPOSE.  See  the   GNU
+//  General Public License for more details.
+//
+//  The  full  GNU  General Public License is  included in  this  distribution
+//  in the file called README.GPLV2-LICENSE.TXT.
+//
+//  Contact Information:
+//  Henry Mitchel, henry.mitchel at intel.com
+//  77 Reed Rd., Hudson, MA  01749
+//
+//                                BSD LICENSE
+//
+//  Copyright(c) 2015-2017, Intel Corporation.
+//
+//  Redistribution and  use  in source  and  binary  forms,  with  or  without
+//  modification,  are   permitted  provided  that  the  following  conditions
+//  are met:
+//
+//    * Redistributions  of  source  code  must  retain  the  above  copyright
+//      notice, this list of conditions and the following disclaimer.
+//    * Redistributions in  binary form  must  reproduce  the  above copyright
+//      notice,  this  list of  conditions  and  the  following disclaimer  in
+//      the   documentation   and/or   other   materials   provided  with  the
+//      distribution.
+//    * Neither   the  name   of  Intel  Corporation  nor  the  names  of  its
+//      contributors  may  be  used  to  endorse  or promote  products derived
+//      from this software without specific prior written permission.
+//
+//  THIS  SOFTWARE  IS  PROVIDED  BY  THE  COPYRIGHT HOLDERS  AND CONTRIBUTORS
+//  "AS IS"  AND  ANY  EXPRESS  OR  IMPLIED  WARRANTIES,  INCLUDING,  BUT  NOT
+//  LIMITED  TO, THE  IMPLIED WARRANTIES OF  MERCHANTABILITY  AND FITNESS  FOR
+//  A  PARTICULAR  PURPOSE  ARE  DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT
+//  OWNER OR CONTRIBUTORS BE LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,
+//  SPECIAL,  EXEMPLARY,  OR  CONSEQUENTIAL   DAMAGES  (INCLUDING,   BUT   NOT
+//  LIMITED  TO,  PROCUREMENT  OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF USE,
+//  DATA,  OR PROFITS;  OR BUSINESS INTERRUPTION)  HOWEVER  CAUSED  AND ON ANY
+//  THEORY  OF  LIABILITY,  WHETHER  IN  CONTRACT,  STRICT LIABILITY,  OR TORT
+//  (INCLUDING  NEGLIGENCE  OR OTHERWISE) ARISING  IN ANY WAY  OUT  OF THE USE
+//  OF  THIS  SOFTWARE, EVEN IF ADVISED  OF  THE  POSSIBILITY  OF SUCH DAMAGE.
+//******************************************************************************
+//****************************************************************************
+//        FILE: ccip_sim_mmio.c
+//     CREATED:
+//      AUTHOR: Joseph Grecco, Intel <joe.grecco@intel.com>
+//              Ananda Ravuri, Intel <ananda.ravuri@intel.com>
+// PURPOSE:
+// HISTORY:
+// COMMENTS:
+// WHEN:          WHO:     WHAT:
+//****************************************************************************
+#include "aalsdk/kernel/kosal.h"
+
+#define MODULE_FLAGS CCIPCIE_DBG_MOD
+
+#include "aalsdk/kernel/aalbus.h"
+#include "aalsdk/kernel/aalinterface.h"
+#include "aalsdk/kernel/aalids.h"
+#include "aalsdk/kernel/aalrm.h"
+#include "aalsdk/kernel/aalqueue.h"
+#include "aalsdk/kernel/ccipdriver.h"
+#include "cci_pcie_driver_internal.h"
+#include "cci_pcie_driver_simulator.h"
+
+
+#include "ccip_fme.h"
+#include "ccip_port.h"
+
+#define OFFSET 0x8
+
+int  ccip_sim_wrt_fme_mmio(btVirtAddr pkvp_fme_mmio)
+{
+   struct CCIP_FME_HDR           fme_hdr;
+   struct CCIP_FME_DFL_THERM     fme_tmp;
+   struct CCIP_FME_DFL_PM        fme_pm;
+   struct CCIP_FME_DFL_FPMON     fme_fpmon;
+   struct CCIP_FME_DFL_GERROR    fme_gerror;
+   struct CCIP_FME_DFL_PR        fme_pr;
+   struct CCIP_PORT_AFU_OFFSET   portoffset;
+   struct CCIP_FME_PCIE1_ERROR   pcie1error;
+   struct CCIP_FME_ERROR0        firsterror;
+
+   int offset =0;
+
+   btVirtAddr ptr= pkvp_fme_mmio;
+
+   PINFO(" ccip_sim_wrt_fme_mmio ENTER\n");
+
+   // FME header
+   fme_hdr.dfh.Type =CCIP_DFType_afu;
+   fme_hdr.dfh.next_DFH_offset =0x1000;
+   fme_hdr.dfh.Feature_rev =0;
+   fme_hdr.dfh.Feature_ID =1;
+   fme_hdr.dfh.eol =0x0;
+   write_ccip_csr64(ptr,offset, fme_hdr.dfh.csr);
+
+   // FME AFU id low
+   fme_hdr.afu_id_l.afu_id_l = CCIP_FME_GUIDL;
+   offset = offset + OFFSET;
+   write_ccip_csr64(ptr,offset,fme_hdr.afu_id_l.csr);
+
+   // FME AFU id high
+   fme_hdr.afu_id_h.afu_id_h = CCIP_FME_GUIDH;
+   offset = offset + OFFSET;
+   write_ccip_csr64(ptr,offset,fme_hdr.afu_id_h.csr);
+
+   // FME next afu id offset
+   fme_hdr.next_afu.afu_id_offset=0x0;
+   offset = offset + OFFSET;
+   write_ccip_csr64(ptr,offset,fme_hdr.next_afu.csr);
+
+   // RSVD
+   fme_hdr.rsvd_fmehdr =0;
+   offset = offset + OFFSET;
+   write_ccip_csr64(ptr,offset,fme_hdr.rsvd_fmehdr);
+
+   // FME sratchpad csr
+   fme_hdr.scratchpad.scratch_pad = 0x1234568;
+   offset = offset + OFFSET;
+   write_ccip_csr64(ptr,offset, fme_hdr.scratchpad.csr);
+
+   // FME Capability CSR
+   fme_hdr.fab_capability.lock_bit =0x0;
+   fme_hdr.fab_capability.cache_assoc =0x0;
+   fme_hdr.fab_capability.cache_size = 0x10;
+   fme_hdr.fab_capability.address_width_bits =0x26;
+   fme_hdr.fab_capability.iommu_support =0x1;
+   fme_hdr.fab_capability.qpi_link_avile =0x01;
+   fme_hdr.fab_capability.pci0_link_avile =0x01;
+   fme_hdr.fab_capability.pci1_link_avile =0x01;
+   fme_hdr.fab_capability.socket_id =0x1;
+   fme_hdr.fab_capability.fabric_verid =0x1;
+   offset = offset + OFFSET;
+   write_ccip_csr64(ptr,offset,fme_hdr.fab_capability.csr);
+
+
+   // 3 simulated ports
+   //port 1
+   portoffset.port_imp =0x1;
+   portoffset.afu_access_control =0x1;
+   portoffset.port_bar =0x2;
+   portoffset.port_offset =0x00000;
+   offset = offset + OFFSET;
+   write_ccip_csr64(ptr,offset,portoffset.csr);
+
+   //port 2
+   portoffset.port_imp =0x1;
+   portoffset.afu_access_control =0x1;
+   portoffset.port_bar =0x1;
+   portoffset.port_offset =0x00000;
+   offset = offset + OFFSET;
+   write_ccip_csr64(ptr,offset,portoffset.csr);
+
+   //port 3
+   portoffset.port_imp =0x0;
+   portoffset.afu_access_control =0x1;
+   portoffset.port_bar =0x1;
+   portoffset.port_offset =0x80000;
+   offset = offset + OFFSET;
+   write_ccip_csr64(ptr,offset,portoffset.csr);
+
+   // FME Feature List
+
+   // FME Temperature Management  Feature
+
+   ptr = ptr+ fme_hdr.dfh.next_DFH_offset;
+   fme_tmp.ccip_fme_tmp_dflhdr.Type =CCIP_DFType_private;
+   fme_tmp.ccip_fme_tmp_dflhdr.next_DFH_offset =0x1000;
+   fme_tmp.ccip_fme_tmp_dflhdr.Feature_rev =0;
+   fme_tmp.ccip_fme_tmp_dflhdr.Feature_ID =CCIP_FME_DFLID_THERM;
+   fme_tmp.ccip_fme_tmp_dflhdr.eol =0x0;
+   offset = 0;
+   write_ccip_csr64(ptr,offset,fme_tmp.ccip_fme_tmp_dflhdr.csr);
+
+
+   // Temperature threshold csr
+   fme_tmp.ccip_tmp_threshold.therm_trip_thshold =0xa;
+   fme_tmp.ccip_tmp_threshold.therm_trip_thshold_status =0x1;
+   fme_tmp.ccip_tmp_threshold.thshold1_status =0x1;
+   fme_tmp.ccip_tmp_threshold.thshold2_status =0x1;
+   fme_tmp.ccip_tmp_threshold.thshold_policy =0x1;
+   fme_tmp.ccip_tmp_threshold.tmp_thshold1 =0xb;
+   fme_tmp.ccip_tmp_threshold.tmp_thshold1_status =0x1;
+   fme_tmp.ccip_tmp_threshold.tmp_thshold2 =0xc;
+   fme_tmp.ccip_tmp_threshold.tmp_thshold2_status =0x1;
+   offset = offset + OFFSET;
+   write_ccip_csr64(ptr,offset,fme_tmp.ccip_tmp_threshold.csr);
+
+   // Temperature Sensor1 csr
+   fme_tmp.ccip_tmp_rdssensor_fm1.dbg_mode =0x1;
+   fme_tmp.ccip_tmp_rdssensor_fm1.tmp_reading =0x55;
+   fme_tmp.ccip_tmp_rdssensor_fm1.tmp_reading_valid =0x1;
+   fme_tmp.ccip_tmp_rdssensor_fm1.tmp_reading_seq_num = 0xabcd;
+   offset = offset + OFFSET;
+   write_ccip_csr64(ptr,offset,fme_tmp.ccip_tmp_rdssensor_fm1.csr);
+
+
+   // Temperature Sensor2 csr
+   fme_tmp.ccip_tmp_rdssensor_fm2.rsvd =0x0;
+   offset = offset + OFFSET;
+   write_ccip_csr64(ptr,offset,fme_tmp.ccip_tmp_rdssensor_fm2.csr);
+
+   // FME Power Management  Feature
+
+   ptr = ptr+ fme_tmp.ccip_fme_tmp_dflhdr.next_DFH_offset;
+   fme_pm.ccip_fme_pm_dflhdr.Type =CCIP_DFType_private;
+   fme_pm.ccip_fme_pm_dflhdr.next_DFH_offset =0x1000;
+   fme_pm.ccip_fme_pm_dflhdr.Feature_rev =0;
+   fme_pm.ccip_fme_pm_dflhdr.Feature_ID= CCIP_FME_DFLID_POWER;
+   fme_pm.ccip_fme_pm_dflhdr.eol =0x0;
+   offset = 0 ;
+   write_ccip_csr64(ptr,offset,fme_pm.ccip_fme_pm_dflhdr.csr);
+
+
+   // Power Management status
+   fme_pm.pm_status.pwr_consumed = 0x299;
+   fme_pm.pm_status.fpga_latency_report = 0x1;
+
+   offset = offset + OFFSET;
+   write_ccip_csr64(ptr,offset,fme_pm.pm_status.csr);
+
+
+
+   // FME Global Performance header
+
+   ptr = ptr+ fme_pm.ccip_fme_pm_dflhdr.next_DFH_offset;
+   fme_fpmon.ccip_fme_fpmon_dflhdr.Type =CCIP_DFType_private;
+   fme_fpmon.ccip_fme_fpmon_dflhdr.next_DFH_offset =0x1000;
+   fme_fpmon.ccip_fme_fpmon_dflhdr.Feature_rev =0;
+   fme_fpmon.ccip_fme_fpmon_dflhdr.Feature_ID= CCIP_FME_DFLID_GPERF;
+   fme_fpmon.ccip_fme_fpmon_dflhdr.eol =0x0;
+   offset = 0;
+   write_ccip_csr64(ptr,offset,fme_fpmon.ccip_fme_fpmon_dflhdr.csr);
+
+   // Cache control
+   fme_fpmon.ccip_fpmon_ch_ctl.cache_event =0x6;
+   fme_fpmon.ccip_fpmon_ch_ctl.freeze =0x1;
+   offset = offset + OFFSET;
+   write_ccip_csr64(ptr,offset,fme_fpmon.ccip_fpmon_ch_ctl.csr);
+
+   // Cache Couter port 1
+   fme_fpmon.ccip_fpmon_ch_ctr_0.cache_counter =0x99;
+   offset = offset + OFFSET;
+   write_ccip_csr64(ptr,offset,fme_fpmon.ccip_fpmon_ch_ctr_0.csr);
+
+   // Cache Couter port 2
+   fme_fpmon.ccip_fpmon_ch_ctr_1.cache_counter =0x88;
+   offset = offset + OFFSET;
+   write_ccip_csr64(ptr,offset,fme_fpmon.ccip_fpmon_ch_ctr_1.csr);
+
+   // fabic control
+   fme_fpmon.ccip_fpmon_fab_ctl.ccip_port_filter =0x1;
+   fme_fpmon.ccip_fpmon_fab_ctl.port_id =0x1;
+   fme_fpmon.ccip_fpmon_fab_ctl.fabric_evt_code =0x5;
+   fme_fpmon.ccip_fpmon_fab_ctl.freeze =0x1;
+   offset = offset + OFFSET;
+   write_ccip_csr64(ptr,offset,fme_fpmon.ccip_fpmon_fab_ctl.csr);
+
+   // fabic ctr
+   fme_fpmon.ccip_fpmon_fab_ctr.fabric_counter= 0x77;
+   offset = offset + OFFSET;
+   write_ccip_csr64(ptr,offset,fme_fpmon.ccip_fpmon_fab_ctr.csr);
+
+   // clock
+   fme_fpmon.ccip_fpmon_clk_ctrs.afu_interf_clock =0x66;
+   offset = offset + OFFSET;
+   write_ccip_csr64(ptr,offset,fme_fpmon.ccip_fpmon_clk_ctrs.csr);
+
+   // FME Global Error header
+
+   ptr = ptr+ fme_fpmon.ccip_fme_fpmon_dflhdr.next_DFH_offset;
+   fme_gerror.ccip_gerror_dflhdr.Type =CCIP_DFType_private;
+   fme_gerror.ccip_gerror_dflhdr.next_DFH_offset =0x1000;
+   fme_gerror.ccip_gerror_dflhdr.Feature_rev =0;
+   fme_gerror.ccip_gerror_dflhdr.Feature_ID= CCIP_FME_DFLID_GERR;
+   fme_gerror.ccip_gerror_dflhdr.eol =0x0;
+   offset = 0;
+   write_ccip_csr64(ptr,offset,fme_gerror.ccip_gerror_dflhdr.csr);
+
+
+   // FME error mask
+   fme_gerror.fme_err_mask.fabric_err =0x1;
+   fme_gerror.fme_err_mask.fabFifo_uoflow =0x1;
+   fme_gerror.fme_err_mask.pcie0_poison_detected =0x1;
+   fme_gerror.fme_err_mask.pcie1_poison_detected =0x1;
+   fme_gerror.fme_err_mask.iommu_parity_error =0x1;
+   fme_gerror.fme_err_mask.afuerr_access_mismatch =0x1;
+
+
+   offset = offset + OFFSET;
+   write_ccip_csr64(ptr,offset,fme_gerror.fme_err_mask.csr);
+
+   // FME error
+   fme_gerror.fme_err.fabric_err =0x1;
+   fme_gerror.fme_err.fabFifo_uoflow =0x1;
+   fme_gerror.fme_err.pcie0_poison_detected =0x1;
+   fme_gerror.fme_err.pcie1_poison_detected =0x1;
+   fme_gerror.fme_err.iommu_parity_error =0x1;
+   fme_gerror.fme_err.afuerr_access_mismatch =0x1;
+
+   offset = offset + OFFSET;
+   write_ccip_csr64(ptr,offset,fme_gerror.fme_err.csr);
+
+   //PCIE0 error mask
+   fme_gerror.pcie0_err_mask.formattype_err = 0x1;
+   fme_gerror.pcie0_err_mask.MWAddr_err = 0x1;
+   fme_gerror.pcie0_err_mask.MWAddrLength_err = 0x1;
+   fme_gerror.pcie0_err_mask.MRAddr_err = 0x1;
+   fme_gerror.pcie0_err_mask.MRAddrLength_err = 0x1;
+   fme_gerror.pcie0_err_mask.cpl_tag_err = 0x1;
+   fme_gerror.pcie0_err_mask.cpl_status_err = 0x1;
+   fme_gerror.pcie0_err_mask.cpl_timeout_err = 0x1;
+
+   offset = offset + OFFSET;
+   write_ccip_csr64(ptr,offset,fme_gerror.pcie0_err_mask.csr);
+
+
+   //PCIE0 error
+   fme_gerror.pcie0_err.formattype_err = 0x1;
+   fme_gerror.pcie0_err.MWAddr_err = 0x1;
+   fme_gerror.pcie0_err.MWAddrLength_err = 0x1;
+   fme_gerror.pcie0_err.MRAddr_err = 0x1;
+   fme_gerror.pcie0_err.MRAddrLength_err = 0x1;
+   fme_gerror.pcie0_err.cpl_tag_err = 0x1;
+   fme_gerror.pcie0_err.cpl_status_err = 0x1;
+   fme_gerror.pcie0_err.cpl_timeout_err = 0x1;
+
+   offset = offset + OFFSET;
+   write_ccip_csr64(ptr,offset,fme_gerror.pcie0_err.csr);
+
+   //PCIE1 error mask
+   fme_gerror.pcie1_err_mask.formattype_err = 0x1;
+   fme_gerror.pcie1_err_mask.MWAddr_err = 0x1;
+   fme_gerror.pcie1_err_mask.MWAddrLength_err = 0x1;
+   fme_gerror.pcie1_err_mask.MRAddr_err = 0x1;
+   fme_gerror.pcie1_err_mask.MRAddrLength_err = 0x1;
+   fme_gerror.pcie1_err_mask.cpl_tag_err = 0x1;
+   fme_gerror.pcie1_err_mask.cpl_status_err = 0x1;
+   fme_gerror.pcie1_err_mask.cpl_timeout_err = 0x1;
+
+   offset = offset + OFFSET;
+   write_ccip_csr64(ptr,offset,fme_gerror.pcie1_err_mask.csr);
+
+
+   //PCIE1 error
+   fme_gerror.pcie1_err.formattype_err = 0x1;
+   fme_gerror.pcie1_err.MWAddr_err = 0x1;
+   fme_gerror.pcie1_err.MWAddrLength_err = 0x1;
+   fme_gerror.pcie1_err.MRAddr_err = 0x1;
+   fme_gerror.pcie1_err.MRAddrLength_err = 0x1;
+   fme_gerror.pcie1_err.cpl_tag_err = 0x1;
+   fme_gerror.pcie1_err.cpl_status_err = 0x1;
+   fme_gerror.pcie1_err.cpl_timeout_err = 0x1;
+
+   offset = offset + OFFSET;
+   write_ccip_csr64(ptr,offset,fme_gerror.pcie1_err.csr);
+
+
+   // FME First error
+
+   firsterror.fabric_err =0x1;
+   firsterror.fabFifo_uoflow =0x1;
+   firsterror.pcie0_poison_detected =0x1;
+
+   fme_gerror.fme_first_err.csr = firsterror.csr;
+   fme_gerror.fme_first_err.errReg_id =0x0;
+   offset = offset + OFFSET;
+   write_ccip_csr64(ptr,offset,fme_gerror.fme_first_err.csr);
+
+   // FME Next error
+   pcie1error.MWAddr_err = 0x1;
+   pcie1error.MWAddrLength_err = 0x1;
+   pcie1error.MRAddr_err = 0x1;
+   pcie1error.MRAddrLength_err = 0x1;
+   pcie1error.cpl_tag_err = 0x1;
+   pcie1error.cpl_status_err = 0x1;
+
+   fme_gerror.fme_next_err.csr = pcie1error.csr;
+   fme_gerror.fme_next_err.errReg_id =0x2;
+   offset = offset + OFFSET;
+   write_ccip_csr64(ptr,offset,fme_gerror.fme_next_err.csr);
+
+
+
+   // RAS Error maks
+   fme_gerror.ras_gerr_mask.temp_trash_ap1 = 0x1;
+   fme_gerror.ras_gerr_mask.temp_trash_ap2 = 0x1;
+   fme_gerror.ras_gerr_mask.pcie_error = 0x1;
+   fme_gerror.ras_gerr_mask.afufatal_error = 0x1;
+   fme_gerror.ras_gerr_mask.prochot_error = 0x1;
+   fme_gerror.ras_gerr_mask.afu_access_mismatch = 0x1;
+   fme_gerror.ras_gerr_mask.injected_warn_error = 0x1;
+   fme_gerror.ras_gerr_mask.pcie_poison_error = 0x1;
+   fme_gerror.ras_gerr_mask.gb_crc_err = 0x1;
+   fme_gerror.ras_gerr_mask.temp_trash_ap6 = 0x1;
+   fme_gerror.ras_gerr_mask.power_trash_ap1 = 0x1;
+   fme_gerror.ras_gerr_mask.power_trash_ap2 = 0x1;
+   fme_gerror.ras_gerr_mask.mbp_error = 0x1;
+
+   offset = offset + OFFSET;
+   write_ccip_csr64(ptr,offset,fme_gerror.ras_gerr_mask.csr);
+
+   // RAS Error
+   fme_gerror.ras_gerr.temp_trash_ap1 = 0x1;
+   fme_gerror.ras_gerr.temp_trash_ap2 = 0x1;
+   fme_gerror.ras_gerr.pcie_error = 0x1;
+   fme_gerror.ras_gerr.afufatal_error = 0x1;
+   fme_gerror.ras_gerr.prochot_error = 0x1;
+   fme_gerror.ras_gerr.afu_access_mismatch = 0x1;
+   fme_gerror.ras_gerr.injected_warn_error = 0x1;
+   fme_gerror.ras_gerr.pcie_poison_error = 0x1;
+   fme_gerror.ras_gerr.gb_crc_err = 0x1;
+   fme_gerror.ras_gerr.temp_trash_ap6 = 0x1;
+   fme_gerror.ras_gerr.power_trash_ap1 = 0x1;
+   fme_gerror.ras_gerr.power_trash_ap2 = 0x1;
+   fme_gerror.ras_gerr.mbp_error = 0x1;
+;
+
+   offset = offset + OFFSET;
+   write_ccip_csr64(ptr,offset,fme_gerror.ras_gerr.csr);
+
+
+   // RAS Error Mask
+   fme_gerror.ras_berror_mask.ktilink_fatal_err = 0x1;
+   fme_gerror.ras_berror_mask.tagcch_fatal_err = 0x1;
+   fme_gerror.ras_berror_mask.cci_fatal_err = 0x1;
+   fme_gerror.ras_berror_mask.ktiprpto_fatal_err = 0x1;
+   fme_gerror.ras_berror_mask.dma_fatal_err = 0x1;
+   fme_gerror.ras_berror_mask.iommu_catast_err = 0x1;
+   fme_gerror.ras_berror_mask.crc_catast_err = 0x1;
+   fme_gerror.ras_berror_mask.therm_catast_err = 0x1;
+   fme_gerror.ras_berror_mask.injected_fatal_err = 0x1;
+
+
+   offset = offset + OFFSET;
+   write_ccip_csr64(ptr,offset,fme_gerror.ras_berror_mask.csr);
+
+
+   // RAS Error
+   fme_gerror.ras_berror.ktilink_fatal_err = 0x1;
+   fme_gerror.ras_berror.tagcch_fatal_err = 0x1;
+   fme_gerror.ras_berror.cci_fatal_err = 0x1;
+   fme_gerror.ras_berror.ktiprpto_fatal_err = 0x1;
+   fme_gerror.ras_berror.dma_fatal_err = 0x1;
+   fme_gerror.ras_berror.iommu_catast_err = 0x1;
+   fme_gerror.ras_berror.crc_catast_err = 0x1;
+   fme_gerror.ras_berror.therm_catast_err = 0x1;
+   fme_gerror.ras_berror.injected_fatal_err = 0x1;
+
+   offset = offset + OFFSET;
+   write_ccip_csr64(ptr,offset,fme_gerror.ras_berror.csr);
+
+   // RAS warning Error Mask
+   fme_gerror.ras_warnerror_mask.event_warn_err= 0x1;
+
+   offset = offset + OFFSET;
+   write_ccip_csr64(ptr,offset,fme_gerror.ras_warnerror_mask.csr);
+
+
+   // RAS warning Error
+   fme_gerror.ras_warnerror.event_warn_err= 0x1;
+
+   offset = offset + OFFSET;
+   write_ccip_csr64(ptr,offset,fme_gerror.ras_warnerror.csr);
+
+
+   // FME PR
+   ptr = ptr+ fme_gerror.ccip_gerror_dflhdr.next_DFH_offset;
+   fme_pr.ccip_pr_dflhdr.Type =CCIP_DFType_private;
+   fme_pr.ccip_pr_dflhdr.next_DFH_offset =0x0;
+   fme_pr.ccip_pr_dflhdr.Feature_rev =0;
+   fme_pr.ccip_pr_dflhdr.Feature_ID= CCIP_FME_DFLID_PR;
+   fme_pr.ccip_pr_dflhdr.eol =0x1;
+   offset = 0;
+   write_ccip_csr64(ptr,offset,fme_pr.ccip_pr_dflhdr.csr);
+
+   // PR control
+   fme_pr.ccip_fme_pr_control.pr_push_complete =0x1;
+   fme_pr.ccip_fme_pr_control.pr_start_req =0x1;
+   fme_pr.ccip_fme_pr_control.pr_regionid =0x1;
+   fme_pr.ccip_fme_pr_control.pr_reset =0x1;
+   fme_pr.ccip_fme_pr_control.pr_reset_ack =0x1;
+   offset = offset + OFFSET;
+   write_ccip_csr64(ptr,offset,fme_pr.ccip_fme_pr_control.csr);
+
+   // PR status
+   fme_pr.ccip_fme_pr_status.pr_host_status =0x5;
+   fme_pr.ccip_fme_pr_status.pr_contoller_status =0x1;
+   fme_pr.ccip_fme_pr_status.pr_status =0x1;
+   fme_pr.ccip_fme_pr_status.pr_credit =0x55;
+
+   offset = offset + OFFSET;
+   write_ccip_csr64(ptr,offset,fme_pr.ccip_fme_pr_status.csr);
+
+   // PR Data
+   fme_pr.ccip_fme_pr_data.pr_data_raw =0x123456;
+   offset = offset + OFFSET;
+   write_ccip_csr64(ptr,offset,fme_pr.ccip_fme_pr_data.csr);
+
+    fme_pr.ccip_fme_pr_err.PR_operation_err =0x1;
+   fme_pr.ccip_fme_pr_err.PR_CRC_err =0x1;
+   fme_pr.ccip_fme_pr_err.PR_bitstream_err =0x1;
+   fme_pr.ccip_fme_pr_err.PR_IP_err =0x1;
+   fme_pr.ccip_fme_pr_err.PR_FIFIO_err =0x1;
+   fme_pr.ccip_fme_pr_err.PR_timeout_err =0x1;
+
+   offset = offset + OFFSET;
+   write_ccip_csr64(ptr,offset,fme_pr.ccip_fme_pr_err.csr);
+
+   PINFO(" ccip_sim_wrt_fme_mmio end\n");
+   return 0;
+}
+
+int  ccip_sim_wrt_port_mmio(btVirtAddr pkvp_fme_mmio)
+{
+   struct CCIP_PORT_HDR          port_hdr;
+   struct CCIP_PORT_DFL_ERR      port_err;
+   struct CCIP_PORT_DFL_UMSG     port_umsg;
+   struct CCIP_PORT_DFL_PR       port_pr;
+   struct CCIP_PORT_DFL_STAP     port_stap;
+   struct CCIP_AFU_Header        afu_hdr;
+
+   btVirtAddr           afuptr;
+   btUnsigned64bitInt   afu_id_offset;
+
+   btVirtAddr           ptr = pkvp_fme_mmio;
+
+
+   btUnsigned64bitInt offset =0;
+
+   PINFO(" ccip_sim_wrt_port_mmio ENTER\n");
+
+   afuptr = ptr;           // First AFU offset relative to First Port
+
+   // Port header
+   port_hdr.ccip_port_dfh.Type = CCIP_DFType_afu;
+   port_hdr.ccip_port_dfh.next_DFH_offset =0x1000;
+   port_hdr.ccip_port_dfh.Feature_rev =0;
+   port_hdr.ccip_port_dfh.Feature_ID =1;
+   port_hdr.ccip_port_dfh.eol =0x0;
+   write_ccip_csr64(ptr,offset,port_hdr.ccip_port_dfh.csr);
+
+   //port afu id low
+   port_hdr.ccip_port_afuidl.afu_id_l = CCIP_PORT_GUIDL;
+   offset = offset + OFFSET;
+   write_ccip_csr64(ptr,offset,port_hdr.ccip_port_afuidl.csr);
+
+   //port afu id high
+   port_hdr.ccip_port_afuidh.afu_id_h = CCIP_PORT_GUIDH;
+   offset = offset + OFFSET;
+   write_ccip_csr64(ptr,offset,port_hdr.ccip_port_afuidh.csr);
+
+   //port next afu offset
+   port_hdr.ccip_port_next_afu.csr = 0;				// Make sure the whole things is zero
+   port_hdr.ccip_port_next_afu.afu_id_offset=0x0;   // Temporary value. Will be filled in when we know the end
+   offset = offset + OFFSET;
+   afu_id_offset = offset;       // Save this so it can be populated at the end
+   write_ccip_csr64(ptr,offset,port_hdr.ccip_port_next_afu.csr) ;
+
+   //rsvd
+   port_hdr.rsvd_porthdr =0;
+   offset = offset + OFFSET;
+   write_ccip_csr64(ptr,offset,port_hdr.rsvd_porthdr);
+
+   // Port scratchpad csr
+   port_hdr.ccip_port_scratchpad.scratch_pad = 0x1234568;
+   offset = offset + OFFSET;
+   write_ccip_csr64(ptr,offset, port_hdr.ccip_port_scratchpad.csr);
+
+   // Port capability csr
+   port_hdr.ccip_port_capability.interrupts =0x1;
+   port_hdr.ccip_port_capability.mmio_size = 0x20;
+   port_hdr.ccip_port_capability.port_id =0x1;
+   offset = offset + OFFSET;
+   write_ccip_csr64(ptr,offset, port_hdr.ccip_port_capability.csr);
+
+   // Port control csr
+   port_hdr.ccip_port_control.ccip_outstanding_request =0x1;
+   port_hdr.ccip_port_control.afu_latny_rep =0x1;
+   port_hdr.ccip_port_control.port_sftreset_control =0x1;
+   offset = offset + OFFSET;
+   write_ccip_csr64(ptr,offset, port_hdr.ccip_port_control.csr);
+
+
+   //Port status
+   port_hdr.ccip_port_status.afu_pwr_state =0x6;
+   offset = offset + OFFSET;
+   write_ccip_csr64(ptr,offset,port_hdr.ccip_port_status.csr);
+
+   // Port Error
+
+   // port error header
+   ptr = ptr+ port_hdr.ccip_port_dfh.next_DFH_offset;
+   offset =0;
+   port_err.ccip_port_err_dflhdr.Type =CCIP_DFType_private;
+   port_err.ccip_port_err_dflhdr.next_DFH_offset =0x1000;
+   port_err.ccip_port_err_dflhdr.Feature_rev =0;
+   port_err.ccip_port_err_dflhdr.Feature_ID= CCIP_PORT_DFLID_ERROR;
+   port_err.ccip_port_err_dflhdr.eol =0x0;
+   write_ccip_csr64(ptr,offset, port_err.ccip_port_err_dflhdr.csr);
+
+
+   //Port Error Mask
+   offset = offset + OFFSET;
+   port_err.ccip_port_error_mask.tx_ch0_overflow =0x0;
+   port_err.ccip_port_error_mask.tx_ch0_invalidreq =0x0;
+   port_err.ccip_port_error_mask.tx_ch0_req_cl_len3 =0x0;
+   port_err.ccip_port_error_mask.tx_ch0_req_cl_len2 =0x0;
+   port_err.ccip_port_error_mask.tx_ch0_req_cl_len4 =0x0;
+   port_err.ccip_port_error_mask.rsvd =0x0;
+
+   port_err.ccip_port_error_mask.tx_ch1_overflow =0x0;
+   port_err.ccip_port_error_mask.tx_ch1_invalidreq =0x0;
+   port_err.ccip_port_error_mask.tx_ch1_req_cl_len3 =0x0;
+   port_err.ccip_port_error_mask.tx_ch1_req_cl_len2 =0x0;
+   port_err.ccip_port_error_mask.tx_ch1_req_cl_len4 =0x0;
+
+   port_err.ccip_port_error_mask.tx_ch1_insuff_datapayload =0x0;
+   port_err.ccip_port_error_mask.tx_ch1_datapayload_overrun =0x0;
+   port_err.ccip_port_error_mask.tx_ch1_incorr_addr =0x0;
+   port_err.ccip_port_error_mask.tx_ch1_sop_detcted =0x0;
+   port_err.ccip_port_error_mask.rsvd1 =0x0;
+
+   port_err.ccip_port_error_mask.mmioread_timeout =0x0;
+   port_err.ccip_port_error_mask.tx_ch2_fifo_overflow =0x0;
+   port_err.ccip_port_error_mask.rsvd2 =0x0;
+   port_err.ccip_port_error_mask.num_pending_req_overflow =0x0;
+   port_err.ccip_port_error_mask.rsvd3 =0x0;
+   write_ccip_csr64(ptr,offset, port_err.ccip_port_error_mask.csr);
+
+     //Port Error Mask
+   offset = offset + OFFSET;
+   port_err.ccip_port_error.tx_ch0_overflow =0x1;
+   port_err.ccip_port_error.tx_ch0_invalidreq =0x1;
+   port_err.ccip_port_error.tx_ch0_req_cl_len3 =0x1;
+   port_err.ccip_port_error.tx_ch0_req_cl_len2 =0x1;
+   port_err.ccip_port_error.tx_ch0_req_cl_len4 =0x1;
+
+
+   port_err.ccip_port_error.tx_ch1_overflow =0x1;
+   port_err.ccip_port_error.tx_ch1_invalidreq =0x1;
+   port_err.ccip_port_error.tx_ch1_req_cl_len3 =0x1;
+   port_err.ccip_port_error.tx_ch1_req_cl_len2 =0x1;
+   port_err.ccip_port_error.tx_ch1_req_cl_len4 =0x1;
+
+   port_err.ccip_port_error.tx_ch1_insuff_datapayload =0x1;
+   port_err.ccip_port_error.tx_ch1_datapayload_overrun =0x1;
+   port_err.ccip_port_error.tx_ch1_incorr_addr =0x1;
+   port_err.ccip_port_error.tx_ch1_sop_detcted =0x1;
+   
+
+   port_err.ccip_port_error.mmioread_timeout =0x1;
+   port_err.ccip_port_error.tx_ch2_fifo_overflow =0x1;
+
+   port_err.ccip_port_error.unexp_mmio_resp =0x1;
+   port_err.ccip_port_error.num_pending_req_overflow =0x1;
+
+   port_err.ccip_port_error.llpr_smrr_err = 0x1;
+   port_err.ccip_port_error.llpr_smrr2_err = 0x1;
+   port_err.ccip_port_error.llpr_mesg_err = 0x1;
+   port_err.ccip_port_error.genport_range_err = 0x1;
+   port_err.ccip_port_error.legrange_low_err = 0x1;
+   port_err.ccip_port_error.legrange_hight_err = 0x1;
+   port_err.ccip_port_error.vgmem_range_err = 0x1;
+   port_err.ccip_port_error.page_fault_err = 0x1;
+   port_err.ccip_port_error.pmr_err = 0x1;
+   port_err.ccip_port_error.ap6_event = 0x1;
+   port_err.ccip_port_error.vfflr_accesseror = 0x1;
+
+   write_ccip_csr64(ptr,offset, port_err.ccip_port_error.csr);
+
+   //Port first error
+   offset = offset + OFFSET;
+   port_err.ccip_port_first_error.tx_ch0_overflow =0x1;
+   port_err.ccip_port_first_error.tx_ch0_invalidreq =0x1;
+   port_err.ccip_port_first_error.tx_ch0_req_cl_len3 =0x1;
+   port_err.ccip_port_first_error.tx_ch0_req_cl_len2 =0x1;
+   port_err.ccip_port_first_error.tx_ch0_req_cl_len4 =0x1;
+
+
+   port_err.ccip_port_first_error.tx_ch1_overflow =0x1;
+   port_err.ccip_port_first_error.tx_ch1_invalidreq =0x1;
+   port_err.ccip_port_first_error.tx_ch1_req_cl_len3 =0x1;
+   port_err.ccip_port_first_error.tx_ch1_req_cl_len2 =0x1;
+   port_err.ccip_port_first_error.tx_ch1_req_cl_len4 =0x1;
+
+   port_err.ccip_port_first_error.tx_ch1_insuff_datapayload =0x1;
+   port_err.ccip_port_first_error.tx_ch1_datapayload_overrun =0x1;
+   port_err.ccip_port_first_error.tx_ch1_incorr_addr =0x1;
+   port_err.ccip_port_first_error.tx_ch1_sop_detcted =0x1;
+
+   port_err.ccip_port_first_error.mmioread_timeout =0x1;
+   port_err.ccip_port_first_error.tx_ch2_fifo_overflow =0x1;
+   port_err.ccip_port_first_error.unexp_mmio_resp =0x1;
+   port_err.ccip_port_first_error.num_pending_req_overflow =0x1;
+
+   port_err.ccip_port_first_error.llpr_smrr_err = 0x1;
+   port_err.ccip_port_first_error.llpr_smrr2_err = 0x1;
+   port_err.ccip_port_first_error.llpr_mesg_err = 0x1;
+   port_err.ccip_port_first_error.genport_range_err = 0x1;
+   port_err.ccip_port_first_error.legrange_low_err = 0x1;
+   port_err.ccip_port_first_error.legrange_hight_err = 0x1;
+   port_err.ccip_port_first_error.vgmem_range_err = 0x1;
+   port_err.ccip_port_first_error.page_fault_err = 0x1;
+   port_err.ccip_port_first_error.pmr_err = 0x1;
+   port_err.ccip_port_first_error.ap6_event = 0x1;
+   port_err.ccip_port_first_error.vfflr_accesseror = 0x1;
+
+   write_ccip_csr64(ptr,offset, port_err.ccip_port_first_error.csr);
+
+   // port malformed request csr
+   offset = offset + OFFSET;
+   port_err.ccip_port_malformed_req_0.malfrd_req_lsb=0x123457;
+   write_ccip_csr64(ptr,offset,port_err.ccip_port_malformed_req_0.csr);
+
+   // port malformed request csr
+   offset = offset + OFFSET;
+   port_err.ccip_port_malformed_req_1.malfrd_req_msb=0x7654321;
+   write_ccip_csr64(ptr,offset, port_err.ccip_port_malformed_req_1.csr);
+
+
+   // USMG DFH
+   // umsg header
+   ptr = ptr+ port_err.ccip_port_err_dflhdr.next_DFH_offset;
+   offset =0;
+   port_umsg.ccip_port_umsg_dflhdr.Type =CCIP_DFType_private;
+   port_umsg.ccip_port_umsg_dflhdr.next_DFH_offset =0x1000;
+   port_umsg.ccip_port_umsg_dflhdr.Feature_rev =0;
+   port_umsg.ccip_port_umsg_dflhdr.Feature_ID= CCIP_PORT_DFLID_USMG;
+   port_umsg.ccip_port_umsg_dflhdr.eol =0x0;
+   write_ccip_csr64(ptr,offset,port_umsg.ccip_port_umsg_dflhdr.csr);
+
+
+   // USMG capability
+   offset = offset + OFFSET;
+   port_umsg.ccip_umsg_capability.no_umsg_alloc_port =0x8;
+   port_umsg.ccip_umsg_capability.status_umsg_engine =0x0;
+   port_umsg.ccip_umsg_capability.umsg_init_status =0x1;
+   write_ccip_csr64(ptr,offset,port_umsg.ccip_umsg_capability.csr);
+
+   //USMG base address
+   offset = offset + OFFSET;
+   port_umsg.ccip_umsg_base_address.umsg_base_address =0x0;
+   write_ccip_csr64(ptr,offset,port_umsg.ccip_umsg_base_address.csr);
+
+   // USMG Mode
+   offset = offset + OFFSET;
+   port_umsg.ccip_umsg_mode.umsg_hit =0x1;
+   write_ccip_csr64(ptr,offset,port_umsg.ccip_umsg_mode.csr);
+
+   // PR CSR Header
+
+   ptr = ptr+ port_umsg.ccip_port_umsg_dflhdr.next_DFH_offset;
+   offset =0;
+
+   port_pr.ccip_port_pr_dflhdr.Type =CCIP_DFType_private;
+   port_pr.ccip_port_pr_dflhdr.next_DFH_offset =0x1000;
+   port_pr.ccip_port_pr_dflhdr.Feature_rev =0;
+   port_pr.ccip_port_pr_dflhdr.Feature_ID= CCIP_PORT_DFLID_PR;
+   port_pr.ccip_port_pr_dflhdr.eol =0x0;
+   write_ccip_csr64(ptr,offset,port_pr.ccip_port_pr_dflhdr.csr);
+
+   // PR Control CSR
+   offset = offset + OFFSET;
+   port_pr.ccip_port_pr_control.pr_start_req =0x1;
+   write_ccip_csr64(ptr,offset,port_pr.ccip_port_pr_control.csr);
+
+   // PR STATUS CSR
+   offset = offset + OFFSET;
+   port_pr.ccip_port_pr_status.pr_status =0x7;
+   port_pr.ccip_port_pr_status.pr_mega_fstatus=0x5;
+   port_pr.ccip_port_pr_status.pr_data_ovrferr =0x1;
+   port_pr.ccip_port_pr_status.pr_engine_error =0x1;
+   port_pr.ccip_port_pr_status.pr_timeout_error =0x1;
+   port_pr.ccip_port_pr_status.pr_access =0x1;
+   port_pr.ccip_port_pr_status.pr_acces_grant =0x1;
+   port_pr.ccip_port_pr_status.pr_credit =0x1;
+   write_ccip_csr64(ptr,offset,port_pr.ccip_port_pr_status.csr);
+
+
+   // PR DATA CSR
+   offset = offset + OFFSET;
+   port_pr.ccip_port_pr_data.pr_data_raw =0xabcd;
+   write_ccip_csr64(ptr,offset,port_pr.ccip_port_pr_data.csr);
+
+   // PR power Budget  CSR
+   offset = offset + OFFSET;
+   port_pr.ccip_port_pr_pbudget.pwr_format =0x4321;
+   write_ccip_csr64(ptr,offset,port_pr.ccip_port_pr_pbudget.csr);
+
+   offset = offset + OFFSET;
+   port_pr.ccip_usr_clk_freq.rsvd =0;
+   write_ccip_csr64(ptr,offset,port_pr.ccip_usr_clk_freq.csr);
+
+
+   // Signal Tap DFH
+   ptr = ptr+ port_pr.ccip_port_pr_dflhdr.next_DFH_offset;
+   offset =0;
+
+   port_stap.ccip_port_stap_dflhdr.Type =CCIP_DFType_private;
+   port_stap.ccip_port_stap_dflhdr.next_DFH_offset =0x0;
+   port_stap.ccip_port_stap_dflhdr.Feature_rev =0;
+   port_stap.ccip_port_stap_dflhdr.Feature_ID= CCIP_PORT_DFLID_STP;
+   port_stap.ccip_port_stap_dflhdr.eol =0x1;
+   write_ccip_csr64(ptr,offset,port_stap.ccip_port_stap_dflhdr.csr);
+
+
+   // SiganlTap CSR
+   offset = offset + OFFSET;
+   port_stap.stap_error.csr =0;
+   write_ccip_csr64(ptr,offset,port_stap.stap_error.csr);
+
+   // First AFU offset is the next free location (ptr + OFFSET) - the base address of Port HDR afuptr
+   offset = (ptr + OFFSET) - afuptr;
+
+   // User AFU - re write the value
+   port_hdr.ccip_port_next_afu.afu_id_offset=offset;
+   write_ccip_csr64(afuptr, afu_id_offset, port_hdr.ccip_port_next_afu.csr);
+
+    ptr = afuptr + port_hdr.ccip_port_next_afu.csr;
+
+   PINFO("AFU offset is %llx beyond PORT header at %p = %p\n", offset, afuptr, ptr );
+
+   offset = 0;
+
+   // Port header
+   afu_hdr.ccip_dfh.Type = CCIP_DFType_afu;
+   afu_hdr.ccip_dfh.next_DFH_offset =0x0;
+   afu_hdr.ccip_dfh.Feature_rev =0;
+   afu_hdr.ccip_dfh.Feature_ID =1;
+   write_ccip_csr64(ptr,offset,afu_hdr.ccip_dfh.csr);
+
+   //port afu id low
+   afu_hdr.ccip_afu_id_l.afu_id_l = CCI_SIM_AFUIDL;
+   offset = offset + OFFSET;
+   write_ccip_csr64(ptr,offset,afu_hdr.ccip_afu_id_l.csr);
+
+   //port afu id high
+   afu_hdr.ccip_afu_id_h.afu_id_h = CCI_SIM_AFUIDH;
+   offset = offset + OFFSET;
+   write_ccip_csr64(ptr,offset,afu_hdr.ccip_afu_id_h.csr);
+
+   //port next afu offset
+   afu_hdr.ccip_next_afu.afu_id_offset = 0x0;        // Temporary value
+   offset = offset + OFFSET;
+   write_ccip_csr64(ptr,offset,afu_hdr.ccip_next_afu.csr);
+
+   PINFO(" ccip_sim_wrt_port_mmio EXIT \n");
+
+
+   return 0;
+}
+
+
+int print_sim_fme_device(struct fme_device *pfme_dev)
+{
+   int res =0;
+   int i =0;
+
+
+   if (NULL == pfme_dev ) {
+      PERR("Unable to allocate system memory for pfme_dev object\n");
+      res = -1;
+      goto EROR;
+   }
+
+   PDEBUG( "*****************************************************************\n");
+   PDEBUG( "*****************************************************************\n");
+   PDEBUG( "****************         FME MMIO CONTENT        ****************\n");
+   PDEBUG( "*****************************************************************\n");
+   PDEBUG( "*****************************************************************\n");
+
+   if(pfme_dev->m_pHDR)
+   {
+      PDEBUG( "FME Header START \n \n");
+
+      PDEBUG( "dfh.Type= %x \n",pfme_dev->m_pHDR->dfh.Type);
+      PDEBUG( "dfh.Feature_ID= %x \n",pfme_dev->m_pHDR->dfh.Feature_ID);
+      PDEBUG( "dfh.Feature_rev= %x \n",pfme_dev->m_pHDR->dfh.Feature_rev);
+      PDEBUG( "dfh.next_DFH_offset= %x \n",pfme_dev->m_pHDR->dfh.next_DFH_offset);
+
+      PDEBUG( "afu_id_l.afu_id_l= %lx \n",(long unsigned int)pfme_dev->m_pHDR->afu_id_l.afu_id_l);
+      PDEBUG( "afu_id_h.afu_id_h= %lx \n",(long unsigned int) pfme_dev->m_pHDR->afu_id_h.afu_id_h);
+
+      PDEBUG( "next_afu.afu_id_offset= %x \n",pfme_dev->m_pHDR->next_afu.afu_id_offset);
+
+      PDEBUG( "scratch_pad= %lx \n",(long unsigned int)pfme_dev->m_pHDR->scratchpad.scratch_pad);
+
+
+      PDEBUG( "fabric_verid= %x \n",pfme_dev->m_pHDR->fab_capability.fabric_verid);
+      PDEBUG( "socket_id= %x \n",pfme_dev->m_pHDR->fab_capability.socket_id);
+      PDEBUG( "pci0_link_avile= %x \n",pfme_dev->m_pHDR->fab_capability.pci0_link_avile);
+      PDEBUG( "pci1_link_avile= %x \n",pfme_dev->m_pHDR->fab_capability.pci1_link_avile);
+      PDEBUG( "qpi_link_avile= %x \n",pfme_dev->m_pHDR->fab_capability.qpi_link_avile);
+      PDEBUG( "iommu_support= %x \n",pfme_dev->m_pHDR->fab_capability.iommu_support);
+
+      PDEBUG( "address_width_bits= %x \n",pfme_dev->m_pHDR->fab_capability.address_width_bits);
+      PDEBUG( "cache_size= %x \n",pfme_dev->m_pHDR->fab_capability.cache_size);
+      PDEBUG( "cache_assoc= %x \n",pfme_dev->m_pHDR->fab_capability.cache_assoc);
+      PDEBUG( "lock_bit= %x \n",pfme_dev->m_pHDR->fab_capability.lock_bit);
+
+      PDEBUG( "QPI link status = %x \n",pfme_dev->m_pHDR->fab_status.upilink_status);
+      PDEBUG( "PCIe0 link status = %x \n",pfme_dev->m_pHDR->fab_status.pcie0link_status);
+      PDEBUG( "PCIe1 link status = %x \n",pfme_dev->m_pHDR->fab_status.pcie1link_status);
+
+
+      PDEBUG( "FME Header END \n \n");
+
+   }
+
+   // Print list of ports
+   for ( i=0 ; i<NUM_ELEMENTS(pfme_dev->m_pHDR->port_offsets) ; i++)
+   {
+      PDEBUG( "i = %d \n",i);
+      if(0 != pfme_dev->m_pHDR->port_offsets[i].port_imp)
+      {
+         PDEBUG( "PORT count = %d \n",i);
+         PDEBUG( "port_imp = %x \n",pfme_dev->m_pHDR->port_offsets[i].port_imp);
+         PDEBUG( "port_arbit_poly = %x \n",pfme_dev->m_pHDR->port_offsets[i].afu_access_control);
+         PDEBUG( "port_bar = %x \n",pfme_dev->m_pHDR->port_offsets[i].port_bar);
+         PDEBUG( "port_offset = %x \n",pfme_dev->m_pHDR->port_offsets[i].port_offset);
+
+      }
+   }
+
+   if(pfme_dev->m_pThermmgmt)
+   {
+      PDEBUG( "FME Temp Feature  START \n \n");
+
+      PDEBUG( "Feature_ID = %x \n",pfme_dev->m_pThermmgmt->ccip_fme_tmp_dflhdr.Feature_ID);
+      PDEBUG( "Feature_rev = %x \n",pfme_dev->m_pThermmgmt->ccip_fme_tmp_dflhdr.Feature_rev);
+      PDEBUG( "next_DFH_offset = %x \n",pfme_dev->m_pThermmgmt->ccip_fme_tmp_dflhdr.next_DFH_offset);
+      PDEBUG( "Type = %x \n",pfme_dev->m_pThermmgmt->ccip_fme_tmp_dflhdr.Type);
+      PDEBUG( "End of List = %x \n",pfme_dev->m_pThermmgmt->ccip_fme_tmp_dflhdr.eol);
+
+
+      PDEBUG( "therm_trip_thshold = %x \n",pfme_dev->m_pThermmgmt->ccip_tmp_threshold.therm_trip_thshold);
+      PDEBUG( "therm_trip_thshold_status = %x \n",pfme_dev->m_pThermmgmt->ccip_tmp_threshold.therm_trip_thshold_status);
+      PDEBUG( "thshold1_status = %x \n",pfme_dev->m_pThermmgmt->ccip_tmp_threshold.thshold1_status);
+      PDEBUG( "thshold2_status = %x \n",pfme_dev->m_pThermmgmt->ccip_tmp_threshold.thshold2_status);
+      PDEBUG( "thshold_policy = %x \n",pfme_dev->m_pThermmgmt->ccip_tmp_threshold.thshold_policy);
+
+      PDEBUG( "tmp_thshold1 = %x \n",pfme_dev->m_pThermmgmt->ccip_tmp_threshold.tmp_thshold1);
+      PDEBUG( "tmp_thshold1_status = %x \n",pfme_dev->m_pThermmgmt->ccip_tmp_threshold.tmp_thshold1_status);
+      PDEBUG( "tmp_thshold2 = %x \n",pfme_dev->m_pThermmgmt->ccip_tmp_threshold.tmp_thshold2);
+      PDEBUG( "tmp_thshold2_status = %x \n",pfme_dev->m_pThermmgmt->ccip_tmp_threshold.tmp_thshold2_status);
+
+      PDEBUG( "dbg_mode = %x \n",pfme_dev->m_pThermmgmt->ccip_tmp_rdssensor_fm1.dbg_mode);
+      PDEBUG( "tmp_reading = %d \n",pfme_dev->m_pThermmgmt->ccip_tmp_rdssensor_fm1.tmp_reading);
+      PDEBUG( "tmp_reading_valid = %d \n",pfme_dev->m_pThermmgmt->ccip_tmp_rdssensor_fm1.tmp_reading_valid);
+      PDEBUG( "tmp_reading_seq_num = %d \n",pfme_dev->m_pThermmgmt->ccip_tmp_rdssensor_fm1.tmp_reading_seq_num);
+
+      PDEBUG( "FM2 rsvd = %lu \n",(long unsigned int)pfme_dev->m_pThermmgmt->ccip_tmp_rdssensor_fm2.rsvd);
+
+      PDEBUG( "FME Temp Feature  END \n \n");
+   }
+
+   if(pfme_dev->m_pPowermgmt)
+   {
+
+      PDEBUG( "FME Power Feature  START \n \n");
+
+      PDEBUG( "Feature_ID = %x \n",pfme_dev->m_pPowermgmt->ccip_fme_pm_dflhdr.Feature_ID);
+      PDEBUG( "Feature_rev = %x \n",pfme_dev->m_pPowermgmt->ccip_fme_pm_dflhdr.Feature_rev);
+      PDEBUG( "Type = %x \n",pfme_dev->m_pPowermgmt->ccip_fme_pm_dflhdr.Type);
+      PDEBUG( "next_DFH_offset = %x \n",pfme_dev->m_pPowermgmt->ccip_fme_pm_dflhdr.next_DFH_offset);
+      PDEBUG( "End of List = %x \n",pfme_dev->m_pPowermgmt->ccip_fme_pm_dflhdr.eol);
+
+
+      PDEBUG( "pwr_consumed = %x \n",pfme_dev->m_pPowermgmt->pm_status.pwr_consumed);
+      PDEBUG( "fpga_latency_report = %d \n",pfme_dev->m_pPowermgmt->pm_status.fpga_latency_report);
+
+
+      PDEBUG( "FME Power Feature  END \n \n");
+
+   }
+
+   if(pfme_dev->m_pPerf)
+   {
+
+      PDEBUG( "FME   Global Performance START \n \n");
+
+      PDEBUG( "Feature_ID = %x \n",pfme_dev->m_pPerf->ccip_fme_fpmon_dflhdr.Feature_ID);
+      PDEBUG( "Feature_rev = %x \n",pfme_dev->m_pPerf->ccip_fme_fpmon_dflhdr.Feature_rev);
+      PDEBUG( "Type = %x \n",pfme_dev->m_pPerf->ccip_fme_fpmon_dflhdr.Type);
+      PDEBUG( "next_DFH_offset = %x \n",pfme_dev->m_pPerf->ccip_fme_fpmon_dflhdr.next_DFH_offset);
+      PDEBUG( "End of List = %x \n",pfme_dev->m_pPerf->ccip_fme_fpmon_dflhdr.eol);
+
+      PDEBUG( "cache_event = %x \n",pfme_dev->m_pPerf->ccip_fpmon_ch_ctl.cache_event);
+      PDEBUG( "freeze = %x \n",pfme_dev->m_pPerf->ccip_fpmon_ch_ctl.freeze);
+
+
+      PDEBUG( "cache_counter = %x \n",( unsigned int)pfme_dev->m_pPerf->ccip_fpmon_ch_ctr_0.cache_counter);
+
+      PDEBUG( "cache_counter = %x \n",( unsigned int)pfme_dev->m_pPerf->ccip_fpmon_ch_ctr_1.cache_counter);
+
+      PDEBUG( "ccip_port_filter = %x \n",pfme_dev->m_pPerf->ccip_fpmon_fab_ctl.ccip_port_filter);
+      PDEBUG( "port_id = %x \n",pfme_dev->m_pPerf->ccip_fpmon_fab_ctl.port_id);
+      PDEBUG( "fabric_evt_code = %x \n",pfme_dev->m_pPerf->ccip_fpmon_fab_ctl.fabric_evt_code);
+      PDEBUG( "freeze = %x \n",pfme_dev->m_pPerf->ccip_fpmon_fab_ctl.freeze);
+
+      PDEBUG( "fabric_counter = %x \n",( unsigned int)pfme_dev->m_pPerf->ccip_fpmon_fab_ctr.fabric_counter);
+
+      PDEBUG( "afu_interf_clock = %lx \n",( long unsigned int)pfme_dev->m_pPerf->ccip_fpmon_clk_ctrs.afu_interf_clock);
+
+      PDEBUG( "FME   Global Performance END \n \n");
+   }
+
+   if(pfme_dev->m_pGerror)
+   {
+      PDEBUG( "FME   Global Erroe START \n \n");
+
+      PDEBUG( "Feature_ID = %x \n",pfme_dev->m_pGerror->ccip_gerror_dflhdr.Feature_ID);
+      PDEBUG( "Feature_rev = %x \n",pfme_dev->m_pGerror->ccip_gerror_dflhdr.Feature_rev);
+      PDEBUG( "Type = %x \n",pfme_dev->m_pGerror->ccip_gerror_dflhdr.Type);
+      PDEBUG( "next_DFH_offset = %x \n",pfme_dev->m_pGerror->ccip_gerror_dflhdr.next_DFH_offset);
+      PDEBUG( "End of List = %x \n",pfme_dev->m_pGerror->ccip_gerror_dflhdr.eol);
+
+      PDEBUG( "FME Error fabric_err  = %x \n",pfme_dev->m_pGerror->fme_err.fabric_err);
+      PDEBUG( "FME Error fabFifo_uoflow  = %x \n",pfme_dev->m_pGerror->fme_err.fabFifo_uoflow);
+      PDEBUG( "FME Error PCIe0 poison_detected  = %x \n",pfme_dev->m_pGerror->fme_err.pcie0_poison_detected);
+      PDEBUG( "FME Error PCIe0 poison_detected  = %x \n",pfme_dev->m_pGerror->fme_err.pcie1_poison_detected);
+      PDEBUG( "FME Error IOMMU Parity Erro  = %x \n",pfme_dev->m_pGerror->fme_err.iommu_parity_error);
+      PDEBUG( "FME Error AFU error mismatch  = %x \n",pfme_dev->m_pGerror->fme_err.afuerr_access_mismatch);
+
+
+      PDEBUG( "FME Error mask  fabric_err  = %x \n",pfme_dev->m_pGerror->fme_err_mask.fabric_err);
+      PDEBUG( "FME Error mask fabFifo_uoflow  = %x \n",pfme_dev->m_pGerror->fme_err_mask.fabFifo_uoflow);
+      PDEBUG( "FME Error PCIe0 poison_detected  = %x \n",pfme_dev->m_pGerror->fme_err_mask.pcie0_poison_detected);
+      PDEBUG( "FME Error PCIe0 poison_detected  = %x \n",pfme_dev->m_pGerror->fme_err_mask.pcie1_poison_detected);
+      PDEBUG( "FME Error IOMMU Parity Erro  = %x \n",pfme_dev->m_pGerror->fme_err_mask.iommu_parity_error);
+      PDEBUG( "FME Error AFU error mismatch  = %x \n",pfme_dev->m_pGerror->fme_err_mask.afuerr_access_mismatch);
+
+
+      PDEBUG( "PCIe0 Error mask  formattype_err  = %x \n",pfme_dev->m_pGerror->pcie0_err_mask.formattype_err);
+      PDEBUG( "PCIe0 Error mask  MWAddr_err  = %x \n",pfme_dev->m_pGerror->pcie0_err_mask.MWAddr_err);
+      PDEBUG( "PCIe0 Error mask  MWAddrLength_err  = %x \n",pfme_dev->m_pGerror->pcie0_err_mask.MWAddrLength_err);
+      PDEBUG( "PCIe0 Error mask  MRAddr_err  = %x \n",pfme_dev->m_pGerror->pcie0_err_mask.MRAddr_err);
+      PDEBUG( "PCIe0 Error mask  MRAddrLength_err  = %x \n",pfme_dev->m_pGerror->pcie0_err_mask.MRAddrLength_err);
+      PDEBUG( "PCIe0 Error mask  cpl_tag_err  = %x \n",pfme_dev->m_pGerror->pcie0_err_mask.cpl_tag_err);
+      PDEBUG( "PCIe0 Error mask  cpl_status_err  = %x \n",pfme_dev->m_pGerror->pcie0_err_mask.cpl_status_err);
+      PDEBUG( "PCIe0 Error mask  formattype_err  = %x \n",pfme_dev->m_pGerror->pcie0_err_mask.cpl_timeout_err);
+
+
+      PDEBUG( "PCIe0 Error   formattype_err  = %x \n",pfme_dev->m_pGerror->pcie0_err.formattype_err);
+      PDEBUG( "PCIe0 Error   MWAddr_err  = %x \n",pfme_dev->m_pGerror->pcie0_err.MWAddr_err);
+      PDEBUG( "PCIe0 Error   MWAddrLength_err  = %x \n",pfme_dev->m_pGerror->pcie0_err.MWAddrLength_err);
+      PDEBUG( "PCIe0 Error   MRAddr_err  = %x \n",pfme_dev->m_pGerror->pcie0_err.MRAddr_err);
+      PDEBUG( "PCIe0 Error   MRAddrLength_err  = %x \n",pfme_dev->m_pGerror->pcie0_err.MRAddrLength_err);
+      PDEBUG( "PCIe0 Error   cpl_tag_err  = %x \n",pfme_dev->m_pGerror->pcie0_err.cpl_tag_err);
+      PDEBUG( "PCIe0 Error   cpl_status_err  = %x \n",pfme_dev->m_pGerror->pcie0_err.cpl_status_err);
+      PDEBUG( "PCIe0 Error   formattype_err  = %x \n",pfme_dev->m_pGerror->pcie0_err.cpl_timeout_err);
+
+
+
+      PDEBUG( "PCIe1 Error mask  formattype_err  = %x \n",pfme_dev->m_pGerror->pcie1_err_mask.formattype_err);
+      PDEBUG( "PCIe1 Error mask  MWAddr_err  = %x \n",pfme_dev->m_pGerror->pcie1_err_mask.MWAddr_err);
+      PDEBUG( "PCIe1 Error mask  MWAddrLength_err  = %x \n",pfme_dev->m_pGerror->pcie1_err_mask.MWAddrLength_err);
+      PDEBUG( "PCIe1 Error mask  MRAddr_err  = %x \n",pfme_dev->m_pGerror->pcie1_err_mask.MRAddr_err);
+      PDEBUG( "PCIe1 Error mask  MRAddrLength_err  = %x \n",pfme_dev->m_pGerror->pcie1_err_mask.MRAddrLength_err);
+      PDEBUG( "PCIe1 Error mask  cpl_tag_err  = %x \n",pfme_dev->m_pGerror->pcie1_err_mask.cpl_tag_err);
+      PDEBUG( "PCIe1 Error mask  cpl_status_err  = %x \n",pfme_dev->m_pGerror->pcie1_err_mask.cpl_status_err);
+      PDEBUG( "PCIe1 Error mask  formattype_err  = %x \n",pfme_dev->m_pGerror->pcie1_err_mask.cpl_timeout_err);
+
+
+      PDEBUG( "PCIe1 Error   formattype_err  = %x \n",pfme_dev->m_pGerror->pcie1_err.formattype_err);
+      PDEBUG( "PCIe1 Error   MWAddr_err  = %x \n",pfme_dev->m_pGerror->pcie1_err.MWAddr_err);
+      PDEBUG( "PCIe1 Error   MWAddrLength_err  = %x \n",pfme_dev->m_pGerror->pcie1_err.MWAddrLength_err);
+      PDEBUG( "PCIe1 Error   MRAddr_err  = %x \n",pfme_dev->m_pGerror->pcie1_err.MRAddr_err);
+      PDEBUG( "PCIe1 Error   MRAddrLength_err  = %x \n",pfme_dev->m_pGerror->pcie1_err.MRAddrLength_err);
+      PDEBUG( "PCIe1 Error   cpl_tag_err  = %x \n",pfme_dev->m_pGerror->pcie1_err.cpl_tag_err);
+      PDEBUG( "PCIe1 Error   cpl_status_err  = %x \n",pfme_dev->m_pGerror->pcie1_err.cpl_status_err);
+      PDEBUG( "PCIe1 Error   formattype_err  = %x \n",pfme_dev->m_pGerror->pcie1_err.cpl_timeout_err);
+
+
+      PDEBUG( "Green BS Error mask  thremal threshold AP1  = %x \n",pfme_dev->m_pGerror->ras_gerr_mask.temp_trash_ap1);
+      PDEBUG( "Green BS Error mask  thremal threshold AP2  = %x \n",pfme_dev->m_pGerror->ras_gerr_mask.temp_trash_ap2);
+      PDEBUG( "Green BS Error mask  pcie_error  = %x \n",pfme_dev->m_pGerror->ras_gerr_mask.pcie_error);
+      PDEBUG( "Green BS Error mask  afufatal_error  = %x \n",pfme_dev->m_pGerror->ras_gerr_mask.afufatal_error);
+      PDEBUG( "Green BS Error mask  proc hot error  = %x \n",pfme_dev->m_pGerror->ras_gerr_mask.prochot_error);
+      PDEBUG( "Green BS Error mask  afu access mode  error  = %x \n",pfme_dev->m_pGerror->ras_gerr_mask.afu_access_mismatch);
+      PDEBUG( "Green BS Error mask  Injected warning  errorr  = %x \n",pfme_dev->m_pGerror->ras_gerr_mask.injected_warn_error);
+      PDEBUG( "Green BS Error mask  PCIe poison port  error  = %x \n",pfme_dev->m_pGerror->ras_gerr_mask.pcie_poison_error);
+      PDEBUG( "Green BS Error mask  gb_crc_err  = %x \n",pfme_dev->m_pGerror->ras_gerr_mask.gb_crc_err);
+      PDEBUG( "Green BS Error mask  thremal threshold AP  = %x \n",pfme_dev->m_pGerror->ras_gerr_mask.temp_trash_ap6);
+      PDEBUG( "Green BS Error mask  Power threshold AP1  = %x \n",pfme_dev->m_pGerror->ras_gerr_mask.power_trash_ap1);
+      PDEBUG( "Green BS Error mask  Power threshold AP6  = %x \n",pfme_dev->m_pGerror->ras_gerr_mask.power_trash_ap2);
+      PDEBUG( "Green BS Error mask  MBP error Error  = %x \n",pfme_dev->m_pGerror->ras_gerr_mask.mbp_error);
+
+
+      PDEBUG( "Green BS Error mask  thremal threshold AP1  = %x \n",pfme_dev->m_pGerror->ras_gerr.temp_trash_ap1);
+      PDEBUG( "Green BS Error mask  thremal threshold AP2  = %x \n",pfme_dev->m_pGerror->ras_gerr.temp_trash_ap2);
+      PDEBUG( "Green BS Error mask  pcie_error  = %x \n",pfme_dev->m_pGerror->ras_gerr.pcie_error);
+      PDEBUG( "Green BS Error mask  afufatal_error  = %x \n",pfme_dev->m_pGerror->ras_gerr.afufatal_error);
+      PDEBUG( "Green BS Error mask  proc hot error  = %x \n",pfme_dev->m_pGerror->ras_gerr.prochot_error);
+      PDEBUG( "Green BS Error mask  afu access mode  error  = %x \n",pfme_dev->m_pGerror->ras_gerr.afu_access_mismatch);
+      PDEBUG( "Green BS Error mask  Injected warning  errorr  = %x \n",pfme_dev->m_pGerror->ras_gerr.injected_warn_error);
+      PDEBUG( "Green BS Error mask  PCIe poison port  error  = %x \n",pfme_dev->m_pGerror->ras_gerr.pcie_poison_error);
+      PDEBUG( "Green BS Error mask  gb_crc_err  = %x \n",pfme_dev->m_pGerror->ras_gerr.gb_crc_err);
+      PDEBUG( "Green BS Error mask  thremal threshold AP  = %x \n",pfme_dev->m_pGerror->ras_gerr.temp_trash_ap6);
+      PDEBUG( "Green BS Error mask  Power threshold AP1  = %x \n",pfme_dev->m_pGerror->ras_gerr.power_trash_ap1);
+      PDEBUG( "Green BS Error mask  Power threshold AP6  = %x \n",pfme_dev->m_pGerror->ras_gerr.power_trash_ap2);
+      PDEBUG( "Green BS Error mask  MBP error Error  = %x \n",pfme_dev->m_pGerror->ras_gerr.mbp_error);
+
+
+
+      PDEBUG( "blue BS Error mask  ktilink_fatal_err  = %x \n",pfme_dev->m_pGerror->ras_berror_mask.ktilink_fatal_err);
+      PDEBUG( "blue BS Error mask  tagcch_fatal_err  = %x \n",pfme_dev->m_pGerror->ras_berror_mask.tagcch_fatal_err);
+      PDEBUG( "blue BS Error mask  cci_fatal_err  = %x \n",pfme_dev->m_pGerror->ras_berror_mask.cci_fatal_err);
+      PDEBUG( "blue BS Error mask  ktiprpto_fatal_err  = %x \n",pfme_dev->m_pGerror->ras_berror_mask.ktiprpto_fatal_err);
+      PDEBUG( "blue BS Error mask  dma_fatal_err  = %x \n",pfme_dev->m_pGerror->ras_berror_mask.dma_fatal_err);
+      PDEBUG( "blue BS Error mask  iommu_catast_err  = %x \n",pfme_dev->m_pGerror->ras_berror_mask.iommu_catast_err);
+      PDEBUG( "blue BS Error mask  crc_catast_err  = %x \n",pfme_dev->m_pGerror->ras_berror_mask.crc_catast_err);
+      PDEBUG( "blue BS Error mask  therm_catast_err  = %x \n",pfme_dev->m_pGerror->ras_berror_mask.therm_catast_err);
+
+
+      PDEBUG( "blue BS Error   ktilink_fatal_err  = %x \n",pfme_dev->m_pGerror->ras_berror.ktilink_fatal_err);
+      PDEBUG( "blue BS Error   tagcch_fatal_err  = %x \n",pfme_dev->m_pGerror->ras_berror.tagcch_fatal_err);
+      PDEBUG( "blue BS Error   cci_fatal_err  = %x \n",pfme_dev->m_pGerror->ras_berror.cci_fatal_err);
+      PDEBUG( "blue BS Error   ktiprpto_fatal_err  = %x \n",pfme_dev->m_pGerror->ras_berror.ktiprpto_fatal_err);
+      PDEBUG( "blue BS Error   dma_fatal_err  = %x \n",pfme_dev->m_pGerror->ras_berror.dma_fatal_err);
+      PDEBUG( "blue BS Error   iommu_catast_err  = %x \n",pfme_dev->m_pGerror->ras_berror.iommu_catast_err);
+      PDEBUG( "blue BS Error   crc_catast_err  = %x \n",pfme_dev->m_pGerror->ras_berror.crc_catast_err);
+      PDEBUG( "blue BS Error   therm_catast_err  = %x \n",pfme_dev->m_pGerror->ras_berror.therm_catast_err);
+
+
+      PDEBUG( "RAS Warning mask  event_warn_err  = %x \n",pfme_dev->m_pGerror->ras_warnerror_mask.event_warn_err);
+      PDEBUG( "RAS Warning   event_warn_err  = %x \n",pfme_dev->m_pGerror->ras_warnerror.event_warn_err);
+
+
+      PDEBUG( "FME   Global Error END \n \n");
+
+   }
+
+   if(pfme_dev->m_pPRmgmt)
+   {
+      PDEBUG( "FME PR Feature  START \n \n");
+
+      PDEBUG( "Feature_ID = %x \n",pfme_dev->m_pPRmgmt->ccip_pr_dflhdr.Feature_ID);
+      PDEBUG( "Feature_rev = %x \n",pfme_dev->m_pPRmgmt->ccip_pr_dflhdr.Feature_rev);
+      PDEBUG( "Type = %x \n",pfme_dev->m_pPRmgmt->ccip_pr_dflhdr.Type);
+      PDEBUG( "next_DFH_offset = %x \n",pfme_dev->m_pPRmgmt->ccip_pr_dflhdr.next_DFH_offset);
+      PDEBUG( "End of List = %x \n",pfme_dev->m_pPRmgmt->ccip_pr_dflhdr.eol);
+
+      PDEBUG( "pr_reset = %x \n",pfme_dev->m_pPRmgmt->ccip_fme_pr_control.pr_reset);
+      PDEBUG( "pr_reset_ack = %x \n",pfme_dev->m_pPRmgmt->ccip_fme_pr_control.pr_reset_ack);
+      PDEBUG( "pr_regionid = %x \n",pfme_dev->m_pPRmgmt->ccip_fme_pr_control.pr_regionid);
+      PDEBUG( "pr_start_req = %x \n",pfme_dev->m_pPRmgmt->ccip_fme_pr_control.pr_start_req);
+      PDEBUG( "pr_push_complete = %x \n",pfme_dev->m_pPRmgmt->ccip_fme_pr_control.pr_push_complete);
+
+
+      PDEBUG( "pr_credit = %x \n",pfme_dev->m_pPRmgmt->ccip_fme_pr_status.pr_credit);
+      PDEBUG( "pr_status = %x \n",pfme_dev->m_pPRmgmt->ccip_fme_pr_status.pr_status);
+      PDEBUG( "pr_contoller_status = %x \n",pfme_dev->m_pPRmgmt->ccip_fme_pr_status.pr_contoller_status);
+      PDEBUG( "pr_host_status = %x \n",pfme_dev->m_pPRmgmt->ccip_fme_pr_status.pr_host_status);
+
+
+      PDEBUG( "pr_data_raw = %x \n",pfme_dev->m_pPRmgmt->ccip_fme_pr_data.pr_data_raw);
+
+      PDEBUG( "PR_operation_err = %x \n",pfme_dev->m_pPRmgmt->ccip_fme_pr_err.PR_operation_err);
+      PDEBUG( "PR_CRC_err = %x \n",pfme_dev->m_pPRmgmt->ccip_fme_pr_err.PR_CRC_err);
+      PDEBUG( "PR_bitstream_err = %x \n",pfme_dev->m_pPRmgmt->ccip_fme_pr_err.PR_bitstream_err);
+      PDEBUG( "PR_IP_err = %x \n",pfme_dev->m_pPRmgmt->ccip_fme_pr_err.PR_IP_err);
+      PDEBUG( "PR_FIFIO_err = %x \n",pfme_dev->m_pPRmgmt->ccip_fme_pr_err.PR_FIFIO_err);
+      PDEBUG( "PR_timeout_err = %x \n",pfme_dev->m_pPRmgmt->ccip_fme_pr_err.PR_timeout_err);
+
+
+      PDEBUG( "FME PR Feature  END \n \n");
+   }
+
+   PDEBUG( "*****************************************************************\n");
+   PDEBUG( "*****************************************************************\n");
+
+   EROR:
+
+   return res;
+}
+
+int print_sim_port_device(struct port_device *pport_dev)
+{
+   int res = 0;
+   if ( NULL == pport_dev ) {
+      PERR("Unable to allocate system memory for pfme_dev object\n");
+      res = -1;
+      goto ERR;
+   }
+
+   PDEBUG( "*****************************************************************\n");
+   PDEBUG( "*****************************************************************\n");
+   PDEBUG( "****************        PORT MMIO CONTENT        ****************\n");
+   PDEBUG( "*****************************************************************\n");
+   PDEBUG( "*****************************************************************\n");
+
+   if(pport_dev->m_pport_hdr)
+   {
+
+      PDEBUG( "PORT Header START \n \n");
+
+      PDEBUG( "dfh.Type= %x \n",pport_dev->m_pport_hdr->ccip_port_dfh.Type);
+      PDEBUG( "dfh.Feature_ID= %x \n",pport_dev->m_pport_hdr->ccip_port_dfh.Feature_ID);
+      PDEBUG( "dfh.Feature_rev= %x \n",pport_dev->m_pport_hdr->ccip_port_dfh.Feature_rev);
+      PDEBUG( "dfh.next_DFH_offset= %x \n",pport_dev->m_pport_hdr->ccip_port_dfh.next_DFH_offset);
+      PDEBUG( "End of List = %x \n",pport_dev->m_pport_hdr->ccip_port_dfh.eol);
+
+
+      PDEBUG( "afu_id_l.afu_id_l= %lx \n",( long unsigned int)pport_dev->m_pport_hdr->ccip_port_afuidl.afu_id_l);
+      PDEBUG( "afu_id_h.afu_id_h= %lx \n",( long unsigned int)pport_dev->m_pport_hdr->ccip_port_afuidh.afu_id_h);
+
+      PDEBUG( "next_afu.afu_id_offset= %x \n",pport_dev->m_pport_hdr->ccip_port_next_afu.afu_id_offset);
+
+      PDEBUG( "scratch_pad= %lx \n",( long unsigned int)pport_dev->m_pport_hdr->ccip_port_scratchpad.scratch_pad);
+
+      PDEBUG( "interrupts= %x \n",pport_dev->m_pport_hdr->ccip_port_capability.interrupts);
+      PDEBUG( "mmio_size= %x \n",pport_dev->m_pport_hdr->ccip_port_capability.mmio_size);
+      PDEBUG( "port_id= %x \n",pport_dev->m_pport_hdr->ccip_port_capability.port_id);
+      // PDEBUG( "usmg_size= %x \n",pport_dev->m_pport_hdr->ccip_port_capability.usmg_size);
+
+      PDEBUG( "ccip_outstanding_request= %x \n",pport_dev->m_pport_hdr->ccip_port_control.ccip_outstanding_request);
+      PDEBUG( "afu_latny_rep= %x \n",pport_dev->m_pport_hdr->ccip_port_control.afu_latny_rep);
+      PDEBUG( "port_sftreset_control= %x \n",pport_dev->m_pport_hdr->ccip_port_control.port_sftreset_control);
+
+      PDEBUG( "afu_pwr_state= %x \n",pport_dev->m_pport_hdr->ccip_port_status.afu_pwr_state);
+
+      PDEBUG( "PORT Header END \n \n");
+
+   }
+
+   if(pport_dev->m_pport_err)
+   {
+
+      PDEBUG( "PORT ERROR  Feature  START \n \n");
+
+      PDEBUG( "Feature_ID = %x \n",pport_dev->m_pport_err->ccip_port_err_dflhdr.Feature_ID);
+      PDEBUG( "Feature_rev = %x \n",pport_dev->m_pport_err->ccip_port_err_dflhdr.Feature_rev);
+      PDEBUG( "Type = %x \n",pport_dev->m_pport_err->ccip_port_err_dflhdr.Type);
+
+      PDEBUG( "next_DFH_offset = %x \n",pport_dev->m_pport_err->ccip_port_err_dflhdr.next_DFH_offset);
+      PDEBUG( "End of List = %x \n",pport_dev->m_pport_err->ccip_port_err_dflhdr.eol);
+
+      PDEBUG( "rsvd = %x \n",(  unsigned int)pport_dev->m_pport_err->ccip_port_error_mask.rsvd);
+
+      PDEBUG( "Port Error tx_ch0_overflow = %x \n",pport_dev->m_pport_err->ccip_port_error.tx_ch0_overflow);
+      PDEBUG( "Port Error tx_ch0_invalidreq = %x \n",pport_dev->m_pport_err->ccip_port_error.tx_ch0_invalidreq);
+      PDEBUG( "Port Error tx_ch0_req_cl_len3 = %x \n",pport_dev->m_pport_err->ccip_port_error.tx_ch0_req_cl_len3);
+      PDEBUG( "Port Error tx_ch0_req_cl_len2 = %x \n",pport_dev->m_pport_err->ccip_port_error.tx_ch0_req_cl_len2);
+      PDEBUG( "Port Error tx_ch0_req_cl_len2 = %x \n",pport_dev->m_pport_err->ccip_port_error.tx_ch0_req_cl_len4);
+
+      PDEBUG( "Port Error tx_ch1_overflow = %x \n",pport_dev->m_pport_err->ccip_port_error.tx_ch1_overflow);
+      PDEBUG( "Port Error tx_ch1_invalidreq = %x \n",pport_dev->m_pport_err->ccip_port_error.tx_ch1_invalidreq);
+      PDEBUG( "Port Error tx_ch1_req_cl_len3 = %x \n",pport_dev->m_pport_err->ccip_port_error.tx_ch1_req_cl_len3);
+      PDEBUG( "Port Error tx_ch1_req_cl_len2 = %x \n",pport_dev->m_pport_err->ccip_port_error.tx_ch1_req_cl_len2);
+      PDEBUG( "Port Error tx_ch1_req_cl_len4 = %x \n",pport_dev->m_pport_err->ccip_port_error.tx_ch1_req_cl_len4);
+
+      PDEBUG( "Port Error tx_ch1_insuff_datapayload = %x \n",pport_dev->m_pport_err->ccip_port_error.tx_ch1_insuff_datapayload);
+      PDEBUG( "Port Error tx_ch1_datapayload_overrun = %x \n",pport_dev->m_pport_err->ccip_port_error.tx_ch1_datapayload_overrun);
+      PDEBUG( "Port Error tx_ch1_incorr_addr = %x \n",pport_dev->m_pport_err->ccip_port_error.tx_ch1_incorr_addr);
+      PDEBUG( "Port Error tx_ch1_sop_detcted = %x \n",pport_dev->m_pport_err->ccip_port_error.tx_ch1_sop_detcted);
+      PDEBUG( "Port Error mmioread_timeout = %x \n",pport_dev->m_pport_err->ccip_port_error.mmioread_timeout);
+      PDEBUG( "Port Error tx_ch2_fifo_overflow = %x \n",pport_dev->m_pport_err->ccip_port_error.tx_ch2_fifo_overflow);
+      PDEBUG( "Port Error num_pending_req_overflow = %x \n",pport_dev->m_pport_err->ccip_port_error.num_pending_req_overflow);
+
+      PDEBUG( "Port Error unexp_mmio_resp = %x \n",pport_dev->m_pport_err->ccip_port_error.unexp_mmio_resp);
+
+      PDEBUG( "Port Error llpr_smrr_err = %x \n",pport_dev->m_pport_err->ccip_port_error.llpr_smrr_err);
+      PDEBUG( "Port Error llpr_smrr2_err = %x \n",pport_dev->m_pport_err->ccip_port_error.llpr_smrr2_err);
+      PDEBUG( "Port Error llpr_mesg_err = %x \n",pport_dev->m_pport_err->ccip_port_error.llpr_mesg_err);
+      PDEBUG( "Port Error genport_range_err = %x \n",pport_dev->m_pport_err->ccip_port_error.genport_range_err);
+      PDEBUG( "Port Error legrange_low_err = %x \n",pport_dev->m_pport_err->ccip_port_error.legrange_low_err);
+      PDEBUG( "Port Error legrange_hight_err = %x \n",pport_dev->m_pport_err->ccip_port_error.legrange_hight_err);
+      PDEBUG( "Port Error vgmem_range_err = %x \n",pport_dev->m_pport_err->ccip_port_error.vgmem_range_err);
+
+      PDEBUG( "Port Error page_fault_err = %x \n",pport_dev->m_pport_err->ccip_port_error.page_fault_err);
+      PDEBUG( "Port Error pmr_err = %x \n",pport_dev->m_pport_err->ccip_port_error.pmr_err);
+      PDEBUG( "Port Error ap6_event = %x \n",pport_dev->m_pport_err->ccip_port_error.ap6_event);
+      PDEBUG( "Port Error vfflr_accesseror = %x \n",pport_dev->m_pport_err->ccip_port_error.vfflr_accesseror);
+
+
+      PDEBUG( "Port First Error tx_ch0_overflow = %x \n",pport_dev->m_pport_err->ccip_port_first_error.tx_ch0_overflow);
+      PDEBUG( "Port First Error tx_ch0_invalidreq = %x \n",pport_dev->m_pport_err->ccip_port_first_error.tx_ch0_invalidreq);
+      PDEBUG( "Port First Error tx_ch0_req_cl_len3 = %x \n",pport_dev->m_pport_err->ccip_port_first_error.tx_ch0_req_cl_len3);
+      PDEBUG( "Port First Error tx_ch0_req_cl_len2 = %x \n",pport_dev->m_pport_err->ccip_port_first_error.tx_ch0_req_cl_len2);
+      PDEBUG( "Port First Error tx_ch0_req_cl_len2 = %x \n",pport_dev->m_pport_err->ccip_port_first_error.tx_ch0_req_cl_len4);
+
+      PDEBUG( "Port First Error tx_ch1_overflow = %x \n",pport_dev->m_pport_err->ccip_port_first_error.tx_ch1_overflow);
+      PDEBUG( "Port First Error tx_ch1_invalidreq = %x \n",pport_dev->m_pport_err->ccip_port_first_error.tx_ch1_invalidreq);
+      PDEBUG( "Port First Error tx_ch1_req_cl_len3 = %x \n",pport_dev->m_pport_err->ccip_port_first_error.tx_ch1_req_cl_len3);
+      PDEBUG( "Port First Error tx_ch1_req_cl_len2 = %x \n",pport_dev->m_pport_err->ccip_port_first_error.tx_ch1_req_cl_len2);
+      PDEBUG( "Port First Error tx_ch1_req_cl_len4 = %x \n",pport_dev->m_pport_err->ccip_port_first_error.tx_ch1_req_cl_len4);
+
+      PDEBUG( "Port First Error tx_ch1_insuff_datapayload = %x \n",pport_dev->m_pport_err->ccip_port_first_error.tx_ch1_insuff_datapayload);
+      PDEBUG( "Port First Error tx_ch1_datapayload_overrun = %x \n",pport_dev->m_pport_err->ccip_port_first_error.tx_ch1_datapayload_overrun);
+      PDEBUG( "Port First Error tx_ch1_incorr_addr = %x \n",pport_dev->m_pport_err->ccip_port_first_error.tx_ch1_incorr_addr);
+      PDEBUG( "Port First Error tx_ch1_sop_detcted = %x \n",pport_dev->m_pport_err->ccip_port_first_error.tx_ch1_sop_detcted);
+      PDEBUG( "Port First Error mmioread_timeout = %x \n",pport_dev->m_pport_err->ccip_port_first_error.mmioread_timeout);
+      PDEBUG( "Port First Error tx_ch2_fifo_overflow = %x \n",pport_dev->m_pport_err->ccip_port_first_error.tx_ch2_fifo_overflow);
+      PDEBUG( "Port First Error num_pending_req_overflow = %x \n",pport_dev->m_pport_err->ccip_port_first_error.num_pending_req_overflow);
+
+
+      PDEBUG( "malfrd_req_lsb = %lx \n",( long unsigned int)pport_dev->m_pport_err->ccip_port_malformed_req_0.malfrd_req_lsb);
+
+      PDEBUG( "malfrd_req_msb = %lx \n",( long unsigned int)pport_dev->m_pport_err->ccip_port_malformed_req_1.malfrd_req_msb);
+
+      PDEBUG( "PORT ERROR  Feature  END \n \n");
+
+   }
+
+   if(pport_dev->m_pport_umsg)
+   {
+      PDEBUG( "PORT USMG  START \n \n");
+
+      PDEBUG( "Feature_ID = %x \n",pport_dev->m_pport_umsg->ccip_port_umsg_dflhdr.Feature_ID);
+      PDEBUG( "Feature_rev = %x \n",pport_dev->m_pport_umsg->ccip_port_umsg_dflhdr.Feature_rev);
+      PDEBUG( "Type = %x \n",pport_dev->m_pport_umsg->ccip_port_umsg_dflhdr.Type);
+      PDEBUG( "next_DFH_offset = %x \n",pport_dev->m_pport_umsg->ccip_port_umsg_dflhdr.next_DFH_offset);
+      PDEBUG( "End of List = %x \n",pport_dev->m_pport_umsg->ccip_port_umsg_dflhdr.eol);
+
+
+      PDEBUG( "no_umsg_alloc_port = %x \n",pport_dev->m_pport_umsg->ccip_umsg_capability.no_umsg_alloc_port);
+      PDEBUG( "status_umsg_engine = %x \n",pport_dev->m_pport_umsg->ccip_umsg_capability.status_umsg_engine);
+      PDEBUG( "umsg_init_status = %x \n",pport_dev->m_pport_umsg->ccip_umsg_capability.umsg_init_status);
+
+
+      PDEBUG( "umsg_base_address = %lx \n",( long unsigned int)pport_dev->m_pport_umsg->ccip_umsg_base_address.umsg_base_address);
+
+      PDEBUG( "umsg_hit = %x \n",pport_dev->m_pport_umsg->ccip_umsg_mode.umsg_hit);
+
+      PDEBUG( "PORT USMG  END \n \n");
+   }
+
+
+   if(pport_dev->m_pport_pr)
+   {
+      PDEBUG( "PORT PR   START \n \n");
+      PDEBUG( "Feature_ID = %x \n",pport_dev->m_pport_pr->ccip_port_pr_dflhdr.Feature_ID);
+      PDEBUG( "Feature_rev = %x \n",pport_dev->m_pport_pr->ccip_port_pr_dflhdr.Feature_rev);
+      PDEBUG( "Type = %x \n",pport_dev->m_pport_pr->ccip_port_pr_dflhdr.Type);
+      PDEBUG( "next_DFH_offset = %x \n",pport_dev->m_pport_pr->ccip_port_pr_dflhdr.next_DFH_offset);
+      PDEBUG( "End of List = %x \n",pport_dev->m_pport_pr->ccip_port_pr_dflhdr.eol);
+
+      PDEBUG( "pr_start_req = %x \n",pport_dev->m_pport_pr->ccip_port_pr_control.pr_start_req);
+
+      PDEBUG( "pr_status = %x \n",pport_dev->m_pport_pr->ccip_port_pr_status.pr_status);
+      PDEBUG( "pr_mega_fstatus = %x \n",pport_dev->m_pport_pr->ccip_port_pr_status.pr_mega_fstatus);
+      PDEBUG( "pr_data_ovrferr = %x \n",pport_dev->m_pport_pr->ccip_port_pr_status.pr_data_ovrferr);
+      PDEBUG( "pr_engine_error = %x \n",pport_dev->m_pport_pr->ccip_port_pr_status.pr_engine_error);
+      PDEBUG( "pr_timeout_error = %x \n",pport_dev->m_pport_pr->ccip_port_pr_status.pr_timeout_error);
+      PDEBUG( "pr_access = %x \n",pport_dev->m_pport_pr->ccip_port_pr_status.pr_access);
+      PDEBUG( "pr_credit = %x \n",pport_dev->m_pport_pr->ccip_port_pr_status.pr_credit);
+
+      PDEBUG( "pr_data_raw = %x \n",pport_dev->m_pport_pr->ccip_port_pr_data.pr_data_raw);
+
+      PDEBUG( "pwr_format = %x \n",( unsigned int)pport_dev->m_pport_pr->ccip_port_pr_pbudget.pwr_format);
+
+      PDEBUG( "PORT PR   END \n \n");
+
+   }
+
+   if(pport_dev->m_pport_stap)
+   {
+
+      PDEBUG( "PORT SIGNAL TAP   START \n \n");
+      PDEBUG( "Feature_ID = %x \n",pport_dev->m_pport_stap->ccip_port_stap_dflhdr.Feature_ID);
+      PDEBUG( "Feature_rev = %x \n",pport_dev->m_pport_stap->ccip_port_stap_dflhdr.Feature_rev);
+      PDEBUG( "Type = %x \n",pport_dev->m_pport_stap->ccip_port_stap_dflhdr.Type);
+      PDEBUG( "next_DFH_offset = %x \n",pport_dev->m_pport_stap->ccip_port_stap_dflhdr.next_DFH_offset);
+      PDEBUG( "End of List = %x \n",pport_dev->m_pport_stap->ccip_port_stap_dflhdr.eol);
+
+      PDEBUG( "Signal tap debug = %x \n",(  unsigned int)pport_dev->m_pport_stap->stap_error.csr);
+
+      PDEBUG( "PORT SIGNAL tap  END \n \n");
+
+   }
+
+   if(0 != pport_dev->m_pport_hdr->ccip_port_next_afu.afu_id_offset) {
+
+      // Get the AFU Header
+      struct CCIP_AFU_Header *pafu_hdr = (struct CCIP_AFU_Header *)(((btVirtAddr)pport_dev->m_pport_hdr) + pport_dev->m_pport_hdr->ccip_port_next_afu.afu_id_offset);
+
+      PDEBUG( "USER AFU   START %p \n \n", pafu_hdr);
+
+      PDEBUG( "Feature_ID = %x \n",pafu_hdr->ccip_dfh.Feature_ID);
+      PDEBUG( "Feature_rev = %x \n",pafu_hdr->ccip_dfh.Feature_rev);
+      PDEBUG( "Type = %x \n",pafu_hdr->ccip_dfh.Type);
+      PDEBUG( "next_DFH_offset = %x \n",pafu_hdr->ccip_dfh.next_DFH_offset);
+
+      PDEBUG( "afu_id_l.afu_id_l= %lx \n",( long unsigned int)pafu_hdr->ccip_afu_id_l.afu_id_l);
+      PDEBUG( "afu_id_h.afu_id_h= %lx \n",( long unsigned int)pafu_hdr->ccip_afu_id_h.afu_id_h);
+
+      PDEBUG( "next_afu.afu_id_offset= %x \n",pafu_hdr->ccip_next_afu.afu_id_offset);
+
+
+      PDEBUG( "USER AFU  END \n \n");
+ //     pafu_hdr = NULL;  // COMPILER COMPLAINS VARIABLE NOT USED UNLESS WE DO THIS
+   }
+
+
+   PDEBUG( "*****************************************************************\n");
+   PDEBUG( "*****************************************************************\n");
+
+   ERR:
+
+   return res;
+
+}
+
+
+
diff --git a/drivers/fpga/aal/cci/ccip_stap.c b/drivers/fpga/aal/cci/ccip_stap.c
new file mode 100644
index 000000000000..b25715b3f8d0
--- /dev/null
+++ b/drivers/fpga/aal/cci/ccip_stap.c
@@ -0,0 +1,347 @@
+//******************************************************************************
+// This  file  is  provided  under  a  dual BSD/GPLv2  license.  When using or
+//         redistributing this file, you may do so under either license.
+//
+//                            GPL LICENSE SUMMARY
+//
+//  Copyright(c) 2015-2017, Intel Corporation.
+//
+//  This program  is  free software;  you  can redistribute it  and/or  modify
+//  it  under  the  terms of  version 2 of  the GNU General Public License  as
+//  published by the Free Software Foundation.
+//
+//  This  program  is distributed  in the  hope that it  will  be useful,  but
+//  WITHOUT   ANY   WARRANTY;   without   even  the   implied   warranty    of
+//  MERCHANTABILITY  or  FITNESS  FOR  A  PARTICULAR  PURPOSE.  See  the   GNU
+//  General Public License for more details.
+//
+//  The  full  GNU  General Public License is  included in  this  distribution
+//  in the file called README.GPLV2-LICENSE.TXT.
+//
+//  Contact Information:
+//  Henry Mitchel, henry.mitchel at intel.com
+//  77 Reed Rd., Hudson, MA  01749
+//
+//                                BSD LICENSE
+//
+//  Copyright(c) 2015-2017, Intel Corporation.
+//
+//  Redistribution and  use  in source  and  binary  forms,  with  or  without
+//  modification,  are   permitted  provided  that  the  following  conditions
+//  are met:
+//
+//    * Redistributions  of  source  code  must  retain  the  above  copyright
+//      notice, this list of conditions and the following disclaimer.
+//    * Redistributions in  binary form  must  reproduce  the  above copyright
+//      notice,  this  list of  conditions  and  the  following disclaimer  in
+//      the   documentation   and/or   other   materials   provided  with  the
+//      distribution.
+//    * Neither   the  name   of  Intel  Corporation  nor  the  names  of  its
+//      contributors  may  be  used  to  endorse  or promote  products derived
+//      from this software without specific prior written permission.
+//
+//  THIS  SOFTWARE  IS  PROVIDED  BY  THE  COPYRIGHT HOLDERS  AND CONTRIBUTORS
+//  "AS IS"  AND  ANY  EXPRESS  OR  IMPLIED  WARRANTIES,  INCLUDING,  BUT  NOT
+//  LIMITED  TO, THE  IMPLIED WARRANTIES OF  MERCHANTABILITY  AND FITNESS  FOR
+//  A  PARTICULAR  PURPOSE  ARE  DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT
+//  OWNER OR CONTRIBUTORS BE LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,
+//  SPECIAL,  EXEMPLARY,  OR  CONSEQUENTIAL   DAMAGES  (INCLUDING,   BUT   NOT
+//  LIMITED  TO,  PROCUREMENT  OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF USE,
+//  DATA,  OR PROFITS;  OR BUSINESS INTERRUPTION)  HOWEVER  CAUSED  AND ON ANY
+//  THEORY  OF  LIABILITY,  WHETHER  IN  CONTRACT,  STRICT LIABILITY,  OR TORT
+//  (INCLUDING  NEGLIGENCE  OR OTHERWISE) ARISING  IN ANY WAY  OUT  OF THE USE
+//  OF  THIS  SOFTWARE, EVEN IF ADVISED  OF  THE  POSSIBILITY  OF SUCH DAMAGE.
+//******************************************************************************
+//****************************************************************************
+/// @file ccip_stap.c
+/// @brief  Definitions for ccip Signal Tap AAL device.
+/// @ingroup aalkernel_ccip
+/// @verbatim
+//        FILE: ccip_port_mmio.c
+//     CREATED: Nov 11, 2015
+//      AUTHOR:
+//
+// PURPOSE:   This file contains the implementation of the CCIP Signal Tap
+//             low-level function (i.e., Physical Interface Protocol driver).
+// HISTORY:
+// COMMENTS:
+// WHEN:          WHO:     WHAT:
+//****************************************************************************///
+#include "aalsdk/kernel/kosal.h"
+#define MODULE_FLAGS CCIPCIE_DBG_MOD
+
+#include "aalsdk/kernel/AALTransactionID_s.h"
+#include "aalsdk/kernel/aalbus-ipip.h"
+#include "aalsdk/kernel/ccip_defs.h"
+
+#include "aalsdk/kernel/ccipdriver.h"
+#include "ccipdrv-events.h"
+
+#include "ccip_port.h"
+#include "cci_pcie_driver_PIPsession.h"
+
+
+
+///////////////////////////////////////////////////////////////////////////////
+///////////////////////////////////////////////////////////////////////////////
+////////////////////                                     //////////////////////
+/////////////////              PIP INTERFACE               ////////////////////
+////////////////////                                     //////////////////////
+///////////////////////////////////////////////////////////////////////////////
+///////////////////////////////////////////////////////////////////////////////
+
+static int CommandHandler( struct aaldev_ownerSession *,
+                           struct aal_pipmessage*);
+
+// TODO going to try and use a common mmapper for all objects
+extern int cci_mmap( struct aaldev_ownerSession *pownerSess,
+                     struct aal_wsid *wsidp,
+                     btAny os_specific );
+
+///=============================================================================
+/// Name: cci_STPpip
+/// @brief Physical Interface Protocol Interface for the Signal Tap AFU
+///              kernel based AFU engine.
+///=============================================================================
+struct aal_ipip cci_STAPpip = {
+   .m_messageHandler = {
+      .sendMessage   = CommandHandler,       // Command Handler
+      .bindSession   = BindSession,          // Session binder
+      .unBindSession = UnbindSession,        // Session unbinder
+   },
+
+   .m_fops = {
+     .mmap = cci_mmap,
+   },
+
+   // Methods for binding and unbinding PIP to generic aal_device
+   //  Unused in this PIP
+   .binddevice    = NULL,      // Binds the PIP to the device
+   .unbinddevice  = NULL,      // Binds the PIP to the device
+};
+
+///============================================================================
+/// Name: cci_create_AAL_SignalTap_Device
+/// @brief Creates and registers Signal Tap objects (resources) we want to
+///        expose through AAL.
+///
+/// @param[in] pportdev - Port device
+/// @param[in] paalid - Base AAL ID for this device.
+/// @return    AAL Device pointer
+///============================================================================
+struct cci_aal_device   *
+               cci_create_AAL_SignalTap_Device( struct port_device  *pportdev,
+                                                struct aal_device_id *paalid)
+{
+   struct cci_aal_device   *pcci_aaldev = NULL;
+   int ret;
+
+   PTRACEIN;
+
+   PVERBOSE("Creating Signal Tap device\n");
+
+   // Construct the cci_aal_device object
+   pcci_aaldev = cci_create_aal_device();
+
+   ASSERT(NULL != pcci_aaldev);
+   if( NULL == pcci_aaldev){
+      return NULL;
+   }
+
+   // Make it a User AFU
+   cci_aaldev_type(pcci_aaldev)     = cci_dev_STAP;
+
+   // Record parentage
+   cci_aaldev_pport(pcci_aaldev)    = pportdev;       // Save its port
+   cci_aaldev_pfme(pcci_aaldev)     = ccip_port_dev_fme(pportdev);
+
+   // Save the PCI devcie handle
+   cci_aaldev_pci_dev(pcci_aaldev)  = ccip_dev_to_pci_dev( ccip_port_to_ccidev(pportdev) );
+
+   // Device Address is the same as the Port. Set the AFU ID information
+   // The following attributes describe the interfaces supported by the device
+   aaldevid_afuguidl(*paalid)            = CCIP_STAP_GUIDL;
+   aaldevid_afuguidh(*paalid)            = CCIP_STAP_GUIDH;
+   aaldevid_pipguid(*paalid)             = CCIP_STAP_PIPIID;
+
+   // Setup the MMIO region parameters
+   cci_aaldev_kvp_afu_mmio(pcci_aaldev)   = (btVirtAddr)ccip_port_stap(pportdev);
+   cci_aaldev_len_afu_mmio(pcci_aaldev)   = sizeof(struct CCIP_PORT_DFL_STAP);
+   cci_aaldev_phys_afu_mmio(pcci_aaldev)  = kosal_virt_to_phys((btVirtAddr)ccip_port_stap(pportdev));
+
+   // Create the AAL device and attach it to the CCI device object
+   cci_aaldev_to_aaldev(pcci_aaldev) =  aaldev_create( "CCIPSTAP",         // AAL device base name
+                                                       paalid,             // AAL ID
+                                                       &cci_STAPpip);
+
+   //CCI device object create fails, delete Signal AAL device
+   if(NULL == cci_aaldev_to_aaldev(pcci_aaldev) ){
+      cci_destroy_aal_device(pcci_aaldev);
+      return NULL;
+   }
+
+   //===========================================================
+   // Set up the optional aal_device attributes
+   //
+
+   // Set how many owners are allowed access to this device simultaneously
+   cci_aaldev_to_aaldev(pcci_aaldev)->m_maxowners = 1;
+
+   // Set the config space mapping permissions
+   cci_aaldev_to_aaldev(pcci_aaldev)->m_mappableAPI = AAL_DEV_APIMAP_NONE;
+
+   if( cci_aaldev_allow_map_mmior_space(pcci_aaldev) ){
+      cci_aaldev_to_aaldev(pcci_aaldev)->m_mappableAPI |= AAL_DEV_APIMAP_MMIOR;
+   }
+
+   // The PIP uses the PIP context to get a handle to the CCI Device from the generic device.
+   aaldev_pip_context(cci_aaldev_to_aaldev(pcci_aaldev)) = (void*)pcci_aaldev;
+
+   // Method called when the device is released (i.e., its destructor)
+   //  The canonical release device calls the user's release method.
+   //  If NULL is provided then only the canonical behavior is done
+   dev_setrelease(cci_aaldev_to_aaldev(pcci_aaldev), cci_release_device);
+
+      // Device is ready for use.  Publish it with the Configuration Management Subsystem
+   ret = cci_publish_aaldevice(pcci_aaldev);
+   ASSERT(ret == 0);
+   if(0> ret){
+      PERR("Failed to initialize AAL Device for CCIPSTAP[%d:%d:%d:%d]",aaldevid_devaddr_busnum(*paalid),
+                                                                       aaldevid_devaddr_devnum(*paalid),
+                                                                       aaldevid_devaddr_fcnnum(*paalid),
+                                                                       aaldevid_devaddr_subdevnum(*paalid));
+      cci_destroy_aal_device(pcci_aaldev);
+      return NULL;
+   }
+   return pcci_aaldev;
+}
+
+
+//=============================================================================
+// Name: CommandHandler
+// Description: Implements the PIP command handler
+// Interface: public
+// Inputs: pownerSess - Session between App and device
+//         Message - Message to process
+// Outputs: none.
+// Comments:
+//=============================================================================
+int
+CommandHandler(struct aaldev_ownerSession *pownerSess,
+               struct aal_pipmessage       *Message)
+{
+#if (1 == ENABLE_DEBUG)
+#define AFU_COMMAND_CASE(x) case x : PDEBUG("%s\n", #x);
+#else
+#define AFU_COMMAND_CASE(x) case x :
+#endif // ENABLE_DEBUG
+
+
+   // Private session object set at session bind time (i.e., when object allocated)
+   struct cci_PIPsession *pSess = (struct cci_PIPsession *)aalsess_pipHandle(pownerSess);
+   struct cci_aal_device  *pdev  = NULL;
+
+   // Overall return value for this function. Set before exiting if there is an error.
+   //    retval = 0 means good return.
+   int retval = 0;
+
+   // UI Driver message
+   struct aalui_CCIdrvMessage *pmsg = (struct aalui_CCIdrvMessage *) Message->m_message;
+
+   // Save original response buffer size in case we return something
+   btWSSize         respBufSize     = Message->m_respbufSize;
+
+   // Assume returning nothing. By setting the response buffer size to 0
+   //   we tell the upstream side that there is no payload to copy back.
+   //   Setting it here means we don't have to set it (or forget to) in each
+   //   command.  We've recorded the payload buffer size above if we do need
+   //   intend to send a payload.
+   Message->m_respbufSize          = 0;
+
+   PTRACEIN;
+
+   // Perform some basic checks while assigning the pdev
+   ASSERT(NULL != pSess );
+   if ( NULL == pSess ) {
+      PDEBUG("Error: No PIP session\n");
+      return -EIO;
+   }
+
+   // Get the cci device
+   pdev = cci_PIPsessionp_to_ccidev(pSess);
+   if ( NULL == pdev ) {
+      PDEBUG("Error: No device\n");
+      return -EIO;
+   }
+
+   //=====================
+   // Message processor
+   //=====================
+   switch ( pmsg->cmd ) {
+
+      // Returns a workspace ID for the Config Space
+      AFU_COMMAND_CASE(ccipdrv_getMMIORmap) {
+         struct aalui_WSMEvent WSID;
+         struct ccidrvreq *preq = (struct ccidrvreq *)pmsg->payload;
+
+         // Used to hold the workspace ID
+         struct aal_wsid   *wsidp            = NULL;
+
+         // clear WSID structure
+         memset(&WSID, 0, sizeof(struct aalui_WSMEvent));
+
+         wsidp = ccidrv_getwsid(pownerSess->m_device, preq->ahmreq.u.wksp.m_wsid);
+         if ( NULL == wsidp ) {
+            PERR("Could not allocate workspace\n");
+            retval = -ENOMEM;
+            /* generate a failure event back to the caller? */
+            goto ERROR;
+         }
+
+         wsidp->m_type = WSM_TYPE_MMIO;
+         PDEBUG("Getting CSR %s Aperature WSID %p using id %llx .\n",
+                   ((WSID_CSRMAP_WRITEAREA == preq->ahmreq.u.wksp.m_wsid) ? "Write" : "Read"),
+                   wsidp,
+                   preq->ahmreq.u.wksp.m_wsid);
+
+         PDEBUG("Apt = %" PRIxPHYS_ADDR " Len = %d.\n",cci_aaldev_phys_afu_mmio(pdev), (int)cci_aaldev_len_afu_mmio(pdev));
+
+         WSID.evtID           = uid_wseventMMIOMap;
+         WSID.wsParms.wsid    = pwsid_to_wsidHandle(wsidp);
+         WSID.wsParms.physptr = cci_aaldev_phys_afu_mmio(pdev);
+         WSID.wsParms.size    = cci_aaldev_len_afu_mmio(pdev);
+
+         // Make this atomic. Check the original response buffer size for room
+         if(respBufSize >= sizeof(struct aalui_WSMEvent)){
+            *((struct aalui_WSMEvent*)Message->m_response) = WSID;
+            Message->m_respbufSize = sizeof(struct aalui_WSMEvent);
+         }
+
+         PDEBUG("Buf size =  %u Returning WSID %llx\n",(unsigned int)Message->m_respbufSize, *((btWSID*)Message->m_response)  );
+         if ( 0 != retval ) {
+            goto ERROR;
+         }
+
+         Message->m_errcode = uid_errnumOK;
+         retval = 0;
+
+         // Add the new wsid onto the session
+         aalsess_add_ws(pownerSess, wsidp->m_list);
+
+      } break;
+
+      default: {
+         // No payload
+         PDEBUG("Unrecognized command %" PRIu64 " or 0x%" PRIx64 " in AFUCommand\n", pmsg->cmd, pmsg->cmd);
+         Message->m_respbufSize          = 0;
+         Message->m_errcode = uid_errnumInvalidRequest;
+         retval = -EINVAL;
+      } break;
+   } // switch (pmsg->cmd)
+
+   ASSERT(0 == retval);
+
+ERROR:
+   return retval;
+}
+
diff --git a/drivers/fpga/aal/cci/ccipdrv-events.h b/drivers/fpga/aal/cci/ccipdrv-events.h
new file mode 100644
index 000000000000..a1c9dccfb69c
--- /dev/null
+++ b/drivers/fpga/aal/cci/ccipdrv-events.h
@@ -0,0 +1,702 @@
+//******************************************************************************
+// This  file  is  provided  under  a  dual BSD/GPLv2  license.  When using or
+//         redistributing this file, you may do so under either license.
+//
+//                            GPL LICENSE SUMMARY
+//
+//  Copyright(c) 2015-2017, Intel Corporation.
+//
+//  This program  is  free software;  you  can redistribute it  and/or  modify
+//  it  under  the  terms of  version 2 of  the GNU General Public License  as
+//  published by the Free Software Foundation.
+//
+//  This  program  is distributed  in the  hope that it  will  be useful,  but
+//  WITHOUT   ANY   WARRANTY;   without   even  the   implied   warranty    of
+//  MERCHANTABILITY  or  FITNESS  FOR  A  PARTICULAR  PURPOSE.  See  the   GNU
+//  General Public License for more details.
+//
+//  The  full  GNU  General Public License is  included in  this  distribution
+//  in the file called README.GPLV2-LICENSE.TXT.
+//
+//  Contact Information:
+//  Henry Mitchel, henry.mitchel at intel.com
+//  77 Reed Rd., Hudson, MA  01749
+//
+//                                BSD LICENSE
+//
+//  Copyright(c) 2015-2017, Intel Corporation.
+//
+//  Redistribution and  use  in source  and  binary  forms,  with  or  without
+//  modification,  are   permitted  provided  that  the  following  conditions
+//  are met:
+//
+//    * Redistributions  of  source  code  must  retain  the  above  copyright
+//      notice, this list of conditions and the following disclaimer.
+//    * Redistributions in  binary form  must  reproduce  the  above copyright
+//      notice,  this  list of  conditions  and  the  following disclaimer  in
+//      the   documentation   and/or   other   materials   provided  with  the
+//      distribution.
+//    * Neither   the  name   of  Intel  Corporation  nor  the  names  of  its
+//      contributors  may  be  used  to  endorse  or promote  products derived
+//      from this software without specific prior written permission.
+//
+//  THIS  SOFTWARE  IS  PROVIDED  BY  THE  COPYRIGHT HOLDERS  AND CONTRIBUTORS
+//  "AS IS"  AND  ANY  EXPRESS  OR  IMPLIED  WARRANTIES,  INCLUDING,  BUT  NOT
+//  LIMITED  TO, THE  IMPLIED WARRANTIES OF  MERCHANTABILITY  AND FITNESS  FOR
+//  A  PARTICULAR  PURPOSE  ARE  DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT
+//  OWNER OR CONTRIBUTORS BE LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,
+//  SPECIAL,  EXEMPLARY,  OR  CONSEQUENTIAL   DAMAGES  (INCLUDING,   BUT   NOT
+//  LIMITED  TO,  PROCUREMENT  OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF USE,
+//  DATA,  OR PROFITS;  OR BUSINESS INTERRUPTION)  HOWEVER  CAUSED  AND ON ANY
+//  THEORY  OF  LIABILITY,  WHETHER  IN  CONTRACT,  STRICT LIABILITY,  OR TORT
+//  (INCLUDING  NEGLIGENCE  OR OTHERWISE) ARISING  IN ANY WAY  OUT  OF THE USE
+//  OF  THIS  SOFTWARE, EVEN IF ADVISED  OF  THE  POSSIBILITY  OF SUCH DAMAGE.
+//******************************************************************************
+//****************************************************************************
+//        FILE: ccidrv-events.h
+//     CREATED: Nov. 2, 2008
+//      AUTHOR: Joseph Grecco, Intel <joe.grecco@intel.com>
+//
+// PURPOSE: This implements the external events for the
+//          Accelerator Abstraction Layer (AAL)
+//          CCIP Debice Driver
+// HISTORY:
+// WHEN:          WHO:     WHAT:
+// 11/02/2015     JG       Initial Version started
+//****************************************************************************
+#ifndef __AALSDK_KERNEL_CCIPDRV_EVENTS_H__
+#define __AALSDK_KERNEL_CCIPDRV_EVENTS_H__
+#include <aalsdk/kernel/kosal.h>
+#include <aalsdk/kernel/aaldevice.h>
+#include <aalsdk/kernel/aalqueue.h>
+
+#include <aalsdk/kernel/ccipdriver.h>
+
+BEGIN_NAMESPACE(AAL)
+
+//=============================================================================
+//=============================================================================
+// Name: ccipdrv_event_afu_response_event
+// @brief AFU Reponse event. Sent to report various AFU responses
+//=============================================================================
+//=============================================================================
+struct ccipdrv_event_afu_response_event
+{
+#define qip_to_ui_evtp_afuresponse(pqi) kosal_container_of(pqi, struct ccipdrv_event_afu_response_event, m_qitem)
+#define ui_evtp_afuresponse_to_qip(evt) ( &AALQI(evt) )
+   //
+   // Including the macro effectively causes this object to be derived from
+   // aal_q_item
+   //
+   _DECLARE_AALQ_TYPE;
+
+   btObjectType      m_devhandle;
+   uid_errnum_e      m_errnum;
+   stTransactionID_t m_tranID;
+   btObjectType      m_context;
+   btUnsignedInt     m_payloadsize;
+   btByte            m_payload[1];
+
+};
+
+//=============================================================================
+// Name: ccipdrv_event_shutdown_event_create
+// Inputs: reason - reason for the shutdown
+//         timeleft - If a timeout was given in the request how much is left
+//                    for user space shutdown.(i.e.,timeout-timeused in kernel)
+// Description: Constructor
+//=============================================================================
+static inline
+struct ccipdrv_event_afu_response_event *
+ccipdrv_event_shutdown_event_create(ui_shutdownreason_e reason,
+                                    btTime              timeleft,
+                                    stTransactionID_t  *tranID,
+                                    btObjectType        context,
+                                    uid_errnum_e        errnum)
+{
+   struct aalui_Shutdown *shutdownnparms = NULL;
+
+   // Allocate for event and payload
+   struct ccipdrv_event_afu_response_event *This =
+      (struct ccipdrv_event_afu_response_event *)kosal_kzmalloc( sizeof(struct ccipdrv_event_afu_response_event) + sizeof(struct aalui_Shutdown) );
+
+   if ( NULL == This ) {
+      return NULL;
+   }
+
+   // Fill in generic stuff
+   This->m_errnum             = errnum;
+   This->m_context            = context;
+   This->m_tranID             = *tranID;
+
+   // Point at the payload
+   shutdownnparms = (struct aalui_Shutdown*)This->m_payload;
+
+   // Fill in the payload
+   shutdownnparms->m_reason = reason;
+   shutdownnparms->m_timeout = timeleft;
+
+   AALQ_QLEN(This) = sizeof(struct aalui_Shutdown);
+   AALQ_QID(This)  = rspid_UID_Shutdown;
+
+   // Initialize the queue item
+   kosal_list_init(&AALQ_QUEUE(This));
+   return This;
+}
+
+//=============================================================================
+// Name: ccipdrv_event_activationchange_event_create
+// Inputs: reason - reason for the shutdown
+//         timeleft - If a timeout was given in the request how much is left
+//                    for user space shutdown.(i.e.,timeout-timeused in kernel)
+// Description: Constructor
+//=============================================================================
+static inline
+struct ccipdrv_event_afu_response_event *
+ccipdrv_event_activationchange_event_create( uid_afurespID_e    respID,
+                                             btObjectType       devhandle,
+                                             stTransactionID_t *tranID,
+                                             btObjectType       context,
+                                             uid_errnum_e       errnum)
+{
+struct aalui_AFUResponse *response = NULL;
+struct ccipdrv_event_afu_response_event *This =
+(struct ccipdrv_event_afu_response_event *)kosal_kzmalloc( sizeof(struct ccipdrv_event_afu_response_event) + sizeof(struct aalui_AFUResponse));
+
+if ( NULL == This ) {
+return NULL;
+}
+
+This->m_devhandle = devhandle;
+This->m_errnum    = errnum;
+This->m_context   = context;
+This->m_tranID    = *tranID;
+
+// Point at the payload
+response = (struct aalui_AFUResponse*)This->m_payload;
+
+response->respID  = respID;
+response->evtData = 0;
+response->payloadsize = 0;
+
+AALQ_QLEN(This) = sizeof(struct aalui_AFUResponse );
+AALQ_QID(This) = rspid_AFU_Response;
+
+// Initialize the queue item
+kosal_list_init(&AALQ_QUEUE(This));
+
+return This;
+}
+
+//=============================================================================
+// Name: ccipdrv_event_reconfig_event_create
+// Inputs:
+// Description: Constructor
+//=============================================================================
+static inline
+struct ccipdrv_event_afu_response_event *
+ccipdrv_event_reconfig_event_create( uid_afurespID_e    respID,
+                                     btObjectType       devhandle,
+                                     stTransactionID_t *tranID,
+                                     btObjectType       context,
+                                     uid_errnum_e       errnum)
+{
+struct aalui_AFUResponse *response = NULL;
+struct ccipdrv_event_afu_response_event *This =
+(struct ccipdrv_event_afu_response_event *)kosal_kzmalloc( sizeof(struct ccipdrv_event_afu_response_event) + sizeof(struct aalui_AFUResponse));
+
+if ( NULL == This ) {
+return NULL;
+}
+
+This->m_devhandle = devhandle;
+This->m_errnum    = errnum;
+This->m_context   = context;
+This->m_tranID    = *tranID;
+
+// Point at the payload
+response = (struct aalui_AFUResponse*)This->m_payload;
+
+response->respID  = respID;
+response->evtData = 0;
+response->payloadsize = 0;
+
+AALQ_QLEN(This) = sizeof(struct aalui_AFUResponse );
+AALQ_QID(This) = rspid_AFU_Response;
+
+// Initialize the queue item
+kosal_list_init(&AALQ_QUEUE(This));
+
+return This;
+}
+
+
+//=============================================================================
+// Name: ccipdrv_event_afu_afuinavlidrequest_create
+// Description: Constructor
+//=============================================================================
+static inline
+struct ccipdrv_event_afu_response_event *
+ccipdrv_event_afu_afuinavlidrequest_create(btObjectType       devhandle,
+                                           stTransactionID_t *tranID,
+                                           btObjectType       context,
+                                           uid_errnum_e       eno)
+{
+   struct aalui_AFUResponse *response = NULL;
+   struct ccipdrv_event_afu_response_event *This =
+      (struct ccipdrv_event_afu_response_event *)kosal_kzmalloc( sizeof(struct ccipdrv_event_afu_response_event) + sizeof(struct aalui_AFUResponse));
+
+   if ( NULL == This ) {
+      return NULL;
+   }
+
+   This->m_devhandle = devhandle;
+   This->m_errnum    = eno;
+   This->m_context   = context;
+   This->m_tranID    = *tranID;
+
+   // Point at the payload
+   response = (struct aalui_AFUResponse*)This->m_payload;
+
+   response->respID  = uid_afurespUndefinedRequest;
+   response->evtData = 0;
+   response->payloadsize = 0;
+
+   AALQ_QLEN(This) = sizeof(struct aalui_AFUResponse );
+   AALQ_QID(This) = rspid_AFU_Response;
+
+   // Initialize the queue item
+   kosal_list_init(&AALQ_QUEUE(This));
+
+   return This;
+}
+
+//=============================================================================
+// Name: ccipdrv_event_afu_afucsrmap_create
+// Description: Constructor
+//=============================================================================
+static inline
+struct ccipdrv_event_afu_response_event *
+ccipdrv_event_afu_afuallocws_create( btObjectType      devhandle,
+                                     btWSID            wsid,
+                                     btVirtAddr        ptr,
+                                     btPhysAddr        physptr,
+                                     btWSSize          size,
+                                     stTransactionID_t tranID,
+                                     btObjectType      context,
+                                     uid_errnum_e      errnum)
+{
+   struct aalui_WSMEvent * WSEvent = NULL;
+   struct ccipdrv_event_afu_response_event *This =
+      (struct ccipdrv_event_afu_response_event *)kosal_kmalloc(sizeof(struct ccipdrv_event_afu_response_event) + sizeof(struct aalui_WSMEvent));
+
+   if ( NULL == This ) {
+      return NULL;
+   }
+
+   This->m_devhandle                = devhandle;
+   This->m_errnum                   = errnum;
+   This->m_context                  = context;
+   This->m_tranID                   = tranID;
+
+   // Point at the payload
+   WSEvent = (struct aalui_WSMEvent*)This->m_payload;
+
+   WSEvent->evtID            = uid_wseventAllocate;
+   WSEvent->wsParms.wsid     = wsid;
+   WSEvent->wsParms.ptr      = ptr;
+   WSEvent->wsParms.physptr  = physptr;
+   WSEvent->wsParms.size     = size;
+
+   AALQ_QID(This)                   = rspid_WSM_Response;
+   AALQ_QLEN(This) = sizeof(struct aalui_WSMEvent);
+
+   // Initialize the queue item
+   kosal_list_init(&AALQ_QUEUE(This));
+   return This;
+}
+
+
+//=============================================================================
+// Name: ccipdrv_event_afu_afufreecws_create
+// Description: Constructor
+//=============================================================================
+static inline
+struct ccipdrv_event_afu_response_event *
+ccipdrv_event_afu_afufreecws_create( btObjectType      devhandle,
+                                     stTransactionID_t tranID,
+                                     btObjectType      context,
+                                     uid_errnum_e      eno)
+{
+   struct aalui_WSMEvent * WSEvent = NULL;
+   struct ccipdrv_event_afu_response_event *This =
+      (struct ccipdrv_event_afu_response_event *)kosal_kmalloc( sizeof(struct ccipdrv_event_afu_response_event)+ sizeof(struct aalui_WSMEvent) );
+   if ( NULL == This ) {
+      return NULL;
+   }
+
+   This->m_devhandle     = devhandle;
+   This->m_errnum        = eno;
+   This->m_context       = context;
+   This->m_tranID        = tranID;
+
+   // Point at the payload
+   WSEvent = (struct aalui_WSMEvent*)This->m_payload;
+   WSEvent->evtID = uid_wseventFree;
+
+   // no payload
+   AALQ_QID(This)  = rspid_WSM_Response;
+   AALQ_QLEN(This) = sizeof(struct aalui_WSMEvent);
+
+   // Initialize the queue item
+   kosal_list_init(&AALQ_QUEUE(This));
+   return This;
+}
+
+///============================================================================
+/// Name: ccipdrv_event_afu_aysnc_pr_revoke_create
+/// @brief Creates AFU revoke event
+///
+/// @param[in] respID - Response ID
+/// @param[in] devhandle -aal device handle.
+/// @param[in] context - applicator context.
+/// @param[in] eno - error id.
+/// @return    afu Response event
+///============================================================================
+static inline
+struct ccipdrv_event_afu_response_event *
+ccipdrv_event_afu_aysnc_pr_revoke_create(uid_afurespID_e    respID,
+                                         btObjectType       devhandle,
+                                         btObjectType       context,
+                                         uid_errnum_e       eno)
+{
+   struct aalui_AFUResponse *response = NULL;
+   struct ccipdrv_event_afu_response_event *This =
+      (struct ccipdrv_event_afu_response_event *)kosal_kzmalloc( sizeof(struct ccipdrv_event_afu_response_event) + sizeof(struct aalui_AFUResponse));
+
+   if ( NULL == This ) {
+      return NULL;
+   }
+
+   This->m_devhandle = devhandle;
+   This->m_errnum    = eno;
+   This->m_context   = context;
+
+   // Point at the payload
+   response = (struct aalui_AFUResponse*)This->m_payload;
+
+   response->respID      = respID;
+   response->evtData     = 0;
+   response->payloadsize = 0;
+
+   AALQ_QID(This)  = rspid_AFU_PR_Revoke_Event;
+   AALQ_QLEN(This) = sizeof(struct aalui_AFUResponse );
+
+   // Initialize the queue item
+   kosal_list_init(&AALQ_QUEUE(This));
+
+   return This;
+}
+
+///============================================================================
+/// Name: ccipdrv_event_afu_aysnc_pr_request_release_create
+/// @brief Creates AFU release event
+///
+/// @param[in] respID - Response ID
+/// @param[in] devhandle -aal device handle.
+/// @param[in] context - applicator context.
+/// @param[in] eno - error id.
+/// @return    afu Response event
+///============================================================================
+static inline
+struct ccipdrv_event_afu_response_event *
+ccipdrv_event_afu_aysnc_pr_request_release_create(uid_afurespID_e    respID,
+                                                  btObjectType       devhandle,
+                                                  btObjectType       context,
+                                                  btUnsigned64bitInt action,
+                                                  btUnsigned64bitInt timeout,
+                                                  uid_errnum_e       eno)
+{
+#if   defined( __AAL_WINDOWS__ )
+   UNREFERENCED_PARAMETER(action);
+#endif
+   struct aalui_PREvent *response = NULL;
+   struct ccipdrv_event_afu_response_event *This =
+      (struct ccipdrv_event_afu_response_event *)kosal_kzmalloc( sizeof(struct ccipdrv_event_afu_response_event) + sizeof(struct aalui_PREvent));
+
+   if ( NULL == This ) {
+      return NULL;
+   }
+
+   This->m_devhandle  = devhandle;
+   This->m_errnum     = eno;
+   This->m_context    = context;
+
+   // Point at the payload
+   response = (struct aalui_PREvent*)This->m_payload;
+
+   response->respID        = respID;
+   response->evtData       = 0;
+   response->reconfTimeout = timeout;
+
+   AALQ_QID(This)  = rspid_AFU_PR_Release_Request_Event;
+   AALQ_QLEN(This) = sizeof(struct aalui_PREvent );
+
+   // Initialize the queue item
+   kosal_list_init(&AALQ_QUEUE(This));
+
+   return This;
+}
+
+///============================================================================
+/// Name: ccipdrv_event_afu_aysnc_pr_release_create
+/// @brief Creates PR release event
+///
+/// @param[in] respID - Response ID
+/// @param[in] devhandle -aal device handle.
+/// @param[in] context - applicator context.
+/// @param[in] eno - error id.
+/// @return    afu Response event
+///============================================================================
+static inline
+struct ccipdrv_event_afu_response_event *
+ccipdrv_event_afu_aysnc_pr_release_create(uid_afurespID_e    respID,
+                                          btObjectType       devhandle,
+                                          btObjectType       context,
+                                          uid_errnum_e       eno)
+{
+   struct aalui_AFUResponse *response = NULL;
+   struct ccipdrv_event_afu_response_event *This =
+      (struct ccipdrv_event_afu_response_event *)kosal_kzmalloc( sizeof(struct ccipdrv_event_afu_response_event) + sizeof(struct aalui_AFUResponse));
+
+   if ( NULL == This ) {
+      return NULL;
+   }
+
+   This->m_devhandle = devhandle;
+   This->m_errnum    = eno;
+   This->m_context   = context;
+
+   // Point at the payload
+   response = (struct aalui_AFUResponse*)This->m_payload;
+
+   response->respID      = respID;
+   response->evtData     = 0;
+   response->payloadsize = 0;
+
+   AALQ_QID(This)  = rspid_AFU_Response;
+   AALQ_QLEN(This) = sizeof(struct aalui_AFUResponse );
+
+   // Initialize the queue item
+   kosal_list_init(&AALQ_QUEUE(This));
+
+   return This;
+}
+
+
+//=============================================================================
+// Name: ccipdrv_event_afu_afugetmmiomap_create
+// Description: Constructor
+//=============================================================================
+static inline
+struct ccipdrv_event_afu_response_event *
+ccipdrv_event_afu_afugetmmiomap_create( btObjectType      devhandle,
+                                        btWSID            wsid,
+                                        btPhysAddr        physptr,
+                                        btWSSize          size,
+                                        stTransactionID_t tranID,
+                                        btObjectType      context,
+                                        uid_errnum_e      errnum)
+{
+   struct aalui_WSMEvent * WSEvent = NULL;
+   struct ccipdrv_event_afu_response_event *This =
+      (struct ccipdrv_event_afu_response_event *)kosal_kmalloc( sizeof(struct ccipdrv_event_afu_response_event) + sizeof(struct aalui_WSMEvent));
+
+   if ( NULL == This ) {
+      return NULL;
+   }
+
+   This->m_devhandle                   = devhandle;
+   This->m_errnum                      = errnum;
+   This->m_context                     = context;
+   This->m_tranID                      = tranID;
+
+   // Point at the payload
+   WSEvent = (struct aalui_WSMEvent*)This->m_payload;
+   WSEvent->evtID               = uid_wseventMMIOMap;
+   WSEvent->wsParms.wsid        = wsid;
+   WSEvent->wsParms.ptr         = NULL;
+   WSEvent->wsParms.physptr     = physptr;
+   WSEvent->wsParms.size        = size;
+
+   // Payload
+   AALQ_QID(This)  = rspid_WSM_Response;
+   AALQ_QLEN(This) = sizeof(struct aalui_WSMEvent);
+
+   // Initialize the queue item
+   kosal_list_init(&AALQ_QUEUE(This));
+   return This;
+}
+
+//=============================================================================
+// Name: ccipdrv_event_bindcmplt_create
+// Description: Constructor
+//=============================================================================
+static inline struct ccipdrv_event_afu_response_event *
+                ccipdrv_event_bindcmplt_create( btObjectType devhandle,
+                                                struct ccipdrv_DeviceAttributes *pattributes,
+                                                uid_errnum_e errnum,
+                                                struct ccipui_ioctlreq  *preq)
+{
+   struct ccipdrv_DeviceAttributes           *pattrib       = NULL;
+   btWSSize                                   payloadsize   = 0;
+   struct ccipdrv_event_afu_response_event   *This          = NULL;
+
+   if( NULL != pattributes){
+      // Payload size is the size of the attribute object minus 1 for the array entry
+      //  plus the size of the variable data
+      payloadsize = (sizeof(struct ccipdrv_DeviceAttributes)) + pattributes->m_size;
+   }
+
+   // Allocate object
+   This =  (struct ccipdrv_event_afu_response_event *)kosal_kzmalloc( sizeof( struct ccipdrv_event_afu_response_event) +
+                                                                      payloadsize );
+   if(This == NULL){
+      return NULL;
+   }
+
+   This->m_devhandle = devhandle;
+   This->m_errnum    = errnum;
+   This->m_context   = preq->context;
+   This->m_tranID    = preq->tranID;
+
+   if(pattributes){
+
+      // Point at payload
+      pattrib = (struct ccipdrv_DeviceAttributes*)This->m_payload;
+
+      // Copy the main body
+      *pattrib = *pattributes;
+      if( 0 != pattributes->m_size){
+         // Now copy the payload
+         memcpy(pattrib->m_devattrib,pattributes->m_devattrib, pattributes->m_size);
+      }
+   }
+
+   AALQ_QID(This)    = rspid_UID_BindComplete;
+   AALQ_QLEN(This)   = payloadsize;
+
+   // Initialize the queue item
+   kosal_list_init(&AALQ_QUEUE(This));
+   return This;
+}
+
+//=============================================================================
+// Name: uidrv_event_unbindcmplt
+// Description: Bind Complete
+//=============================================================================
+struct uidrv_event_unbindcmplt
+{
+#define qip_to_ui_evtp_unbindcmplt(pqi) (container_of( pqi, struct uidrv_event_unbindcmplt, m_qitem ) )
+#define ui_evtp_unbindcmplt_to_qip(evt) ( &AALQI(evt) )
+   //
+   // Including the macro effectively causes this object to be derived from
+   // aal_q_item
+   //
+   _DECLARE_AALQ_TYPE;
+
+   uid_errnum_e                 m_errno;
+   stTransactionID_t            m_tranID;
+   void                        *m_context;
+};
+static inline
+struct ccipdrv_event_afu_response_event *
+ccipdrv_event_afu_aysnc_reconf_pwr_create(uid_afurespID_e    respID,
+                                          btObjectType       devhandle,
+                                          btObjectType       context,
+                                          btInt socketID,
+                                          btInt busID,
+                                          btInt deviceID,
+                                          btInt functionID,
+                                          btInt Reconf_PwrRequired,
+                                          stTransactionID_t tranID,
+                                          uid_errnum_e       eno)
+{
+#if   defined( __AAL_WINDOWS__ )
+   UNREFERENCED_PARAMETER(action);
+#endif
+   struct aalui_PwrMgrReconfEvent *response = NULL;
+   struct ccipdrv_event_afu_response_event *This =
+      (struct ccipdrv_event_afu_response_event *)kosal_kzmalloc( sizeof(struct ccipdrv_event_afu_response_event) + sizeof(struct aalui_PwrMgrReconfEvent));
+
+   if ( NULL == This ) {
+      return NULL;
+   }
+
+   This->m_devhandle  = devhandle;
+   This->m_errnum     = eno;
+   This->m_context    = context;
+
+   // Point at the payload
+   response = (struct aalui_PwrMgrReconfEvent*)This->m_payload;
+
+   response->m_respID               = respID;
+   response->m_evtData              = 0;
+   response->m_SocketID             = socketID;
+   response->m_DeviceID             = deviceID;
+   response->m_BusID                = busID;
+   response->m_FunctionID           = functionID;
+   response->m_Reconf_PwrRequired   = Reconf_PwrRequired;
+   response->m_tranID               = tranID;
+
+   AALQ_QID(This)  = rspid_PR_Power_Request_Event;
+   AALQ_QLEN(This) = sizeof(struct aalui_PwrMgrReconfEvent );
+
+   // Initialize the queue item
+   kosal_list_init(&AALQ_QUEUE(This));
+
+   return This;
+}
+
+//=============================================================================
+// Name: uidrv_event_Unbindcmplt_create
+// Description: Constructor
+//=============================================================================
+static inline struct ccipdrv_event_afu_response_event *
+                     ccipdrv_event_Unbindcmplt_create(uid_errnum_e errnum,
+                                                    struct ccipui_ioctlreq  *preq)
+{
+   struct ccipdrv_event_afu_response_event * This =
+                        (struct ccipdrv_event_afu_response_event *)kosal_kzmalloc(sizeof(struct ccipdrv_event_afu_response_event));
+   if(This == NULL){
+      return NULL;
+   }
+
+   This->m_context   = preq->context;
+   This->m_tranID    = preq->tranID;
+   This->m_errnum    = errnum;
+
+   AALQ_QID(This)    = rspid_UID_UnbindComplete;
+   AALQ_QLEN(This)   = 0;
+
+   // Initialize the queue item
+   kosal_list_init(&AALQ_QUEUE(This));
+   return This;
+}
+
+//=============================================================================
+// Name: ccipdrv_event_afuresponse_destroy
+// Description: Destructor
+//=============================================================================
+static inline
+void
+ccipdrv_event_afuresponse_destroy(struct ccipdrv_event_afu_response_event *This)
+{
+   kosal_kfree(This, sizeof(struct ccipdrv_event_afu_response_event) + AALQ_QLEN(This));
+}
+
+
+END_NAMESPACE(AAL)
+
+#endif // __AALSDK_KERNEL_CCIPDRV_EVENTS_H__
+
diff --git a/drivers/fpga/aal/cci/kOSAL.c b/drivers/fpga/aal/cci/kOSAL.c
new file mode 100644
index 000000000000..6335f93fba8a
--- /dev/null
+++ b/drivers/fpga/aal/cci/kOSAL.c
@@ -0,0 +1,692 @@
+//******************************************************************************
+// This  file  is  provided  under  a  dual BSD/GPLv2  license.  When using or
+//         redistributing this file, you may do so under either license.
+//
+//                            GPL LICENSE SUMMARY
+//
+//  Copyright(c) 2012-2017, Intel Corporation.
+//
+//  This program  is  free software;  you  can redistribute it  and/or  modify
+//  it  under  the  terms of  version 2 of  the GNU General Public License  as
+//  published by the Free Software Foundation.
+//
+//  This  program  is distributed  in the  hope that it  will  be useful,  but
+//  WITHOUT   ANY   WARRANTY;   without   even  the   implied   warranty    of
+//  MERCHANTABILITY  or  FITNESS  FOR  A  PARTICULAR  PURPOSE.  See  the   GNU
+//  General Public License for more details.
+//
+//  The  full  GNU  General Public License is  included in  this  distribution
+//  in the file called README.GPLV2-LICENSE.TXT.
+//
+//  Contact Information:
+//  Henry Mitchel, henry.mitchel at intel.com
+//  77 Reed Rd., Hudson, MA  01749
+//
+//                                BSD LICENSE
+//
+//  Copyright(c) 2012-2017, Intel Corporation.
+//
+//  Redistribution and  use  in source  and  binary  forms,  with  or  without
+//  modification,  are   permitted  provided  that  the  following  conditions
+//  are met:
+//
+//    * Redistributions  of  source  code  must  retain  the  above  copyright
+//      notice, this list of conditions and the following disclaimer.
+//    * Redistributions in  binary form  must  reproduce  the  above copyright
+//      notice,  this  list of  conditions  and  the  following disclaimer  in
+//      the   documentation   and/or   other   materials   provided  with  the
+//      distribution.
+//    * Neither   the  name   of  Intel  Corporation  nor  the  names  of  its
+//      contributors  may  be  used  to  endorse  or promote  products derived
+//      from this software without specific prior written permission.
+//
+//  THIS  SOFTWARE  IS  PROVIDED  BY  THE  COPYRIGHT HOLDERS  AND CONTRIBUTORS
+//  "AS IS"  AND  ANY  EXPRESS  OR  IMPLIED  WARRANTIES,  INCLUDING,  BUT  NOT
+//  LIMITED  TO, THE  IMPLIED WARRANTIES OF  MERCHANTABILITY  AND FITNESS  FOR
+//  A  PARTICULAR  PURPOSE  ARE  DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT
+//  OWNER OR CONTRIBUTORS BE LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,
+//  SPECIAL,  EXEMPLARY,  OR  CONSEQUENTIAL   DAMAGES  (INCLUDING,   BUT   NOT
+//  LIMITED  TO,  PROCUREMENT  OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF USE,
+//  DATA,  OR PROFITS;  OR BUSINESS INTERRUPTION)  HOWEVER  CAUSED  AND ON ANY
+//  THEORY  OF  LIABILITY,  WHETHER  IN  CONTRACT,  STRICT LIABILITY,  OR TORT
+//  (INCLUDING  NEGLIGENCE  OR OTHERWISE) ARISING  IN ANY WAY  OUT  OF THE USE
+//  OF  THIS  SOFTWARE, EVEN IF ADVISED  OF  THE  POSSIBILITY  OF SUCH DAMAGE.
+//******************************************************************************
+//****************************************************************************
+/// @file kOSAL.c
+/// @brief Implementation of the Kernel abstraction functions.
+/// @ingroup kOSAL
+/// @verbatim
+/// Accelerator Abstraction Layer
+///
+/// AUTHORS:  Joseph Grecco, Intel Corporation
+///           Tim Whisonant, Intel Corporation
+///
+/// HISTORY:
+/// WHEN:          WHO:     WHAT:
+/// 12/27/2012     JG       Initial version
+//****************************************************************************
+#include "aalsdk/kernel/kosal.h"
+#define MODULE_FLAGS KOSAL_DBG_MOD
+
+#if defined( __AAL_LINUX__ )
+#include <linux/vmalloc.h>
+# include <linux/delay.h>
+#include <linux/dma-mapping.h>
+#include <linux/rtc.h>
+#endif // __AAL_LINUX__
+
+#if defined( __AAL_UNKNOWN_OS__ )
+# error Implement kOSAL for unknown OS.
+#endif // __AAL_UNKNOWN_OS__
+
+//=============================================================================
+/// kosal_pci_read_config_dword
+/// @brief     Read a dword from PCIe device Config space
+/// @param[in] dev - PCI device handle
+///            offset - offset into Config space starting from beginning of 
+//                      header.
+//             
+/// @return    0 failed
+///
+/// @note   Windows intrinsic numbers bits 0 to 63, ffsll numbers
+///         them 1 to 64. Using ffsll variation.
+/// @note   Windows intrinsic must be set outside function
+//
+//=============================================================================
+btInt _kosal_pci_read_config_dword(__ASSERT_HERE_PROTO
+                                   pkosal_pci_dev      pdev,
+                                   btUnsigned32bitInt  offset,
+                                   btUnsigned32bitInt *pval)
+{
+   btInt res;
+#if   defined( __AAL_WINDOWS__ )
+   ULONG bytesRead = 0;
+#endif // __AAL_WINDOWS__
+
+   __ASSERT_HERE_IN_FN(NULL != pdev);
+   __ASSERT_HERE_IN_FN(NULL != pval);
+   if((NULL ==  pdev) || (NULL == pval)) {
+      res = -EINVAL;
+      return res ;
+   }
+
+#if   defined( __AAL_LINUX__ )
+
+   res = ( pci_read_config_dword(pdev, offset, pval) ? 0 : 1 );
+
+#elif defined( __AAL_WINDOWS__ )
+
+   bytesRead = pdev->GetBusData(pdev->Context,             // Context of bus interface
+                                PCI_WHICHSPACE_CONFIG,     // Config space
+                                pval,                      // Where to return it
+                                offset,                    // From the beginning
+                                sizeof(btUnsigned32bitInt));
+
+   res = ( sizeof(btUnsigned32bitInt) == bytesRead ? 1 : 0 );
+
+#endif // OS
+
+   PPCI_HERE("kosal_pci_read_config_dword(pdev=0x%" PRIxUINTPTR_T ", offset=%u [0x%x], pval=0x%" PRIxUINTPTR_T ") : *pval=0x%x [%u]\n",
+                __UINTPTR_T_CAST(pdev),
+                offset, offset,
+                __UINTPTR_T_CAST(pval),
+                *pval, *pval);
+
+   return res;
+}
+
+//=============================================================================
+/// kosal_virt_to_phys
+/// @brief     Convert a kernel virtual address to physical
+/// @param[in] vaddr - kernel virtual
+/// @return    physica address or NULLif  failed
+//=============================================================================
+btPhysAddr
+kosal_virt_to_phys(btAny vaddr)
+{
+#if   defined( __AAL_LINUX__ )
+
+   return (btPhysAddr)virt_to_phys(vaddr);
+
+#elif defined( __AAL_WINDOWS__ )
+
+   PHYSICAL_ADDRESS physaddr = { 0 };
+     
+   physaddr = MmGetPhysicalAddress(vaddr);
+
+   return (btPhysAddr)physaddr.QuadPart;
+
+#endif // OS
+}
+
+//=============================================================================
+/// kosal_mdelay
+/// @brief     Delay in milliseconds
+/// @param[in] time in millisecs
+/// @return    1 if success
+/// @note      This function may only be called when IRQL <= APC_LEVEL
+//=============================================================================
+btInt _kosal_mdelay(__ASSERT_HERE_PROTO btTime delay)
+{
+   btInt res;
+#if   defined( __AAL_WINDOWS__ )
+   NTSTATUS      status;
+   LARGE_INTEGER rel_timout_in_100ns;
+# if ENABLE_ASSERT
+   UNREFERENCED_PARAMETER(__file);
+   UNREFERENCED_PARAMETER(__line);
+   UNREFERENCED_PARAMETER(__fn);
+# endif // ENABLE_ASSERT
+#endif // __AAL_WINDOWS__
+
+   PPOLLING_HERE("kosal_mdelay(delay=%llu [0x%llx]) sleeping\n", delay, delay);
+
+#if   defined( __AAL_LINUX__ )
+
+   mdelay(delay);
+   res = 1;
+
+#elif defined( __AAL_WINDOWS__ )
+
+   // Relative time is specified as a negative value.
+   // Timeout is specified in 100 ns.
+   rel_timout_in_100ns.QuadPart = -((LONGLONG)delay * 10000);
+
+   status = KeDelayExecutionThread(KernelMode, FALSE, &rel_timout_in_100ns);
+
+   res = ( NT_SUCCESS(status) ? 1 : 0 );
+
+#endif // OS
+
+   PPOLLING_HERE("kosal_mdelay(delay=%llu [0x%llx]) waking\n", delay, delay);
+   return res;
+}
+
+//=============================================================================
+/// kosal_udelay
+/// @brief     Delay in microseconds
+/// @param[in] time in micro seconds
+/// @return    1 if success
+/// @note      This function may only be called when IRQL <= APC_LEVEL
+//=============================================================================
+btInt _kosal_udelay(__ASSERT_HERE_PROTO btTime delay)
+{
+   btInt res;
+#if   defined( __AAL_WINDOWS__ )
+   NTSTATUS      status;
+   LARGE_INTEGER rel_timout_in_100ns;
+# if ENABLE_ASSERT
+   UNREFERENCED_PARAMETER(__file);
+   UNREFERENCED_PARAMETER(__line);
+   UNREFERENCED_PARAMETER(__fn);
+# endif // ENABLE_ASSERT
+#endif // __AAL_WINDOWS__
+
+   PPOLLING_HERE("kosal_udelay(delay=%llu [0x%llx]) sleeping\n", delay, delay);
+
+#if   defined( __AAL_LINUX__ )
+
+   udelay(delay);
+   res = 1;
+
+#elif defined( __AAL_WINDOWS__ )
+   
+   // Relative time is specified as a negative value.
+   // Timeout is specified in 100 ns.
+   rel_timout_in_100ns.QuadPart = -((LONGLONG)delay * 10);
+
+   status = KeDelayExecutionThread(KernelMode, FALSE, &rel_timout_in_100ns);
+   res = ( NT_SUCCESS(status) ? 1 : 0 );
+
+#endif // OS
+
+   PPOLLING_HERE("kosal_udelay(delay=%llu [0x%llx]) waking\n", delay, delay);
+   return res;
+}
+
+btVirtAddr _kosal_kmalloc(__ASSERT_HERE_PROTO btWSSize size_in_bytes)
+{
+   btVirtAddr krnl_virt = NULL;
+
+   __ASSERT_HERE_IN_FN(size_in_bytes > 0);
+
+#if   defined( __AAL_LINUX__ )
+# ifdef __i386__
+   krnl_virt = __get_free_pages(GFP_KERNEL, get_order(kosal_round_up_to_page_size(size_in_bytes)));
+# else
+   krnl_virt = kmalloc((size_t)size_in_bytes, GFP_KERNEL);
+# endif // __i386__
+#elif defined( __AAL_WINDOWS__ )
+
+   krnl_virt = (btVirtAddr)MmAllocateNonCachedMemory((SIZE_T)size_in_bytes);
+
+#endif // OS
+
+   __ASSERT_HERE_IN_FN(NULL != krnl_virt);
+
+   PMEMORY_HERE("kosal_kmalloc(size=%llu [0x%llx]) = 0x%" PRIxUINTPTR_T " [phys=0x%" PRIxPHYS_ADDR "]\n",
+                   size_in_bytes, size_in_bytes,
+                   __UINTPTR_T_CAST(krnl_virt),
+                   kosal_virt_to_phys(krnl_virt));
+
+   return krnl_virt;
+}
+
+btVirtAddr _kosal_kzmalloc(__ASSERT_HERE_PROTO btWSSize size_in_bytes)
+{
+   btVirtAddr krnl_virt = NULL;
+
+   __ASSERT_HERE_IN_FN(size_in_bytes > 0);
+
+#if   defined( __AAL_LINUX__ )
+# ifdef __i386__
+   krnl_virt = __get_free_pages(GFP_KERNEL, get_order(kosal_round_up_to_page_size(size_in_bytes)));
+   if(krnl_virt){
+      memset(krnl_virt, 0 , (size_t)size_in_bytes);
+   }
+# else
+   krnl_virt = kmalloc((size_t)size_in_bytes, GFP_KERNEL);
+   if(krnl_virt){
+      memset(krnl_virt, 0 , (size_t)size_in_bytes);
+   }
+# endif // __i386__
+#elif defined( __AAL_WINDOWS__ )
+
+   krnl_virt = (btVirtAddr)MmAllocateNonCachedMemory((SIZE_T)size_in_bytes);
+   if(krnl_virt){
+      RtlZeroMemory(krnl_virt, (SIZE_T)size_in_bytes);
+   }
+#endif // OS
+
+   __ASSERT_HERE_IN_FN(NULL != krnl_virt);
+
+   PMEMORY_HERE("kosal_kzmalloc(size=%llu [0x%llx]) = 0x%" PRIxUINTPTR_T " [phys=0x%" PRIxPHYS_ADDR "]\n",
+                   size_in_bytes, size_in_bytes,
+                   __UINTPTR_T_CAST(krnl_virt),
+                   kosal_virt_to_phys(krnl_virt));
+
+   return krnl_virt;
+}
+
+void _kosal_kfree(__ASSERT_HERE_PROTO btAny krnl_virt, btWSSize size_in_bytes)
+{
+   __ASSERT_HERE_IN_FN(NULL != krnl_virt);
+   __ASSERT_HERE_IN_FN(size_in_bytes > 0);
+
+   PMEMORY_HERE("kosal_kfree(0x%" PRIxUINTPTR_T " [phys=0x%" PRIxPHYS_ADDR "], size=%llu [0x%llx])\n",
+                   __UINTPTR_T_CAST(krnl_virt),
+                   kosal_virt_to_phys(krnl_virt),
+                   size_in_bytes, size_in_bytes);
+
+   if ( NULL != krnl_virt ) {
+
+#if   defined( __AAL_LINUX__ )
+# ifdef __i386__
+      free_pages(krnl_virt, get_order(kosal_round_up_to_page_size(size_in_bytes)));
+# else
+      UNREFERENCED_PARAMETER(size_in_bytes);
+      kfree(krnl_virt);
+# endif // __i386__
+#elif defined( __AAL_WINDOWS__ )
+
+      MmFreeNonCachedMemory(krnl_virt, (SIZE_T)size_in_bytes);
+
+#endif // OS
+
+   }
+
+}
+
+//=============================================================================
+/// kosal_alloc_contiguous_mem_nocache
+/// @brief     Allocate a buffer of contiguous physical pages
+/// @param[in] size in bytes
+/// @return    pointer to memory. NULL if failure.
+/// @note      
+//=============================================================================
+btVirtAddr _kosal_alloc_contiguous_mem_nocache(__ASSERT_HERE_PROTO btWSSize size_in_bytes)
+{
+#if   defined( __AAL_LINUX__ )
+   btVirtAddr pg;
+   btVirtAddr buffer_end;
+#elif defined( __AAL_WINDOWS__ )
+   PHYSICAL_ADDRESS minaddr = { 0ULL };
+   PHYSICAL_ADDRESS maxaddr = { 0xFFFFFFFFFFFFFFFFULL };
+   PHYSICAL_ADDRESS alignment;
+   maxaddr.LowPart= 0xffffffff;
+   maxaddr.HighPart= 0xffffffff;
+#endif // __AAL_WINDOWS__
+
+   btVirtAddr krnl_virt = NULL;
+
+   __ASSERT_HERE_IN_FN(size_in_bytes > 0);
+   
+
+
+#if   defined( __AAL_LINUX__ )
+
+   krnl_virt = (btVirtAddr)__get_free_pages(GFP_KERNEL, get_order(size_in_bytes));
+   __ASSERT_HERE_IN_FN(NULL != krnl_virt);
+   if ( NULL == krnl_virt ) {
+      return NULL;
+   }
+   
+   // Set each page as reserved so that the swapper will not page them out.
+   buffer_end = krnl_virt + size_in_bytes;
+   for ( pg = krnl_virt ; pg < buffer_end ; pg += PAGE_SIZE ) {
+      SetPageReserved( virt_to_page((unsigned long)pg) );
+   }
+
+#elif defined( __AAL_WINDOWS__ )
+   // MmAllocateContiguousMemorySpecifyCache allocates a block of nonpaged memory that is contiguous
+   //  in physical address space. The routine maps this block to a contiguous block of virtual memory
+   //  in the system address space and returns the virtual address of the base of this block.
+   //  The routine aligns the starting address of a contiguous memory allocation to a memory page boundary.
+   
+   alignment.QuadPart = kosal_round_up_to_page_size(size_in_bytes);
+   krnl_virt = (btVirtAddr)MmAllocateContiguousMemorySpecifyCache((SIZE_T)size_in_bytes,
+                                                                  minaddr,
+                                                                  maxaddr,
+                                                                  alignment,
+                                                                  MmNonCached);
+   __ASSERT_HERE_IN_FN(NULL != krnl_virt);
+   if ( NULL == krnl_virt ) {
+      return NULL;
+   }
+
+#endif // OS
+
+   // Recommended security practice..
+   memset(krnl_virt, 0, (size_t)size_in_bytes);
+
+   PMEMORY_HERE("kosal_alloc_contiguous_mem_nocache(size=%llu [0x%llx]) = 0x%" PRIxUINTPTR_T " [phys=0x%" PRIxPHYS_ADDR "]\n",
+                   size_in_bytes, size_in_bytes,
+                   __UINTPTR_T_CAST(krnl_virt),
+                   kosal_virt_to_phys(krnl_virt));
+
+   return krnl_virt;
+}
+
+//=============================================================================
+/// kosal_free_contiguous_mem
+/// @brief     Free buffer of contiguous physical pages allocated through
+///            kosal_alloc_contiguous_mem_nocache
+/// @param[in] size in bytes
+/// @return    pointer to memory. NULL if failure.
+/// @note      
+//=============================================================================
+void _kosal_free_contiguous_mem(__ASSERT_HERE_PROTO btAny krnl_virt, btWSSize size_in_bytes)
+{
+#if   defined( __AAL_WINDOWS__ )
+   UNREFERENCED_PARAMETER(size_in_bytes);
+#endif // __AAL_WINDOWS__
+
+   __ASSERT_HERE_IN_FN(NULL != krnl_virt);
+   __ASSERT_HERE_IN_FN(size_in_bytes > 0);
+
+   PMEMORY_HERE("kosal_free_contiguous_mem(ptr=0x%" PRIxUINTPTR_T " [phys=0x%" PRIxPHYS_ADDR "], bytes=%llu [0x%llx])\n",
+                   __UINTPTR_T_CAST(krnl_virt),
+                   kosal_virt_to_phys(krnl_virt),
+                   size_in_bytes, size_in_bytes);
+
+   // Recommended security practice..
+   if ( NULL != krnl_virt ) {
+      memset(krnl_virt, 0, (size_t)size_in_bytes);
+   }
+
+#if   defined( __AAL_LINUX__ )
+
+   if ( NULL != krnl_virt ) {
+      // Clear the reserved bit.
+      btVirtAddr pg;
+      btVirtAddr buffer_end = krnl_virt + size_in_bytes;
+
+      for ( pg = krnl_virt ; pg < buffer_end ; pg += PAGE_SIZE ) {
+         ClearPageReserved( virt_to_page((unsigned long)pg) );
+      }
+
+      free_pages((unsigned long)krnl_virt, get_order(size_in_bytes));
+   }
+
+#elif defined( __AAL_WINDOWS__ )
+
+   if ( NULL != krnl_virt ) {
+      MmFreeContiguousMemory(krnl_virt);
+   }
+
+#endif // OS
+}
+
+//=============================================================================
+/// _kosal_alloc_dma_coherent
+/// @brief     Allocate a buffer of DMA-able coherent contiguous memory
+/// @param[in] devhandle OS specific
+///            size in bytes
+///            pdma_handle Address to return DMA address for device
+/// @return    pointer to memory. NULL if failure.
+/// @note
+//=============================================================================
+btVirtAddr _kosal_alloc_dma_coherent( __ASSERT_HERE_PROTO btHANDLE devhandle,
+                                       btWSSize size_in_bytes,
+                                      btHANDLE *pdma_handle)
+{
+#if defined( __AAL_WINDOWS__ )
+   PHYSICAL_ADDRESS minaddr = { 0ULL };
+   PHYSICAL_ADDRESS maxaddr = { 0xFFFFFFFFFFFFFFFFULL };
+   PHYSICAL_ADDRESS alignment;
+   maxaddr.LowPart= 0xffffffff;
+   maxaddr.HighPart= 0xffffffff;
+#endif // __AAL_WINDOWS__
+
+   btVirtAddr krnl_virt = NULL;
+
+   __ASSERT_HERE_IN_FN(size_in_bytes > 0);
+
+
+
+#if   defined( __AAL_LINUX__ )
+
+   krnl_virt = (btVirtAddr)dma_alloc_coherent(&((struct pci_dev*)devhandle)->dev, size_in_bytes, (dma_addr_t*)pdma_handle, GFP_KERNEL);
+   __ASSERT_HERE_IN_FN(NULL != krnl_virt);
+   if ( NULL == krnl_virt ) {
+      return NULL;
+   }
+
+
+#elif defined( __AAL_WINDOWS__ )
+   // MmAllocateContiguousMemorySpecifyCache allocates a block of nonpaged memory that is contiguous
+   //  in physical address space. The routine maps this block to a contiguous block of virtual memory
+   //  in the system address space and returns the virtual address of the base of this block.
+   //  The routine aligns the starting address of a contiguous memory allocation to a memory page boundary.
+
+   alignment.QuadPart = kosal_round_up_to_page_size(size_in_bytes);
+   krnl_virt = (btVirtAddr)MmAllocateContiguousMemorySpecifyCache((SIZE_T)size_in_bytes,
+                                                                  minaddr,
+                                                                  maxaddr,
+                                                                  alignment,
+                                                                  MmNonCached);
+   __ASSERT_HERE_IN_FN(NULL != krnl_virt);
+   if ( NULL == krnl_virt ) {
+      return NULL;
+   }
+
+#endif // OS
+
+   // Recommended security practice..
+   memset(krnl_virt, 0, (size_t)size_in_bytes);
+
+   PMEMORY_HERE("_kosal_alloc_dma_coherent(size=%llu [0x%llx]) = 0x%" PRIxUINTPTR_T " [phys=0x%" PRIxPHYS_ADDR "]\n",
+                   size_in_bytes, size_in_bytes,
+                   __UINTPTR_T_CAST(krnl_virt),
+                 (long unsigned int)*pdma_handle);
+
+   return krnl_virt;
+}
+
+//=============================================================================
+/// kosal_free_contiguous_mem
+/// @brief     Free buffer of contiguous physical pages allocated through
+///            kosal_alloc_contiguous_mem_nocache
+/// @param[in] size in bytes
+/// @return    pointer to memory. NULL if failure.
+/// @note
+//=============================================================================
+void _kosal_free_dma_coherent( __ASSERT_HERE_PROTO btHANDLE devhandle,
+                               btVirtAddr krnl_virt,
+                               btWSSize size_in_bytes,
+                               btHANDLE dma_handle)
+{
+#if   defined( __AAL_WINDOWS__ )
+   UNREFERENCED_PARAMETER(size_in_bytes);
+#endif // __AAL_WINDOWS__
+
+   __ASSERT_HERE_IN_FN(NULL != krnl_virt);
+   __ASSERT_HERE_IN_FN(size_in_bytes > 0);
+
+   PMEMORY_HERE("_kosal_free_dma_coherent(ptr=0x%" PRIxUINTPTR_T " [phys=0x%" PRIxPHYS_ADDR "], bytes=%llu [0x%llx])\n",
+                   __UINTPTR_T_CAST(krnl_virt),
+                   kosal_virt_to_phys(krnl_virt),
+                   size_in_bytes, size_in_bytes);
+
+   // Recommended security practice..
+   if ( NULL != krnl_virt ) {
+      memset(krnl_virt, 0, (size_t)size_in_bytes);
+   }
+
+#if   defined( __AAL_LINUX__ )
+
+
+      dma_free_coherent(&((struct pci_dev*)devhandle)->dev, size_in_bytes, krnl_virt, (dma_addr_t)dma_handle);
+
+#elif defined( __AAL_WINDOWS__ )
+
+   if ( NULL != krnl_virt ) {
+      MmFreeContiguousMemory(krnl_virt);
+   }
+
+#endif // OS
+}
+
+#if   defined( __AAL_LINUX__ )
+
+void task_poller(struct work_struct *work)
+{
+   struct delayed_work *delayedWork = container_of(work, struct delayed_work, work);
+   struct kosal_work_object *pwork  = container_of(delayedWork, struct kosal_work_object, workobj);
+
+   pwork->fnct(pwork->context);
+
+}
+void kosal_queue_delayed_work(kosal_work_queue wq, struct kosal_work_object *pwo, KOSAL_TIME msec) {
+
+   queue_delayed_work(wq,&(pwo->workobj),msecs_to_jiffies(msec));
+}
+
+
+#elif defined( __AAL_WINDOWS__ )
+
+void WorkItemCallback(IN PDEVICE_OBJECT pdevObject, IN PVOID Context) {
+   struct kosal_work_object *pwork = ( struct kosal_work_object * )Context;
+   UNREFERENCED_PARAMETER(pdevObject);
+   kosal_mdelay(pwork->msec_delay);
+   pwork->fnct(pwork->context);
+   return;
+}
+
+void kosal_queue_delayed_work(kosal_work_queue wq, struct kosal_work_object *pwo, btTime msec)
+{
+   pwo->msec_delay = msec;
+   IoQueueWorkItem(wq, WorkItemCallback, DelayedWorkQueue, pwo);
+}
+
+void kosal_wake_up_interruptible(kosal_poll_object *pwaitq)
+{
+   NTSTATUS Status;
+   if ( NULL != *pwaitq ) {
+      // Check to see if the IRP was canceled already   
+      Status = WdfRequestUnmarkCancelable(*pwaitq);
+      if ( Status != STATUS_CANCELLED ) {
+         // Complete normally
+         WdfRequestComplete(*pwaitq, STATUS_SUCCESS);
+      }
+   }
+   kosal_poll_object_consume(pwaitq);
+}
+
+#endif // __AAL_WINDOWS__
+
+btVirtAddr _kosal_get_user_buffer( __ASSERT_HERE_PROTO btVirtAddr user_prt, btWSSize size_in_bytes)
+{
+
+
+#if   defined( __AAL_LINUX__ )
+   unsigned long ret;
+   btVirtAddr pkbuffer = vmalloc(size_in_bytes);
+   if(NULL== pkbuffer){
+      return NULL;
+   }
+
+   memset(pkbuffer,0,size_in_bytes);
+   ret = copy_from_user(pkbuffer, user_prt, size_in_bytes);
+   if(ret != 0){
+      vfree(pkbuffer);
+      return NULL;
+   }
+   return pkbuffer;
+#elif defined( __AAL_WINDOWS__ )  //TODO
+   UNREFERENCED_PARAMETER(user_prt);
+   UNREFERENCED_PARAMETER(size_in_bytes);
+
+   __ASSERT_HERE_IN_FN( NULL != user_prt );
+   __ASSERT_HERE_IN_FN( 0 != size_in_bytes );
+   return NULL;
+#endif
+}
+
+void _kosal_free_user_buffer(__ASSERT_HERE_PROTO btVirtAddr user_prt,  btWSSize size_in_bytes)
+{
+
+#if   defined( __AAL_LINUX__ )
+   vfree(user_prt);
+#elif defined( __AAL_WINDOWS__ )  // TODO
+   UNREFERENCED_PARAMETER( user_prt );
+   UNREFERENCED_PARAMETER( size_in_bytes );
+
+   __ASSERT_HERE_IN_FN( NULL != user_prt );
+   __ASSERT_HERE_IN_FN( 0 != size_in_bytes );
+
+#endif
+}
+
+
+char* kosal_gettimestamp(void) 
+{
+
+#if defined( __AAL_LINUX__ )
+
+   static char timestamp[200];
+   struct rtc_time tm;
+   struct timeval time;
+   unsigned long local_time;
+
+   do_gettimeofday(&time);
+   local_time = (u32)(time.tv_sec - (sys_tz.tz_minuteswest * 60));
+   rtc_time_to_tm(local_time, &tm);
+
+   sprintf(timestamp," Time Stamp: %04d-%02d-%02d %02d:%02d:%02d ",
+                                                                   tm.tm_year + 1900,
+                                                                   tm.tm_mon + 1,
+                                                                   tm.tm_mday,
+                                                                   tm.tm_hour,
+                                                                   tm.tm_min,
+                                                                   tm.tm_sec);
+
+   return timestamp;
+#elif defined( __AAL_WINDOWS__ )
+
+#endif
+}
+
+
+
diff --git a/drivers/fpga/aal/include/aalsdk/kernel/AALTransactionID_s.h b/drivers/fpga/aal/include/aalsdk/kernel/AALTransactionID_s.h
new file mode 100644
index 000000000000..fd44fcee10ea
--- /dev/null
+++ b/drivers/fpga/aal/include/aalsdk/kernel/AALTransactionID_s.h
@@ -0,0 +1,115 @@
+//******************************************************************************
+// This  file  is  provided  under  a  dual BSD/GPLv2  license.  When using or
+//         redistributing this file, you may do so under either license.
+//
+//                            GPL LICENSE SUMMARY
+//
+//  Copyright(c) 2008-2017, Intel Corporation.
+//
+//  This program  is  free software;  you  can redistribute it  and/or  modify
+//  it  under  the  terms of  version 2 of  the GNU General Public License  as
+//  published by the Free Software Foundation.
+//
+//  This  program  is distributed  in the  hope that it  will  be useful,  but
+//  WITHOUT   ANY   WARRANTY;   without   even  the   implied   warranty    of
+//  MERCHANTABILITY  or  FITNESS  FOR  A  PARTICULAR  PURPOSE.  See  the   GNU
+//  General Public License for more details.
+//
+//  The  full  GNU  General Public License is  included in  this  distribution
+//  in the file called README.GPLV2-LICENSE.TXT.
+//
+//  Contact Information:
+//  Henry Mitchel, henry.mitchel at intel.com
+//  77 Reed Rd., Hudson, MA  01749
+//
+//                                BSD LICENSE
+//
+//  Copyright(c) 2008-2017, Intel Corporation.
+//
+//  Redistribution and  use  in source  and  binary  forms,  with  or  without
+//  modification,  are   permitted  provided  that  the  following  conditions
+//  are met:
+//
+//    * Redistributions  of  source  code  must  retain  the  above  copyright
+//      notice, this list of conditions and the following disclaimer.
+//    * Redistributions in  binary form  must  reproduce  the  above copyright
+//      notice,  this  list of  conditions  and  the  following disclaimer  in
+//      the   documentation   and/or   other   materials   provided  with  the
+//      distribution.
+//    * Neither   the  name   of  Intel  Corporation  nor  the  names  of  its
+//      contributors  may  be  used  to  endorse  or promote  products derived
+//      from this software without specific prior written permission.
+//
+//  THIS  SOFTWARE  IS  PROVIDED  BY  THE  COPYRIGHT HOLDERS  AND CONTRIBUTORS
+//  "AS IS"  AND  ANY  EXPRESS  OR  IMPLIED  WARRANTIES,  INCLUDING,  BUT  NOT
+//  LIMITED  TO, THE  IMPLIED WARRANTIES OF  MERCHANTABILITY  AND FITNESS  FOR
+//  A  PARTICULAR  PURPOSE  ARE  DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT
+//  OWNER OR CONTRIBUTORS BE LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,
+//  SPECIAL,  EXEMPLARY,  OR  CONSEQUENTIAL   DAMAGES  (INCLUDING,   BUT   NOT
+//  LIMITED  TO,  PROCUREMENT  OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF USE,
+//  DATA,  OR PROFITS;  OR BUSINESS INTERRUPTION)  HOWEVER  CAUSED  AND ON ANY
+//  THEORY  OF  LIABILITY,  WHETHER  IN  CONTRACT,  STRICT LIABILITY,  OR TORT
+//  (INCLUDING  NEGLIGENCE  OR OTHERWISE) ARISING  IN ANY WAY  OUT  OF THE USE
+//  OF  THIS  SOFTWARE, EVEN IF ADVISED  OF  THE  POSSIBILITY  OF SUCH DAMAGE.
+//******************************************************************************
+//****************************************************************************
+/// @file AALTransactionID_s.h
+/// @brief Definition of the shared TransactionID_s structure.
+/// @ingroup Events
+/// @verbatim
+/// Accelerator Abstraction Layer
+///
+/// AUTHOR: Joseph Grecco, Intel Corporation
+///
+/// HISTORY:
+/// COMMENTS:
+/// WHEN:          WHO:     WHAT:
+/// 11/17/2008     JG       Initial version
+/// 01/04/2009     HM       Updated Copyright
+/// 05/15/2015     JG       Added Support for IBase@endverbatim
+//****************************************************************************
+#ifndef __AALSDK_KERNEL_AALTRANSACTIONID_S_H__
+#define __AALSDK_KERNEL_AALTRANSACTIONID_S_H__
+
+// This file is shared across user and kernel space.
+#if defined( __AAL_KERNEL__ )
+# include <aalsdk/kernel/aaltypes.h>
+#else
+# include <aalsdk/AALTypes.h>
+#endif // __AAL_USER__
+
+
+BEGIN_NAMESPACE(AAL)
+
+#ifdef __cplusplus
+   class IBase;
+#else
+   typedef struct IBase IBase;
+#endif // __cplusplus
+
+/// User/Kernel shared Transaction ID structure.
+/// @ingroup Events
+typedef struct stTransactionID_t
+{
+   btApplicationContext m_Context;
+   btEventHandler       m_Handler;
+   IBase               *m_IBase;
+   btBool               m_Filter;
+   btID                 m_intID;
+} stTransactionID_t;
+
+
+// Note: using an absolute number here (40, 20) to ensure that both user and kernel are getting
+//       the same sized struct.
+#if   (8 == sizeof_void_ptr)
+   CASSERT(40 == sizeof(stTransactionID_t));
+#elif (4 == sizeof_void_ptr)
+   CASSERT(20 == sizeof(stTransactionID_t));
+#else
+#  error Add stTransactionID_t size check for unknown address size.
+#endif // sizeof_void_ptr
+
+END_NAMESPACE(AAL)
+
+#endif // __AALSDK_KERNEL_AALTRANSACTIONID_S_H__
+
diff --git a/drivers/fpga/aal/include/aalsdk/kernel/AALWorkspace.h b/drivers/fpga/aal/include/aalsdk/kernel/AALWorkspace.h
new file mode 100644
index 000000000000..cfa1598e11b2
--- /dev/null
+++ b/drivers/fpga/aal/include/aalsdk/kernel/AALWorkspace.h
@@ -0,0 +1,120 @@
+//******************************************************************************
+// This  file  is  provided  under  a  dual BSD/GPLv2  license.  When using or
+//         redistributing this file, you may do so under either license.
+//
+//                            GPL LICENSE SUMMARY
+//
+//  Copyright(c) 2008-2017, Intel Corporation.
+//
+//  This program  is  free software;  you  can redistribute it  and/or  modify
+//  it  under  the  terms of  version 2 of  the GNU General Public License  as
+//  published by the Free Software Foundation.
+//
+//  This  program  is distributed  in the  hope that it  will  be useful,  but
+//  WITHOUT   ANY   WARRANTY;   without   even  the   implied   warranty    of
+//  MERCHANTABILITY  or  FITNESS  FOR  A  PARTICULAR  PURPOSE.  See  the   GNU
+//  General Public License for more details.
+//
+//  The  full  GNU  General Public License is  included in  this  distribution
+//  in the file called README.GPLV2-LICENSE.TXT.
+//
+//  Contact Information:
+//  Henry Mitchel, henry.mitchel at intel.com
+//  77 Reed Rd., Hudson, MA  01749
+//
+//                                BSD LICENSE
+//
+//  Copyright(c) 2008-2017, Intel Corporation.
+//
+//  Redistribution and  use  in source  and  binary  forms,  with  or  without
+//  modification,  are   permitted  provided  that  the  following  conditions
+//  are met:
+//
+//    * Redistributions  of  source  code  must  retain  the  above  copyright
+//      notice, this list of conditions and the following disclaimer.
+//    * Redistributions in  binary form  must  reproduce  the  above copyright
+//      notice,  this  list of  conditions  and  the  following disclaimer  in
+//      the   documentation   and/or   other   materials   provided  with  the
+//      distribution.
+//    * Neither   the  name   of  Intel  Corporation  nor  the  names  of  its
+//      contributors  may  be  used  to  endorse  or promote  products derived
+//      from this software without specific prior written permission.
+//
+//  THIS  SOFTWARE  IS  PROVIDED  BY  THE  COPYRIGHT HOLDERS  AND CONTRIBUTORS
+//  "AS IS"  AND  ANY  EXPRESS  OR  IMPLIED  WARRANTIES,  INCLUDING,  BUT  NOT
+//  LIMITED  TO, THE  IMPLIED WARRANTIES OF  MERCHANTABILITY  AND FITNESS  FOR
+//  A  PARTICULAR  PURPOSE  ARE  DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT
+//  OWNER OR CONTRIBUTORS BE LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,
+//  SPECIAL,  EXEMPLARY,  OR  CONSEQUENTIAL   DAMAGES  (INCLUDING,   BUT   NOT
+//  LIMITED  TO,  PROCUREMENT  OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF USE,
+//  DATA,  OR PROFITS;  OR BUSINESS INTERRUPTION)  HOWEVER  CAUSED  AND ON ANY
+//  THEORY  OF  LIABILITY,  WHETHER  IN  CONTRACT,  STRICT LIABILITY,  OR TORT
+//  (INCLUDING  NEGLIGENCE  OR OTHERWISE) ARISING  IN ANY WAY  OUT  OF THE USE
+//  OF  THIS  SOFTWARE, EVEN IF ADVISED  OF  THE  POSSIBILITY  OF SUCH DAMAGE.
+//******************************************************************************
+//****************************************************************************
+/// @file AALWorkspace.h
+/// @brief Definition of the shared(user/kernel) Workspace enums and structures.
+/// @ingroup AALCore
+/// @verbatim
+/// Accelerator Abstraction Layer
+///
+/// AUTHORS: Henry Mitchel, Intel Corporation
+///          Joseph Grecco, Intel Corporation
+///          Alvin Chen,    Intel Corporation
+///
+/// HISTORY:
+/// WHEN:          WHO:     WHAT:
+/// 12/03/2008     HM       Initial version
+/// 01/04/2009     HM       Updated Copyright
+/// 06/10/2012     HM       aaltypes.h is in the kernel. Fixed access.
+/// 06/11/2012     HM       backed out previous change. Everything breaks.
+///                            re-opened redmine[110]@endverbatim
+//****************************************************************************
+#ifndef __AALSDK_KERNEL_AALWORKSPACE__
+#define __AALSDK_KERNEL_AALWORKSPACE__
+#include <aalsdk/kernel/aaltypes.h>
+
+//////////////////////////////////////////////////////////////////////////////
+//////////////////////////////////////////////////////////////////////////////
+//
+// WARNING!! AHM_DESC_* MUST TRACK THE EQUIVALENT DEFINITIONS IN FAPPIPDEFS.H
+//
+// If for some reason they cannot, then a conversion layer is needed.
+//
+//////////////////////////////////////////////////////////////////////////////
+//////////////////////////////////////////////////////////////////////////////
+
+#define AHM_DESC_SOT          (1<<5)
+#define AHM_DESC_MOT          (1<<6)
+#define AHM_DESC_EOT          (1<<7)
+
+
+BEGIN_NAMESPACE(AAL)
+
+   typedef enum
+   {
+      MASTER_PHYS_MODE    = 0,
+      MASTER_VIRT_MODE    = 1,
+      SLAVE_MODE          = 2,
+   } TTASK_MODE;
+
+   /// Task descriptor type.
+   /// @ingroup BasicTypes
+   typedef enum
+   {
+      INPUT_DESC    = 0, ///< Input descriptor.
+      OUTPUT_DESC   = 1, ///< Output descriptor.
+   } TDESC_TYPE;
+
+   typedef enum
+   {
+      START_OF_TASK   = AHM_DESC_SOT,
+      MIDDLE_OF_TASK  = AHM_DESC_MOT,
+      END_OF_TASK     = AHM_DESC_EOT,
+      COMPLETE_TASK   = AHM_DESC_SOT | AHM_DESC_MOT | AHM_DESC_EOT
+   } TDESC_POSITION;
+
+END_NAMESPACE(AAL)
+
+#endif // __AALSDK_KERNEL_AALWORKSPACE__
diff --git a/drivers/fpga/aal/include/aalsdk/kernel/KernelStructs.h b/drivers/fpga/aal/include/aalsdk/kernel/KernelStructs.h
new file mode 100644
index 000000000000..6c0c55840503
--- /dev/null
+++ b/drivers/fpga/aal/include/aalsdk/kernel/KernelStructs.h
@@ -0,0 +1,166 @@
+// Copyright(c) 2008-2017, Intel Corporation
+//
+// Redistribution  and  use  in source  and  binary  forms,  with  or  without
+// modification, are permitted provided that the following conditions are met:
+//
+// * Redistributions of  source code  must retain the  above copyright notice,
+//   this list of conditions and the following disclaimer.
+// * Redistributions in binary form must reproduce the above copyright notice,
+//   this list of conditions and the following disclaimer in the documentation
+//   and/or other materials provided with the distribution.
+// * Neither the name  of Intel Corporation  nor the names of its contributors
+//   may be used to  endorse or promote  products derived  from this  software
+//   without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE
+// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE
+// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR
+// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF
+// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS
+// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN
+// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE
+// POSSIBILITY OF SUCH DAMAGE.
+//****************************************************************************
+/// @file KernelStructs.h
+/// @brief Utilities used when working with the Resource Manager
+/// @ingroup ResMgr
+/// @verbatim
+/// Accelerator Abstraction Layer
+///
+/// AUTHOR: Henry Mitchel, Intel Corporation.
+///
+/// HISTORY:
+/// WHEN:          WHO:     WHAT:
+/// 11/09/2008     HM       Initial version started
+/// 12/14/2008     HM       Added initial support for ui_ioctl,
+///                            Found namespacing issues
+/// 01/01/2009     HM       Resolved most namespacing issues by making all of them
+///                            global in scope, only qualifying the objects being
+///                            streamed.
+///                         Still some questions as to why some do not resolve
+///                            even in global scope, and actually need a restricted
+///                            scope, e.g. for TTASK_MODE.
+/// 01/04/2009     HM       Updated Copyright
+/// 03/08/2009     HM       Removed DestroyRMIoctlReq() to CAASResourceManager.h
+/// 03/20/2009     HM       Added more kernel structures
+/// 12/09/2009     JG       Pulled out AFU PIP commands aalui_afucmd_e
+///                            and moved it to fappip.h and defined them as FAP
+///                            pip specific.@endverbatim
+//****************************************************************************
+#ifndef __AALSDK_KERNEL_KERNELSTRUCTS_H__
+#define __AALSDK_KERNEL_KERNELSTRUCTS_H__
+#include <aalsdk/AALLoggerExtern.h>       // LOG_VERBOSE
+#include <aalsdk/ResMgr.h>                // Definitions for user mode RM users
+                                          // Types, Events, aalrm, aalrm_server, aalrm_client
+                                          // Interestingly, for just operator<<, not needed
+#include <aalsdk/kernel/ccipdriver.h>          // user mode UI users, as well
+//#include <aalsdk/kernel/fappip.h>         // FAP PIP interface
+#include <aalsdk/kernel/aalmafu.h>        // MAFU interface
+#include <aalsdk/kernel/AALWorkspace.h>   // TTASK_MODE, TDESC_TYPE
+
+
+BEGIN_NAMESPACE(AAL)
+
+typedef enum
+{
+   eLogLevel_Emergency =      LOG_EMERG,     // system is unusable
+   eLogLevel_Alert =          LOG_ALERT,     // action must be taken immediately
+   eLogLevel_Critical =       LOG_CRIT,      // critical conditions
+   eLogLevel_Error =          LOG_ERR,       // error conditions
+   eLogLevel_Warning =        LOG_WARNING,   // warning conditions
+   eLogLevel_Notice =         LOG_NOTICE,    // normal but significant condition
+   eLogLevel_Informational =  LOG_INFO,      // informational
+   eLogLevel_Debug =          LOG_DEBUG,     // debug-level messages
+   eLogLevel_Verbose =        LOG_VERBOSE    // NOT a LINUX level. AAL for really verbose output
+} LogLevel_t;
+
+   /*
+    * Apparently, this (definition of operator << in both global and AAL:: namespaces) is needed
+    * because this operator is called from within
+    * another AAL::operator<<, and it does not resolve unless there is an
+    * AAL::operator<<(TTASK_MODE). I am not sure if this is correct, but empirically
+    * it appears to be occurring. If this function is removed, TTASK_MODE printed from
+    * within 'std::ostream& AAL::operator << (std::ostream& s, const WorkSpaceMapper::WkSp& wksp)'
+    * will not resolve to the generic one, but instead will print the enum as
+    * if it were an integer. Specifically, that reference will NOT find the version
+    * that is in global scope, above.
+    */
+
+//--------------------------   A A L T Y P E S   ------------------------
+
+AASLIB_API std::ostream & operator << (std::ostream & , const btVirtAddr & );
+
+//-----------------------------  L I N U X   ----------------------------
+
+AASLIB_API std::ostream & operator << (std::ostream & , const LogLevel_t & );
+
+//-------------------------------   R M   -------------------------------
+
+AASLIB_API std::ostream & operator << (std::ostream & , const stTransactionID_t        & );
+AASLIB_API std::ostream & operator << (std::ostream & , const aal_bus_types_e          & );
+AASLIB_API std::ostream & operator << (std::ostream & , const aal_device_type_e        & );
+AASLIB_API std::ostream & operator << (std::ostream & , const aal_device_addr          & );
+AASLIB_API std::ostream & operator << (std::ostream & , const aal_device_id            & );
+AASLIB_API std::ostream & operator << (std::ostream & , const device_attrib            & );
+AASLIB_API std::ostream & operator << (std::ostream & , const krms_cfgUpDate_e         & );
+AASLIB_API std::ostream & operator << (std::ostream & , const aalrms_configUpDateEvent & );
+AASLIB_API std::ostream & operator << (std::ostream & , const rms_msgIDs_e             & );
+AASLIB_API std::ostream & operator << (std::ostream & , const rms_result_e             & );
+AASLIB_API std::ostream & operator << (std::ostream & , const aalrms_requestdevice     & );
+AASLIB_API std::ostream & operator << (std::ostream & , const aalrm_ioctlreq           & );
+
+
+//-------------------------------   FAP   --------------------------------
+//AASLIB_API std::ostream & operator << (std::ostream & , const fappip_afuCmdID_e  & );
+
+//-------------------------------   U I   --------------------------------
+
+AASLIB_API std::ostream & operator << (std::ostream & , const uid_msgIDs_e       & );
+AASLIB_API std::ostream & operator << (std::ostream & , const uid_errnum_e       & );
+AASLIB_API std::ostream & operator << (std::ostream & , const uid_mgtAfuCmdID_e  & );
+AASLIB_API std::ostream & operator << (std::ostream & , const uid_afurespID_e    & );
+AASLIB_API std::ostream & operator << (std::ostream & , const uid_wseventID_e    & );
+
+//-------------------------------   W S  --------------------------------
+AASLIB_API std::ostream & operator << (std::ostream & , const TTASK_MODE     & );
+AASLIB_API std::ostream & operator << (std::ostream & , const TDESC_TYPE     & );
+AASLIB_API std::ostream & operator << (std::ostream & , const TDESC_POSITION & );
+
+END_NAMESPACE(AAL)
+
+
+AASLIB_API std::ostream & operator << (std::ostream & , const AAL::btVirtAddr & );
+
+AASLIB_API std::ostream & operator << (std::ostream & , const AAL::LogLevel_t & );
+
+AASLIB_API std::ostream & operator << (std::ostream & , const AAL::stTransactionID_t        & );
+AASLIB_API std::ostream & operator << (std::ostream & , const AAL::aal_bus_types_e          & );
+AASLIB_API std::ostream & operator << (std::ostream & , const AAL::aal_device_type_e        & );
+AASLIB_API std::ostream & operator << (std::ostream & , const AAL::aal_device_addr          & );
+AASLIB_API std::ostream & operator << (std::ostream & , const AAL::aal_device_id            & );
+AASLIB_API std::ostream & operator << (std::ostream & , const AAL::device_attrib            & );
+AASLIB_API std::ostream & operator << (std::ostream & , const AAL::krms_cfgUpDate_e         & );
+AASLIB_API std::ostream & operator << (std::ostream & , const AAL::aalrms_configUpDateEvent & );
+AASLIB_API std::ostream & operator << (std::ostream & , const AAL::rms_msgIDs_e             & );
+AASLIB_API std::ostream & operator << (std::ostream & , const AAL::rms_result_e             & );
+AASLIB_API std::ostream & operator << (std::ostream & , const AAL::aalrms_requestdevice     & );
+AASLIB_API std::ostream & operator << (std::ostream & , const AAL::aalrm_ioctlreq           & );
+
+//AASLIB_API std::ostream & operator << (std::ostream & , const AAL::fappip_afuCmdID_e  & );
+
+AASLIB_API std::ostream & operator << (std::ostream & , const AAL::uid_msgIDs_e       & );
+AASLIB_API std::ostream & operator << (std::ostream & , const AAL::uid_errnum_e       & );
+AASLIB_API std::ostream & operator << (std::ostream & , const AAL::uid_mgtAfuCmdID_e  & );
+AASLIB_API std::ostream & operator << (std::ostream & , const AAL::uid_afurespID_e    & );
+AASLIB_API std::ostream & operator << (std::ostream & , const AAL::uid_wseventID_e    & );
+
+AASLIB_API std::ostream & operator << (std::ostream & , const AAL::TTASK_MODE     & );
+AASLIB_API std::ostream & operator << (std::ostream & , const AAL::TDESC_TYPE     & );
+AASLIB_API std::ostream & operator << (std::ostream & , const AAL::TDESC_POSITION & );
+
+#endif // __AALSDK_KERNEL_KERNELSTRUCTS_H__
+
+
diff --git a/drivers/fpga/aal/include/aalsdk/kernel/aalbus-device.h b/drivers/fpga/aal/include/aalsdk/kernel/aalbus-device.h
new file mode 100644
index 000000000000..10aa24e9c6c7
--- /dev/null
+++ b/drivers/fpga/aal/include/aalsdk/kernel/aalbus-device.h
@@ -0,0 +1,419 @@
+//******************************************************************************
+// This  file  is  provided  under  a  dual BSD/GPLv2  license.  When using or
+//         redistributing this file, you may do so under either license.
+//
+//                            GPL LICENSE SUMMARY
+//
+//  Copyright(c) 2008-2017, Intel Corporation.
+//
+//  This program  is  free software;  you  can redistribute it  and/or  modify
+//  it  under  the  terms of  version 2 of  the GNU General Public License  as
+//  published by the Free Software Foundation.
+//
+//  This  program  is distributed  in the  hope that it  will  be useful,  but
+//  WITHOUT   ANY   WARRANTY;   without   even  the   implied   warranty    of
+//  MERCHANTABILITY  or  FITNESS  FOR  A  PARTICULAR  PURPOSE.  See  the   GNU
+//  General Public License for more details.
+//
+//  The  full  GNU  General Public License is  included in  this  distribution
+//  in the file called README.GPLV2-LICENSE.TXT.
+//
+//  Contact Information:
+//  Henry Mitchel, henry.mitchel at intel.com
+//  77 Reed Rd., Hudson, MA  01749
+//
+//                                BSD LICENSE
+//
+//  Copyright(c) 2008-2017, Intel Corporation.
+//
+//  Redistribution and  use  in source  and  binary  forms,  with  or  without
+//  modification,  are   permitted  provided  that  the  following  conditions
+//  are met:
+//
+//    * Redistributions  of  source  code  must  retain  the  above  copyright
+//      notice, this list of conditions and the following disclaimer.
+//    * Redistributions in  binary form  must  reproduce  the  above copyright
+//      notice,  this  list of  conditions  and  the  following disclaimer  in
+//      the   documentation   and/or   other   materials   provided  with  the
+//      distribution.
+//    * Neither   the  name   of  Intel  Corporation  nor  the  names  of  its
+//      contributors  may  be  used  to  endorse  or promote  products derived
+//      from this software without specific prior written permission.
+//
+//  THIS  SOFTWARE  IS  PROVIDED  BY  THE  COPYRIGHT HOLDERS  AND CONTRIBUTORS
+//  "AS IS"  AND  ANY  EXPRESS  OR  IMPLIED  WARRANTIES,  INCLUDING,  BUT  NOT
+//  LIMITED  TO, THE  IMPLIED WARRANTIES OF  MERCHANTABILITY  AND FITNESS  FOR
+//  A  PARTICULAR  PURPOSE  ARE  DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT
+//  OWNER OR CONTRIBUTORS BE LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,
+//  SPECIAL,  EXEMPLARY,  OR  CONSEQUENTIAL   DAMAGES  (INCLUDING,   BUT   NOT
+//  LIMITED  TO,  PROCUREMENT  OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF USE,
+//  DATA,  OR PROFITS;  OR BUSINESS INTERRUPTION)  HOWEVER  CAUSED  AND ON ANY
+//  THEORY  OF  LIABILITY,  WHETHER  IN  CONTRACT,  STRICT LIABILITY,  OR TORT
+//  (INCLUDING  NEGLIGENCE  OR OTHERWISE) ARISING  IN ANY WAY  OUT  OF THE USE
+//  OF  THIS  SOFTWARE, EVEN IF ADVISED  OF  THE  POSSIBILITY  OF SUCH DAMAGE.
+//******************************************************************************
+//****************************************************************************
+//        FILE: aalbus-device.h
+//     CREATED: 09/15/2008
+//      AUTHOR: Joseph Grecco
+//
+// PURPOSE:  This file contains the definitions for AAL device generic behavior.
+//           Accelerator Abstraction Layer (AAL)
+//           Accelerator Hardware Module bus driver module
+// HISTORY:
+// COMMENTS:
+// WHEN:          WHO:     WHAT:
+// 09/15/2008     JG       Initial version started
+// 11/11/2008     JG       Added legal header
+// 11/25/2008     HM       Large merge
+// 12/10/2008     JG       Added support for bound wsmgr
+// 12/16/2008     JG       Began support for abort and shutdown
+//                            Added Support for WSID object
+//                            Major interface changes.
+// 12/18/2008     JG       Added owner Session initializer and
+//                            copier.
+// 01/04/2009     HM       Updated Copyright
+// 02/26/2009     JG       Began dynamic config implementation
+// 03/17/2009     JG       Added macro for pipContext
+// 03/23/2009     JG       Removed bridge device
+// 04/13/2009     JG       Added support for version kernel 2.6.27
+// 05/11/2009     JG/HM    Added <linux/device.h> and other headers
+// 05/20/2009     JG       Changed aaldev_pipp to use real pip interface
+//                         instead of aal_interface
+// 10/22/2009     JG       Added aaldev_AddOwner_e in support of modified
+//                         device methods
+// 02/11/2010     JG       Support for kernel 2.6.31
+// 02/14/2012     JG       Removed some unused and deprecated macros.
+// 12/04/2012     JG       Moved PIP definitions 
+// 02/26/2013     AG       Add wsid tracking and validation routines
+//****************************************************************************
+#ifndef __AALSDK_KERNEL_AALBUS_DEVICE_H__
+#define __AALSDK_KERNEL_AALBUS_DEVICE_H__
+#include <aalsdk/kernel/kosal.h>
+#include <aalsdk/kernel/aalqueue.h>
+#include <aalsdk/kernel/aalmafu.h>
+#include <aalsdk/kernel/AALTransactionID_s.h>
+#include <aalsdk/kernel/aalbus-ipip.h>
+
+
+BEGIN_NAMESPACE(AAL)
+
+
+extern kosal_semaphore g_listlock;
+
+
+//=============================================================================
+// Name: aal_device_factory
+// Description: AAL device factory interface. This interface is imeplemented
+//              by objects that create and destroy aal_device objects
+//=============================================================================
+struct aal_device_factory {
+#if 0
+   struct aal_device * (*create) (struct aal_device_id *devID,
+                                  btObjectType          manifest);
+#endif
+   btInt               (*destroy)(struct aal_device *dev);
+
+   struct aal_device * (*create) (struct mafu_CreateAFU *pRequest,
+                                  void (*relfcnp)(pkosal_os_dev ),
+                                  struct aal_ipip       *ipipp);
+
+};
+
+#define _DECLARE_DEVFACTORY_TYPE struct aal_device_factory m_devfact
+#define INIT_FACT_CREATE_DEVICE  m_devfact.create
+#define INIT_FACT_DESTROY_DEVICE m_devfact.destroy
+
+#define aaldev_factp(c) c->m_devfact
+#define aaldev_fact(c)  c.m_devfact
+
+
+//-----------------------
+//  Device creation flags
+//-----------------------
+#define AAL_DEV_CREATE_UNREGISTERED (0x01)
+
+
+// Default methods
+static inline
+struct aal_device *
+aaldev_def_create_device(struct mafu_CreateAFU   *pRequest,
+                         void (*relfcnp)(pkosal_os_dev ),
+                         struct aal_ipip         *ipipp)
+{
+   UNREFERENCED_PARAMETER(pRequest);
+   UNREFERENCED_PARAMETER(relfcnp);
+   UNREFERENCED_PARAMETER(ipipp);
+   return NULL;
+}
+
+static inline
+btInt
+aaldev_def_destroy_device(struct aal_device *devp)
+{
+   UNREFERENCED_PARAMETER(devp);
+   return 0;
+}
+
+// Prototypes for AAL Bus interface
+struct aal_device *
+aaldev_create_device(struct mafu_CreateAFU *,
+                     void (*relfcnp)(pkosal_os_dev ),
+                     struct aal_ipip *);
+btInt
+aaldev_destroy_device(struct aal_device * );
+
+// Used by the matching routines to mask individual fields of the ID
+#define AAL_DEV_ID_MASK_VENDOR      (0x1 <<  1)
+#define AAL_DEV_ID_MASK_AHMGUID     (0x1 <<  2)
+#define AAL_DEV_ID_MASK_AFUGUID     (0x1 <<  3)
+#define AAL_DEV_ID_MASK_PIPGUID     (0x1 <<  4)
+#define AAL_DEV_ID_MASK_DEVID       (0x1 <<  5)
+#define AAL_DEV_ID_MASK_SUBDEVNUM   (0x1 <<  6)
+#define AAL_DEV_ID_MASK_BUSTYPE     (0x1 <<  7)
+#define AAL_DEV_ID_MASK_DEVTYPE     (0x1 <<  8)
+#define AAL_DEV_ID_MASK_ADDR        (0x1 <<  9)
+#define AAL_DEV_ID_MASK_DEVNUM      (0x1 << 10)
+#define AAL_DEV_ID_MASK_BUSNUM      (0x1 << 11)
+#define AAL_DEV_ID_MASK_SOCKETNUM   (0x1 << 12)
+
+// Common mask for resource manager
+#define AAL_DEV_ID_MASK_EXCEPT_ADDR  AAL_DEV_ID_MASK_VENDOR+AAL_DEV_ID_MASK_AHMGUID+AAL_DEV_ID_MASK_AFUGUID+AAL_DEV_ID_MASK_PIPGUID+AAL_DEV_ID_MASK_BUSTYPE+AAL_DEV_ID_MASK_DEVTYPE
+
+#define AAL_DEV_ID_MASK_EXACT       0
+
+struct aaldev_ownerSession; //forward reference
+struct aalui_wsid;
+
+//=============================================================================
+// Name: aal_uiapi
+// Description: UI interface - Interface adaptor between and the
+//              PIP and the Universal Interface Driver.
+//=============================================================================
+struct aal_uiapi {
+   // Send a PIP event back to the Application
+   btInt (*sendevent)(btObjectType ,                 // UI Session handle
+                      struct aal_device *,           // Device
+                      struct aal_q_item *,           // Event
+                      btObjectType );                // Message context
+
+   // Get a wsid for the workspace manager
+   struct aal_wsid * (*getwsid)(struct aal_device *, // Device
+                                btWSID );            // Internal wsid
+
+   btInt (*freewsid)(struct aal_wsid *);              // Internal wsid
+
+   /* validate a wsid against known list of allocated wsids */
+   int (*valwsid)(struct aal_wsid *);
+};
+
+
+
+//=============================================================================
+// Name: ownerSess_Init
+// Description: Initialize a Owner Session
+//=============================================================================
+static inline
+void
+ownerSess_Init(struct aaldev_ownerSession *pSess, btAny ownerContext)
+{
+   memset(pSess, 0, sizeof(struct aaldev_ownerSession));
+   pSess->m_ownerContext = ownerContext;  // Typically used by AIA to carry teh owner interface
+   kosal_list_init(&pSess->m_wshead);
+}
+
+
+//=============================================================================
+// Name: ownerSess_Copy
+// Description: Copies an ownerSess object
+//=============================================================================
+static inline
+void
+ownerSess_Copy(struct aaldev_ownerSession *destSess,
+               struct aaldev_ownerSession *srcSess)
+{
+   *destSess = *srcSess;
+   kosal_list_replace_init(&srcSess->m_wshead, &destSess->m_wshead);
+}
+
+//=============================================================================
+// Name: aaldev_owner
+// Description: Represents a device owner. This object sits on 2 lists. The
+//              devicelist is headed by the owning session (e.g., will have a
+//              common pid). It represents the list of devices owned by the
+//              session.
+//              The ownerlist is headed by the device and
+//              maintains a list owners of the device.
+//=============================================================================
+struct aaldev_owner {
+   btPID                      m_pid;         // Pid of the owning process
+   struct aal_device         *m_device;      // Device being owned
+   btObjectType               m_manifest;    // Opaque manifest
+   struct aaldev_ownerSession m_sess;        // Owner session
+   kosal_list_head            m_devicelist;  // Session owner's device list
+   kosal_list_head            m_ownerlist;   // Device owner list it is on
+   kosal_semaphore            m_sem;         // Private semaphore
+};
+
+
+//=============================================================================
+// Name: aaldev_owner_init
+// Description: Initialize the Device Owner structure
+// Interface: public
+// Inputs:  pdevown - pointer to the device owner
+//          pid - Process ID of owner
+//          manifest - opaque pointer to a owner manifest
+// Comments:
+//=============================================================================
+static inline
+void
+aaldev_owner_init(struct aaldev_owner *pdevown,
+                  btPID                pid,
+                  btAny                ownerContext,
+                  btObjectType         manifest)
+{
+   kosal_list_init(&pdevown->m_devicelist);
+   kosal_list_init(&pdevown->m_ownerlist);
+   kosal_mutex_init(&pdevown->m_sem);
+
+   pdevown->m_pid      = pid;
+   pdevown->m_device   = NULL;
+   pdevown->m_manifest = manifest;
+   ownerSess_Init(&pdevown->m_sess, ownerContext);
+}
+
+//=============================================================================
+// Name: AAL_PDO_DEVICE_CONTEXT
+// Description: The context of the AAL Device.  
+// Interface: public
+// Comments:
+//=============================================================================
+typedef struct _AAL_PDO_DEVICE_CONTEXT
+{
+   // Common AAL Device Structure
+   struct aal_device            *m_aaldevice;
+   struct device_attributes     *m_pdevAttributes;
+   // UNUSED
+   //   AAL_BUS_WMI_STD_DATA   StdAALdeviceData;
+   //   WDFDEVICE              pMontorConfigAPIControlDevice;
+
+
+} AAL_PDO_DEVICE_CONTEXT, *PAAL_PDO_DEVICE_CONTEXT;
+
+//-----------------------------------------------------------------------------
+//-----------------------------------------------------------------------------
+//                            AAL Class
+//-----------------------------------------------------------------------------
+//-----------------------------------------------------------------------------
+
+#if   defined( __AAL_LINUX__ )
+//=============================================================================
+// Name: aal_class_id
+// Description: Class ID identifies the interface
+//=============================================================================
+struct aal_class_id {
+   btUnsigned32bitInt m_majorversion;
+   btUnsigned32bitInt m_minorversion;
+   btUnsigned64bitInt m_releaseversion;
+   btUnsigned64bitInt m_classGUID;
+};
+
+
+//=============================================================================
+// Name: aal_classdevice
+// Description: AAL specific class device
+//=============================================================================
+struct aal_classdevice {
+#define AAL_CLASSDEV_IS_REGISTERED 0x00000001
+   btUnsigned32bitInt   m_flags;
+
+   struct aal_class_id  m_classid;        // ID for  the public interface
+   btIID               *m_devIIDlist;     // List of supported device module APIs
+
+   struct aal_bus      *m_bus;            // AAL Bus interface
+
+   // Base class
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,26)
+    struct device       m_classdev;       // Class device
+#else
+    struct class_device m_classdev;
+#endif
+};
+#define aal_classdev_is_registered(p)  flag_is_set((p)->m_flags, AAL_CLASSDEV_IS_REGISTERED)
+#define aal_classdev_set_registered(p) flag_setf((p)->m_flags,   AAL_CLASSDEV_IS_REGISTERED)
+#define aal_classdev_clr_registered(p) flag_clrf((p)->m_flags,   AAL_CLASSDEV_IS_REGISTERED)
+
+#define aal_classdevp_to_devp(p)       (&(p)->m_classdev)
+#define aal_classdevp_to_dev(p)        ((p)->m_classdev)
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,26)
+#define aal_classdev_set_name(p, cname) (dev_set_name(&(p)->m_classdev, cname))
+#define aal_classdev_get_name(p)        (dev_name(&(p)->m_classdev))
+#else
+#define aal_classdev_set_name(p, cname) (strncpy((char *)(p)->m_classdev.class_id, cname, BUS_ID_SIZE))
+#define aal_classdev_get_name(p)        ((const char *)( (p)->m_classdev.class_id ))
+#endif
+
+#define aal_classdev_devtype(p)        ((p)->m_classdev.devt)
+
+#endif // OS
+
+#if 0
+//=============================================================================
+// Name: aaldev_prep
+// Description: Prepare the device structure for initialization
+// Interface: public
+// Inputs: pdev - pointer to the device
+// Comments:
+//=============================================================================
+static inline void aaldev_prep(struct aal_device *pdev)
+{
+   // Initialize the structure
+   memset(pdev, 0, sizeof(struct aal_device));
+
+   dev_markUnRegistered(pdev);
+
+   //Version of the structure
+   pdev->m_version  = AAL_DEVICE_VERSION;
+
+   // Used as part of the handle validation
+   pdev->m_validator = (btUnsigned64bitInt)virt_to_phys(pdev);
+
+   kosal_list_init(&pdev->m_ownerlist);
+   kosal_mutex_init(&pdev->m_sem);
+   kosal_mutex_init(&pdev->m_listsem);
+}
+#endif
+
+
+//-----------------------------------------------------------------------------
+// Externals
+//-----------------------------------------------------------------------------
+extern
+btInt
+aaldev_init(struct aal_device * );
+
+extern
+aaldev_AddOwner_e
+aaldev_addOwner(struct aal_device * ,
+                btPID ,
+                btObjectType ,
+                btAny,
+                pkosal_list_head );
+
+extern
+btInt
+aaldev_removeOwner(struct aal_device * , btPID );
+
+extern
+aaldev_AddOwner_e
+aaldev_udateOwner(struct aal_device * ,
+                  btPID ,
+                  struct aaldev_ownerSession * ,
+                  pkosal_list_head );
+
+
+END_NAMESPACE(AAL)
+
+#endif // __AALSDK_KERNEL_AALBUS_DEVICE_H__
+
diff --git a/drivers/fpga/aal/include/aalsdk/kernel/aalbus-ipip.h b/drivers/fpga/aal/include/aalsdk/kernel/aalbus-ipip.h
new file mode 100644
index 000000000000..6248da806928
--- /dev/null
+++ b/drivers/fpga/aal/include/aalsdk/kernel/aalbus-ipip.h
@@ -0,0 +1,181 @@
+//******************************************************************************
+// This  file  is  provided  under  a  dual BSD/GPLv2  license.  When using or
+//         redistributing this file, you may do so under either license.
+//
+//                            GPL LICENSE SUMMARY
+//
+//  Copyright(c) 2008-2017, Intel Corporation.
+//
+//  This program  is  free software;  you  can redistribute it  and/or  modify
+//  it  under  the  terms of  version 2 of  the GNU General Public License  as
+//  published by the Free Software Foundation.
+//
+//  This  program  is distributed  in the  hope that it  will  be useful,  but
+//  WITHOUT   ANY   WARRANTY;   without   even  the   implied   warranty    of
+//  MERCHANTABILITY  or  FITNESS  FOR  A  PARTICULAR  PURPOSE.  See  the   GNU
+//  General Public License for more details.
+//
+//  The  full  GNU  General Public License is  included in  this  distribution
+//  in the file called README.GPLV2-LICENSE.TXT.
+//
+//  Contact Information:
+//  Henry Mitchel, henry.mitchel at intel.com
+//  77 Reed Rd., Hudson, MA  01749
+//
+//                                BSD LICENSE
+//
+//  Copyright(c) 2008-2017, Intel Corporation.
+//
+//  Redistribution and  use  in source  and  binary  forms,  with  or  without
+//  modification,  are   permitted  provided  that  the  following  conditions
+//  are met:
+//
+//    * Redistributions  of  source  code  must  retain  the  above  copyright
+//      notice, this list of conditions and the following disclaimer.
+//    * Redistributions in  binary form  must  reproduce  the  above copyright
+//      notice,  this  list of  conditions  and  the  following disclaimer  in
+//      the   documentation   and/or   other   materials   provided  with  the
+//      distribution.
+//    * Neither   the  name   of  Intel  Corporation  nor  the  names  of  its
+//      contributors  may  be  used  to  endorse  or promote  products derived
+//      from this software without specific prior written permission.
+//
+//  THIS  SOFTWARE  IS  PROVIDED  BY  THE  COPYRIGHT HOLDERS  AND CONTRIBUTORS
+//  "AS IS"  AND  ANY  EXPRESS  OR  IMPLIED  WARRANTIES,  INCLUDING,  BUT  NOT
+//  LIMITED  TO, THE  IMPLIED WARRANTIES OF  MERCHANTABILITY  AND FITNESS  FOR
+//  A  PARTICULAR  PURPOSE  ARE  DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT
+//  OWNER OR CONTRIBUTORS BE LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,
+//  SPECIAL,  EXEMPLARY,  OR  CONSEQUENTIAL   DAMAGES  (INCLUDING,   BUT   NOT
+//  LIMITED  TO,  PROCUREMENT  OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF USE,
+//  DATA,  OR PROFITS;  OR BUSINESS INTERRUPTION)  HOWEVER  CAUSED  AND ON ANY
+//  THEORY  OF  LIABILITY,  WHETHER  IN  CONTRACT,  STRICT LIABILITY,  OR TORT
+//  (INCLUDING  NEGLIGENCE  OR OTHERWISE) ARISING  IN ANY WAY  OUT  OF THE USE
+//  OF  THIS  SOFTWARE, EVEN IF ADVISED  OF  THE  POSSIBILITY  OF SUCH DAMAGE.
+//******************************************************************************
+//****************************************************************************
+//        FILE: aalbus-ipip.h
+//     CREATED: 12/5/2012
+//      AUTHOR: Joseph Grecco
+//
+// PURPOSE:  This file contains the definitions for AAL Physical Interface 
+//           Protocol (PIP).
+//           Accelerator Abstraction Layer (AAL)
+//           Accelerator Hardware Module bus driver module
+// HISTORY:
+// COMMENTS:
+// WHEN:          WHO:     WHAT:
+// 12/04/2012     JG       Seperated from aalbus-device.h for Windows 
+//                         portability.
+//****************************************************************************
+#ifndef __AALSDK_KERNEL_AALBUS_IPIP_H__
+#define __AALSDK_KERNEL_AALBUS_IPIP_H__
+#include <aalsdk/kernel/aalwsservice.h>
+#include <aalsdk/kernel/AALTransactionID_s.h>
+
+BEGIN_NAMESPACE(AAL)
+
+struct aal_device;
+struct aaldev_ownerSession;
+//=============================================================================
+// Name: aal_fops
+// Description: AAL hooks for file operations used optionally by PIPS
+//=============================================================================
+struct aal_fops
+{
+   // mmap
+   btInt (*mmap)(struct aaldev_ownerSession *, // Owner sesssion
+                 struct aal_wsid *,            // WSID
+                 btAny );                      // OS specific structure
+};
+
+//=============================================================================
+// Name: aal_pipapi
+// Description: PIP interface handler - Interface adaptor between Universal
+//              Interface Driver and the PIP.
+//=============================================================================
+
+// Message/Transaction wrapper
+struct aal_pipmessage
+{
+   btVirtAddr           m_message;        // Message body
+   btVirtAddr           m_response;       // Response body
+   btWSSize             m_respbufSize;    // Response buffer size
+   stTransactionID_t    m_tranID;         // Transaction ID to identify result
+   btObjectType         m_context;        // Optional token
+   btUnsigned32bitInt   m_errcode;        // Errror
+};
+
+// Message handler interface definition
+struct aal_pipmsghandler
+{
+   // Binds the UI driver session interface with PIP
+   btInt (*bindSession)(struct aaldev_ownerSession *);
+
+   // UnBinds the UI driver session
+   btInt (*unBindSession)(struct aaldev_ownerSession *);
+
+   // Send a UI message to the PIP
+   btInt (*sendMessage)(struct aaldev_ownerSession *,   // Owner Session
+                        struct aal_pipmessage *);       // Message
+
+};
+
+
+//=============================================================================
+// Name: aal_ipip
+// Description: Physical Interface Protocol Interface
+//=============================================================================
+struct aal_ipip
+{
+   struct aal_pipmsghandler   m_messageHandler; // PIP's message handler
+
+   // Methods for binding and unbinding PIP to generic aal_device
+   //  these may be used to allow PIPs to perform device initialization
+   //  if the PIP is implemented independent of the driver Object's probe
+   //  method.
+   btInt (*binddevice)(struct aal_ipip *, struct aal_device *);   // Binds the PIP to the device
+   btInt (*unbinddevice)(struct aal_device *);                    // Unbinds the PIP
+
+   // Used for driver interface forwarding
+   struct aal_fops            m_fops;
+
+   // Workspace manager
+   struct aal_interface      *m_iwsmgr;  // Workspace manager interface container
+   struct aal_wsservice      *m_wsmgr;   // Workspace manager interface
+
+   // Channel activate and deactivate commands
+   btInt (*activate_channel)(struct aal_device * );
+   btInt (*deactivate_channel)(struct aal_device * );
+//-------------------------------------------------------------------------------
+//-------------------------------------------------------------------------------
+};
+
+// Convenience macros
+#define aalpip_hasBind(p)     (NULL != (p)->binddevice)
+#define aalpip_hasUnbind(p)   (NULL != (p)->unbinddevice)
+#define aalpip_bindevice(p,d) ((p)->binddevice(p,d))
+#define aalpip_unbindevice(p) ((p)->unbinddevice)
+
+// fop macros
+#define aalpip_hasmmap(p)     (NULL != (p)->m_fops.mmap)
+#define aalpip_mmap(p)        ((p)->m_fops.mmap)
+
+#define aalpip_iwsmgr(d)      ((d)->m_iwsmgr)
+#define aalpip_wsmgrp(d)      ((d)->m_wsmgr)
+
+
+//=============================================================================
+// Name: aalpip_init
+// Description:Initialize the PIP structure
+//=============================================================================
+static inline 
+void
+aalpip_init(struct aal_ipip *ppip)
+{
+   memset(ppip, 0, sizeof(struct aal_ipip));
+}
+
+END_NAMESPACE(AAL)
+
+#endif // __AALSDK_KERNEL_AALBUS_IPIP_H__
+
diff --git a/drivers/fpga/aal/include/aalsdk/kernel/aalbus.h b/drivers/fpga/aal/include/aalsdk/kernel/aalbus.h
new file mode 100644
index 000000000000..6175d2c4b7be
--- /dev/null
+++ b/drivers/fpga/aal/include/aalsdk/kernel/aalbus.h
@@ -0,0 +1,832 @@
+//******************************************************************************
+// This  file  is  provided  under  a  dual BSD/GPLv2  license.  When using or
+//         redistributing this file, you may do so under either license.
+//
+//                            GPL LICENSE SUMMARY
+//
+//  Copyright(c) 2008-2017, Intel Corporation.
+//
+//  This program  is  free software;  you  can redistribute it  and/or  modify
+//  it  under  the  terms of  version 2 of  the GNU General Public License  as
+//  published by the Free Software Foundation.
+//
+//  This  program  is distributed  in the  hope that it  will  be useful,  but
+//  WITHOUT   ANY   WARRANTY;   without   even  the   implied   warranty    of
+//  MERCHANTABILITY  or  FITNESS  FOR  A  PARTICULAR  PURPOSE.  See  the   GNU
+//  General Public License for more details.
+//
+//  The  full  GNU  General Public License is  included in  this  distribution
+//  in the file called README.GPLV2-LICENSE.TXT.
+//
+//  Contact Information:
+//  Henry Mitchel, henry.mitchel at intel.com
+//  77 Reed Rd., Hudson, MA  01749
+//
+//                                BSD LICENSE
+//
+//  Copyright(c) 2008-2017, Intel Corporation.
+//
+//  Redistribution and  use  in source  and  binary  forms,  with  or  without
+//  modification,  are   permitted  provided  that  the  following  conditions
+//  are met:
+//
+//    * Redistributions  of  source  code  must  retain  the  above  copyright
+//      notice, this list of conditions and the following disclaimer.
+//    * Redistributions in  binary form  must  reproduce  the  above copyright
+//      notice,  this  list of  conditions  and  the  following disclaimer  in
+//      the   documentation   and/or   other   materials   provided  with  the
+//      distribution.
+//    * Neither   the  name   of  Intel  Corporation  nor  the  names  of  its
+//      contributors  may  be  used  to  endorse  or promote  products derived
+//      from this software without specific prior written permission.
+//
+//  THIS  SOFTWARE  IS  PROVIDED  BY  THE  COPYRIGHT HOLDERS  AND CONTRIBUTORS
+//  "AS IS"  AND  ANY  EXPRESS  OR  IMPLIED  WARRANTIES,  INCLUDING,  BUT  NOT
+//  LIMITED  TO, THE  IMPLIED WARRANTIES OF  MERCHANTABILITY  AND FITNESS  FOR
+//  A  PARTICULAR  PURPOSE  ARE  DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT
+//  OWNER OR CONTRIBUTORS BE LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,
+//  SPECIAL,  EXEMPLARY,  OR  CONSEQUENTIAL   DAMAGES  (INCLUDING,   BUT   NOT
+//  LIMITED  TO,  PROCUREMENT  OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF USE,
+//  DATA,  OR PROFITS;  OR BUSINESS INTERRUPTION)  HOWEVER  CAUSED  AND ON ANY
+//  THEORY  OF  LIABILITY,  WHETHER  IN  CONTRACT,  STRICT LIABILITY,  OR TORT
+//  (INCLUDING  NEGLIGENCE  OR OTHERWISE) ARISING  IN ANY WAY  OUT  OF THE USE
+//  OF  THIS  SOFTWARE, EVEN IF ADVISED  OF  THE  POSSIBILITY  OF SUCH DAMAGE.
+//******************************************************************************
+//****************************************************************************
+//        FILE: aalbus.h
+//     CREATED: 02/14/2008
+//      AUTHOR: Joseph Grecco
+//
+// PURPOSE:  External definitions for the AAL Logical Bus driver module
+// HISTORY:
+// COMMENTS:
+// WHEN:          WHO:     WHAT:
+// 02-14-08       JG       Initial version created
+// 11/11/2008     JG       Added legal header
+// 11/25/2008     HM       Large merge
+// 01/04/2009     HM       Updated Copyright
+// 02/26/2009     JG       Began dynamic config implementation
+// 02/11/2010     JG       Support for kernel 2.6.31
+// 07/15/2012     HM       Support for kernel 2.6.18
+// 05/15/2014     JG       Added Windows support.  AAL 4.x refactoring.
+//****************************************************************************
+#ifndef __AALSDK_KERNEL_AALBUS_H__
+#define __AALSDK_KERNEL_AALBUS_H__
+#include <aalsdk/kernel/kosal.h>
+#include <aalsdk/kernel/aalbus-device.h>
+#include <aalsdk/kernel/aaldevice.h>
+
+#if defined( __AAL_LINUX__ )
+struct inode;               // forward reference for 2.6.18 kernel for #include cdev.h
+
+#include <linux/device.h>
+#include <linux/cdev.h>     // struct cdev
+#include <linux/fs.h>
+#include <linux/version.h>
+#include <linux/kobject.h>
+#elif defined( __AAL_WINDOWS__ )
+
+// Specifies the device class for objects on the bus
+DEFINE_GUID(GUID_DEVCLASS_AAL_DEVICE,
+   0x89cb01b0, 0x1c62, 0x4c24, 0x9f, 0x51, 0x4f, 0x27, 0xdb, 0x38, 0x4c, 0xc4);
+// {89CB01B0-1C62-4C24-9F51-4F27DB384CC4}
+
+#endif
+
+
+BEGIN_NAMESPACE(AAL)
+
+//-----------------------------------------------------------------------------
+//-----------------------------------------------------------------------------
+//                            Exports
+//-----------------------------------------------------------------------------
+//-----------------------------------------------------------------------------
+extern
+struct aal_bus *
+aalbus_get_bus(void);
+
+// TODO REMOVE
+struct aal_device_id; // Forward reference
+extern
+struct aal_device *
+aalbus_get_device(struct aal_device_id *devID,
+                  btUnsigned32bitInt mask );
+
+// Forward reference
+struct aal_bus;
+
+//-----------------------------------------------------------------------------
+// Public Interface
+//-----------------------------------------------------------------------------
+#define  AAL_vendINTC         (0x8086LL)     //Should come out of INTCDEFS.h TODO
+
+//TODO ALL GO AWAY
+//=============================================================================
+// IDs for device driver module APIs i.e., Interface between User API module
+// and the low-level device driver module. This is the interface exposed
+// by a device driver that is used by an UI driver.  Acquired via the
+// get_interface() method
+//=============================================================================
+#define  AAL_DDAPI_IID_07      (0x00007000)   // Interface used in 0.70
+#define  AAL_DDAPI_IID_100     (0x01000000)   // Interface used in 1.00
+
+//=============================================================================
+// PIP Version IDs - This represents the physical interface implemented by the
+// device and device driver
+//=============================================================================
+#define AAL_FSB_PIPID_V10      (0x0000A000)   // Interface used in 1.0
+#define AAL_FSB_PIPID_V07      (0x00007000)   // Interface used in 0.70
+#define AAL_ASM_PIPID_V10      (0x1000A000)   // Interface used in 1.0
+#define AAL_ASM_PIPID_V07      (0x10007000)   // Interface used in 0.70
+// TODO HERE
+
+
+// forward references
+struct aal_driver;
+struct aal_classdevice;
+struct aal_interface;
+struct aal_device_id;
+
+//-----------------------------------------------------------------------------
+//-----------------------------------------------------------------------------
+//                            AAL Bus
+//-----------------------------------------------------------------------------
+//-----------------------------------------------------------------------------
+
+
+//=============================================================================
+// Name: aalbus_event_config_update_t
+// Description:SIgnature for config update event callback handler
+// Inputs: devhndl - handle to the device
+//         devid - device ID
+//         context - context
+//=============================================================================
+typedef void (*aalbus_event_config_update_t)(struct aal_device *devhndl,
+                                             krms_cfgUpDate_e   updateType,
+                                             btPID              pid,
+                                             btObjectType       context);
+
+
+//=============================================================================
+// Prototypes for default AALbus methods
+//=============================================================================
+static inline
+btInt
+aalbus_def_register_class_device(struct aal_classdevice *classdevice);
+static inline
+void
+aalbus_def_unregister_class_device(struct aal_classdevice *classdevice);
+static inline
+btInt
+aalbus_def_register_device(struct aal_device *dev);
+static inline
+void
+aalbus_def_unregister_device(struct aal_device *dev);
+static inline
+btInt
+aalbus_def_init_driver(kosal_ownermodule      *powner,
+                       struct aal_driver      *driver,
+                       struct aal_classdevice *pclassdev,
+                       const char             *devname,
+                       btInt                   devmajor);
+static inline
+btInt
+aalbus_def_release_driver(struct aal_driver      *driver,
+                          struct aal_classdevice *pclassdev);
+static inline
+btInt
+aalbus_def_register_driver(struct aal_driver *driver);
+static inline
+void
+aalbus_def_unregister_driver(struct aal_driver *driver);
+static inline
+btInt
+aalbus_def_register_service_interface(struct aal_interface *pinterface);
+static inline
+btInt
+aalbus_def_unregister_service_interface(struct aal_interface *pinterface);
+static inline
+struct aal_interface *
+aalbus_def_get_service_interface(btIID iid);
+static inline
+void
+aalbus_def_release_service_interface(struct aal_interface *pinterface);
+static inline
+btInt
+aalbus_def_has_interface(btIID iid);
+static inline
+struct aal_device *
+aalbus_def_get_device(struct aal_device_id *, btUnsigned32bitInt );
+static inline
+struct aal_device *
+aalbus_def_handle_to_device(btObjectType handle);
+static inline
+btInt
+aal_bus_def_register_config_update_handler(aalbus_event_config_update_t EventHandler,
+                                           btObjectType                 context);
+#if 0
+//static inline btInt aalbus_walk_device_chain(void);
+#endif
+static inline
+btInt
+aal_bus_def_send_config_update_event(struct aal_device *pdev,
+                                     krms_cfgUpDate_e   updateType,
+                                     btPID              pid);
+//static inline btInt aalbus_def_send_uevent(struct aal_device *dev, enum kobject_action act, char *env[] );
+
+
+
+// Used in register_device to indicate register with the native bus
+#define AAL_BUSTYPE_NATIVE    (kosal_bus_type )(-1)
+
+//=============================================================================
+// Name: aal_bus
+// Description: AAL bus class - Public members
+//=============================================================================
+struct aal_bus {
+#define AAL_BUS_VERSION 0x0001000000000001ULL
+   btUnsigned64bitInt      m_version; // Interface version
+
+   // Declare as a device factory
+   _DECLARE_DEVFACTORY_TYPE;
+
+   // Device bus methods
+   btInt                   (*register_device)( struct aal_device *dev );
+   void                    (*unregister_device)( struct aal_device *dev );
+
+
+   struct aal_device *     (*get_device)( struct aal_device_id *devID, btUnsigned32bitInt mask );
+   struct aal_device *     (*handle_to_device)( void *handle );
+
+   // Driver registration methods
+   btInt                   (*init_driver)(kosal_ownermodule      *powner,
+                                          struct aal_driver      *driver,
+                                          struct aal_classdevice *pclassdev,
+                                          const char             *devname,
+                                          btInt                   devmajor);
+   btInt                   (*release_driver)(struct aal_driver      *driver,
+                                             struct aal_classdevice *pclassdev);
+   btInt                   (*register_driver)(struct aal_driver *driver);
+   void                    (*unregister_driver)(struct aal_driver *driver);
+
+   // Class registration methods
+   btInt                   (*register_class_device)( struct aal_classdevice *classdevice );
+   void                    (*unregister_class_device)( struct aal_classdevice *classdevice );
+
+   // Service interface methods  // TODO add event handler for deferred allocation as well as shutdown notifications
+   btInt                   (*register_service_interface)( struct aal_interface *pinterface );
+   btInt                   (*unregister_service_interface)( struct aal_interface *pinterface );
+   btInt                   (*unregister_service_interface_id)(btIID iid);
+   struct aal_interface *  (*get_service_interface)(btIID iid);
+   void                    (*release_service_interface)( struct aal_interface *pinterface );
+   btInt                   (*has_interface)(btIID iid);
+
+   btInt                   (*register_config_update_handler)(aalbus_event_config_update_t EventHandler,
+                                                             btObjectType context );
+#if 0
+   btInt                   (*walk_device_chain)(void);
+#endif
+   btInt                   (*send_config_update_event)( struct aal_device *pdev,
+                                                        krms_cfgUpDate_e updateType,
+                                                        btPID pid );
+//   btInt                   (*send_uevent)(struct aal_device *dev, enum kobject_action act, char *env[] );
+
+   btInt                   (*dev_is_valid)(struct aal_device *);
+
+   struct aal_bus *        m_parent;
+};
+
+
+
+//=============================================================================
+//               Default bus method implementations
+// These methods are set by the aal_bus_init() function to insure that a valid
+// implementation exists for all member pointers.
+//
+// These defaults are primarily intended for bus drivers that are derived from
+// aal_bus.  NOTE that several of these defaults call the aal_bus base instance.
+// The aal_bus_type singleton driver instance MUST implement these functions
+// aal_bus cannot use the default as infinite recursion will occur!
+//=============================================================================
+static inline
+btInt
+aalbus_def_register_device(struct aal_device *dev)
+{
+   return aalbus_get_bus()->register_device(dev);
+}
+static inline
+void
+aalbus_def_unregister_device(struct aal_device *dev)
+{
+   UNREFERENCED_PARAMETER(dev);
+   return;
+}
+static inline
+struct aal_device *
+aalbus_def_get_device(struct aal_device_id *devID, btUnsigned32bitInt mask)
+{
+   UNREFERENCED_PARAMETER(devID);
+   UNREFERENCED_PARAMETER(mask);
+   return NULL;
+}
+static inline
+struct aal_device *
+aalbus_def_handle_to_device(btObjectType handle)
+{
+   UNREFERENCED_PARAMETER(handle);
+   return NULL;
+}
+static inline
+btInt
+aalbus_def_init_driver(kosal_ownermodule      *powner,
+                       struct aal_driver      *driver,
+                       struct aal_classdevice *pclassdev,
+                       const char             *devname,
+                       btInt                   devmajor)
+{
+   UNREFERENCED_PARAMETER(powner);
+   UNREFERENCED_PARAMETER(driver);
+   UNREFERENCED_PARAMETER(pclassdev);
+   UNREFERENCED_PARAMETER(devname);
+   UNREFERENCED_PARAMETER(devmajor);
+   return -EINVAL;
+}
+static inline
+btInt
+aalbus_def_release_driver(struct aal_driver      *driver,
+                          struct aal_classdevice *pclassdev)
+{
+   UNREFERENCED_PARAMETER(driver);
+   UNREFERENCED_PARAMETER(pclassdev);
+   return -EINVAL;
+}
+static inline
+btInt
+aalbus_def_register_driver(struct aal_driver *driver)
+{
+   UNREFERENCED_PARAMETER(driver);
+   return -EINVAL;
+}
+static inline
+void
+aalbus_def_unregister_driver(struct aal_driver *driver)
+{
+   UNREFERENCED_PARAMETER(driver);
+   return;
+}
+static inline
+btInt
+aalbus_def_register_class_device(struct aal_classdevice *classdevice)
+{
+   return aalbus_get_bus()->register_class_device( classdevice );
+}
+static inline
+void
+aalbus_def_unregister_class_device( struct aal_classdevice *classdevice )
+{
+   UNREFERENCED_PARAMETER(classdevice);
+   return;
+}
+static inline
+btInt
+aalbus_def_register_service_interface(struct aal_interface *pinterface)
+{
+   UNREFERENCED_PARAMETER(pinterface);
+   return -EINVAL;
+}
+static inline
+btInt
+aalbus_def_unregister_service_interface(struct aal_interface *pinterface)
+{
+   UNREFERENCED_PARAMETER(pinterface);
+   return -EINVAL;
+}
+static inline
+struct aal_interface *
+aalbus_def_get_service_interface(btIID iid)
+{
+   UNREFERENCED_PARAMETER(iid);
+   return NULL;
+}
+static inline
+void
+aalbus_def_release_service_interface(struct aal_interface *pinterface)
+{
+   UNREFERENCED_PARAMETER(pinterface);
+   return;
+}
+static inline
+btInt
+aalbus_def_has_interface(btIID iid)
+{
+   UNREFERENCED_PARAMETER(iid);
+   return -EINVAL;
+}
+static inline
+btInt
+aal_bus_def_register_config_update_handler(aalbus_event_config_update_t EventHandler,
+                                           btObjectType                 context)
+{
+   UNREFERENCED_PARAMETER(EventHandler);
+   UNREFERENCED_PARAMETER(context);
+   return -EINVAL;
+}
+
+#if 0
+static inline
+btInt
+aal_bus_def_walk_device_chain(void)
+{
+   return -EINVAL;
+}
+#endif
+
+static inline
+btInt
+aal_bus_def_send_config_update_event(struct aal_device *pdev,
+                                     krms_cfgUpDate_e   updateType,
+                                     btPID              pid)
+{
+   // Send to root AAL Bus
+   return aalbus_get_bus()->send_config_update_event(pdev, updateType, pid );
+}
+
+#if 0
+static inline
+btInt
+aalbus_def_send_uevent(struct aal_device *dev, enum kobject_action act, char *env[] )
+{
+   UNREFERENCED_PARAMETER(dev);
+   UNREFERENCED_PARAMETER(dev);
+   UNREFERENCED_PARAMETER(dev);
+   return 0;
+}
+#endif
+
+inline static
+btInt
+aalbus_def_validate_device(struct aal_device *ignored)
+{
+   UNREFERENCED_PARAMETER(ignored);
+   return 0;
+}
+//=============================================================================
+// Name: aal_bus_init
+// Description: Insures aal_bus in an initialized state
+// Interface: private
+// Inputs: pbus - aal_bus structure.
+// Outputs: none.
+// Comments: NOTE the aal_bus driver singleton MUST implement some of these
+//           methods (override).  Derived busses may choose not to implement
+//           all methods
+//=============================================================================
+static inline
+void
+aal_bus_init(struct aal_bus *pbus)
+{
+   memset(pbus, 0, sizeof(struct aal_bus));
+   pbus->register_device               = aalbus_def_register_device;
+   pbus->unregister_device             = aalbus_def_unregister_device;
+   // MEGAMERGE: create_device --> INIT_FACT_CREATE_DEVICE, and destroy_device --> INIT_FACT_DESTROY_DEVICE
+   pbus->INIT_FACT_CREATE_DEVICE       = aaldev_def_create_device;
+   pbus->INIT_FACT_DESTROY_DEVICE      = aaldev_def_destroy_device;
+   pbus->get_device                    = aalbus_def_get_device;
+   pbus->handle_to_device              = aalbus_def_handle_to_device;
+   pbus->init_driver                   = aalbus_def_init_driver;
+   pbus->release_driver                = aalbus_def_release_driver;
+   pbus->register_driver               = aalbus_def_register_driver;
+   pbus->unregister_driver             = aalbus_def_unregister_driver;
+   pbus->register_class_device         = aalbus_def_register_class_device;
+   pbus->unregister_class_device       = aalbus_def_unregister_class_device;
+   pbus->register_service_interface    = aalbus_def_register_service_interface;
+   pbus->unregister_service_interface  = aalbus_def_unregister_service_interface;
+   pbus->get_service_interface         = aalbus_def_get_service_interface;
+   pbus->release_service_interface     = aalbus_def_release_service_interface;
+   pbus->has_interface                 = aalbus_def_has_interface;
+   pbus->register_config_update_handler = aal_bus_def_register_config_update_handler;
+//   pbus->walk_device_chain             = aalbus_walk_device_chain;
+   pbus->release_service_interface     = aalbus_def_release_service_interface;
+   pbus->send_config_update_event      = aal_bus_def_send_config_update_event;
+//   pbus->send_uevent                   = aalbus_def_send_uevent;
+
+   pbus->m_version                     = AAL_BUS_VERSION;
+}
+
+
+//=============================================================================
+// Name: aal_bus_sane
+// Description: Insures aal_bus is complete with no unset interface pointers
+// Interface: private
+// Inputs: pbus - aal_bus structure.
+// Outputs: Sets uninitialized fields
+// Comments:
+//=============================================================================
+//=============================================================================
+static inline
+void
+aal_bus_sane(struct aal_bus *pbus)
+{
+   if(!pbus->register_device){
+      pbus->register_device = aalbus_def_register_device;
+   }
+
+   if(!pbus->unregister_device){
+      pbus->unregister_device = aalbus_def_unregister_device;
+   }
+
+   if(!pbus->get_device){
+      pbus->get_device = aalbus_def_get_device;
+   }
+
+   if(!pbus->INIT_FACT_CREATE_DEVICE){
+      pbus->INIT_FACT_CREATE_DEVICE = aaldev_def_create_device;
+   }
+
+   if(!pbus->INIT_FACT_DESTROY_DEVICE){
+      pbus->INIT_FACT_DESTROY_DEVICE = aaldev_def_destroy_device;
+   }
+
+   if(!pbus->handle_to_device){
+      pbus->handle_to_device = aalbus_def_handle_to_device;
+   }
+
+   if ( !pbus->init_driver ) {
+      pbus->init_driver = aalbus_def_init_driver;
+   }
+
+   if ( !pbus->release_driver ) {
+      pbus->release_driver = aalbus_def_release_driver;
+   }
+
+   if(!pbus->register_driver){
+      pbus->register_driver = aalbus_def_register_driver;
+   }
+
+   if(!pbus->unregister_driver){
+      pbus->unregister_driver = aalbus_def_unregister_driver;
+   }
+
+   if(!pbus->register_class_device){
+      pbus->register_class_device = aalbus_def_register_class_device;
+   }
+
+   if(!pbus->unregister_class_device){
+      pbus->unregister_class_device = aalbus_def_unregister_class_device;
+   }
+
+   if(!pbus->register_service_interface){
+      pbus->register_service_interface = aalbus_def_register_service_interface;
+   }
+
+   if(!pbus->unregister_service_interface){
+      pbus->unregister_service_interface = aalbus_def_unregister_service_interface;
+   }
+
+   if(!pbus->get_service_interface){
+      pbus->get_service_interface = aalbus_def_get_service_interface;
+   }
+
+   if(!pbus->release_service_interface){
+      pbus->release_service_interface  = aalbus_def_release_service_interface;
+   }
+
+   if(!pbus->has_interface){
+      pbus->has_interface = aalbus_def_has_interface;
+   }
+
+   if(!pbus->register_config_update_handler){
+      pbus->register_config_update_handler = aal_bus_def_register_config_update_handler;
+   }
+
+   if(!pbus->send_config_update_event){
+      pbus->send_config_update_event = aal_bus_def_send_config_update_event;
+   }
+#if 0
+   if( !pbus->send_uevent){
+      pbus->send_uevent = aalbus_def_send_uevent;
+   }
+#endif
+   if( !pbus->dev_is_valid){
+      pbus->dev_is_valid = aalbus_def_validate_device;
+   }
+
+}
+
+
+
+//-----------------------------------------------------------------------------
+//-----------------------------------------------------------------------------
+//                            AAL Driver
+//-----------------------------------------------------------------------------
+//-----------------------------------------------------------------------------
+
+//=============================================================================
+// Name: aal_driver
+// Description: AAL specific driver object definition
+//=============================================================================
+struct aal_driver {
+#if (1 == ENABLE_CANARIES)
+#define _struct_aal_driver_canary_size              20
+#define _struct_aal_driver_start_canary_const       "s:struct aal_driver"
+#define _struct_aal_driver_define_start_canary      char _struct_aal_driver_start_canary[_struct_aal_driver_canary_size]
+#define _struct_aal_driver_end_canary_const         "e:struct aal_driver"
+#define _struct_aal_driver_define_end_canary        char _struct_aal_driver_end_canary[_struct_aal_driver_canary_size]
+#define _struct_aal_driver_start_canary_initializer { 's', ':', 's', 't', 'r', 'u', 'c', 't', ' ', 'a', 'a', 'l', '_', 'd', 'r', 'i', 'v', 'e', 'r', 0 },
+#define _struct_aal_driver_end_canary_initializer   { 'e', ':', 's', 't', 'r', 'u', 'c', 't', ' ', 'a', 'a', 'l', '_', 'd', 'r', 'i', 'v', 'e', 'r', 0 }
+   _struct_aal_driver_define_start_canary;
+#else
+#define _struct_aal_driver_start_canary_initializer
+#define _struct_aal_driver_end_canary_initializer
+#endif // ENABLE_CANARIES
+
+#define AAL_DRIVER_FLAG_CHRDEV_REGION_OBTAINED 0x00000001
+#define AAL_DRIVER_FLAG_IS_REGISTERED          0x00000002
+#define AAL_DRIVER_FLAG_CHRDEV_ADDED           0x00000004
+   btUnsigned16bitInt         m_flags;
+
+   // List of sessions owned by this driver
+   kosal_list_head            m_sesslist;
+
+   // Return an interface pointer based on the iid. Used to dynamically
+   // bind to a custom interface the driver may export. Typically used to
+   // export the internal control interface used by a user space interface
+   // driver.
+   struct aal_interface *(*get_interface)(struct aal_driver* drv, btIID iid);
+
+   // Return 1 if interface supported
+   btInt (*has_interface)(struct aal_driver* drv, btIID iid);
+
+   // Returns 1 if the interface specified in iid can be used. Typically
+   // used to find out if a user space interface driver can "speak" a particular
+   // interface.
+   btInt (*supports_interface)(struct aal_driver* drv, btIID iid);
+
+   // Char device file operations interface methods for user space interface
+   // or may be used to hold the internal interface of a device driver
+#if   defined( __AAL_LINUX__ )
+   struct file_operations      m_fops;  // Interface
+   struct cdev                 m_cdev;  // character device
+   btInt                       m_major; // major number of device node
+#elif defined( __AAL_WINDOWS__ )
+   btInt (*ioctl)(btAny ,
+                  btUnsigned32bitInt ,
+                  btAny ,
+                  btWSSize ,
+                  btAny ,
+                  btWSSize * );
+   btUnsigned64bitInt
+         (*poll)(kosal_poll_object, 
+                 btAny );
+#endif
+
+
+   // List of implemented dynamic interfaces
+   btIID                      *m_iids;
+
+   // ID list of supported devices if this is a device driver
+   const struct aal_device_id *m_idtable;
+
+   // Called to determine if this driver supports a device
+   btInt (*m_match)(struct aal_driver* drv, struct aal_device* dev);
+
+   // Called to initialize the hardware
+   btInt (*m_probe)(struct aal_device* dev);
+
+   // AAL Bus interface
+   struct   aal_bus           *m_bus;
+#if defined( __AAL_LINUX__ )
+   //Generic device driver base
+   struct device_driver        m_driver;
+#endif // __AAL_LINUX__
+
+#if (1 == ENABLE_CANARIES)
+   _struct_aal_driver_define_end_canary;
+#endif // ENABLE_CANARIES
+};
+
+#define aaldrv_is_chrdev_region_obtained(drv)  ((drv)->m_flags & AAL_DRIVER_FLAG_CHRDEV_REGION_OBTAINED)
+#define aaldrv_set_chrdev_region_obtained(drv) ((drv)->m_flags |= AAL_DRIVER_FLAG_CHRDEV_REGION_OBTAINED)
+#define aaldrv_clr_chrdev_region_obtained(drv) ((drv)->m_flags &= ~AAL_DRIVER_FLAG_CHRDEV_REGION_OBTAINED)
+
+#define aaldrv_is_registered(drv)     ((drv)->m_flags & AAL_DRIVER_FLAG_IS_REGISTERED)
+#define aaldrv_set_is_registered(drv) ((drv)->m_flags |= AAL_DRIVER_FLAG_IS_REGISTERED)
+#define aaldrv_clr_is_registered(drv) ((drv)->m_flags &= ~AAL_DRIVER_FLAG_IS_REGISTERED)
+
+#define aaldrv_is_chrdev_added(drv)   ((drv)->m_flags & AAL_DRIVER_FLAG_CHRDEV_ADDED)
+#define aaldrv_set_chrdev_added(drv)  ((drv)->m_flags |= AAL_DRIVER_FLAG_CHRDEV_ADDED)
+#define aaldrv_clr_chrdev_added(drv)  ((drv)->m_flags &= ~AAL_DRIVER_FLAG_CHRDEV_ADDED)
+
+//-----------------------------
+// aal_driver casting operators
+//-----------------------------
+#define base_to_aaldrv(drv)      (container_of( drv, struct aal_driver, m_driver ) )
+#define aaldrv_to_basep(drv)     (&(drv)->m_driver)
+#define aaldrv_to_base(drv)      ((drv)->m_driver)
+#define aaldrv_to_base_busp(drv) (aaldrv_to_base(drv).bus)
+
+
+//-----------------------
+// aal_driver Accesssors
+//-----------------------
+#define aaldrv_sess_list(drv) ((drv)->m_sesslist)
+#define aaldrv_fops(drv)      ((drv)->m_fops)
+#define aaldrv_fopsp(drv)     (&(drv)->m_fops)
+#define aaldrv_cdevp(drv)     (&(drv)->m_cdev)
+#define aaldrv_dev_major(drv) ((drv)->m_major)
+#define aaldrv_iids(drv)      ((drv)->m_iids)
+#define aaldrv_aalbus(drv)    (*((drv)->m_bus))
+#define aaldrv_aalbusp(drv)   ((drv)->m_bus)
+
+//=============================================================================
+// Name: aal_driver_init
+// Description: Initialize the structure
+//=============================================================================
+#if 0
+// Most drivers embed a subset. Careful about wiping it clean here.
+#define aal_driver_init(p)                  \
+do                                          \
+{                                           \
+   memset(p, 0, sizeof(struct aal_driver)); \
+   kosal_list_init((&(p)->m_sesslist);      \
+}while(0)
+#endif
+
+
+/** @brief wrapper for checking valid device structure
+ * @param[in] pdev pointer to the device to check
+ * @return non-zero if pdev appears to be a valid device
+ *
+ * Checking the validity of a device requires an aalbus, so can't be performed
+ * inside the aalbus-device.h.  This inline exists for backwards-compatiblity.
+ * If the caller already has a reference to aalbus, it can invoke the check
+ * directly.  */
+inline static int
+aaldev_valid(struct aal_device *pdev) {
+   struct aal_bus *aalbus_p;
+
+   aalbus_p = aalbus_get_bus();
+
+   ASSERT(NULL != aalbus_p);
+   if ( NULL == aalbus_p ) {
+      return 0;
+   }
+
+   ASSERT(NULL != aalbus_p->dev_is_valid);
+   if ( NULL == aalbus_p->dev_is_valid ) {
+      return 0;
+   }
+
+   return aalbus_p->dev_is_valid(pdev);
+}
+
+
+/** @brief casting from btObjectType to aal_device, with sanity checking
+ * @param[in] handle_p pointer to handle to convert to aal_device
+ * @return pointer to struct aal_device on success, NULL on failure */
+static inline
+struct aal_device *aaldev_handle_to_devp(btObjectType handle)
+{
+   /* this will break if btObjectType becomes something other than a (void *) */
+   struct aal_device *dev_p = handle;
+
+   if (0 == aaldev_valid(dev_p)) {
+      return NULL;
+   } else {
+      return dev_p;
+   }
+}
+
+
+/** @brief casting from aal_device to btObject, with sanity checking
+ * @param[in] dev_p pointer to aal_device to convert to handle
+ * @return pointer to btObjectType on success, NULL on failure */
+static inline
+btObjectType aaldevp_to_devhandle(struct aal_device *dev_p)
+{
+   if (0 == aaldev_valid(dev_p)) {
+      return NULL;
+   } else {
+      /* this will break if btObjectType becomes something other than a
+       * (void *) */
+      return dev_p;
+   }
+}
+
+
+//-----------------------------------------------------------------------------
+//-----------------------------------------------------------------------------
+//                            AAL Macros
+//-----------------------------------------------------------------------------
+//-----------------------------------------------------------------------------
+
+// casting macros
+#define base_to_aal_bus(bus) (container_of( bus, struct aal_bus_type, m_bustype ) )
+#define ibus_to_aal_bus(bus) (container_of( bus, struct aal_bus_type, m_ibus ) )
+
+//#define base_to_aal_dev(dev) (container_of( dev, struct aal_device, m_dev ) )
+
+
+END_NAMESPACE(AAL)
+
+#endif // __AALSDK_KERNEL_AALBUS_H__
+
diff --git a/drivers/fpga/aal/include/aalsdk/kernel/aalbus_Defs.h b/drivers/fpga/aal/include/aalsdk/kernel/aalbus_Defs.h
new file mode 100644
index 000000000000..838b5297db60
--- /dev/null
+++ b/drivers/fpga/aal/include/aalsdk/kernel/aalbus_Defs.h
@@ -0,0 +1,134 @@
+//******************************************************************************
+// This  file  is  provided  under  a  dual BSD/GPLv2  license.  When using or
+//         redistributing this file, you may do so under either license.
+//
+//                            GPL LICENSE SUMMARY
+//
+//  Copyright(c) 2014-2017, Intel Corporation.
+//
+//  This program  is  free software;  you  can redistribute it  and/or  modify
+//  it  under  the  terms of  version 2 of  the GNU General Public License  as
+//  published by the Free Software Foundation.
+//
+//  This  program  is distributed  in the  hope that it  will  be useful,  but
+//  WITHOUT   ANY   WARRANTY;   without   even  the   implied   warranty    of
+//  MERCHANTABILITY  or  FITNESS  FOR  A  PARTICULAR  PURPOSE.  See  the   GNU
+//  General Public License for more details.
+//
+//  The  full  GNU  General Public License is  included in  this  distribution
+//  in the file called README.GPLV2-LICENSE.TXT.
+//
+//  Contact Information:
+//  Henry Mitchel, henry.mitchel at intel.com
+//  77 Reed Rd., Hudson, MA  01749
+//
+//                                BSD LICENSE
+//
+//  Copyright(c) 2014-2017, Intel Corporation.
+//
+//  Redistribution and  use  in source  and  binary  forms,  with  or  without
+//  modification,  are   permitted  provided  that  the  following  conditions
+//  are met:
+//
+//    * Redistributions  of  source  code  must  retain  the  above  copyright
+//      notice, this list of conditions and the following disclaimer.
+//    * Redistributions in  binary form  must  reproduce  the  above copyright
+//      notice,  this  list of  conditions  and  the  following disclaimer  in
+//      the   documentation   and/or   other   materials   provided  with  the
+//      distribution.
+//    * Neither   the  name   of  Intel  Corporation  nor  the  names  of  its
+//      contributors  may  be  used  to  endorse  or promote  products derived
+//      from this software without specific prior written permission.
+//
+//  THIS  SOFTWARE  IS  PROVIDED  BY  THE  COPYRIGHT HOLDERS  AND CONTRIBUTORS
+//  "AS IS"  AND  ANY  EXPRESS  OR  IMPLIED  WARRANTIES,  INCLUDING,  BUT  NOT
+//  LIMITED  TO, THE  IMPLIED WARRANTIES OF  MERCHANTABILITY  AND FITNESS  FOR
+//  A  PARTICULAR  PURPOSE  ARE  DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT
+//  OWNER OR CONTRIBUTORS BE LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,
+//  SPECIAL,  EXEMPLARY,  OR  CONSEQUENTIAL   DAMAGES  (INCLUDING,   BUT   NOT
+//  LIMITED  TO,  PROCUREMENT  OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF USE,
+//  DATA,  OR PROFITS;  OR BUSINESS INTERRUPTION)  HOWEVER  CAUSED  AND ON ANY
+//  THEORY  OF  LIABILITY,  WHETHER  IN  CONTRACT,  STRICT LIABILITY,  OR TORT
+//  (INCLUDING  NEGLIGENCE  OR OTHERWISE) ARISING  IN ANY WAY  OUT  OF THE USE
+//  OF  THIS  SOFTWARE, EVEN IF ADVISED  OF  THE  POSSIBILITY  OF SUCH DAMAGE.
+//******************************************************************************
+//****************************************************************************
+//        FILE: aalbusDefs.h
+//     CREATED: Feb. 27, 2015
+//      AUTHOR: Joseph Grecco, Intel Corporation.
+//
+// PURPOSE: Public Definitions for the AAL Bus subsystem
+// HISTORY:
+// WHEN:          WHO:     WHAT:
+//****************************************************************************
+#ifndef __AALSDK_KERNEL_BUS_DEFS_H__
+#define __AALSDK_KERNEL_BUS_DEFS_H__
+
+
+//-----------------------------------------------------------------------------
+// Request message IDs
+//-----------------------------------------------------------------------------
+typedef enum
+{
+   // User Resource Manager requests
+   reqid_bus_RequestDevice = 1,     // Device Allocation Request
+   reqid_bus_ReleaseDevice,        // Device Release Request
+
+   // Device configuration requests
+   reqid_bus_DeviceRequest,          // Send a device request
+
+   // Administration
+   reqid_bus_Shutdown,                  // Request that the Service session shutdown
+   reqid_bus_Restart,                   // Request to restart the RMCS without close/open
+
+   // Kernel Resource Manager requests
+   reqid_bus_SetConfigUpdates,     // Used to set configuration updates
+
+   // Response and Event IDs
+   rspid_bus_RequestDevice = 0xF000, // Device Allocation Response
+
+   // Device configuration requests
+   rspid_bus_DeviceRequest,          // Device Request response
+
+   // Kernel Resource Manager Responses and events
+   evtid_bus_ConfigUpdate,         // Configuration Update
+
+   // Administration
+   rspid_bus_Shutdown,                  // Service is shutdown
+   rspid_bus_Started
+
+} aalbus_msgIDs_e;
+
+
+//-----------------------------------------------------------------------------
+// Shutdown reason codes
+//-----------------------------------------------------------------------------
+typedef enum
+{
+   aalbus_shutdownReasonNormal = 0,
+   aalbus_shutdownReasonMaint,
+   aalbus_aalbus_shutdownFailure,
+   aalbus_aalbus_shutdownReasonRestart
+} aalbus_shutdownreason_e;
+
+//-----------------------------------------------------------------------------
+// Result message IDs - TODO COMBINE THESE WITH A GLOBAL SET
+//-----------------------------------------------------------------------------
+typedef enum
+{
+   aalbus_resultOK = 0,                                        // No error
+   aalbus_resultMaxOwnersErr,                                  // Max device owners
+   aalbus_resultDuplicateOwnerErr,                             // PID already owner
+   aalbus_resultNotOwnerErr,                                   // PID not owner
+   aalbus_resultInvalidDevice,                                 // Invalid device handle
+   aalbus_resultErrno,                                         // Errno has only info
+   aalbus_resultBadParm,                                       // Invalid parameter
+   aalbus_resultCancelled,                                     // Transaction cancelled
+   aalbus_resultDeviceHasNoPIPAssigned,                        // No PIP assigned
+   aalbus_resultNoAppropriateInterface,                        // No interface
+   aalbus_resultSystemErr                                      // System Error
+} aalbus_result_e;
+
+
+
+#endif //__AALSDK_KERNEL_BUS_DEFS_H__
diff --git a/drivers/fpga/aal/include/aalsdk/kernel/aalbus_iconfigmonitor.h b/drivers/fpga/aal/include/aalsdk/kernel/aalbus_iconfigmonitor.h
new file mode 100644
index 000000000000..0373b1942ac1
--- /dev/null
+++ b/drivers/fpga/aal/include/aalsdk/kernel/aalbus_iconfigmonitor.h
@@ -0,0 +1,141 @@
+//******************************************************************************
+// This  file  is  provided  under  a  dual BSD/GPLv2  license.  When using or
+//         redistributing this file, you may do so under either license.
+//
+//                            GPL LICENSE SUMMARY
+//
+//  Copyright(c) 2014-2017, Intel Corporation.
+//
+//  This program  is  free software;  you  can redistribute it  and/or  modify
+//  it  under  the  terms of  version 2 of  the GNU General Public License  as
+//  published by the Free Software Foundation.
+//
+//  This  program  is distributed  in the  hope that it  will  be useful,  but
+//  WITHOUT   ANY   WARRANTY;   without   even  the   implied   warranty    of
+//  MERCHANTABILITY  or  FITNESS  FOR  A  PARTICULAR  PURPOSE.  See  the   GNU
+//  General Public License for more details.
+//
+//  The  full  GNU  General Public License is  included in  this  distribution
+//  in the file called README.GPLV2-LICENSE.TXT.
+//
+//  Contact Information:
+//  Henry Mitchel, henry.mitchel at intel.com
+//  77 Reed Rd., Hudson, MA  01749
+//
+//                                BSD LICENSE
+//
+//  Copyright(c) 2014-2017, Intel Corporation.
+//
+//  Redistribution and  use  in source  and  binary  forms,  with  or  without
+//  modification,  are   permitted  provided  that  the  following  conditions
+//  are met:
+//
+//    * Redistributions  of  source  code  must  retain  the  above  copyright
+//      notice, this list of conditions and the following disclaimer.
+//    * Redistributions in  binary form  must  reproduce  the  above copyright
+//      notice,  this  list of  conditions  and  the  following disclaimer  in
+//      the   documentation   and/or   other   materials   provided  with  the
+//      distribution.
+//    * Neither   the  name   of  Intel  Corporation  nor  the  names  of  its
+//      contributors  may  be  used  to  endorse  or promote  products derived
+//      from this software without specific prior written permission.
+//
+//  THIS  SOFTWARE  IS  PROVIDED  BY  THE  COPYRIGHT HOLDERS  AND CONTRIBUTORS
+//  "AS IS"  AND  ANY  EXPRESS  OR  IMPLIED  WARRANTIES,  INCLUDING,  BUT  NOT
+//  LIMITED  TO, THE  IMPLIED WARRANTIES OF  MERCHANTABILITY  AND FITNESS  FOR
+//  A  PARTICULAR  PURPOSE  ARE  DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT
+//  OWNER OR CONTRIBUTORS BE LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,
+//  SPECIAL,  EXEMPLARY,  OR  CONSEQUENTIAL   DAMAGES  (INCLUDING,   BUT   NOT
+//  LIMITED  TO,  PROCUREMENT  OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF USE,
+//  DATA,  OR PROFITS;  OR BUSINESS INTERRUPTION)  HOWEVER  CAUSED  AND ON ANY
+//  THEORY  OF  LIABILITY,  WHETHER  IN  CONTRACT,  STRICT LIABILITY,  OR TORT
+//  (INCLUDING  NEGLIGENCE  OR OTHERWISE) ARISING  IN ANY WAY  OUT  OF THE USE
+//  OF  THIS  SOFTWARE, EVEN IF ADVISED  OF  THE  POSSIBILITY  OF SUCH DAMAGE.
+//******************************************************************************
+//******************************************************************************
+//        FILE: aalbus_iconfigmonitor.h
+//     CREATED: May 15, 2014
+//      AUTHOR: Joseph Grecco, Intel Corporation.
+//
+// PURPOSE: Definitions for the AAL IMonitorConfig AAL Bus Service interface.  
+//          This interface is used by resource monitors/managers to be notified
+//          when device resoures change.
+// HISTORY:
+// WHEN:          WHO:     WHAT:
+//******************************************************************************
+#ifndef __AALSDK_KERNEL_BUS_ICONFIG_MONITOR_H__
+#define __AALSDK_KERNEL_BUS_ICONFIG_MONITOR_H__
+
+#include <aalsdk/kernel/kosal.h>
+#include <aalsdk/kernel/iaaldevice.h>
+#include <aalsdk/kernel/aalbus_Defs.h>
+#include <aalsdk/kernel/AALTransactionID_s.h>
+
+
+//==========================================
+// Definitions for accessing the Service API
+//==========================================
+#if defined(__AAL_WINDOWS__)
+
+// Device names
+#define AALBUS_CONFMON_SERVICE_NAME_STRING            L"\\Device\\AAL_IConfigMonitor"
+#define AALBUS_CONFMON_SERVICE_SYMBOLIC_NAME_STRING   L"\\DosDevices\\AAL_IConfigMonitor"
+#define AALBUS_CONFMON_SERVICE_DOSNAME__STRING        "\\\\.\\AAL_IConfigMonitor"
+
+//
+// Interface Guid for config monitor Service.
+DEFINE_GUID(GUID_DEVINTERFACE_AALBUS_CONFIG_STATE_MONITOR,
+   0x701d4f32, 0x26cb, 0x4a87, 0xbb, 0xc4, 0xd1, 0xeb, 0xa, 0x3b, 0x51, 0xd2);
+// {701D4F32-26CB-4A87-BBC4-D1EB0A3B51D2}
+
+
+// Device Control API Commands
+#define FILE_DEVICE_BUSENUM         FILE_DEVICE_BUS_EXTENDER
+
+#define AALBUS_CONFIG_MONITOR_IOCTL(_index_) \
+    CTL_CODE (FILE_DEVICE_BUSENUM, (_index_ + 0xF), METHOD_BUFFERED, FILE_READ_DATA)
+
+
+#define IOCTL_CONFMON_POLL			               AALBUS_CONFIG_MONITOR_IOCTL(0x0)
+#define IOCTL_CONFMON_CANCEL_POLL               AALBUS_CONFIG_MONITOR_IOCTL(0x1)
+#define IOCTL_CONFMON_GETMSG_DESC               AALBUS_CONFIG_MONITOR_IOCTL(0x2)
+#define IOCTL_CONFMON_GETMSG                    AALBUS_CONFIG_MONITOR_IOCTL(0x3)
+#define IOCTL_CONFMON_ENABLEEVENTS              AALBUS_CONFIG_MONITOR_IOCTL(0x4)
+
+#else if defined (__AAL_LINUX__)
+
+// Device node name
+#define AALBUS_CONFMON_SERVICE_NAME_STRING           "AAL_IConfigMonitor"
+
+#endif
+
+
+BEGIN_NAMESPACE( AAL )
+
+BEGIN_C_DECLS
+
+//=============================================================================
+// Name: aalbus_configmonitor_message
+// Description: Structure used for sending and receiving messages between the
+//              Resource monitor and the AAL kernel service.
+// Comments:
+//=============================================================================
+struct aalbus_configmonitor_message {
+   // Message header
+   btWSSize                size;
+   krms_cfgUpDate_e        id;                  // Type of update
+   btObjectType            req_handle;          // Request Handle used in response [IN/OUT]
+   struct aal_device_id    device_id;           // Standard device attributes
+   btUnsignedInt           maxOwners;           // Max number of owners
+   btWSSize                attribute_size;      // Length of attributes 
+};
+// Attributes follow the base structure and is a variable length object.  Returns NULL if none
+#define aalbus_configmon_msg_attributes(t,p) ( p->attribute_size != 0 ? ((t)((btByteArray)p+sizeof(struct aalbus_configmonitor_message))) : NULL )
+
+
+END_C_DECLS
+
+END_NAMESPACE( AAL )
+
+#endif //__AALSDK_KERNEL_BUS_ICONFIG_MONITOR_H__
+
diff --git a/drivers/fpga/aal/include/aalsdk/kernel/aalbus_iupdate_config.h b/drivers/fpga/aal/include/aalsdk/kernel/aalbus_iupdate_config.h
new file mode 100644
index 000000000000..509c9e80a512
--- /dev/null
+++ b/drivers/fpga/aal/include/aalsdk/kernel/aalbus_iupdate_config.h
@@ -0,0 +1,260 @@
+//******************************************************************************
+// This  file  is  provided  under  a  dual BSD/GPLv2  license.  When using or
+//         redistributing this file, you may do so under either license.
+//
+//                            GPL LICENSE SUMMARY
+//
+//  Copyright(c) 2014-2017, Intel Corporation.
+//
+//  This program  is  free software;  you  can redistribute it  and/or  modify
+//  it  under  the  terms of  version 2 of  the GNU General Public License  as
+//  published by the Free Software Foundation.
+//
+//  This  program  is distributed  in the  hope that it  will  be useful,  but
+//  WITHOUT   ANY   WARRANTY;   without   even  the   implied   warranty    of
+//  MERCHANTABILITY  or  FITNESS  FOR  A  PARTICULAR  PURPOSE.  See  the   GNU
+//  General Public License for more details.
+//
+//  The  full  GNU  General Public License is  included in  this  distribution
+//  in the file called README.GPLV2-LICENSE.TXT.
+//
+//  Contact Information:
+//  Henry Mitchel, henry.mitchel at intel.com
+//  77 Reed Rd., Hudson, MA  01749
+//
+//                                BSD LICENSE
+//
+//  Copyright(c) 2014-2017, Intel Corporation.
+//
+//  Redistribution and  use  in source  and  binary  forms,  with  or  without
+//  modification,  are   permitted  provided  that  the  following  conditions
+//  are met:
+//
+//    * Redistributions  of  source  code  must  retain  the  above  copyright
+//      notice, this list of conditions and the following disclaimer.
+//    * Redistributions in  binary form  must  reproduce  the  above copyright
+//      notice,  this  list of  conditions  and  the  following disclaimer  in
+//      the   documentation   and/or   other   materials   provided  with  the
+//      distribution.
+//    * Neither   the  name   of  Intel  Corporation  nor  the  names  of  its
+//      contributors  may  be  used  to  endorse  or promote  products derived
+//      from this software without specific prior written permission.
+//
+//  THIS  SOFTWARE  IS  PROVIDED  BY  THE  COPYRIGHT HOLDERS  AND CONTRIBUTORS
+//  "AS IS"  AND  ANY  EXPRESS  OR  IMPLIED  WARRANTIES,  INCLUDING,  BUT  NOT
+//  LIMITED  TO, THE  IMPLIED WARRANTIES OF  MERCHANTABILITY  AND FITNESS  FOR
+//  A  PARTICULAR  PURPOSE  ARE  DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT
+//  OWNER OR CONTRIBUTORS BE LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,
+//  SPECIAL,  EXEMPLARY,  OR  CONSEQUENTIAL   DAMAGES  (INCLUDING,   BUT   NOT
+//  LIMITED  TO,  PROCUREMENT  OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF USE,
+//  DATA,  OR PROFITS;  OR BUSINESS INTERRUPTION)  HOWEVER  CAUSED  AND ON ANY
+//  THEORY  OF  LIABILITY,  WHETHER  IN  CONTRACT,  STRICT LIABILITY,  OR TORT
+//  (INCLUDING  NEGLIGENCE  OR OTHERWISE) ARISING  IN ANY WAY  OUT  OF THE USE
+//  OF  THIS  SOFTWARE, EVEN IF ADVISED  OF  THE  POSSIBILITY  OF SUCH DAMAGE.
+//******************************************************************************
+//****************************************************************************
+//        FILE: aalbus_iupdate_config.h
+//     CREATED: May 13, 2014
+//      AUTHOR: Joseph Grecco, Intel Corporation.
+//
+// PURPOSE: Public definitions for the AAL IUpdateConfig AAL Bus interface
+//          This file defines the Ring 0 and Ring 3 accesses methods
+// HISTORY:
+// WHEN:          WHO:     WHAT:
+//
+//****************************************************************************
+#ifndef __AALSDK_KERNEL_BUS_IUPDATE_CONFIG_H__
+#define __AALSDK_KERNEL_BUS_IUPDATE_CONFIG_H__
+
+#include <aalsdk/kernel/kosal.h>
+#if defined( __AAL_KERNEL__ )
+#include <aalsdk/kernel/aaltypes.h>
+#else
+#include <aalsdk/AALTypes.h>
+#endif
+
+#include <aalsdk/kernel/aaldevice.h>
+
+//
+// Define an Interface Guid to access the proprietary toaster interface.
+// This guid is used to identify a specific interface in IRP_MN_QUERY_INTERFACE
+// handler.
+//
+BEGIN_NAMESPACE( AAL )
+
+BEGIN_C_DECLS
+
+//--------------------------------
+// Interface definitions commands
+//--------------------------------
+#if defined( __AAL_WINDOWS__ )
+
+//==============
+// IUpdateConfig
+//==============
+//
+// Define Interface reference/dereference routines for
+//  Interfaces exported by IRP_MN_QUERY_INTERFACE
+//
+typedef VOID(*PINTERFACE_REFERENCE)(PVOID Context);
+typedef VOID(*PINTERFACE_DEREFERENCE)(PVOID Context);
+
+#if defined( __AAL_KERNEL__ )
+
+// Main methods
+typedef BOOLEAN(*PUPDATECONFIG_ADD_DEVICE)(IN WDFDEVICE, IN   PVOID Record);
+typedef BOOLEAN(*PUPDATECONFIG_REMOVE_DEVICE)(IN WDFDEVICE, IN PVOID Record);
+
+
+//===============================================
+// Interface for changing a device resource state
+//===============================================
+typedef struct _UPDATECONFIG_INTERFACE_STANDARD {
+   INTERFACE                        InterfaceHeader;
+   PUPDATECONFIG_ADD_DEVICE         AddDevice;
+   PUPDATECONFIG_REMOVE_DEVICE      RemoveDevice;
+} UPDATECONFIG_INTERFACE_STANDARD, *PUPDATECONFIG_INTERFACE_STANDARD;
+
+
+// Interface for kernel access
+DEFINE_GUID( GUID_AALBUS_CONFIGMANAGER_QUERY_INTERFACE,
+0x47205c5a, 0x958, 0x4cb0, 0x9e, 0xe, 0xcf, 0xf2, 0x84, 0x71, 0x88, 0x50);
+// {47205C5A-0958-4CB0-9E0E-CFF284718850}
+
+#endif
+
+// Inteface for user mode access
+DEFINE_GUID( GUID_AALBUS_CONFIGMANAGER_DEVINTERFACE,
+   0x868c257d, 0xc827, 0x496b, 0xae, 0x33, 0x13, 0x53, 0x80, 0x24, 0xe, 0x8c);
+// {868C257D-C827-496B-AE33-135380240E8C}
+
+// Device names for user mode access
+#define AALBUS_CONFIGMANAGER_SERVICE_NAME_STRING                L"\\Device\\aalbus\AAL_IConfigManager"
+#define AALBUS_CONFIGMANAGER_SERVICE_SYMBOLIC_NAME_STRING       L"\\DosDevices\\aalbus\AAL_IConfigManager"
+
+// Device Control API Commands
+#define FILE_DEVICE_AALBUS	FILE_DEVICE_BUS_EXTENDER
+
+#define AALBUS_IUPDATE_IOCTL(_index_) \
+    CTL_CODE (FILE_DEVICE_AALBUS, _index_, METHOD_BUFFERED, FILE_READ_DATA)
+
+#define IOCTL_AALBUS_ADD_DEVICE					   AALBUS_IUPDATE_IOCTL(0x0)
+#define IOCTL_AALBUS_REMOVE_DEVICE              AALBUS_IUPDATE_IOCTL(0x1)
+#define IOCTL_AALBUS_UPDATE_DEVICE_STATE        AALBUS_IUPDATE_IOCTL(0x2)
+#define IOCTL_AALBUS_FIND_DEVICE_HANDLE         AALBUS_IUPDATE_IOCTL(0x3)
+
+#elif defined(__AAL_LINUX__)
+#define AALBUS_UPDATECONFIG_SERVICE_NAME_STRING                "AAL_IUpdateConfig"
+
+#endif
+#if 0
+//=============================================================================
+// Name:        aalbus_create_device_attrib
+// Description: Create the Device Attribute object
+// Inputs:      pextended - [in, optional] Pointer to extended attibutes
+//              extSize - Size of ext attributes
+//              ppub_attr - [in, optional] Pointer to public attibutes
+//              attrSize - Size of public attributes
+// Comments: The caller may pass NULL for the attributes pointer.  In this
+//           case the buffer will be allocated but not filled in.
+//=============================================================================
+static inline struct device_attributes  * 
+                                    aalbus_create_device_attrib( btAny pextended, 
+                                                                 btWSSize extSize, 
+                                                                 btAny ppub_attr, 
+                                                                 btWSSize attrSize )
+{
+   struct device_attributes  * pDevAttr = NULL;
+   btWSSize objSize = sizeof( struct device_attributes ) + extSize + attrSize;
+   btByteArray pend = NULL;
+
+   // Allocate the space for the object
+#if defined( __AAL_KERNEL__ )
+   pDevAttr = ( struct device_attributes  *)kosal_kmalloc( objSize );
+#else
+   pDevAttr = (struct device_attributes*)malloc(objSize);
+#endif
+
+   AALBUS_INIT_DEVICE_ATTIBUTES(pDevAttr);
+   pDevAttr->size = objSize;
+
+   // First availble spot is right at the end of the structure
+   pDevAttr->extended_attrib_size = extSize;
+   if((0 != extSize) && (NULL != pextended)){
+      pend = aalbus_config_dev_pextattributes( btByteArray, pDevAttr );
+      memcpy( pend, pextended, extSize );
+      pend += extSize;
+   }
+   
+   // Public attributes follow.
+   pDevAttr->pub_attrib_size = attrSize;
+   if((0 != attrSize) && (NULL != ppub_attr)){
+      pend = aalbus_config_dev_ppubattributes( btByteArray, pDevAttr );
+      memcpy( pend, ppub_attr, attrSize );
+   }
+
+   return pDevAttr;
+}
+
+
+//=============================================================================
+// Name:        IUpdateConfig_Request
+// Type[Dir]:   Request [IN]
+// Command ID:  
+// Description: Used when sending a Create Device request to the AAL Bus
+// Comments:  
+//=============================================================================
+struct IUpdateConfig_Request {
+   btWSSize                               size;           // Size of complete request
+   btUnsignedInt                          action;         // Command dependent
+   struct device_attributes               attributes; 
+};
+
+
+#define AALBUS_INIT_CONFIG_REQUEST(p)  memset( p, 0, sizeof( struct IUpdateConfig_Request))
+
+#if defined( __AAL_KERNEL__ )
+#define aalbus_destroy_config_request(p)  kosal_kfree(p, p->size) 
+#else 
+#define aalbus_destroy_config_request(p) free(p) 
+#endif
+
+//=============================================================================
+// Name:        aalbus_create_config_request
+// Description: Create the Config requestobject
+// Inputs:      
+// Comments: The caller may pass NULL for the attributes pointer.  In this
+//           case the buffer will be allocated but not filled in.
+//=============================================================================
+static inline struct IUpdateConfig_Request  * 
+   aalbus_create_config_request( struct device_attributes  *pattr)
+{
+   struct IUpdateConfig_Request  * pConfigReq = NULL;
+   btWSSize objSize = sizeof( struct IUpdateConfig_Request ) + pattr->size;
+//   btByteArray pend = NULL;
+
+   // Allocate the space for the object
+#if defined( __AAL_KERNEL__ )
+   pConfigReq = ( struct IUpdateConfig_Request  * )kosal_kmalloc( objSize );
+#else
+   pConfigReq = (struct IUpdateConfig_Request  * )malloc( objSize );
+#endif
+
+   if(NULL == pConfigReq){
+      return NULL;
+   }
+   
+   AALBUS_INIT_CONFIG_REQUEST( pConfigReq );
+   memcpy( &pConfigReq->attributes, pattr, pattr->size);
+   pConfigReq->size = objSize;
+   
+   return pConfigReq;
+}
+#endif
+
+END_C_DECLS
+
+END_NAMESPACE( AAL )
+
+#endif // __AALSDK_KERNEL_BUS_IUPDATE_CONFIG_H__
+
diff --git a/drivers/fpga/aal/include/aalsdk/kernel/aaldefs.h b/drivers/fpga/aal/include/aalsdk/kernel/aaldefs.h
new file mode 100644
index 000000000000..dc843fb5ff00
--- /dev/null
+++ b/drivers/fpga/aal/include/aalsdk/kernel/aaldefs.h
@@ -0,0 +1,915 @@
+//******************************************************************************
+// This  file  is  provided  under  a  dual BSD/GPLv2  license.  When using or
+//         redistributing this file, you may do so under either license.
+//
+//                            GPL LICENSE SUMMARY
+//
+//  Copyright(c) 2012-2017, Intel Corporation.
+//
+//  This program  is  free software;  you  can redistribute it  and/or  modify
+//  it  under  the  terms of  version 2 of  the GNU General Public License  as
+//  published by the Free Software Foundation.
+//
+//  This  program  is distributed  in the  hope that it  will  be useful,  but
+//  WITHOUT   ANY   WARRANTY;   without   even  the   implied   warranty    of
+//  MERCHANTABILITY  or  FITNESS  FOR  A  PARTICULAR  PURPOSE.  See  the   GNU
+//  General Public License for more details.
+//
+//  The  full  GNU  General Public License is  included in  this  distribution
+//  in the file called README.GPLV2-LICENSE.TXT.
+//
+//  Contact Information:
+//  Henry Mitchel, henry.mitchel at intel.com
+//  77 Reed Rd., Hudson, MA  01749
+//
+//                                BSD LICENSE
+//
+//  Copyright(c) 2012-2017, Intel Corporation.
+//
+//  Redistribution and  use  in source  and  binary  forms,  with  or  without
+//  modification,  are   permitted  provided  that  the  following  conditions
+//  are met:
+//
+//    * Redistributions  of  source  code  must  retain  the  above  copyright
+//      notice, this list of conditions and the following disclaimer.
+//    * Redistributions in  binary form  must  reproduce  the  above copyright
+//      notice,  this  list of  conditions  and  the  following disclaimer  in
+//      the   documentation   and/or   other   materials   provided  with  the
+//      distribution.
+//    * Neither   the  name   of  Intel  Corporation  nor  the  names  of  its
+//      contributors  may  be  used  to  endorse  or promote  products derived
+//      from this software without specific prior written permission.
+//
+//  THIS  SOFTWARE  IS  PROVIDED  BY  THE  COPYRIGHT HOLDERS  AND CONTRIBUTORS
+//  "AS IS"  AND  ANY  EXPRESS  OR  IMPLIED  WARRANTIES,  INCLUDING,  BUT  NOT
+//  LIMITED  TO, THE  IMPLIED WARRANTIES OF  MERCHANTABILITY  AND FITNESS  FOR
+//  A  PARTICULAR  PURPOSE  ARE  DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT
+//  OWNER OR CONTRIBUTORS BE LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,
+//  SPECIAL,  EXEMPLARY,  OR  CONSEQUENTIAL   DAMAGES  (INCLUDING,   BUT   NOT
+//  LIMITED  TO,  PROCUREMENT  OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF USE,
+//  DATA,  OR PROFITS;  OR BUSINESS INTERRUPTION)  HOWEVER  CAUSED  AND ON ANY
+//  THEORY  OF  LIABILITY,  WHETHER  IN  CONTRACT,  STRICT LIABILITY,  OR TORT
+//  (INCLUDING  NEGLIGENCE  OR OTHERWISE) ARISING  IN ANY WAY  OUT  OF THE USE
+//  OF  THIS  SOFTWARE, EVEN IF ADVISED  OF  THE  POSSIBILITY  OF SUCH DAMAGE.
+//******************************************************************************
+//****************************************************************************
+//        FILE: aaldefs.h
+//     CREATED: 04/04/2012
+//      AUTHOR: Tim Whisonant
+//
+// PURPOSE:  This file contains macro definitions for the
+//           Accelerator Abstraction Layer (AAL)
+//
+// HISTORY:
+// COMMENTS:
+// WHEN:          WHO:     WHAT:
+// 04/04/2012     TSW      Initial version
+// 10/24/2012     TSW      Cleanup for faplib
+//****************************************************************************
+#ifndef __AALSDK_KERNEL_AALDEFS_H__
+#define __AALSDK_KERNEL_AALDEFS_H__
+
+// Compile decisions based on C vs C++.
+#ifdef __cplusplus
+# ifndef BEGIN_C_DECLS
+#    define BEGIN_C_DECLS extern "C" {
+# endif // BEGIN_C_DECLS
+# ifndef END_C_DECLS
+#    define END_C_DECLS   }
+# endif // END_C_DECLS
+# ifndef BEGIN_NAMESPACE
+#    define BEGIN_NAMESPACE(__n) namespace __n {
+# endif // BEGIN_NAMESPACE
+# ifndef END_NAMESPACE
+#    define END_NAMESPACE(__n)   }
+# endif // END_NAMESPACE
+# ifndef USING_NAMESPACE
+#    define USING_NAMESPACE(__n) using namespace __n ;
+# endif // USING_NAMESPACE
+# ifndef NULL
+#    define NULL 0
+# endif // NULL
+#else
+# ifndef BEGIN_C_DECLS
+#    define BEGIN_C_DECLS
+# endif // BEGIN_C_DECLS
+# ifndef END_C_DECLS
+#    define END_C_DECLS
+# endif // END_C_DECLS
+# ifndef BEGIN_NAMESPACE
+#    define BEGIN_NAMESPACE(__n)
+# endif // BEGIN_NAMESPACE
+# ifndef END_NAMESPACE
+#    define END_NAMESPACE(__n)
+# endif // END_NAMESPACE
+# ifndef USING_NAMESPACE
+#    define USING_NAMESPACE(__n)
+# endif // USING_NAMESPACE
+# ifndef NULL
+#    define NULL ((void *)0)
+# endif // NULL
+#endif // __cplusplus
+
+
+// Compile decisions based on target OS.
+#ifndef __AAL_OS_DEFINED
+#define __AAL_OS_DEFINED 1
+# if defined( _WIN32 ) || defined( _WIN64 )
+// Windows
+#    ifdef __AAL_WINDOWS__
+#       undef __AAL_WINDOWS__
+#    endif // __AAL_WINDOWS__
+#    define __AAL_WINDOWS__ 1
+#    ifdef __AAL_ANDROID__
+#       undef __AAL_ANDROID__
+#    endif // __AAL_ANDROID__
+#    ifdef __AAL_LINUX__
+#       undef __AAL_LINUX__
+#    endif // __AAL_LINUX__
+#    ifdef __AAL_APPLE__
+#       undef __AAL_APPLE__
+#    endif // __AAL_APPLE__
+#    ifdef __AAL_UNKNOWN_OS__
+#       undef __AAL_UNKNOWN_OS__
+#    endif // __AAL_UNKNOWN_OS__
+#    if !defined( __cplusplus ) && !defined( inline )
+#       define inline _inline
+#    endif // inline
+#    ifndef __iomem
+#       define __iomem
+#    endif // __iomem
+
+// TODO: Android
+
+# elif defined( __linux__ )
+#    ifdef __AAL_WINDOWS__
+#       undef __AAL_WINDOWS__
+#    endif // __AAL_WINDOWS__
+#    ifdef __AAL_ANDROID__
+#       undef __AAL_ANDROID__
+#    endif // __AAL_ANDROID__
+#    ifdef __AAL_LINUX__
+#       undef __AAL_LINUX__
+#    endif // __AAL_LINUX__
+#    define __AAL_LINUX__ 1
+#    ifdef __AAL_APPLE__
+#       undef __AAL_APPLE__
+#    endif // __AAL_APPLE__
+#    ifdef __AAL_UNKNOWN_OS__
+#       undef __AAL_UNKNOWN_OS__
+#    endif // __AAL_UNKNOWN_OS__
+#    define memcpy_s(d,l1,s,l2) memcpy(d,s,l1)
+# elif defined( __APPLE__ )
+// Apple
+#    ifdef __AAL_WINDOWS__
+#       undef __AAL_WINDOWS__
+#    endif // __AAL_WINDOWS__
+#    ifdef __AAL_ANDROID__
+#       undef __AAL_ANDROID__
+#    endif // __AAL_ANDROID__
+#    ifdef __AAL_LINUX__
+#       undef __AAL_LINUX__
+#    endif // __AAL_LINUX__
+#    ifdef __AAL_APPLE__
+#       undef __AAL_APPLE__
+#    endif // __AAL_APPLE__
+#    define __AAL_APPLE__ 1
+#    ifdef __AAL_UNKNOWN_OS__
+#       undef __AAL_UNKNOWN_OS__
+#    endif // __AAL_UNKNOWN_OS__
+# else
+// Unknown
+#    ifdef __AAL_WINDOWS__
+#       undef __AAL_WINDOWS__
+#    endif // __AAL_WINDOWS__
+#    ifdef __AAL_ANDROID__
+#       undef __AAL_ANDROID__
+#    endif // __AAL_ANDROID__
+#    ifdef __AAL_LINUX__
+#       undef __AAL_LINUX__
+#    endif // __AAL_LINUX__
+#    ifdef __AAL_APPLE__
+#       undef __AAL_APPLE__
+#    endif // __AAL_APPLE__
+#    ifdef __AAL_UNKNOWN_OS__
+#       undef __AAL_UNKNOWN_OS__
+#    endif // __AAL_UNKNOWN_OS__
+#    define __AAL_UNKNOWN_OS__ 1
+# endif // target OS
+#endif // __AAL_OS_DEFINED
+
+
+#ifndef __AAL_USER_VS_KERNEL_DEFINED
+#define __AAL_USER_VS_KERNEL_DEFINED 1
+// Compile decisions based on user space vs. kernel space
+# if defined( __AAL_WINDOWS__ ) && defined( __KERNEL__ )
+#    if !defined( __AAL_KERNEL__ ) || ( 0 == __AAL_KERNEL__ )
+#       ifdef __AAL_KERNEL__
+#          undef __AAL_KERNEL__
+#       endif
+#       define __AAL_KERNEL__ 1
+#    endif // __AAL_KERNEL__
+#    if defined( __AAL_USER__ )
+#       undef __AAL_USER__
+#    endif // __AAL_USER__
+
+// TODO: Android
+
+# elif defined( __AAL_LINUX__ ) && defined( __KERNEL__ )
+#    if !defined( __AAL_KERNEL__ ) || ( 0 == __AAL_KERNEL__ )
+#       ifdef __AAL_KERNEL__
+#          undef __AAL_KERNEL__
+#       endif
+#       define __AAL_KERNEL__ 1
+#    endif // __AAL_KERNEL__
+#    if defined( __AAL_USER__ )
+#       undef __AAL_USER__
+#    endif // __AAL_USER__
+# elif defined( __AAL_APPLE__ ) && defined( KERNEL )
+#    if !defined( __AAL_KERNEL__ ) || ( 0 == __AAL_KERNEL__ )
+#       ifdef __AAL_KERNEL__
+#          undef __AAL_KERNEL__
+#       endif
+#       define __AAL_KERNEL__ 1
+#    endif // __AAL_KERNEL__
+#    if defined( __AAL_USER__ )
+#       undef __AAL_USER__
+#    endif // __AAL_USER__
+# else
+// Assume user (non-kernel) mode
+#    if !defined( __AAL_USER__ ) || ( 0 == __AAL_USER__ )
+#       ifdef __AAL_USER__
+#          undef __AAL_USER__
+#       endif
+#       define __AAL_USER__ 1
+#    endif // __AAL_USER__
+#    if defined( __AAL_KERNEL__ )
+#       undef __AAL_KERNEL__
+#    endif // __AAL_KERNEL__
+# endif // user vs. kernel
+#endif // __AAL_USER_VS_KERNEL_DEFINED
+
+
+// dll magic for Windows dll's
+#if defined( __AAL_USER__ ) && defined( __AAL_WINDOWS__ )
+// The following ifdef block is the standard way of creating macros which make exporting
+// from a DLL simpler. All files within this DLL are compiled with the XYZ_EXPORTS
+// symbol defined on the command line. this symbol should not be defined on any project
+// that uses this DLL. This way any other project whose source files include this file see
+// OSAL_API functions as being imported from a DLL, wheras this DLL sees symbols
+// defined with this macro as being exported.
+# ifdef OSAL_EXPORTS
+#    define OSAL_API                      __declspec(dllexport)
+# else
+#    define OSAL_API                      __declspec(dllimport)
+# endif // OSAL_EXPORTS
+# ifdef AALRUNTIME_EXPORTS
+#    define AALRUNTIME_API                __declspec(dllexport)
+# else
+#    define AALRUNTIME_API                __declspec(dllimport)
+# endif // AALRUNTIME_EXPORTS
+# ifdef AASLIB_EXPORTS
+#    define AASLIB_API                    __declspec(dllexport)
+# else
+#    define AASLIB_API                    __declspec(dllimport)
+# endif // AASLIB_EXPORTS
+# ifdef AIASERVICE_EXPORTS
+#    define AIASERVICE_API                __declspec(dllexport)
+# else
+#    define AIASERVICE_API                __declspec(dllimport)
+# endif // AIASERVICE_EXPORTS
+# ifdef UAIA_EXPORTS
+#    define UAIA_API                      __declspec(dllexport)
+# else
+#    define UAIA_API                      __declspec(dllimport)
+# endif // UAIA_EXPORTS
+# ifdef AALRESMGR_EXPORTS
+#     define AALRESOURCEMANAGERCLIENT_API __declspec(dllexport)
+#     define AALRESOURCEMANAGER_API       __declspec(dllexport)
+#     define RESMGR_SERVICE_API           __declspec(dllexport)
+# else
+#     define AALRESOURCEMANAGERCLIENT_API __declspec(dllimport)
+#     define AALRESOURCEMANAGER_API       __declspec(dllimport)
+#     define RESMGR_SERVICE_API           __declspec(dllimport)
+# endif // Resource Manager
+# ifdef RRM_EXPORTS
+#    define RRM_API                       __declspec(dllexport)
+# else
+#    define RRM_API                       __declspec(dllimport)
+# endif // RRM_EXPORTS
+# ifdef RRMBROKER_EXPORTS
+#    define RRMBROKER_API                 __declspec(dllexport)
+# else
+#    define RRMBROKER_API                 __declspec(dllimport)
+# endif // RRMBROKER_EXPORTS
+#else
+# define __declspec(x)
+// OSAL
+# define OSAL_API                         __declspec(0)
+// AALRUNTIME
+# define AALRUNTIME_API                   __declspec(0)
+// AASLib
+# define AASLIB_API                       __declspec(0)
+// AIAService
+# define AIASERVICE_API                   __declspec(0)
+// uAIA
+# define UAIA_API                         __declspec(0)
+// Resource Manager Client
+# define AALRESOURCEMANAGERCLIENT_API     __declspec(0)
+// Resource Manager
+# define AALRESOURCEMANAGER_API           __declspec(0)
+# define RESMGR_SERVICE_API               __declspec(0)
+# define RRM_API                          __declspec(0)
+# define RRMBROKER_API                    __declspec(0)
+#endif // OS
+
+
+// Full path to current source file.
+#ifndef __AAL_FULL_FILE__
+# define __AAL_FULL_FILE__     __FILE__
+#endif // __AAL_FULL_FILE__
+
+
+// Compile decisions based on toolchain.
+#if defined( __INTEL_COMPILER )
+// Intel C/C++
+# ifndef __AAL_FUNC__
+#    define __AAL_FUNC__       __func__
+# endif // __AAL_FUNC__
+# ifndef __AAL_FUNCSIG__
+#    define __AAL_FUNCSIG__    __func__
+# endif // __AAL_FUNCSIG__
+# ifndef __AAL_SHORT_FILE__
+#    define __AAL_SHORT_FILE__ __BASE_FILE__
+# endif // __AAL_SHORT_FILE__
+#elif defined ( _MSC_VER )
+// MS C/C++
+# ifndef __AAL_FUNC__
+#    define __AAL_FUNC__       __FUNCTION__
+# endif // __AAL_FUNC__
+# ifndef __AAL_FUNCSIG__
+#    define __AAL_FUNCSIG__    __FUNCSIG__
+# endif // __AAL_FUNCSIG__
+# ifndef __AAL_SHORT_FILE__
+static inline
+const char * AALWinShortFile(const char *f) {
+   const char *p = f;
+   while ( *p ) { ++p; }
+   while ( (p > f)  &&
+           ('/'  != *p) &&
+           ('\\' != *p) ) { --p; }
+   if ( p > f ) { ++p; }
+   return p;
+}
+#    define __AAL_SHORT_FILE__ AALWinShortFile( __FILE__ )
+# endif // __AAL_SHORT_FILE__
+#elif defined( __GNUC__ ) && !defined( __cplusplus )
+// gcc
+// __func__ is part of the C99 standard.
+# ifndef __AAL_FUNC__
+#    define __AAL_FUNC__       __func__
+# endif // __AAL_FUNC__
+// For C, __PRETTY_FUNCTION__ is an alias for __func__.
+# ifndef __AAL_FUNCSIG__
+#    define __AAL_FUNCSIG__    __PRETTY_FUNCTION__
+# endif // __AAL_FUNCSIG__
+# ifndef __AAL_SHORT_FILE__
+#define __AAL_SHORT_FILE__         \
+({ const char *file = __FILE__;    \
+   const char *p    = file;        \
+   while ( *p ) { ++p; }           \
+   while ( (p > file)  &&          \
+           ('/'  != *p) &&         \
+           ('\\' != *p) ) { --p; } \
+   if ( p > file ) { ++p; }        \
+   p;                              \
+})
+# endif // __AAL_SHORT_FILE__
+#elif defined ( __GNUG__ )
+// g++
+# ifndef __AAL_FUNC__
+#    define __AAL_FUNC__       __func__
+# endif // __AAL_FUNC__
+// For C++, __PRETTY_FUNCTION__ expands to the function signature.
+# ifndef __AAL_FUNCSIG__
+#    define __AAL_FUNCSIG__    __PRETTY_FUNCTION__
+# endif // __AAL_FUNCSIG__
+# ifndef __AAL_SHORT_FILE__
+#define __AAL_SHORT_FILE__         \
+({ const char *file = __FILE__;    \
+   const char *p    = file;        \
+   while ( *p ) { ++p; }           \
+   while ( (p > file)  &&          \
+           ('/'  != *p) &&         \
+           ('\\' != *p) ) { --p; } \
+   if ( p > file ) { ++p; }        \
+   p;                              \
+})
+# endif // __AAL_SHORT_FILE__
+#endif // toolchain
+
+
+#if defined( __AAL_WINDOWS__ )
+# if defined( __AAL_KERNEL__ )
+#    include <ntddk.h>
+#    ifndef __cplusplus
+#       ifndef true
+#          define true TRUE
+#       endif // true
+#       ifndef false
+#          define false FALSE
+#       endif // false
+#    endif // __cplusplus
+#    include <ntdef.h> // Unicode (defines __TEXT)
+#    ifdef _T
+#       undef _T
+#    endif // _T
+#    define _T(__str_literal) __TEXT(__str_literal)
+# else
+#    ifndef WIN32_LEAN_AND_MEAN
+#       define WIN32_LEAN_AND_MEAN 1
+#    endif // WIN32_LEAN_AND_MEAN
+#    include <windows.h>
+#    include <winsock2.h>
+#    ifndef __cplusplus
+#       ifndef true
+#          define true TRUE
+#       endif // true
+#       ifndef false
+#          define false FALSE
+#       endif // false
+#    endif // __cplusplus
+#    include <tchar.h> // Unicode (defines _T)
+# endif // user vs. kernel
+#elif defined( __AAL_LINUX__ )
+# if defined( __AAL_KERNEL__ )
+#    include <linux/version.h>
+#    include <linux/kernel.h>
+#    include <linux/stddef.h> // true, false
+#    include <linux/module.h>
+#    include <linux/moduleparam.h>
+#    include <linux/init.h>
+#    include <linux/types.h>
+#    include <linux/mm.h>
+#    include <linux/highmem.h>
+#    include <linux/fs.h>
+#    include <linux/delay.h>
+#    include <linux/wait.h>
+#    include <linux/sched.h>
+#    include <linux/poll.h>
+#    include <linux/pci.h>
+#    include <linux/aer.h>
+# else
+#    ifndef __cplusplus
+#       ifndef true
+#          define true 1
+#       endif // true
+#       ifndef false
+#          define false 0
+#       endif // false
+#    else
+#       include <memory.h>
+#    endif // __cplusplus
+#    include <sys/time.h> // gettimeofday, struct timeval, struct timespec.
+#    include <unistd.h>   // close
+#    include <sys/types.h>
+#    include <sys/stat.h>
+#    include <fcntl.h>
+#    include <limits.h>
+#    include <sys/ioctl.h>
+#    include <sys/socket.h>
+#    include <netinet/in.h>
+#    include <netdb.h>
+#    include <poll.h>
+#    include <sys/mman.h>
+#    include <pthread.h>
+# endif // user vs. kernel
+# ifdef _T
+#    undef _T
+# endif // _T
+# ifdef _UNICODE
+#    define _T(__str_literal) L##__str_literal
+# else
+#    define _T(__str_literal) __str_literal
+# endif // _UNICODE
+#endif // OS
+
+
+#if !defined(ENABLE_ASSERT) || (0 == ENABLE_ASSERT)
+# ifndef ENABLE_ASSERT
+#    define ENABLE_ASSERT 0
+# endif // ENABLE_ASSERT
+#else
+# undef ENABLE_ASSERT
+# define ENABLE_ASSERT 1
+#endif // ENABLE_ASSERT
+
+
+#ifndef __CASSERT_DEFINED
+#define __CASSERT_DEFINED 1
+# if (0 == ENABLE_ASSERT)
+#    define CASSERT(__expr) extern char __CASSERT_DISABLED__[1]
+# else
+     BEGIN_C_DECLS
+#    define CASSERT(__expr) extern char __CASSERT_FAILED__[!(__expr) ? -1 : 1]
+     END_C_DECLS
+# endif // ENABLE_ASSERT
+#endif // __CASSERT_DEFINED
+
+
+#if defined( __AAL_USER__ )
+# define __user
+# include <stdlib.h>
+# include <string.h>
+# include <errno.h>
+# ifdef __cplusplus
+#    include <algorithm>
+#    include <ctime>
+#    include <fstream>
+#    include <iostream>
+#    include <iomanip>
+#    include <list>
+#    include <map>
+#    include <queue>
+#    include <sstream>
+#    include <string>
+#    include <vector>
+# else
+#    include <stdio.h>
+# endif // __cplusplus
+# ifndef __AAL_USER_ASSERT_DEFINED
+# define __AAL_USER_ASSERT_DEFINED 1
+#    ifdef ASSERT_HERE
+#       undef ASSERT_HERE
+#    endif // ASSERT_HERE
+#    ifdef ASSERT
+#       undef ASSERT
+#    endif // ASSERT
+#    if (0 == ENABLE_ASSERT)
+#       define ASSERT_HERE(__file, __line, __fn, __expr) do{}while(0)
+#       define ASSERT(__expr) do{}while(0)
+#       ifdef __cplusplus
+#          define __ASSERT_HERE_PROTO_VOID
+#       else
+#          define __ASSERT_HERE_PROTO_VOID void
+#       endif // __cplusplus
+#       define __ASSERT_HERE_PROTO
+#       define __ASSERT_HERE_ARGS_VOID
+#       define __ASSERT_HERE_ARGS
+#       define __ASSERT_HERE_IN_FN(__expr) do{}while(0)
+#    else
+static inline
+void
+AALUserAssertFail(const char *__file, int __line, const char *__fn, const char *__expr)
+{
+#ifdef __cplusplus
+   std::cerr << "AAL ASSERT( " << __expr << " ) FAILED " <<
+                __fn << "():" << __file << ":" << __line << std::endl;
+#else
+   fprintf(stderr, "AAL ASSERT( %s ) FAILED %s():%s:%d\n",
+           __expr, __fn, __file, __line);
+#endif // __cplusplus
+}
+
+#       define ASSERT_HERE(__file, __line, __fn, __expr) \
+do                                                       \
+{                                                        \
+   if ( !(__expr) ) {                                    \
+      AALUserAssertFail(__file, __line, __fn, #__expr);  \
+   }                                                     \
+}while(0)
+
+#       define ASSERT(__expr)                                                 \
+do                                                                            \
+{                                                                             \
+   if ( !(__expr) ) {                                                         \
+      AALUserAssertFail(__AAL_SHORT_FILE__, __LINE__, __AAL_FUNC__, #__expr); \
+   }                                                                          \
+}while(0)
+
+#       define __ASSERT_HERE_PROTO_VOID    const char *__file, int __line, const char *__fn
+#       define __ASSERT_HERE_PROTO         const char *__file, int __line, const char *__fn,
+#       define __ASSERT_HERE_ARGS_VOID     __AAL_SHORT_FILE__, __LINE__, __AAL_FUNC__
+#       define __ASSERT_HERE_ARGS          __AAL_SHORT_FILE__, __LINE__, __AAL_FUNC__,
+#       define __ASSERT_HERE_IN_FN(__expr) ASSERT_HERE(__file, __line, __fn, __expr)
+#    endif // ENABLE_ASSERT
+# endif // __AAL_USER_ASSERT_DEFINED
+#endif // __AAL_USER__
+
+
+#if defined( __AAL_KERNEL__ )
+# ifndef __AAL_KERNEL_ASSERT_DEFINED
+# define __AAL_KERNEL_ASSERT_DEFINED 1
+#    ifdef ASSERT_HERE
+#       undef ASSERT_HERE
+#    endif // ASSERT_HERE
+#    ifdef ASSERT
+#       undef ASSERT
+#    endif // ASSERT
+#    if (0 == ENABLE_ASSERT)
+#       define ASSERT_HERE(__file, __line, __fn, __expr) do{}while(0)
+#       define ASSERT(__expr) do{}while(0)
+#       ifdef __cplusplus
+#          define __ASSERT_HERE_PROTO_VOID
+#       else
+#          define __ASSERT_HERE_PROTO_VOID void
+#       endif // __cplusplus
+#       define __ASSERT_HERE_PROTO
+#       define __ASSERT_HERE_ARGS_VOID
+#       define __ASSERT_HERE_ARGS
+#       define __ASSERT_HERE_IN_FN(__expr) do{}while(0)
+#    elif defined( __AAL_WINDOWS__ )
+#       define ASSERT_HERE(__file, __line, __fn, __expr)                 \
+do                                                                       \
+{                                                                        \
+   if ( !(__expr) ) {                                                    \
+      DbgPrint("%s(%d)%s(): Soft assertion failed\n   Expression: %s\n", \
+                  __file, __line, __fn, #__expr);                        \
+   }                                                                     \
+}while(0)
+#       define ASSERT(__expr) RTL_SOFT_ASSERT(__expr)
+#    elif defined( __AAL_LINUX__ )
+static inline
+void
+AALKernelAssertFail(const char *__file, int __line, const char *__fn, const char *__expr)
+{
+   printk(KERN_EMERG "A:[%d] AAL ASSERT( %s ) FAILED %s():%s:%d\n",
+          current->tgid, __expr, __fn, __file, __line);
+}
+
+#       define ASSERT_HERE(__file, __line, __fn, __expr)  \
+do                                                        \
+{                                                         \
+   if ( !(__expr) ) {                                     \
+      AALKernelAssertFail(__file, __line, __fn, #__expr); \
+   }                                                      \
+}while(0)
+
+#       define ASSERT(__expr)                                                   \
+do                                                                              \
+{                                                                               \
+   if ( !(__expr) ) {                                                           \
+      AALKernelAssertFail(__AAL_SHORT_FILE__, __LINE__, __AAL_FUNC__, #__expr); \
+   }                                                                            \
+}while(0)
+
+#    endif // ENABLE_ASSERT && __AAL_LINUX__
+#    if (1 == ENABLE_ASSERT)
+#       define __ASSERT_HERE_PROTO_VOID    const char *__file, int __line, const char *__fn
+#       define __ASSERT_HERE_PROTO         const char *__file, int __line, const char *__fn,
+#       define __ASSERT_HERE_ARGS_VOID     __AAL_SHORT_FILE__, __LINE__, __AAL_FUNC__
+#       define __ASSERT_HERE_ARGS          __AAL_SHORT_FILE__, __LINE__, __AAL_FUNC__,
+#       define __ASSERT_HERE_IN_FN(__expr) ASSERT_HERE(__file, __line, __fn, __expr)
+#    endif // ENABLE_ASSERT
+# endif // __AAL_KERNEL_ASSERT_DEFINED
+#endif // __AAL_KERNEL__
+
+
+// We let DEBUG, _DEBUG, and NDEBUG override ENABLE_DEBUG here, in order to satisfy
+//  external projects that rely on these.
+#if defined(DEBUG) || defined(_DEBUG)
+# if defined(NDEBUG)
+#    error Both (DEBUG or _DEBUG) and NDEBUG are defined.
+# endif // NDEBUG
+# if defined(ENABLE_DEBUG)
+// override ENABLE_DEBUG
+#    undef  ENABLE_DEBUG
+#    define ENABLE_DEBUG 1
+# else
+#    define ENABLE_DEBUG 1
+# endif // ENABLE_DEBUG
+#elif defined(NDEBUG)
+# if defined(ENABLE_DEBUG)
+// override ENABLE_DEBUG
+#    undef  ENABLE_DEBUG
+#    define ENABLE_DEBUG 0
+# else
+#    define ENABLE_DEBUG 0
+# endif // ENABLE_DEBUG
+#else
+// None of DEBUG, _DEBUG, NDEBUG are defined - allow ENABLE_DEBUG to control their definition.
+# if defined(ENABLE_DEBUG) && (0 == ENABLE_DEBUG)
+#    define NDEBUG 1
+# elif defined(ENABLE_DEBUG)
+#    define DEBUG 1
+#    define _DEBUG 1
+#    undef  ENABLE_DEBUG
+#    define ENABLE_DEBUG 1
+# else
+#    define NDEBUG 1
+#    define ENABLE_DEBUG 0
+# endif // ENABLE_DEBUG
+#endif // DEBUG || _DEBUG
+
+
+#define ENABLE_CANARIES (0 && (1 == ENABLE_DEBUG))
+# if (1 == ENABLE_CANARIES)
+// struct X
+// {
+// #if (1 == ENABLE_CANARIES)
+// #define _struct_X_canary_size              11
+// #define _struct_X_start_canary_const       "s:struct X"
+// #define _struct_X_define_start_canary      char _struct_X_start_canary[_struct_X_canary_size]
+// #define _struct_X_end_canary_const         "e:struct X"
+// #define _struct_X_define_end_canary        char _struct_X_end_canary[_struct_X_canary_size]
+// #define _struct_X_start_canary_initializer { 's', ':', 's', 't', 'r', 'u', 'c', 't', ' ', 'X', 0 },
+// #define _struct_X_end_canary_initializer   { 'e', ':', 's', 't', 'r', 'u', 'c', 't', ' ', 'X', 0 }
+//    _struct_X_define_start_canary;
+// #else
+// #define _struct_X_start_canary_initializer
+// #define _struct_X_end_canary_initializer
+// #endif // ENABLE_CANARIES
+//
+// (normal contents of struct X here)
+//
+// #if (1 == ENABLE_CANARIES)
+//    _struct_X_define_end_canary;
+// #endif // ENABLE_CANARIES
+// } x = { _struct_X_start_canary_initializer (normal initializers here), _struct_X_end_canary_initializer };
+//
+
+// strncpy((ptr)->_##type##_start_canary, _##type##_start_canary_const, _##type##_canary_size);
+// ex)
+//   canary_start_init(struct_X, &x);
+#define canary_start_init(type, ptr)                       \
+do                                                         \
+{  const char *_canary = _##type##_start_canary_const;     \
+   char       *_p      = (ptr)->_##type##_start_canary;    \
+   char       *_end    = (_p + _##type##_canary_size) - 1; \
+   while ( *_canary && (_p < _end) ) {                     \
+      *_p = *_canary; ++_p; ++_canary;                     \
+   }                                                       \
+   *_p = 0;                                                \
+}while(0)
+
+// strncpy((ptr)->_##type##_end_canary, _##type##_end_canary_const, _##type##_canary_size);
+// ex)
+//   canary_end_init(struct_X, &x);
+#define canary_end_init(type, ptr)                         \
+do                                                         \
+{  const char *_canary = _##type##_end_canary_const;       \
+   char       *_p      = (ptr)->_##type##_end_canary;      \
+   char       *_end    = (_p + _##type##_canary_size) - 1; \
+   while ( *_canary && (_p < _end) ) {                     \
+      *_p = *_canary; ++_p; ++_canary;                     \
+   }                                                       \
+   *_p = 0;                                                \
+}while(0)
+
+// ex)
+//   canaries_init(struct_X, &x);
+#define canaries_init(type, ptr) \
+do                               \
+{                                \
+   canary_start_init(type, ptr); \
+   canary_end_init(type, ptr);   \
+}while(0)
+
+
+// memset((ptr)->_##type##_start_canary, 0, _##type##_canary_size);
+// ex)
+//   canary_start_clear(struct_X, &x);
+#define canary_start_clear(type, ptr)          \
+do                                             \
+{  char *_p   = (ptr)->_##type##_start_canary; \
+   char *_end = _p + _##type##_canary_size;    \
+   while ( _p < _end ) {                       \
+      *_p = 0; ++_p;                           \
+   }                                           \
+}while(0)
+
+// memset((ptr)->_##type##_end_canary, 0, _##type##_canary_size);
+// ex)
+//   canary_end_clear(struct_X, &x);
+#define canary_end_clear(type, ptr)          \
+do                                           \
+{  char *_p   = (ptr)->_##type##_end_canary; \
+   char *_end = _p + _##type##_canary_size;  \
+   while ( _p < _end ) {                     \
+      *_p = 0; ++_p;                         \
+   }                                         \
+}while(0)
+
+// ex)
+//   canaries_clear(struct_X, &x);
+#define canaries_clear(type, ptr) \
+do                                \
+{                                 \
+   canary_start_clear(type, ptr); \
+   canary_end_clear(type, ptr);   \
+}while(0)
+
+
+// bool_res = (0 == strncmp(_##type##_start_canary_const, (ptr)->_##type##_start_canary, _##type##_canary_size));
+// ex)
+//   btBool valid;
+//   canary_start_is_valid(struct_X, &x, valid);
+//   if ( valid ) ...
+#define canary_start_is_valid(type, ptr, bool_res)      \
+do                                                      \
+{  const char *_canary = _##type##_start_canary_const;  \
+   char       *_p      = (ptr)->_##type##_start_canary; \
+   char       *_end    = _p + _##type##_canary_size;    \
+   unsigned char _valid = 1;                            \
+   while ( _p < _end ) { /* verify 0-terminator, too */ \
+      if ( *_p != *_canary ) {                          \
+         _valid = 0;                                    \
+         break;                                         \
+      }                                                 \
+      ++_p; ++_canary;                                  \
+   }                                                    \
+   bool_res = _valid;                                   \
+}while(0)
+
+// bool_res = (0 == strncmp(_##type##_end_canary_const, (ptr)->_##type##_end_canary, _##type##_canary_size));
+//   btBool valid;
+//   canary_end_is_valid(struct_X, &x, valid);
+//   if ( valid ) ...
+#define canary_end_is_valid(type, ptr, bool_res)        \
+do                                                      \
+{  const char *_canary = _##type##_end_canary_const;    \
+   char       *_p      = (ptr)->_##type##_end_canary;   \
+   char       *_end    = _p + _##type##_canary_size;    \
+   unsigned char _valid = 1;                            \
+   while ( _p < _end ) { /* verify 0-terminator, too */ \
+      if ( *_p != *_canary ) {                          \
+         _valid = 0;                                    \
+         break;                                         \
+      }                                                 \
+      ++_p; ++_canary;                                  \
+   }                                                    \
+   bool_res = _valid;                                   \
+}while(0)
+
+//   btBool valid;
+//   canaries_are_valid(struct_X, &x, valid);
+//   if ( valid ) ...
+#define canaries_are_valid(type, ptr, bool_res)    \
+do                                                 \
+{  unsigned char _start_valid;                     \
+   unsigned char _end_valid;                       \
+   canary_start_is_valid(type, ptr, _start_valid); \
+   canary_end_is_valid(type, ptr, _end_valid);     \
+   bool_res = (_start_valid && _end_valid);        \
+}while(0)
+
+#else
+
+# define canary_start_init(type, ptr)
+# define canary_end_init(type, ptr)
+# define canaries_init(type, ptr)
+
+# define canary_start_clear(type, ptr)
+# define canary_end_clear(type, ptr)
+# define canaries_clear(type, ptr)
+
+# define canary_start_is_valid(type, ptr, bool_res)
+# define canary_end_is_valid(type, ptr, bool_res)
+# define canaries_are_valid(type, ptr, bool_res)
+#endif // ENABLE_CANARIES
+
+
+// Must always evaluate to 0.
+#ifdef DEPRECATED
+# undef DEPRECATED
+#endif // DEPRECATED
+#define DEPRECATED 0
+
+
+// Set 1+ flags
+#ifndef flag_setf
+# define flag_setf(flags, f)     ( (flags) |= (f) )
+#endif // flag_setf
+// Clear 1+ flags
+#ifndef flag_clrf
+# define flag_clrf(flags, f)     ( (flags) &= ~(f) )
+#endif // flag_clrf
+// 1+ flags from f are set?
+#ifndef flag_is_set
+# define flag_is_set(flags, f)   ( (flags) & (f) )
+#endif // flag_is_set
+// 1+ flags from f are clear?
+#ifndef flag_is_clr
+# define flag_is_clr(flags, f)   ( ((flags) & (f)) != (f) )
+#endif // flag_is_clr
+// All flags from f are set?
+#ifndef flags_are_set
+# define flags_are_set(flags, f) ( ((flags) & (f)) == (f) )
+#endif // flags_are_set
+// All flags from f are clear?
+#ifndef flags_are_clr
+# define flags_are_clr(flags, f) ( ((flags) & (f)) == 0 )
+#endif // flags_are_clr
+
+
+#if defined( __AAL_USER__ )
+# ifndef __NO_PRAGMA_BUILD_MSG__
+#    define BUILD_MSG(s) __FILE__ " COMMENT: " #s
+# else
+#    define BUILD_MSG(s)
+#    define message
+# endif // __NO_PRAGMA_BUILD_MSG__
+#endif // __AAL_USER__
+
+#endif // __AALSDK_KERNEL_AALDEFS_H__
+
diff --git a/drivers/fpga/aal/include/aalsdk/kernel/aaldevice.h b/drivers/fpga/aal/include/aalsdk/kernel/aaldevice.h
new file mode 100644
index 000000000000..162dc0e14174
--- /dev/null
+++ b/drivers/fpga/aal/include/aalsdk/kernel/aaldevice.h
@@ -0,0 +1,352 @@
+//******************************************************************************
+// This  file  is  provided  under  a  dual BSD/GPLv2  license.  When using or
+//         redistributing this file, you may do so under either license.
+//
+//                            GPL LICENSE SUMMARY
+//
+//  Copyright(c) 2008-2017, Intel Corporation.
+//
+//  This program  is  free software;  you  can redistribute it  and/or  modify
+//  it  under  the  terms of  version 2 of  the GNU General Public License  as
+//  published by the Free Software Foundation.
+//
+//  This  program  is distributed  in the  hope that it  will  be useful,  but
+//  WITHOUT   ANY   WARRANTY;   without   even  the   implied   warranty    of
+//  MERCHANTABILITY  or  FITNESS  FOR  A  PARTICULAR  PURPOSE.  See  the   GNU
+//  General Public License for more details.
+//
+//  The  full  GNU  General Public License is  included in  this  distribution
+//  in the file called README.GPLV2-LICENSE.TXT.
+//
+//  Contact Information:
+//  Henry Mitchel, henry.mitchel at intel.com
+//  77 Reed Rd., Hudson, MA  01749
+//
+//                                BSD LICENSE
+//
+//  Copyright(c) 2008-2017, Intel Corporation.
+//
+//  Redistribution and  use  in source  and  binary  forms,  with  or  without
+//  modification,  are   permitted  provided  that  the  following  conditions
+//  are met:
+//
+//    * Redistributions  of  source  code  must  retain  the  above  copyright
+//      notice, this list of conditions and the following disclaimer.
+//    * Redistributions in  binary form  must  reproduce  the  above copyright
+//      notice,  this  list of  conditions  and  the  following disclaimer  in
+//      the   documentation   and/or   other   materials   provided  with  the
+//      distribution.
+//    * Neither   the  name   of  Intel  Corporation  nor  the  names  of  its
+//      contributors  may  be  used  to  endorse  or promote  products derived
+//      from this software without specific prior written permission.
+//
+//  THIS  SOFTWARE  IS  PROVIDED  BY  THE  COPYRIGHT HOLDERS  AND CONTRIBUTORS
+//  "AS IS"  AND  ANY  EXPRESS  OR  IMPLIED  WARRANTIES,  INCLUDING,  BUT  NOT
+//  LIMITED  TO, THE  IMPLIED WARRANTIES OF  MERCHANTABILITY  AND FITNESS  FOR
+//  A  PARTICULAR  PURPOSE  ARE  DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT
+//  OWNER OR CONTRIBUTORS BE LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,
+//  SPECIAL,  EXEMPLARY,  OR  CONSEQUENTIAL   DAMAGES  (INCLUDING,   BUT   NOT
+//  LIMITED  TO,  PROCUREMENT  OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF USE,
+//  DATA,  OR PROFITS;  OR BUSINESS INTERRUPTION)  HOWEVER  CAUSED  AND ON ANY
+//  THEORY  OF  LIABILITY,  WHETHER  IN  CONTRACT,  STRICT LIABILITY,  OR TORT
+//  (INCLUDING  NEGLIGENCE  OR OTHERWISE) ARISING  IN ANY WAY  OUT  OF THE USE
+//  OF  THIS  SOFTWARE, EVEN IF ADVISED  OF  THE  POSSIBILITY  OF SUCH DAMAGE.
+//******************************************************************************
+//****************************************************************************
+//        FILE: aaldevice.h
+//     CREATED: 09/18/2008
+//      AUTHOR: Joseph Grecco - Intel
+//
+// PURPOSE: This file contains public definitions for AAL device objects
+// HISTORY:
+// COMMENTS:
+// WHEN:          WHO:     WHAT:
+// 09/18/08       JG       Initial version created
+// 11/11/2008     JG       Added legal header
+// 11/13/2008     HM       Added AAL_GUID_t, standard GUID
+// 01/04/2009     HM       Updated Copyright
+// 02/26/2009     JG       Began dynamic config implementation
+// 10/09/2009     JG       Added support for Host Based AFUs
+// 10/22/2009     JG       Added aaldev_AddOwner_e in support of modified
+//                         device methods
+// 04/28/2010     HM       Added return value checks to kosal_sem_get_krnl_alertable()
+// 03/06/2011     HM       Added comment showing expansion of aal_device_id
+// 06/25/2013     JG       Added device address macros
+//****************************************************************************
+#ifndef __AALSDK_KERNEL_AALDEVICE_H__
+#define __AALSDK_KERNEL_AALDEVICE_H__
+#include <aalsdk/kernel/kosal.h>
+#include <aalsdk/kernel/iaaldevice.h>
+#include <aalsdk/kernel/aalbus-device.h>
+
+//-----------------------------------------------------------------------------
+//-----------------------------------------------------------------------------
+//                               AAL Device
+//-----------------------------------------------------------------------------
+//-----------------------------------------------------------------------------
+#define  AAL_DEVICE_VERSION   0x0001000000000200
+
+BEGIN_NAMESPACE(AAL)
+
+BEGIN_C_DECLS
+
+#if 0
+//=============================================================================
+// Name: aaldevCallbacks
+// Description: Interface for driver notifications
+//=============================================================================
+struct aaldevCallbacks
+{
+   void (*devReleased)(struct device*);                  // Called when device released
+   btInt(*devAdd)( struct aal_device *dev);              // Function called when device is created
+};
+#endif
+
+#if 1
+// KObject length restrictions disapppear in 2.6.31 and later
+#if   defined( __AAL_LINUX__ )
+# if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,30)
+#    define BUS_ID_SIZE 20
+# endif
+#elif defined( __AAL_WINDOWS__ )
+# define BUS_ID_SIZE 20
+#endif // OS
+
+
+//=============================================================================
+// Name: aal_device
+// Description: AAL specific device object definition
+//=============================================================================
+struct aal_device {
+   btUnsigned64bitInt m_version;       // Interface version
+#define AAL_DEVICE_FLAG_IS_REGISTERED 0x00000001
+   btUnsigned16bitInt m_flags;
+
+   // Device interface used by AAL Bus
+   AAL_DEVICE_INTERFACE          i;
+
+   // Device specific information
+   struct aal_device_id m_devid;       // Device ID
+
+   //-----------------------
+   // Interface plug-ins
+   //-----------------------
+#if DEPRECATED //NOT USED
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,23)
+   int (*m_uevent)(struct aal_device *dev, struct kobj_uevent_env *env);
+#else
+   int (*m_uevent)(struct aal_device *dev,
+                   char             **envp,
+                   int                num_envp,
+                   char              *buffer,
+                   int                buffer_size);
+#endif
+#endif // DEPRECATED
+
+   // PIP Interface bindings
+   struct aal_interface *m_ipip;           // PIP service interface container
+   struct aal_ipip      *m_pip;            // PIP interface
+   btObjectType          m_pipContext;     // PIP specific context
+
+
+   btInt                 m_devstate;       // Device state 1 - if activated 0 - if quiescent
+   kosal_list_head       m_ownerlist;      // List of owning sessions
+   kosal_mutex           m_listsem;        // Lock used for protecting list manipulations
+   btUnsigned32bitInt    m_numowners;      // Number of owners
+   btUnsigned32bitInt    m_maxowners;      // MAximum number of owners
+   btUnsigned16bitInt    m_mappableAPI;    // Supports direct access to PIP
+
+   kosal_mutex           m_sem;            // Private mutex
+
+   struct aal_bus       *m_bus;            // AAL Bus interface
+
+   kosal_os_dev          m_dev;            // Device base class
+   char                  m_basename[BUS_ID_SIZE];
+   btPhysAddr            m_validator;      // Used for validation
+   /* allocation list.  head is in aal_bus_type.alloc_list_head */
+   kosal_list_head       m_alloc_list;
+
+   btAny                 m_context;        //
+
+};
+
+//-----------------
+//   Casting Macros
+//-----------------
+#define basedev_to_aaldev(dev)           ( kosal_container_of(dev, struct aal_device, m_dev) )
+#define aaldev_to_basedev(dev)           ((dev)->m_dev)
+
+#define aaldev_to_any(s,pdev)            ((s)(pdev->m_context))
+#define aaldev_context(pdev)             (pdev->m_context)
+
+#define aaldev_is_registered(p)          flag_is_set((p)->m_flags, AAL_DEVICE_FLAG_IS_REGISTERED)
+#define aaldev_set_registered(p)         flag_setf((p)->m_flags,   AAL_DEVICE_FLAG_IS_REGISTERED)
+#define aaldev_clr_registered(p)         flag_clrf((p)->m_flags,   AAL_DEVICE_FLAG_IS_REGISTERED)
+
+//-----------------------
+// aal_device Accesssors
+//-----------------------
+#define aaldev_pipid(d)                  ((d)->m_devid.m_pipGUID)                // PIP IID
+#define aaldev_pipp(d)                   ((d)->m_pip)                            // PIP pointer
+#define aaldev_pipmsgHandlerp(d)         ( &(aaldev_pipp(d))->m_messageHandler ) // Message handler
+#define aaldev_interface(d)              ((d)->i)                                // Device interface
+#define aaldev_pip_interface(d)          ((d)->m_ipip)                           // PIP interface container object
+#define aaldev_pip_context(d)            ((d)->m_pipContext)                     // Context
+#define aaldev_pip_context_to_obj(t,d)   ( (t) (d->m_pipContext) )               // Context cast to type
+
+#if   defined( __AAL_LINUX__ )
+#  if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,29)
+#     define aaldev_devname(dev)              ( dev_name(&aaldev_to_basedev(dev)) )
+#  else
+#     define aaldev_devname(dev)              ((dev)->m_dev.bus_id)
+#  endif
+#elif defined( __AAL_WINDOWS__ )
+#     define aaldev_devname(dev)              ((dev)->m_dev.m_basename)
+#endif // OS
+
+
+#define aaldev_bus(dev)                  (*(dev)->m_bus)
+#define aaldev_busp(dev)                 ((dev)->m_bus)
+#define aaldev_basedriverp(d)            (aaldev_to_basedev(d).driver)
+
+#define aaldev_basename(dev)             ((dev)->m_basename)
+
+#define aaldev_devid(dev)                ((dev)->m_devid)
+#define aaldev_devid_devtype(dev)        (((dev)->m_devid).m_devicetype)
+#define aaldev_devid_ahmguid(dev)        (((dev)->m_devid).m_ahmGUID)
+#define aaldev_devid_pipguid(dev)        (((dev)->m_devid).m_pipGUID)
+#define aaldev_devid_afuguid(dev)        (((dev)->m_devid).m_afuGUID)
+#define aaldev_devid_afuguidl(dev)       (((dev)->m_devid).m_afuGUIDl)
+#define aaldev_devid_afuguidh(dev)       (((dev)->m_devid).m_afuGUIDh)
+#define aaldev_devid_vendorid(dev)       (((dev)->m_devid).m_vendor)
+
+#define aaldev_devaddr(dev)              ((dev)->m_devid.m_devaddr)
+#define aaldev_devaddr_bustype(dev)      (aaldev_devaddr(dev).m_bustype)
+#define aaldev_devaddr_busnum(dev)       (aaldev_devaddr(dev).m_busnum)
+#define aaldev_devaddr_devnum(dev)       (aaldev_devaddr(dev).m_devicenum)
+#define aaldev_devaddr_fcnnum(dev)       (aaldev_devaddr(dev).m_functnum)
+#define aaldev_devaddr_subdevnum(dev)    (aaldev_devaddr(dev).m_subdevnum)
+#define aaldev_devaddr_instanceNum(dev)  (aaldev_devaddr(dev).m_instanceNum)
+#define aaldev_devaddr_socketnum(dev)    (aaldev_devaddr(dev).m_socketnum)
+
+// Utility macros
+#define aaldev_haspip(devp)              (NULL != (devp)->m_pip)
+#define aaldev_mappableAPI(devp)         ((devp)->m_mappableAPI)
+#define aaldev_allowsDirectAPI(devp)     (AAL_DEV_APIMAP_NONE != (devp)->m_mappableAPI)
+#define aaldev_allowsAPIMode(devp, m)    ( ((devp)->m_mappableAPI & (m)) == (m) )
+
+//-----------------
+// Utility
+//-----------------
+#define link_aalchild_to_parent(c,p)     ((c)->m_dev.parent =  &((p)->m_dev))
+#define is_driver_device_owner(drvp,dev) ( aaldrv_to_basep(drvp) == aaldev_basedriverp(dev) )
+#endif
+
+
+//=============================================================================
+// Name: aaldev_create
+// Description: Creates the device structure.
+// Interface: public
+// Returns aal_device * - success; NULL = failure
+// Inputs: devIDp - pointer to aal_device ID to create
+//         ipipp - pointer to PIP for this device.
+// Outputs: none.
+// Comments:
+//=============================================================================
+static inline struct aal_device *
+         aaldev_create( char *szDevName,
+                        struct aal_device_id *devID,
+                        struct aal_ipip      *ipipp)
+{
+#define AAL_AFU_DEVICE_BASENAME     "AALAFU"
+
+   struct aal_device    *paaldevice = NULL;
+
+   ASSERT(devID);
+
+   // Allocate the new aal_device
+   paaldevice = (struct aal_device    *)kosal_kmalloc(sizeof(struct aal_device));
+   if ( NULL == paaldevice ) {
+      PERR( ": Error allocating device memory for bus type %d busID[%d:%d:%x:%d]\n",
+                                 (unsigned) devID->m_devaddr.m_bustype,
+                                 devID->m_devaddr.m_busnum,
+                                 devID->m_devaddr.m_devicenum,
+                                 devID->m_devaddr.m_subdevnum,
+								 devID->m_devaddr.m_instanceNum);
+      return NULL;
+   }
+
+   // DPRINTF do not resolve properly in a header file because there is no well-defined
+   //   external linkage for the "debug" variable. This should be PINFO with the correct
+   //   module linkage defined in the calling .c file set up prior to including this file.
+   // See RedMine 566
+   //   DPRINTF(AALBUS_DBG_MOD," Preparing AAL device %s\n", szDevName);
+
+    // Prepare the new device
+   memset(paaldevice, 0, sizeof(struct aal_device));
+
+   paaldevice->m_devid        = *devID;
+
+   // Store the base name
+   if ( 0 == strlen(szDevName) ) {
+      // Default
+      strncpy(aaldev_basename(paaldevice), AAL_AFU_DEVICE_BASENAME, BUS_ID_SIZE-1);
+   } else {
+      strncpy(aaldev_basename(paaldevice), szDevName,      BUS_ID_SIZE-1);
+   }
+#if   defined( __AAL_LINUX__ )
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,29)
+   dev_set_name(&aaldev_to_basedev(paaldevice),
+                "%s[%d:%d:%d:%x:%d:%d]",
+                (char*)aaldev_basename(paaldevice),
+                aaldev_devaddr_busnum(paaldevice),
+                aaldev_devaddr_devnum(paaldevice),
+                aaldev_devaddr_fcnnum(paaldevice),
+                aaldev_devaddr_subdevnum(paaldevice),
+                aaldev_devaddr_socketnum(paaldevice),
+                aaldev_devaddr_instanceNum(paaldevice));
+#else
+   // Construct the device name from the base name and the device ID
+   snprintf((char*)aaldev_devname(paaldevice), BUS_ID_SIZE,
+            "%s[%d:%d:%d:%x:%d:%d]",
+            (char*)aaldev_basename(paaldevice),
+            aaldev_devaddr_busnum(paaldevice),
+            aaldev_devaddr_devnum(paaldevice),
+            aaldev_devaddr_fcnnum(paaldevice),
+            aaldev_devaddr_subdevnum(paaldevice),
+            aaldev_devaddr_socketnum(paaldevice),
+            aaldev_devaddr_instanceNum(paaldevice));
+#endif
+#endif
+
+   kosal_list_init(&paaldevice->m_ownerlist);
+   kosal_list_init(&paaldevice->m_alloc_list);
+   kosal_mutex_init(&paaldevice->m_sem);
+   kosal_mutex_init(&paaldevice->m_listsem);
+
+   // Version of the structure
+   paaldevice->m_version      = AAL_DEVICE_VERSION;
+
+   // Used as part of the handle validation
+   paaldevice->m_validator = kosal_virt_to_phys( paaldevice );
+
+   // DPRINTF do not resolve properly in a header file because there is no well-defined
+   //   external linkage for the "debug" variable. This should be PINFO with the correct
+   //   module linkage defined in the calling .c file set up prior to including this file.
+   // See RedMine 566
+   // Initialize the device ID info
+   // DPRINTF(AALBUS_DBG_MOD," Initializing AAL device %p\n", paaldevice);
+
+   // The Context is a PIP defined data value
+   //   The standard AAL PIP pointer is stored as well
+   paaldevice->m_pipContext   = NULL;
+   aaldev_pipp(paaldevice)    = ipipp;
+
+   return paaldevice;
+}
+END_C_DECLS
+
+END_NAMESPACE(AAL)
+
+#endif // __AALSDK_KERNEL_AALDEVICE_H__
+
diff --git a/drivers/fpga/aal/include/aalsdk/kernel/aalids.h b/drivers/fpga/aal/include/aalsdk/kernel/aalids.h
new file mode 100644
index 000000000000..e476c6a513f2
--- /dev/null
+++ b/drivers/fpga/aal/include/aalsdk/kernel/aalids.h
@@ -0,0 +1,169 @@
+//******************************************************************************
+// This  file  is  provided  under  a  dual BSD/GPLv2  license.  When using or
+//         redistributing this file, you may do so under either license.
+//
+//                            GPL LICENSE SUMMARY
+//
+//  Copyright(c) 2008-2017, Intel Corporation.
+//
+//  This program  is  free software;  you  can redistribute it  and/or  modify
+//  it  under  the  terms of  version 2 of  the GNU General Public License  as
+//  published by the Free Software Foundation.
+//
+//  This  program  is distributed  in the  hope that it  will  be useful,  but
+//  WITHOUT   ANY   WARRANTY;   without   even  the   implied   warranty    of
+//  MERCHANTABILITY  or  FITNESS  FOR  A  PARTICULAR  PURPOSE.  See  the   GNU
+//  General Public License for more details.
+//
+//  The  full  GNU  General Public License is  included in  this  distribution
+//  in the file called README.GPLV2-LICENSE.TXT.
+//
+//  Contact Information:
+//  Henry Mitchel, henry.mitchel at intel.com
+//  77 Reed Rd., Hudson, MA  01749
+//
+//                                BSD LICENSE
+//
+//  Copyright(c) 2008-2017, Intel Corporation.
+//
+//  Redistribution and  use  in source  and  binary  forms,  with  or  without
+//  modification,  are   permitted  provided  that  the  following  conditions
+//  are met:
+//
+//    * Redistributions  of  source  code  must  retain  the  above  copyright
+//      notice, this list of conditions and the following disclaimer.
+//    * Redistributions in  binary form  must  reproduce  the  above copyright
+//      notice,  this  list of  conditions  and  the  following disclaimer  in
+//      the   documentation   and/or   other   materials   provided  with  the
+//      distribution.
+//    * Neither   the  name   of  Intel  Corporation  nor  the  names  of  its
+//      contributors  may  be  used  to  endorse  or promote  products derived
+//      from this software without specific prior written permission.
+//
+//  THIS  SOFTWARE  IS  PROVIDED  BY  THE  COPYRIGHT HOLDERS  AND CONTRIBUTORS
+//  "AS IS"  AND  ANY  EXPRESS  OR  IMPLIED  WARRANTIES,  INCLUDING,  BUT  NOT
+//  LIMITED  TO, THE  IMPLIED WARRANTIES OF  MERCHANTABILITY  AND FITNESS  FOR
+//  A  PARTICULAR  PURPOSE  ARE  DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT
+//  OWNER OR CONTRIBUTORS BE LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,
+//  SPECIAL,  EXEMPLARY,  OR  CONSEQUENTIAL   DAMAGES  (INCLUDING,   BUT   NOT
+//  LIMITED  TO,  PROCUREMENT  OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF USE,
+//  DATA,  OR PROFITS;  OR BUSINESS INTERRUPTION)  HOWEVER  CAUSED  AND ON ANY
+//  THEORY  OF  LIABILITY,  WHETHER  IN  CONTRACT,  STRICT LIABILITY,  OR TORT
+//  (INCLUDING  NEGLIGENCE  OR OTHERWISE) ARISING  IN ANY WAY  OUT  OF THE USE
+//  OF  THIS  SOFTWARE, EVEN IF ADVISED  OF  THE  POSSIBILITY  OF SUCH DAMAGE.
+//******************************************************************************
+//****************************************************************************
+//        FILE: aalids.h
+//     CREATED: 04/15/2008
+//      AUTHOR: Alvin Chen - Intel
+//
+// PURPOSE: AAL IDs definitions.
+//
+// HISTORY:
+// COMMENTS:
+// WHEN:          WHO:     WHAT:
+// 04/15/10       AC       Initial version created
+//****************************************************************************
+#ifndef __AALSDK_KERNEL_AALIDS_H__
+#define __AALSDK_KERNEL_AALIDS_H__
+
+
+/////////////////////////////////////////////////////////////////////////////////
+// Device ID information
+/////////////////////////////////////////////////////////////////////////////////
+
+/////////////////////////////////////////////////////////////////////////////////
+// ASM related IDs
+/////////////////////////////////////////////////////////////////////////////////
+//#define  ASM_DEVICE_ID_AHM   (0xf0f0)       //Emulated device
+//#define  ASM_DEVICE_ID_AFU   (0x0001)       //Emulated AFU
+#define  ASM_AHM_GUID         (0x3333111133331111LL)
+
+#define  ASM_AFU_GUID         (0x40040586)   //Emulated AHM GUID
+
+#define  ASM_MAFU_GUID        (0xA0A0A0A0A0A0A0A0LL)
+
+// Class Device ID informaton
+#define ASM_CLASS_MAJVERSION  (0x00000001)
+#define ASM_CLASS_MINVERSION  (0x00000000)
+#define ASM_CLASS_RELEASE     (0x00000001)
+
+/////////////////////////////////////////////////////////////////////////////////
+// FSB related IDs
+/////////////////////////////////////////////////////////////////////////////////
+#define  FSB_AHM_GUID         (0x90808086)   //Emulated AHM GUID
+#define  FSB_AFU_GUID         (0x50040586)   //Emulated AHM GUID
+
+// Class Device ID information
+#define FSB_CLASS_MAJVERSION  (0x00000002)
+#define FSB_CLASS_MINVERSION  (0x00000000)
+#define FSB_CLASS_RELEASE     (0x00000001)
+
+
+/////////////////////////////////////////////////////////////////////////////////
+// HOST AFU related IDs
+/////////////////////////////////////////////////////////////////////////////////
+#define  HOST_AHM_GUID        (0xffff0000ffff0000LL)
+
+
+#define  HOST_MAFU_IID        (0xffff0000ffff0001LL)
+#define  HOST_AFU_IID         (0xffff0000ffff0002LL)
+
+
+#define  HOST_MAFUPIP_IID              (0xffff0000fffe0001LL)
+#define  HOST_AFUPIP_IID               (0xffff0000fffe0002LL)
+#define  HOST_SAMPLE_AFUPIP_IID        (0xffff0000fffe0003LL)
+
+#define  HOST_EDGESAMPLE_AFUPIP_IID    (0xffff0000fffe0004LL)
+
+#define  HOST_MAFUAPI_IID        (0xffff0000fffd0001LL)
+#define  HOST_AFUAPI_IID         (0xffff0000fffd0002LL)
+#define  HOST_HEALAFUAPI_IID     (0xffff0000fffd0003LL)
+#define  HOST_SAMPLE_AFUAPI_IID  (0xffff0000fffd0004LL)
+
+
+/////////////////////////////////////////////////////////////////////////////////
+// QPI related IDs
+/////////////////////////////////////////////////////////////////////////////////
+#define  QPI_AHM_GUID        (0xffff0000dfff0000LL)
+
+
+// AFU IDs, 0xffff0000dfffxxxx
+#define  QPI_MAFU_IID        (0xffff0000dfff0001LL)
+#define  QPI_CCIAFU_IID      (0xffff0000dfff0002LL)   //TODO This has to change
+#define  QPI_CCISIMAFU_IID   (0xffff0000dfff0003LL)   //TODO This has to change
+#define  QPI_SPLAFU_IID      (0xffff0000dfff0004LL)   //TODO This has to change
+
+// PIP IDs, 0xffff0000dffexxxx
+#define  QPI_MAFUPIP_IID      (0xffff0000dffe0001LL)
+#define  QPI_CCIAFUPIP_IID    (0xffff0000dffe0002LL)
+#define  QPI_CCISIMAFUPIP_IID (0xffff0000dffe0004LL)
+
+// API IDs, 0xffff0000dffdxxxx
+#define  QPI_MAFUAPI_IID      (0xffff0000dffd0001LL)
+#define  QPI_CCIAFUAPI_IID    (0xffff0000dffd0002LL)
+#define  QPI_SPLAFUAPI_IID    (0xffff0000dffd0003LL)
+#define  QPI_CCISIMAFUAPI_IID (0xffff0000dffd0004LL)
+
+#define SPL2_MAFUPIP_IID      (0xbb353944ae885dddLL)
+#define SPL2_AFUPIP_IID       (0x8ee7ef537e245c28LL)
+#define SPL2_AFUAPI_IID       (0xa579bdeabc56d3c5LL)
+
+#define CCIV4_AFUPIP_IID      (0x8ee7ef537e245c28LL)
+#define CCIV4_AFUAPI_IID      (0xa579bdeabc56d3c6LL)
+#define CCIV4_SIMAFUPIP_IID   (0x5e2f2894f9a14eb1LL)
+#define CCIV4_MAFUPIP_IID     (0xbb353944ae885ddfLL)
+#define CCIV4_CMAFUPIP_IID    (0xbb353944ae885ddeLL)
+
+#define CCI_AFUPIP_IID      (0x8ee7ef537e245c28LL)
+#define CCI_AFUAPI_IID      (0xa579bdeabc56d3c6LL)
+#define CCI_SIMAFUPIP_IID   (0x5e2f2894f9a14eb1LL)
+#define CCI_MAFUPIP_IID     (0xbb353944ae885ddfLL)
+#define CCI_CMAFUPIP_IID    (0xbb353944ae885ddeLL)
+
+/////////////////////////////////////////////////////////////////////////////////
+// QPI related IDs
+/////////////////////////////////////////////////////////////////////////////////
+
+#endif // __AALSDK_KERNEL_AALIDS_H__
+
diff --git a/drivers/fpga/aal/include/aalsdk/kernel/aalinterface.h b/drivers/fpga/aal/include/aalsdk/kernel/aalinterface.h
new file mode 100644
index 000000000000..63a2355da6dc
--- /dev/null
+++ b/drivers/fpga/aal/include/aalsdk/kernel/aalinterface.h
@@ -0,0 +1,212 @@
+//******************************************************************************
+// This  file  is  provided  under  a  dual BSD/GPLv2  license.  When using or
+//         redistributing this file, you may do so under either license.
+//
+//                            GPL LICENSE SUMMARY
+//
+//  Copyright(c) 2008-2017, Intel Corporation.
+//
+//  This program  is  free software;  you  can redistribute it  and/or  modify
+//  it  under  the  terms of  version 2 of  the GNU General Public License  as
+//  published by the Free Software Foundation.
+//
+//  This  program  is distributed  in the  hope that it  will  be useful,  but
+//  WITHOUT   ANY   WARRANTY;   without   even  the   implied   warranty    of
+//  MERCHANTABILITY  or  FITNESS  FOR  A  PARTICULAR  PURPOSE.  See  the   GNU
+//  General Public License for more details.
+//
+//  The  full  GNU  General Public License is  included in  this  distribution
+//  in the file called README.GPLV2-LICENSE.TXT.
+//
+//  Contact Information:
+//  Henry Mitchel, henry.mitchel at intel.com
+//  77 Reed Rd., Hudson, MA  01749
+//
+//                                BSD LICENSE
+//
+//  Copyright(c) 2008-2017, Intel Corporation.
+//
+//  Redistribution and  use  in source  and  binary  forms,  with  or  without
+//  modification,  are   permitted  provided  that  the  following  conditions
+//  are met:
+//
+//    * Redistributions  of  source  code  must  retain  the  above  copyright
+//      notice, this list of conditions and the following disclaimer.
+//    * Redistributions in  binary form  must  reproduce  the  above copyright
+//      notice,  this  list of  conditions  and  the  following disclaimer  in
+//      the   documentation   and/or   other   materials   provided  with  the
+//      distribution.
+//    * Neither   the  name   of  Intel  Corporation  nor  the  names  of  its
+//      contributors  may  be  used  to  endorse  or promote  products derived
+//      from this software without specific prior written permission.
+//
+//  THIS  SOFTWARE  IS  PROVIDED  BY  THE  COPYRIGHT HOLDERS  AND CONTRIBUTORS
+//  "AS IS"  AND  ANY  EXPRESS  OR  IMPLIED  WARRANTIES,  INCLUDING,  BUT  NOT
+//  LIMITED  TO, THE  IMPLIED WARRANTIES OF  MERCHANTABILITY  AND FITNESS  FOR
+//  A  PARTICULAR  PURPOSE  ARE  DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT
+//  OWNER OR CONTRIBUTORS BE LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,
+//  SPECIAL,  EXEMPLARY,  OR  CONSEQUENTIAL   DAMAGES  (INCLUDING,   BUT   NOT
+//  LIMITED  TO,  PROCUREMENT  OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF USE,
+//  DATA,  OR PROFITS;  OR BUSINESS INTERRUPTION)  HOWEVER  CAUSED  AND ON ANY
+//  THEORY  OF  LIABILITY,  WHETHER  IN  CONTRACT,  STRICT LIABILITY,  OR TORT
+//  (INCLUDING  NEGLIGENCE  OR OTHERWISE) ARISING  IN ANY WAY  OUT  OF THE USE
+//  OF  THIS  SOFTWARE, EVEN IF ADVISED  OF  THE  POSSIBILITY  OF SUCH DAMAGE.
+//******************************************************************************
+//****************************************************************************
+//        FILE: aalinterface.h
+//     CREATED: 02/21/2008
+//      AUTHOR: Joseph Grecco
+//
+// PURPOSE:  External definitions for the AAL Interface object
+// HISTORY:
+// COMMENTS:
+// WHEN:          WHO:     WHAT:
+// 02-21-08       JG       Initial version created
+// 11/11/2008     JG       Added legal header
+// 01/04/2009     HM       Updated Copyright
+// 04/19/2012     TSW      Deprecate __func__ in favor of platform-agnostic
+//                          __AAL_FUNC__.
+//****************************************************************************
+#ifndef __AALSDK_KERNEL_AALINTERFACE_H__
+#define __AALSDK_KERNEL_AALINTERFACE_H__
+#include <aalsdk/kernel/kosal.h>
+
+BEGIN_NAMESPACE(AAL)
+
+//-----------------------------------------------------------------------------
+//-----------------------------------------------------------------------------
+//                            AAL Interface
+//-----------------------------------------------------------------------------
+//-----------------------------------------------------------------------------
+
+
+//=============================================================================
+// Name: aal_interface
+// Description: AAL Interface represents an opaque, typically dynamically
+//              bindable, interface
+//=============================================================================
+struct aal_interface {
+#define AAL_INTERFACE_FLAG_IS_REGISTERED 0x00000001
+   btUnsigned32bitInt m_flags;
+   kosal_ownermodule  m_owner;    // Module that owns this interface
+   bt32bitInt         m_count;    // Number of outstanding get's
+   btIID              m_iid;      // Interface ID
+   void              *m_iptr;     // Pointer to the interface. Must be cast
+   kosal_list_head    m_list;     // Used when interface is in a list
+};
+
+#define aalinterface_is_registered(p)  ((p)->m_flags & AAL_INTERFACE_FLAG_IS_REGISTERED)
+#define aalinterface_set_registered(p) ((p)->m_flags |= AAL_INTERFACE_FLAG_IS_REGISTERED)
+#define aalinterface_clr_registered(p) ((p)->m_flags &= ~AAL_INTERFACE_FLAG_IS_REGISTERED)
+
+#define aalinterface_count(p)          ((p)->m_count)
+#define aalinterface_get(p)            (++((p)->m_count))
+#define aalinterface_put(p)            (--((p)->m_count))
+
+// Casting macro for aal_interfaces. Returns NULL if improper cast
+#define cast_aal_interface(t,i,p) ( (t*) ((i==p->m_iid) ? p->m_iptr : NULL) )
+#define aalinterface_iptr(p)      (p->m_iptr)
+
+//=============================================================================
+// Name: aal_interface_init
+// Description: Initialize and interface
+//=============================================================================
+#define aal_interface_init(i,p,id) \
+do                                 \
+{  i.m_flags = 0;                  \
+   i.m_owner = THIS_MODULE;        \
+   i.m_count = 0;                  \
+   i.m_iid   = id;                 \
+   i.m_iptr  = p;                  \
+   kosal_list_init(&i.m_list);     \
+}while(0)
+
+//=============================================================================
+// Name: aal_interface_find
+// Description: Finds and returns an interface of the specified type
+// Interface: inline
+// Inputs: list - list of interfaces
+//         iid - ID of interface to find
+// Outputs: NULL - Failed. Interface if successful
+// Comments: This function does not increment the module reference count
+//           If this interface is to be used outside the owning module
+//           the client should take the necessary precautions such as
+//           issuing a try_module_get() on the owner prior to using.
+//=============================================================================
+static inline
+struct aal_interface *
+aal_interface_find(kosal_list_head *list, btIID iid)
+{
+   struct aal_interface *tmp = NULL;
+
+   kosal_list_for_each_entry(tmp, list, m_list, struct aal_interface) {
+      if ( tmp->m_iid == iid ) {
+         return tmp;
+      }
+   }
+   return NULL;
+}
+
+//=============================================================================
+// Name: aal_interface_add
+// Description: Adds an interface
+// Interface: inline
+// Inputs: list - list of interfaces
+//         pinterface - interface to add
+// Outputs: 0 - success.
+//=============================================================================
+static inline
+int
+aal_interface_add(kosal_list_head      *list,
+                  kosal_semaphore      *sem,
+                  struct aal_interface *pinterface)
+{
+   if ( unlikely( kosal_sem_get_krnl_alertable(sem) ) ) {
+      return -2;
+   }
+
+   if ( aal_interface_find(list, pinterface->m_iid) ) {
+      kosal_sem_put(sem);
+      // Already registered
+      return -1;
+   }
+   kosal_list_add(&pinterface->m_list, list);
+   kosal_sem_put(sem);
+
+   return 0;
+}
+
+//=============================================================================
+// Name: aal_interface_del
+// Description: Finds and returns an interface of the specified type
+// Interface: inline
+// Inputs: list - list of interfaces
+//         pinterface - interface to delete
+// Outputs: 0 - success.
+//=============================================================================
+static inline
+int
+aal_interface_del(kosal_list_head      *list,
+                  kosal_semaphore      *sem,
+                  struct aal_interface *pinterface)
+{
+   if ( unlikely( kosal_sem_get_krnl_alertable(sem) ) ) {
+      return -2;
+   }
+
+   if ( NULL == aal_interface_find(list, pinterface->m_iid) ) {
+      kosal_sem_put(sem);
+      // Not found
+      return -1;
+   }
+
+   kosal_list_del_init(&pinterface->m_list);
+   kosal_sem_put(sem);
+
+   return 0;
+}
+
+END_NAMESPACE(AAL)
+
+#endif // __AALSDK_KERNEL_AALINTERFACE_H__
+
diff --git a/drivers/fpga/aal/include/aalsdk/kernel/aalmafu-events.h b/drivers/fpga/aal/include/aalsdk/kernel/aalmafu-events.h
new file mode 100644
index 000000000000..4d484f841c96
--- /dev/null
+++ b/drivers/fpga/aal/include/aalsdk/kernel/aalmafu-events.h
@@ -0,0 +1,286 @@
+//******************************************************************************
+// This  file  is  provided  under  a  dual BSD/GPLv2  license.  When using or
+//         redistributing this file, you may do so under either license.
+//
+//                            GPL LICENSE SUMMARY
+//
+//  Copyright(c) 2009-2017, Intel Corporation.
+//
+//  This program  is  free software;  you  can redistribute it  and/or  modify
+//  it  under  the  terms of  version 2 of  the GNU General Public License  as
+//  published by the Free Software Foundation.
+//
+//  This  program  is distributed  in the  hope that it  will  be useful,  but
+//  WITHOUT   ANY   WARRANTY;   without   even  the   implied   warranty    of
+//  MERCHANTABILITY  or  FITNESS  FOR  A  PARTICULAR  PURPOSE.  See  the   GNU
+//  General Public License for more details.
+//
+//  The  full  GNU  General Public License is  included in  this  distribution
+//  in the file called README.GPLV2-LICENSE.TXT.
+//
+//  Contact Information:
+//  Henry Mitchel, henry.mitchel at intel.com
+//  77 Reed Rd., Hudson, MA  01749
+//
+//                                BSD LICENSE
+//
+//  Copyright(c) 2009-2017, Intel Corporation.
+//
+//  Redistribution and  use  in source  and  binary  forms,  with  or  without
+//  modification,  are   permitted  provided  that  the  following  conditions
+//  are met:
+//
+//    * Redistributions  of  source  code  must  retain  the  above  copyright
+//      notice, this list of conditions and the following disclaimer.
+//    * Redistributions in  binary form  must  reproduce  the  above copyright
+//      notice,  this  list of  conditions  and  the  following disclaimer  in
+//      the   documentation   and/or   other   materials   provided  with  the
+//      distribution.
+//    * Neither   the  name   of  Intel  Corporation  nor  the  names  of  its
+//      contributors  may  be  used  to  endorse  or promote  products derived
+//      from this software without specific prior written permission.
+//
+//  THIS  SOFTWARE  IS  PROVIDED  BY  THE  COPYRIGHT HOLDERS  AND CONTRIBUTORS
+//  "AS IS"  AND  ANY  EXPRESS  OR  IMPLIED  WARRANTIES,  INCLUDING,  BUT  NOT
+//  LIMITED  TO, THE  IMPLIED WARRANTIES OF  MERCHANTABILITY  AND FITNESS  FOR
+//  A  PARTICULAR  PURPOSE  ARE  DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT
+//  OWNER OR CONTRIBUTORS BE LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,
+//  SPECIAL,  EXEMPLARY,  OR  CONSEQUENTIAL   DAMAGES  (INCLUDING,   BUT   NOT
+//  LIMITED  TO,  PROCUREMENT  OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF USE,
+//  DATA,  OR PROFITS;  OR BUSINESS INTERRUPTION)  HOWEVER  CAUSED  AND ON ANY
+//  THEORY  OF  LIABILITY,  WHETHER  IN  CONTRACT,  STRICT LIABILITY,  OR TORT
+//  (INCLUDING  NEGLIGENCE  OR OTHERWISE) ARISING  IN ANY WAY  OUT  OF THE USE
+//  OF  THIS  SOFTWARE, EVEN IF ADVISED  OF  THE  POSSIBILITY  OF SUCH DAMAGE.
+//******************************************************************************
+//****************************************************************************
+//        FILE: aalmafu-events.h
+//     CREATED: Oct. 26, 2008
+//      AUTHOR: Joseph Grecco, Intel Corporation.
+//
+// PURPOSE: This implements the external events for the
+//          Accelerator Abstraction Layer (AAL)
+//          Universal Interface Driver
+// HISTORY:
+// WHEN:          WHO:     WHAT:
+// 05/06/2009     HM       Removed inappropriate hard path coding of 
+//                            aas/kernel/include
+//****************************************************************************
+#ifndef __AALSDK_KERNEL_AALMAFU_EVENTS_H__
+#define __AALSDK_KERNEL_AALMAFU_EVENTS_H__
+#include <aalsdk/kernel/aalui-events.h>
+#include <aalsdk/kernel/aalmafu.h>
+
+BEGIN_NAMESPACE(AAL)
+
+//=============================================================================
+// Name: uidrv_event_mafu_ConfigureAFU
+// Description: Constructor
+// Inputs:
+//=============================================================================
+static inline struct uidrv_event_afu_response_event *
+   uidrv_event_mafu_ConfigureAFU_create( btObjectType             devhandle,
+                                         afu_descriptor          *pafudec,
+                                         btUnsigned32bitInt       respID,
+                                         stTransactionID_t       *tranID,
+                                         btObjectType             context,
+                                         uid_errnum_e             eno)
+{
+   // Response buffer structure defined as Response followed by payload
+   struct uidrv_event_afu_response_event * This =
+      (struct uidrv_event_afu_response_event *)kosal_kmalloc(sizeof(struct uidrv_event_afu_response_event));
+   if ( NULL == This ) {
+      return NULL;
+   }
+
+   memset(This, 0, sizeof(struct uidrv_event_afu_response_event));
+
+   This->m_devhandle = devhandle;
+   This->m_errnum    = eno;
+   This->m_context   = context;
+   This->m_tranID    = *tranID;
+   AALQ_QLEN(This)   = 0;
+   This->m_payload   = NULL;
+
+   //-------------------------------------------------------------
+   // Load the response data if present
+   //  - Uses the payload field so that the generic event delivery
+   //    code in uidrv_process_message() is consistent
+   //-------------------------------------------------------------
+   if ( NULL == pafudec ) {
+      This->m_response = (struct aalui_AFUResponse *) kosal_kmalloc(sizeof(struct aalui_AFUResponse));
+      if (unlikely((void*) This->m_response == NULL)) {
+         This->m_errnum = uid_errnumNoMem;
+      } else {
+         memset(This->m_response, 0, sizeof(struct aalui_AFUResponse));
+         This->m_response->respID = respID;
+         AALQ_QLEN(This) = sizeof(struct aalui_AFUResponse);
+      }
+   } else {
+      // Allocate the response
+      struct big {
+         struct aalui_AFUResponse rsp;
+         afu_descriptor           afu_desc;
+      };
+
+      // also implicitly sets m_response since m_response and m_payload are in a union
+      struct big *pbig = (struct big *)kosal_kmalloc(sizeof(struct big));
+      This->m_payload = (btVirtAddr)pbig;
+
+      if ( unlikely( NULL == This->m_payload ) ) {
+         This->m_errnum = uid_errnumNoMem;
+      } else {
+         memset(pbig, 0, sizeof(struct big));
+
+         pbig->rsp.respID         = respID;
+         pbig->rsp.payloadsize    = sizeof(afu_descriptor);
+
+         // Copy in the contents of the aalui_taskComplete
+         pbig->afu_desc           = *pafudec;
+         pbig->afu_desc.cfgStatus = 
+                     uid_afurespAFUCreateComplete == respID ? krms_ccfgUpdate_DevAdded : krms_ccfgUpdate_DevRemoved;;
+
+         AALQ_QLEN(This) = sizeof(struct aalui_AFUResponse) + sizeof(afu_descriptor);
+      }
+   }
+
+   AALQ_QID(This) = rspid_AFU_Response;
+
+   // Initialize the queue item
+   kosal_list_init(&AALQ_QUEUE(This));
+   return This;
+}
+
+
+//=============================================================================
+// Name: uidrv_event_mafu_DestroyAFU_create
+// Description: Constructor
+//=============================================================================
+static inline struct uidrv_event_afu_response_event *
+         uidrv_event_mafu_DestroyAFU_create( btObjectType              devhandle,
+                                             stTransactionID_t        *tranID,
+                                             btObjectType              context,
+                                             uid_errnum_e              eno)
+{
+   // Response buffer structure defined as Response followed by payload
+   struct uidrv_event_afu_response_event * This =
+      (struct uidrv_event_afu_response_event *) kosal_kmalloc(sizeof(struct uidrv_event_afu_response_event));
+   if ( NULL == This ) {
+      return NULL;
+   }
+   memset(This, 0, sizeof(struct uidrv_event_afu_response_event));
+
+   This->m_devhandle = devhandle;
+   This->m_errnum    = eno;
+   This->m_tranID    = *tranID;
+   This->m_context   = context;
+
+   This->m_payload = (btVirtAddr) kosal_kmalloc(sizeof(struct aalui_AFUResponse ));
+   if ( unlikely( NULL == This->m_payload ) ) {
+      This->m_errnum = uid_errnumNoMem;
+   } else {
+      memset(This->m_payload, 0, sizeof(struct aalui_AFUResponse));
+      This->m_response->respID = uid_afurespAFUDestroyComplete;
+      AALQ_QLEN(This) = sizeof(struct aalui_AFUResponse);
+   }
+
+   AALQ_QID(This) = rspid_AFU_Response;
+
+   // Initialize the queue item
+   kosal_list_init(&AALQ_QUEUE(This));
+   return This;
+}
+
+//=============================================================================
+// Name: uidrv_event_mafu_afuactivate_create
+// Description: Constructor
+//=============================================================================
+static inline struct uidrv_event_afu_response_event *
+      uidrv_event_mafu_afuactivate_create( btObjectType              devhandle,
+                                           unsigned                  subdev,
+                                           stTransactionID_t        *tranID,
+                                           btObjectType              context,
+                                           uid_errnum_e              eno)
+{
+   // Response buffer structure defined as Response followed by payload
+   struct uidrv_event_afu_response_event *This =
+      (struct uidrv_event_afu_response_event *) kosal_kmalloc(sizeof(struct uidrv_event_afu_response_event));
+   if ( NULL == This ) {
+      return NULL;
+   }
+
+   memset(This, 0, sizeof(struct uidrv_event_afu_response_event));
+
+   This->m_devhandle = devhandle;
+   This->m_tranID    = *tranID;
+   This->m_context   = context;
+   This->m_errnum    = eno;
+
+   This->m_response = (struct aalui_AFUResponse *) kosal_kmalloc(sizeof(struct aalui_AFUResponse));
+   if ( unlikely( NULL == This->m_response ) ) {
+      This->m_errnum = uid_errnumNoMem;
+   } else {
+      memset(This->m_response, 0, sizeof(struct aalui_AFUResponse));
+
+      This->m_response->respID  = uid_afurespActivateComplete;
+      This->m_response->evtData = subdev;
+
+      AALQ_QLEN(This) = sizeof(struct aalui_AFUResponse);
+   }
+
+   AALQ_QID(This) = rspid_AFU_Response;
+
+   // Initialize the queue item
+   kosal_list_init(&AALQ_QUEUE(This));
+   return This;
+}
+
+//=============================================================================
+// Name: uidrv_event_mafu_afudeactivate_create
+// Description: Constructor
+//=============================================================================
+static inline struct uidrv_event_afu_response_event *
+      uidrv_event_mafu_afudeactivate_create(btObjectType              devhandle,
+                                            unsigned                  subdev,
+                                            stTransactionID_t        *tranID,
+                                            btObjectType              context,
+                                            uid_errnum_e              eno)
+{
+   struct uidrv_event_afu_response_event * This =
+      (struct uidrv_event_afu_response_event *) kosal_kmalloc(sizeof(struct uidrv_event_afu_response_event));
+   if ( NULL == This ) {
+      return NULL;
+   }
+
+   memset(This, 0, sizeof(struct uidrv_event_afu_response_event));
+
+   This->m_devhandle = devhandle;
+   This->m_tranID    = *tranID;
+   This->m_context   = context;
+   This->m_errnum    = eno;
+
+   AALQ_QLEN(This) = 0;
+   This->m_payload = NULL;
+
+   This->m_response = (struct aalui_AFUResponse *) kosal_kmalloc(sizeof(struct aalui_AFUResponse));
+   if ( unlikely( NULL == This->m_response ) ) {
+      This->m_errnum = uid_errnumNoMem;
+   } else {
+      memset(This->m_response, 0, sizeof(struct aalui_AFUResponse));
+
+      This->m_response->respID  = uid_afurespDeactivateComplete;
+      This->m_response->evtData = subdev;
+
+      AALQ_QLEN(This) = sizeof(struct aalui_AFUResponse);
+   }
+
+   AALQ_QID(This) = rspid_AFU_Response;
+
+   // Initialize the queue item
+   kosal_list_init(&AALQ_QUEUE(This));
+   return This;
+}
+
+END_NAMESPACE(AAL)
+
+#endif // __AALSDK_KERNEL_AALMAFU_EVENTS_H__
+
diff --git a/drivers/fpga/aal/include/aalsdk/kernel/aalmafu.h b/drivers/fpga/aal/include/aalsdk/kernel/aalmafu.h
new file mode 100644
index 000000000000..bf8d9160aefd
--- /dev/null
+++ b/drivers/fpga/aal/include/aalsdk/kernel/aalmafu.h
@@ -0,0 +1,194 @@
+//******************************************************************************
+// This  file  is  provided  under  a  dual BSD/GPLv2  license.  When using or
+//         redistributing this file, you may do so under either license.
+//
+//                            GPL LICENSE SUMMARY
+//
+//  Copyright(c) 2009-2017, Intel Corporation.
+//
+//  This program  is  free software;  you  can redistribute it  and/or  modify
+//  it  under  the  terms of  version 2 of  the GNU General Public License  as
+//  published by the Free Software Foundation.
+//
+//  This  program  is distributed  in the  hope that it  will  be useful,  but
+//  WITHOUT   ANY   WARRANTY;   without   even  the   implied   warranty    of
+//  MERCHANTABILITY  or  FITNESS  FOR  A  PARTICULAR  PURPOSE.  See  the   GNU
+//  General Public License for more details.
+//
+//  The  full  GNU  General Public License is  included in  this  distribution
+//  in the file called README.GPLV2-LICENSE.TXT.
+//
+//  Contact Information:
+//  Henry Mitchel, henry.mitchel at intel.com
+//  77 Reed Rd., Hudson, MA  01749
+//
+//                                BSD LICENSE
+//
+//  Copyright(c) 2009-2017, Intel Corporation.
+//
+//  Redistribution and  use  in source  and  binary  forms,  with  or  without
+//  modification,  are   permitted  provided  that  the  following  conditions
+//  are met:
+//
+//    * Redistributions  of  source  code  must  retain  the  above  copyright
+//      notice, this list of conditions and the following disclaimer.
+//    * Redistributions in  binary form  must  reproduce  the  above copyright
+//      notice,  this  list of  conditions  and  the  following disclaimer  in
+//      the   documentation   and/or   other   materials   provided  with  the
+//      distribution.
+//    * Neither   the  name   of  Intel  Corporation  nor  the  names  of  its
+//      contributors  may  be  used  to  endorse  or promote  products derived
+//      from this software without specific prior written permission.
+//
+//  THIS  SOFTWARE  IS  PROVIDED  BY  THE  COPYRIGHT HOLDERS  AND CONTRIBUTORS
+//  "AS IS"  AND  ANY  EXPRESS  OR  IMPLIED  WARRANTIES,  INCLUDING,  BUT  NOT
+//  LIMITED  TO, THE  IMPLIED WARRANTIES OF  MERCHANTABILITY  AND FITNESS  FOR
+//  A  PARTICULAR  PURPOSE  ARE  DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT
+//  OWNER OR CONTRIBUTORS BE LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,
+//  SPECIAL,  EXEMPLARY,  OR  CONSEQUENTIAL   DAMAGES  (INCLUDING,   BUT   NOT
+//  LIMITED  TO,  PROCUREMENT  OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF USE,
+//  DATA,  OR PROFITS;  OR BUSINESS INTERRUPTION)  HOWEVER  CAUSED  AND ON ANY
+//  THEORY  OF  LIABILITY,  WHETHER  IN  CONTRACT,  STRICT LIABILITY,  OR TORT
+//  (INCLUDING  NEGLIGENCE  OR OTHERWISE) ARISING  IN ANY WAY  OUT  OF THE USE
+//  OF  THIS  SOFTWARE, EVEN IF ADVISED  OF  THE  POSSIBILITY  OF SUCH DAMAGE.
+//******************************************************************************
+//****************************************************************************
+//        FILE: aalmafu.h
+//     CREATED: Oct 22, 2009
+//      AUTHOR: Joseph Grecco, Intel Corporation.
+//
+// PURPOSE: Definitions for the AAL Management AFU low-level interface
+// HISTORY:
+// WHEN:          WHO:     WHAT:
+// 05/06/2009     HM       Removed inappropriate hard path coding of 
+//                            aas/kernel/include
+//****************************************************************************
+#ifndef __AALSDK_KERNEL_AALMAFU_H__
+#define __AALSDK_KERNEL_AALMAFU_H__
+#include <aalsdk/kernel/aaltypes.h>
+#include <aalsdk/kernel/iaaldevice.h>
+
+
+BEGIN_NAMESPACE(AAL)
+
+BEGIN_C_DECLS
+
+//----------------
+// MAFU commands
+//----------------
+typedef enum {
+   // Management AFU commands
+   aalui_mafucmd,
+   aalui_mafucmdActvateAFU,
+   aalui_mafucmdDeactvateAFU,
+   aalui_mafucmdInitializeAFU,
+   aalui_mafucmdFreeAFU,
+   aalui_mafucmdCreateAFU,
+   aalui_mafucmdDestroyAFU,
+} uid_mgtAfuCmdID_e;
+
+
+//=============================================================================
+// Name:        mafu_CreateAFU
+// Type[Dir]:   Request [IN]
+// Object:      PIP
+// Command ID:  aalui_mafucmdCreateAFU
+// Input:
+// Description: Used when sending a Create AFU request to the MAFU
+// Comments:    Pointed to by the payload of mafu_request.
+//              NOTE: The size parameter in mafu_request must equal
+//              sizeof(struct mafu_CreateAFU)+sizeof(uevent_args)
+//              where sizeof(uevent_args) will be
+//              sigma(strlen(uevent_args[0->(n-1)]) + n). In other words the
+//              size of the entire contiguous block.
+//=============================================================================
+struct mafu_CreateAFU {
+   struct aal_device_id    device_id;
+
+   btUnsignedInt           actionflags;            // state to leave device
+
+   // Name length must fit parameters of the Kobject device name
+   #define MAFU_MAX_BASENAME_LEN   8               // Maximum size of name base
+   btByte                  basename[MAFU_MAX_BASENAME_LEN+1]; // Base name of device
+   btUnsignedInt           maxshares;              // Maximum number of shares
+#define MAFU_CONFIGURE_UNLIMTEDSHARES  (~0U)
+
+   btUnsigned16bitInt      enableDirectAPI;        // Enable direct PIP access
+
+   btWSSize                manifest_size;          // Length of optional parms
+   btByteArray             manifest;               // Optional additional parms
+   btUnsignedInt           num_uevent_args;        // Number of uevent arguments
+   btByte                  uevent_args[1];         // Block of ASCIIZ args
+};
+
+#define mafu_CreateAFU_STATIC_INITIALIZER(mca) \
+{                                              \
+   .actionflags = 0,                           \
+   .basename = { 0, },                         \
+   .maxshares = 0,                             \
+   .enableDirectAPI = AAL_DEV_APIMAP_NONE,     \
+   .manifest_size = 0,                         \
+   .manifest = NULL,                           \
+   .num_uevent_args = 0,                       \
+}
+
+//=============================================================================
+// Name: afu_descriptor
+// Type[Dir]: Request{IN] Event/Response [OUT]
+// Object: MAFU engine
+// Description: Result from an AFU Create or enum. Contains basic AFU
+//              attributes.
+// Comments:
+//=============================================================================
+typedef struct afu_descriptor {
+   krms_cfgUpDate_e     cfgStatus;
+   struct aal_device_id devid;   // Device ID
+   btByte               basename[MAFU_MAX_BASENAME_LEN+1];
+} afu_descriptor;
+
+
+//=============================================================================
+// Name:        mafu_DestroyAFU
+// Type[Dir]:   Request [IN]
+// Object:      PIP
+// Command ID:  aalui_mafucmdDestroyAFU
+// Input:       dev_desc - afu_descriptor for device to destroy.
+// Description: Used when sending a Destroy AFU request to the MAFU
+// Comments:    Pointed to by the payload of mafu_request.
+//              The descriptor must be unambiguous and describe a device owned
+//              by this MAFU.
+//=============================================================================
+struct mafu_DestroyAFU {
+   afu_descriptor dev_desc;
+};
+
+
+//=============================================================================
+// Name: mafu_request
+// Type[Dir]: Request [IN]
+// Object: Management AFU
+// Command ID: reqid_UID_SendAFU
+// Input: subdeviceMask - device mask indicates devices to operate on
+//        size - size of optional payload
+//        payload - optional payload
+// Description: Request a device be configured
+//=============================================================================
+struct mafu_request {
+   uid_mgtAfuCmdID_e     cmd;              // Management AFU command
+
+   union {
+      btUnsigned64bitInt subdeviceMask;    // Channel
+      btObjectType       devhandle;        //device handle
+   };
+
+   btWSSize              size;             // size of payload
+   btVirtAddr            payload;          // optional payload, of length size
+};
+
+
+END_C_DECLS
+
+END_NAMESPACE(AAL)
+
+#endif // __AALSDK_KERNEL_AALMAFU_H__
+
diff --git a/drivers/fpga/aal/include/aalsdk/kernel/aalqueue.h b/drivers/fpga/aal/include/aalsdk/kernel/aalqueue.h
new file mode 100644
index 000000000000..d4966fbb68fe
--- /dev/null
+++ b/drivers/fpga/aal/include/aalsdk/kernel/aalqueue.h
@@ -0,0 +1,429 @@
+//******************************************************************************
+// This  file  is  provided  under  a  dual BSD/GPLv2  license.  When using or
+//         redistributing this file, you may do so under either license.
+//
+//                            GPL LICENSE SUMMARY
+//
+//  Copyright(c) 2008-2017, Intel Corporation.
+//
+//  This program  is  free software;  you  can redistribute it  and/or  modify
+//  it  under  the  terms of  version 2 of  the GNU General Public License  as
+//  published by the Free Software Foundation.
+//
+//  This  program  is distributed  in the  hope that it  will  be useful,  but
+//  WITHOUT   ANY   WARRANTY;   without   even  the   implied   warranty    of
+//  MERCHANTABILITY  or  FITNESS  FOR  A  PARTICULAR  PURPOSE.  See  the   GNU
+//  General Public License for more details.
+//
+//  The  full  GNU  General Public License is  included in  this  distribution
+//  in the file called README.GPLV2-LICENSE.TXT.
+//
+//  Contact Information:
+//  Henry Mitchel, henry.mitchel at intel.com
+//  77 Reed Rd., Hudson, MA  01749
+//
+//                                BSD LICENSE
+//
+//  Copyright(c) 2008-2017, Intel Corporation.
+//
+//  Redistribution and  use  in source  and  binary  forms,  with  or  without
+//  modification,  are   permitted  provided  that  the  following  conditions
+//  are met:
+//
+//    * Redistributions  of  source  code  must  retain  the  above  copyright
+//      notice, this list of conditions and the following disclaimer.
+//    * Redistributions in  binary form  must  reproduce  the  above copyright
+//      notice,  this  list of  conditions  and  the  following disclaimer  in
+//      the   documentation   and/or   other   materials   provided  with  the
+//      distribution.
+//    * Neither   the  name   of  Intel  Corporation  nor  the  names  of  its
+//      contributors  may  be  used  to  endorse  or promote  products derived
+//      from this software without specific prior written permission.
+//
+//  THIS  SOFTWARE  IS  PROVIDED  BY  THE  COPYRIGHT HOLDERS  AND CONTRIBUTORS
+//  "AS IS"  AND  ANY  EXPRESS  OR  IMPLIED  WARRANTIES,  INCLUDING,  BUT  NOT
+//  LIMITED  TO, THE  IMPLIED WARRANTIES OF  MERCHANTABILITY  AND FITNESS  FOR
+//  A  PARTICULAR  PURPOSE  ARE  DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT
+//  OWNER OR CONTRIBUTORS BE LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,
+//  SPECIAL,  EXEMPLARY,  OR  CONSEQUENTIAL   DAMAGES  (INCLUDING,   BUT   NOT
+//  LIMITED  TO,  PROCUREMENT  OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF USE,
+//  DATA,  OR PROFITS;  OR BUSINESS INTERRUPTION)  HOWEVER  CAUSED  AND ON ANY
+//  THEORY  OF  LIABILITY,  WHETHER  IN  CONTRACT,  STRICT LIABILITY,  OR TORT
+//  (INCLUDING  NEGLIGENCE  OR OTHERWISE) ARISING  IN ANY WAY  OUT  OF THE USE
+//  OF  THIS  SOFTWARE, EVEN IF ADVISED  OF  THE  POSSIBILITY  OF SUCH DAMAGE.
+//******************************************************************************
+//****************************************************************************
+//        FILE: aalqueue.h
+//     CREATED: 09/15/2008
+//      AUTHOR: Joseph Grecco
+//
+// PURPOSE:  External definitions for the AAL queue utilities
+// HISTORY:
+// COMMENTS:
+// WHEN:          WHO:     WHAT:
+// 09-15-08       JG       Initial version created
+// 11/11/2008     JG       Added legal header
+// 01/04/2009     HM       Updated Copyright
+// 02/03/2009     JG       Added _aal_q_swapqueue
+//                           Removed unused fields in queue struct.
+// 02/04/2009     JG       Added _aal_q_doForEachItem
+// 04/28/2010     HM       Added return value checks to kosal_sem_get_krnl_alertable()
+// 08/06/2010     HM       Added #include <asm/uaccess.h>, previously included
+//                            only implicitly
+// 04/19/2012     TSW      Deprecate __func__ in favor of platform-agnostic
+//                          __AAL_FUNC__.
+// 09/12/2010     HM       Added LINUX_VERSION_CODE for semaphore.h
+//****************************************************************************
+#ifndef __AALSDK_KERNEL_AALQUEUE_H__
+#define __AALSDK_KERNEL_AALQUEUE_H__
+#include <aalsdk/kernel/kosal.h>
+
+
+BEGIN_NAMESPACE(AAL)
+
+//-----------------------------------------------------------------------------
+//                         Queue Primitives
+//-----------------------------------------------------------------------------
+
+//=============================================================================
+// Name: rm_q_item
+// Description: Base class for queuable requests
+//=============================================================================
+struct aal_q_item {
+   btID            m_id;
+   btWSSize        m_length;
+   kosal_list_head m_queue;
+};
+
+//Macro used to embed this type in a subclass structure
+#define _DECLARE_AALQ_TYPE struct aal_q_item  m_qitem
+
+// Macros for accessing base members
+#define QI_QUEUE(pqi)      ((pqi)->m_queue)
+#define QI_QID(pqi)        ((pqi)->m_id)
+#define QI_LEN(pqi)        (NULL == (pqi) ? 0 : (pqi)->m_length)
+
+// Macros for accessing base members
+#define AALQI(pqi)         ((pqi)->m_qitem)
+#define AALQIP(pqi)        (&(pqi)->m_qitem)
+#define AALQ_QUEUE(pqi)    ((pqi)->m_qitem.m_queue)
+#define AALQ_QID(pqi)      ((pqi)->m_qitem.m_id)
+#define AALQ_QLEN(pqi)     ((pqi)->m_qitem.m_length)
+
+
+//=============================================================================
+// Name: aal_queue_t
+// Description: AAL queue object
+//=============================================================================
+typedef struct {
+   kosal_mutex     m_sem;
+   kosal_list_head m_queue;
+} aal_queue_t;
+
+//=============================================================================
+// Name: aal_queue_t
+// Description: AAL queue object
+//=============================================================================
+inline static void aal_queue_init(aal_queue_t *thisQueue)
+{
+   // Initialize base members
+   kosal_list_init(&thisQueue->m_queue);
+   kosal_mutex_init(&thisQueue->m_sem);
+}
+
+
+
+//=============================================================================
+// Name: _aal_q_enqueue
+// Description: Queues a request
+// Interface: private
+// Inputs: pqitem - item
+//         pqueue - queue
+// Outputs: none.
+// Comments:
+//=============================================================================
+static inline void _aal_q_enqueue(struct aal_q_item *pqitem,
+                                  aal_queue_t       *pqueue)
+{
+   // kosal_sem_get_user_alertable(&pqueue->m_sem);
+   // Try to acquire lock. If cannot, then abort.
+   if ( unlikely( kosal_sem_get_user_alertable(&pqueue->m_sem) ) ) {
+      kosal_printk("kosal_sem_get_user_alertable interrupted in.\n");
+      return;
+   }
+   kosal_list_add_tail(&pqitem->m_queue, &pqueue->m_queue);
+   kosal_sem_put(&pqueue->m_sem);
+}
+
+
+//=============================================================================
+// Name: _aal_q_pushqueue
+// Description: Queues a request on head
+// Interface: private
+// Inputs: pqitem - item
+//         pqueue - queue
+// Outputs: none.
+// Comments:
+//=============================================================================
+static inline void _aal_q_pushqueue(struct aal_q_item *pqitem,
+                                    aal_queue_t       *pqueue)
+{
+   // kosal_sem_get_user_alertable(&pqueue->m_sem);
+   // Try to acquire lock. If cannot, then abort.
+   if ( unlikely( kosal_sem_get_user_alertable(&pqueue->m_sem) ) ) {
+      kosal_printk("kosal_sem_get_user_alertable interrupted.\n");
+      return;
+   }
+   kosal_list_add_head( &pqitem->m_queue, &pqueue->m_queue );
+   kosal_sem_put(&pqueue->m_sem);
+}
+
+
+//=============================================================================
+// Name: _aal_q_dequeue
+// Description: Get the next item from the queue
+// Interface: private
+// Inputs: pqueue - queue
+// Returns: next item; NULL - empty.
+// Comments:
+//=============================================================================
+static inline struct aal_q_item * _aal_q_dequeue(aal_queue_t *pqueue)
+{
+   struct aal_q_item *pqitem;
+
+   // kosal_sem_get_user_alertable(&pqueue->m_sem);
+   // Try to acquire lock. If cannot, then abort.
+   if ( unlikely( kosal_sem_get_user_alertable(&pqueue->m_sem) ) ) {
+      kosal_printk("kosal_sem_get_user_alertable interrupted in.\n");
+      return NULL;
+   }
+
+   if ( kosal_list_is_empty(&pqueue->m_queue) ) {
+      kosal_sem_put(&pqueue->m_sem);
+      return NULL;
+   }
+
+   // Get a pointer to the item
+   pqitem = kosal_list_get_object(kosal_list_next(&pqueue->m_queue), 
+                                  struct aal_q_item, 
+                                  m_queue);
+
+   kosal_list_del_init(&pqitem->m_queue);
+
+   kosal_sem_put(&pqueue->m_sem);
+
+   return pqitem;
+}
+
+//=============================================================================
+// Name: _aal_q_swapqueue
+// Description: Swap item from one queue to another atomically
+// Interface: private
+// Inputs: pfrom - queue the item should be on
+//         pto - queue the item will be placed on
+// Returns: none
+// Comments: Note that for performance reasons the from queue is not checked
+//           to see if the item is actually present. If it is not then the
+//           result is the same as if an enqueue was done to pto while pfrom
+//           is protected from change.
+//=============================================================================
+static inline void _aal_q_swapqueue(struct aal_q_item *pqitem,
+                                    aal_queue_t       *pfrom,
+                                    aal_queue_t       *pto)
+{
+
+//   kosal_sem_get_user_alertable(&pfrom->m_sem);
+//   kosal_sem_get_user_alertable(&pto->m_sem);
+
+   // Try to acquire lock. If cannot, then abort.
+   if ( unlikely( kosal_sem_get_user_alertable(&pfrom->m_sem) ) ) {
+      kosal_printk("kosal_sem_get_user_alertable of &pfrom->m_sem interrupted.\n");
+      return;
+   }
+
+   // Try to acquire lock. If cannot, then abort.
+   if ( unlikely( kosal_sem_get_user_alertable(&pto->m_sem) ) ) {
+      kosal_printk("kosal_sem_get_user_alertable of &pto->m_sem interrupted.\n");
+      kosal_sem_put(&pfrom->m_sem);
+      return;
+   }
+
+   // Remove the item
+   kosal_list_del_init(&pqitem->m_queue);
+
+   // Add to target queue
+   kosal_list_add_tail(&pqitem->m_queue, &pto->m_queue);
+
+   kosal_sem_put(&pto->m_sem);
+   kosal_sem_put(&pfrom->m_sem);
+}
+
+//=============================================================================
+// Name: _aal_q_peek
+// Description: Get the next item from the request queue without dequeing
+// Interface: private
+// Inputs: pqueue - queue
+// Returns: next item; NULL - empty.
+// Comments: returns NULL if cannot acquire mutex, even if not empty
+//=============================================================================
+static inline struct aal_q_item * _aal_q_peek(aal_queue_t *pqueue)
+{
+   struct aal_q_item *pqitem;
+
+   // FIXME 20100428 -- Joe, you need to look at this error return value
+   // kosal_sem_get_user_alertable(&pqueue->m_sem);
+   // Try to acquire lock. If cannot, then abort.
+   if ( unlikely( kosal_sem_get_user_alertable(&pqueue->m_sem) ) ) {
+      kosal_printk("kosal_sem_get_user_alertable interrupted.\n");
+      return NULL;
+   }
+
+   if ( kosal_list_is_empty(&pqueue->m_queue) ) {
+      kosal_sem_put(&pqueue->m_sem);
+      return NULL;
+   }
+
+   // Get a pointer to the item
+   pqitem = kosal_list_get_object(kosal_list_next(&pqueue->m_queue), struct aal_q_item, m_queue);
+
+   kosal_sem_put(&pqueue->m_sem);
+
+   return pqitem;
+}
+
+
+//=============================================================================
+// Name: _aal_q_empty
+// Description: return status of  queue
+// Interface: private
+// Inputs: pqueue - queue
+// Returns: >0 - empty
+// Comments: Returns "empty" if cannot lock semaphore
+//=============================================================================
+static inline int _aal_q_empty(aal_queue_t *pqueue)
+{
+   int ret = 0;
+
+   // kosal_sem_get_user_alertable(&pqueue->m_sem);
+   // Try to acquire lock. If cannot, then abort.
+   if ( unlikely( kosal_sem_get_user_alertable(&pqueue->m_sem) ) ) {
+      kosal_printk("kosal_sem_get_user_alertable interrupted.\n");
+      return 0;
+   }
+
+   ret = kosal_list_is_empty(&pqueue->m_queue);
+   kosal_sem_put(&pqueue->m_sem);
+   return ret;
+}
+
+//=============================================================================
+// Name: _aal_q_find
+// Description: return whether an item is on a specified queue
+// Interface: private
+// Inputs: pqitem - item
+//         pqueue - queue
+// Returns: aal_q_item * pqitem - found item
+// Comments:
+//=============================================================================
+static inline kosal_list_head * _aal_q_find(pkosal_list_head pitem,
+                                            aal_queue_t     *pqueue)
+{
+
+   pkosal_list_head pitr;
+   pkosal_list_head result = NULL;
+
+   // kosal_sem_get_user_alertable(&pqueue->m_sem);
+   // Try to acquire lock. If cannot, then abort.
+   if ( unlikely( kosal_sem_get_user_alertable(&pqueue->m_sem) ) ) {
+      kosal_printk("kosal_sem_get_user_alertable interrupted.\n");
+      return NULL;
+   }
+
+   //Loop through the list looking for a match
+   kosal_list_for_each(pitr, &pqueue->m_queue) {
+      if( pitr == pitem ) {
+         result = pitr;
+         break;
+      }
+   }
+   kosal_sem_put(&pqueue->m_sem);
+   return result;
+}
+
+//=============================================================================
+// Name: _aal_q_remove
+// Description: remove an entry from the queue
+// Interface: private
+// Inputs: pitem - item
+// Comments:
+//=============================================================================
+static inline void _aal_q_remove(pkosal_list_head pitem,
+                                 aal_queue_t     *pqueue)
+{
+   // kosal_sem_get_user_alertable(&pqueue->m_sem);
+   // Try to acquire lock. If cannot, then abort.
+   if ( unlikely( kosal_sem_get_user_alertable(&pqueue->m_sem) ) ) {
+      kosal_printk("kosal_sem_get_user_alertable interrupted.\n");
+      return;
+   }
+
+   kosal_list_del_init(pitem);
+
+   kosal_sem_put(&pqueue->m_sem);
+}
+
+
+
+//=============================================================================
+// Name: _aal_q_doForEachItem
+// Description: Calls the function pointed to by fcn for each item on the
+//              queue pointed to by pqueue. Continues until queue is empty or
+//              the callback returns non-zero. The context is used to provide
+//              the callback with additional arguments it needs.
+// Interface: public
+// Inputs: pqueue - queue to process
+//         fcn - pointer to callback
+//         context - context to pass
+// Returns: pointer to last item processed or NULL if list completed
+// Comments:
+//=============================================================================
+//-----------------------------------------------------------------------------
+// Prototype for call back used in doForeachOwner
+typedef int (*aal_q_ProcessItem_t)(struct aal_q_item *,
+                                   aal_queue_t *,
+                                   btAny );
+//-----------------------------------------------------------------------------
+static inline struct aal_q_item * _aal_q_doForEachItem(aal_queue_t        *pqueue,
+                                                       aal_q_ProcessItem_t fcn,
+                                                       btAny               context)
+{
+   pkosal_list_head   pitr;
+   pkosal_list_head   temp;
+   struct aal_q_item *pqitem = NULL;
+
+   // kosal_sem_get_user_alertable(&pqueue->m_sem);
+   // Try to acquire lock. If cannot, then abort.
+   if ( unlikely( kosal_sem_get_user_alertable(&pqueue->m_sem) ) ) {
+      kosal_printk("kosal_sem_get_user_alertable interrupted.\n");
+      return NULL;
+   }
+   
+   UNREFERENCED_PARAMETER(temp);
+   //Loop through the list looking for a match
+   kosal_list_for_each_safe(pitr, temp, &pqueue->m_queue) {
+      pqitem = kosal_get_object_containing(pitr, struct aal_q_item, m_queue);
+      // If the function returns non-zero return current item
+      if ( fcn(pqitem, pqueue, context) != 0 ) {
+         kosal_sem_put(&pqueue->m_sem);
+         return pqitem;
+      }
+   }
+
+   kosal_sem_put(&pqueue->m_sem);
+   return NULL;
+}
+
+END_NAMESPACE(AAL)
+
+#endif // __AALSDK_KERNEL_AALQUEUE_H__
+
diff --git a/drivers/fpga/aal/include/aalsdk/kernel/aalrm-services.h b/drivers/fpga/aal/include/aalsdk/kernel/aalrm-services.h
new file mode 100644
index 000000000000..8a5398bb76d3
--- /dev/null
+++ b/drivers/fpga/aal/include/aalsdk/kernel/aalrm-services.h
@@ -0,0 +1,100 @@
+//******************************************************************************
+// This  file  is  provided  under  a  dual BSD/GPLv2  license.  When using or
+//         redistributing this file, you may do so under either license.
+//
+//                            GPL LICENSE SUMMARY
+//
+//  Copyright(c) 2008-2017, Intel Corporation.
+//
+//  This program  is  free software;  you  can redistribute it  and/or  modify
+//  it  under  the  terms of  version 2 of  the GNU General Public License  as
+//  published by the Free Software Foundation.
+//
+//  This  program  is distributed  in the  hope that it  will  be useful,  but
+//  WITHOUT   ANY   WARRANTY;   without   even  the   implied   warranty    of
+//  MERCHANTABILITY  or  FITNESS  FOR  A  PARTICULAR  PURPOSE.  See  the   GNU
+//  General Public License for more details.
+//
+//  The  full  GNU  General Public License is  included in  this  distribution
+//  in the file called README.GPLV2-LICENSE.TXT.
+//
+//  Contact Information:
+//  Henry Mitchel, henry.mitchel at intel.com
+//  77 Reed Rd., Hudson, MA  01749
+//
+//                                BSD LICENSE
+//
+//  Copyright(c) 2008-2017, Intel Corporation.
+//
+//  Redistribution and  use  in source  and  binary  forms,  with  or  without
+//  modification,  are   permitted  provided  that  the  following  conditions
+//  are met:
+//
+//    * Redistributions  of  source  code  must  retain  the  above  copyright
+//      notice, this list of conditions and the following disclaimer.
+//    * Redistributions in  binary form  must  reproduce  the  above copyright
+//      notice,  this  list of  conditions  and  the  following disclaimer  in
+//      the   documentation   and/or   other   materials   provided  with  the
+//      distribution.
+//    * Neither   the  name   of  Intel  Corporation  nor  the  names  of  its
+//      contributors  may  be  used  to  endorse  or promote  products derived
+//      from this software without specific prior written permission.
+//
+//  THIS  SOFTWARE  IS  PROVIDED  BY  THE  COPYRIGHT HOLDERS  AND CONTRIBUTORS
+//  "AS IS"  AND  ANY  EXPRESS  OR  IMPLIED  WARRANTIES,  INCLUDING,  BUT  NOT
+//  LIMITED  TO, THE  IMPLIED WARRANTIES OF  MERCHANTABILITY  AND FITNESS  FOR
+//  A  PARTICULAR  PURPOSE  ARE  DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT
+//  OWNER OR CONTRIBUTORS BE LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,
+//  SPECIAL,  EXEMPLARY,  OR  CONSEQUENTIAL   DAMAGES  (INCLUDING,   BUT   NOT
+//  LIMITED  TO,  PROCUREMENT  OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF USE,
+//  DATA,  OR PROFITS;  OR BUSINESS INTERRUPTION)  HOWEVER  CAUSED  AND ON ANY
+//  THEORY  OF  LIABILITY,  WHETHER  IN  CONTRACT,  STRICT LIABILITY,  OR TORT
+//  (INCLUDING  NEGLIGENCE  OR OTHERWISE) ARISING  IN ANY WAY  OUT  OF THE USE
+//  OF  THIS  SOFTWARE, EVEN IF ADVISED  OF  THE  POSSIBILITY  OF SUCH DAMAGE.
+//******************************************************************************
+//****************************************************************************
+//        FILE: aalrm-services.h
+//     CREATED: 02/20/2008
+//      AUTHOR: Joseph Grecco - Intel
+//
+// PURPOSE: This file contains public definitions for the
+//          AAL Resource Manager Kernel Module Service Interfaces
+// HISTORY:
+// COMMENTS:
+// WHEN:          WHO:     WHAT:
+// 02/20/08       JG       Initial version created
+// 11/11/2008     JG       Added legal header
+// 01/04/2009     HM       Updated Copyright
+//****************************************************************************
+#ifndef __AALSDK_KERNEL_AALRM_SERVICES_H__
+#define __AALSDK_KERNEL_AALRM_SERVICES_H__
+#include <aalsdk/kernel/aalbus.h>
+#include <aalsdk/kernel/aalrm.h>
+
+BEGIN_NAMESPACE(AAL)
+
+//-----------------------------------------------------------------------------
+// Public Interface
+//-----------------------------------------------------------------------------
+
+//Interface Identifier
+#define  AALRM_API_MAJVERSION     (0x00000001)
+#define  AALRM_API_MINVERSION     (0x00000000)
+#define  AALRM_API_RELEASE        (0x00000000)
+
+#define  AALRM_API_INTC           (0x0000000000001000)
+
+// API IIDs TODO should come from aal ids
+#define AAL_RMAPI_IID_01         (0x1)
+
+
+//=============================================================================
+//=============================================================================
+//                       Resource Manager Service interface
+//=============================================================================
+//=============================================================================
+
+END_NAMESPACE(AAL)
+
+#endif // __AALSDK_KERNEL_AALRM_SERVICES_H__
+
diff --git a/drivers/fpga/aal/include/aalsdk/kernel/aalrm.h b/drivers/fpga/aal/include/aalsdk/kernel/aalrm.h
new file mode 100644
index 000000000000..6c266f8db56a
--- /dev/null
+++ b/drivers/fpga/aal/include/aalsdk/kernel/aalrm.h
@@ -0,0 +1,215 @@
+//******************************************************************************
+// This  file  is  provided  under  a  dual BSD/GPLv2  license.  When using or
+//         redistributing this file, you may do so under either license.
+//
+//                            GPL LICENSE SUMMARY
+//
+//  Copyright(c) 2008-2017, Intel Corporation.
+//
+//  This program  is  free software;  you  can redistribute it  and/or  modify
+//  it  under  the  terms of  version 2 of  the GNU General Public License  as
+//  published by the Free Software Foundation.
+//
+//  This  program  is distributed  in the  hope that it  will  be useful,  but
+//  WITHOUT   ANY   WARRANTY;   without   even  the   implied   warranty    of
+//  MERCHANTABILITY  or  FITNESS  FOR  A  PARTICULAR  PURPOSE.  See  the   GNU
+//  General Public License for more details.
+//
+//  The  full  GNU  General Public License is  included in  this  distribution
+//  in the file called README.GPLV2-LICENSE.TXT.
+//
+//  Contact Information:
+//  Henry Mitchel, henry.mitchel at intel.com
+//  77 Reed Rd., Hudson, MA  01749
+//
+//                                BSD LICENSE
+//
+//  Copyright(c) 2008-2017, Intel Corporation.
+//
+//  Redistribution and  use  in source  and  binary  forms,  with  or  without
+//  modification,  are   permitted  provided  that  the  following  conditions
+//  are met:
+//
+//    * Redistributions  of  source  code  must  retain  the  above  copyright
+//      notice, this list of conditions and the following disclaimer.
+//    * Redistributions in  binary form  must  reproduce  the  above copyright
+//      notice,  this  list of  conditions  and  the  following disclaimer  in
+//      the   documentation   and/or   other   materials   provided  with  the
+//      distribution.
+//    * Neither   the  name   of  Intel  Corporation  nor  the  names  of  its
+//      contributors  may  be  used  to  endorse  or promote  products derived
+//      from this software without specific prior written permission.
+//
+//  THIS  SOFTWARE  IS  PROVIDED  BY  THE  COPYRIGHT HOLDERS  AND CONTRIBUTORS
+//  "AS IS"  AND  ANY  EXPRESS  OR  IMPLIED  WARRANTIES,  INCLUDING,  BUT  NOT
+//  LIMITED  TO, THE  IMPLIED WARRANTIES OF  MERCHANTABILITY  AND FITNESS  FOR
+//  A  PARTICULAR  PURPOSE  ARE  DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT
+//  OWNER OR CONTRIBUTORS BE LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,
+//  SPECIAL,  EXEMPLARY,  OR  CONSEQUENTIAL   DAMAGES  (INCLUDING,   BUT   NOT
+//  LIMITED  TO,  PROCUREMENT  OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF USE,
+//  DATA,  OR PROFITS;  OR BUSINESS INTERRUPTION)  HOWEVER  CAUSED  AND ON ANY
+//  THEORY  OF  LIABILITY,  WHETHER  IN  CONTRACT,  STRICT LIABILITY,  OR TORT
+//  (INCLUDING  NEGLIGENCE  OR OTHERWISE) ARISING  IN ANY WAY  OUT  OF THE USE
+//  OF  THIS  SOFTWARE, EVEN IF ADVISED  OF  THE  POSSIBILITY  OF SUCH DAMAGE.
+//******************************************************************************
+//****************************************************************************
+//        FILE: aalrm.h
+//     CREATED: 02/25/2008
+//      AUTHOR: Joseph Grecco - Intel
+//
+// PURPOSE: This file contains public definitions common to the
+//          AAL Resource Manager Server and Client Kernel Module Interface
+// HISTORY:
+// COMMENTS:
+// WHEN:          WHO:     WHAT:
+// 02/25/08       JG       Initial version created
+// 11/10/08       JG       Separated common definitions
+// 11/11/2008     JG       Added legal header
+// 01/04/2009     HM       Updated Copyright
+// 01/08/2009     JG       Cleanup and refactoring
+//****************************************************************************
+#ifndef __AALSDK_KERNEL_AALRM_H__
+#define __AALSDK_KERNEL_AALRM_H__
+#include <aalsdk/kernel/AALTransactionID_s.h>
+#include <aalsdk/kernel/iaaldevice.h>
+
+BEGIN_NAMESPACE(AAL)
+
+BEGIN_C_DECLS
+
+
+//-----------------------------------------------------------------------------
+// Request message IDs
+//-----------------------------------------------------------------------------
+typedef enum
+{
+   // User Resource Manager requests
+   reqid_URMS_RequestDevice=1,      // Device Allocation Request
+   reqid_URMS_ReleaseDevice,        // Device Release Request
+
+   // Registrar requests
+   reqid_RS_Registrar,              // Registrar Request
+
+   // Device configuration requests
+   reqid_RM_DeviceRequest,          // Send a device request
+
+   // Administration
+   reqid_Shutdown,                  // Request that the Service session shutdown
+   reqid_Restart,                   // Request to restart the RMCS without close/open
+
+   // Kernel Resource Manager requests
+   reqid_KRMS_SetConfigUpdates,     // Used to set configuration updates
+
+   // Response and Event IDs
+   rspid_URMS_RequestDevice=0xF000, // Device Allocation Response
+
+   // Registrar responses and events
+   rspid_RS_Registrar,              // Registrar Response
+
+   // Device configuration requests
+   rspid_RM_DeviceRequest,          // Device Request response
+
+   // Kernel Resource Manager Responses and events
+   evtid_KRMS_ConfigUpdate,         // Configuration Update
+
+   // Administration
+   rspid_Shutdown,                  // Service is shutdown
+   rspid_Started,
+
+   // FPGA API queries and enumeration requests
+   apiid_Enumerate,
+   apiid_GetProperties
+
+} rms_msgIDs_e;
+
+//-----------------------------------------------------------------------------
+// Request message IDs
+//-----------------------------------------------------------------------------
+typedef enum
+{
+   rms_resultOK = aaldev_addowner_OK,                      // No error
+   rms_resultMaxOwnersErr = aaldev_addowner_MaxOwners,     // Max device owners
+   rms_resultDuplicateOwnerErr = aaldev_addowner_DupOwner, // PID already owner
+   rms_resultNotOwnerErr = aaldev_addowner_NotOwner,       // PID not owner
+   rms_resultInvalidDevice = aaldev_addowner_InvalidDevice,// Invalid device handle
+   rms_resultErrno,                    // Errno has only info
+   rms_resultBadParm,                  // Invalid parameter
+   rms_resultCancelled,                // Transaction cancelled
+   rms_resultDeviceHasNoPIPAssigned,   // No PIP assigned
+   rms_resultNoAppropriateInterface,   // No interface
+   rms_resultSystemErr = aaldev_addowner_SysErr             // System Error
+} rms_result_e;
+
+
+//-----------------------------------------------------------------------------
+// Shutdown reason codes
+//-----------------------------------------------------------------------------
+typedef enum
+{
+   rms_shutdownReasonNormal=0,
+   rms_shutdownReasonMaint,
+   rms_rms_shutdownFailure,
+   rms_rms_shutdownReasonRestart
+} rms_shutdownreason_e;
+
+
+//=============================================================================
+// Name: aalrms_DeviceRequest
+// Type[Dir]: Request [IN]
+// Object: Kernel Resource Manager Service
+// Command ID: reqid_RM_DeviceRequest
+// Input:
+// Description: Request a device be configured
+//=============================================================================
+struct aalrms_DeviceRequest {
+   btUnsigned64bitInt         subdeviceMask; // Channel [IN]
+   enum aal_device_request_e  reqid;         // Request id
+   btWSSize                   size;          // size of payload [IN]
+   btByte                     payload;       // first char of variably length payload [IN]
+};
+
+// Size of structure without payload
+#define DEVREQUEST_DEVHDRSZ  ( offsetof(struct aalrms_DeviceRequest, payload) )
+
+
+
+//=============================================================================
+// Name: aalrm_ioctlreq
+// Description: Structure used for sending and receiving messages between the
+//              Resource Manager user and the AAL kernel
+//              services
+// Comments: Fields labeled [IN] refer to parameters that are passed into the
+//           kernel services from the user space app. OUT refers to parameters
+//           that will be filled in by the kernel services.
+//=============================================================================
+struct aalrm_ioctlreq {
+   // Message header
+   rms_msgIDs_e          id;          // ID of request on Queue Head [IN/OUT]
+   rms_result_e          result_code; // Result code [IN/OUT]
+   btObjectType          req_handle;  // Request Handle used in response [IN/OUT]
+   stTransactionID_t     tranID;      // TransactionID
+   btObjectType          context;     // Context
+   // Generic Payload
+   union
+   {
+      btUnsigned64bitInt data;        // Payload data [IN/OUT]
+      btObjectType       res_handle;  // Resource handle
+   };
+   btWSSize              size;        // Size of payload [IN/OUT]
+   btVirtAddr            payload;     // Pointer to Payload buffer [IN/OUT]
+};
+
+
+#ifdef __AAL_LINUX__
+# define AALRM_IOCTL_GETMSG_DESC  _IOR  ('x', 0x00, struct aalrm_ioctlreq)
+# define AALRM_IOCTL_GETMSG       _IOWR ('x', 0x01, struct aalrm_ioctlreq)
+# define AALRM_IOCTL_SENDMSG      _IOWR ('x', 0x02, struct aalrm_ioctlreq)
+#endif // __AAL_LINUX__
+
+
+END_C_DECLS
+
+END_NAMESPACE(AAL)
+
+#endif // __AALSDK_KERNEL_AALRM_H__
+
diff --git a/drivers/fpga/aal/include/aalsdk/kernel/aalrm_client.h b/drivers/fpga/aal/include/aalsdk/kernel/aalrm_client.h
new file mode 100644
index 000000000000..29dbec5febe3
--- /dev/null
+++ b/drivers/fpga/aal/include/aalsdk/kernel/aalrm_client.h
@@ -0,0 +1,158 @@
+//******************************************************************************
+// This  file  is  provided  under  a  dual BSD/GPLv2  license.  When using or
+//         redistributing this file, you may do so under either license.
+//
+//                            GPL LICENSE SUMMARY
+//
+//  Copyright(c) 2008-2017, Intel Corporation.
+//
+//  This program  is  free software;  you  can redistribute it  and/or  modify
+//  it  under  the  terms of  version 2 of  the GNU General Public License  as
+//  published by the Free Software Foundation.
+//
+//  This  program  is distributed  in the  hope that it  will  be useful,  but
+//  WITHOUT   ANY   WARRANTY;   without   even  the   implied   warranty    of
+//  MERCHANTABILITY  or  FITNESS  FOR  A  PARTICULAR  PURPOSE.  See  the   GNU
+//  General Public License for more details.
+//
+//  The  full  GNU  General Public License is  included in  this  distribution
+//  in the file called README.GPLV2-LICENSE.TXT.
+//
+//  Contact Information:
+//  Henry Mitchel, henry.mitchel at intel.com
+//  77 Reed Rd., Hudson, MA  01749
+//
+//                                BSD LICENSE
+//
+//  Copyright(c) 2008-2017, Intel Corporation.
+//
+//  Redistribution and  use  in source  and  binary  forms,  with  or  without
+//  modification,  are   permitted  provided  that  the  following  conditions
+//  are met:
+//
+//    * Redistributions  of  source  code  must  retain  the  above  copyright
+//      notice, this list of conditions and the following disclaimer.
+//    * Redistributions in  binary form  must  reproduce  the  above copyright
+//      notice,  this  list of  conditions  and  the  following disclaimer  in
+//      the   documentation   and/or   other   materials   provided  with  the
+//      distribution.
+//    * Neither   the  name   of  Intel  Corporation  nor  the  names  of  its
+//      contributors  may  be  used  to  endorse  or promote  products derived
+//      from this software without specific prior written permission.
+//
+//  THIS  SOFTWARE  IS  PROVIDED  BY  THE  COPYRIGHT HOLDERS  AND CONTRIBUTORS
+//  "AS IS"  AND  ANY  EXPRESS  OR  IMPLIED  WARRANTIES,  INCLUDING,  BUT  NOT
+//  LIMITED  TO, THE  IMPLIED WARRANTIES OF  MERCHANTABILITY  AND FITNESS  FOR
+//  A  PARTICULAR  PURPOSE  ARE  DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT
+//  OWNER OR CONTRIBUTORS BE LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,
+//  SPECIAL,  EXEMPLARY,  OR  CONSEQUENTIAL   DAMAGES  (INCLUDING,   BUT   NOT
+//  LIMITED  TO,  PROCUREMENT  OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF USE,
+//  DATA,  OR PROFITS;  OR BUSINESS INTERRUPTION)  HOWEVER  CAUSED  AND ON ANY
+//  THEORY  OF  LIABILITY,  WHETHER  IN  CONTRACT,  STRICT LIABILITY,  OR TORT
+//  (INCLUDING  NEGLIGENCE  OR OTHERWISE) ARISING  IN ANY WAY  OUT  OF THE USE
+//  OF  THIS  SOFTWARE, EVEN IF ADVISED  OF  THE  POSSIBILITY  OF SUCH DAMAGE.
+//******************************************************************************
+//****************************************************************************
+//        FILE: aalrm-client.h
+//     CREATED: 02/20/2008
+//      AUTHOR: Joseph Grecco - Intel
+//
+// PURPOSE: This file contains public definitions for the
+//          AAL Resource Manager Client Service Module Interface
+// HISTORY:
+// COMMENTS:
+// WHEN:          WHO:     WHAT:
+// 02/20/08       JG       Initial version created
+// 11/10/08       JG       Renamed aalrm_client to separate out rmc specifics
+//                            from common definitions
+// 11/11/2008     JG       Added legal header
+// 01/04/2009     HM       Updated Copyright
+// 01/08/2009     JG       Cleanup and refactoring
+//****************************************************************************
+#ifndef __AALSDK_KERNEL_AALRM_CLIENT_H__
+#define __AALSDK_KERNEL_AALRM_CLIENT_H__
+#include <aalsdk/kernel/aalrm.h>
+
+BEGIN_NAMESPACE(AAL)
+
+BEGIN_C_DECLS
+
+#define RESMGR_DEV_NAME "aalresmgr"
+
+///////////////////////////////////////////////////////////////////////////////
+///////////////////////////////////////////////////////////////////////////////
+////////////////////                                     //////////////////////
+/////////////////     RESOURCE MANAGER CLIENT INTERFACE    ////////////////////
+////////////////////                                     //////////////////////
+///////////////////////////////////////////////////////////////////////////////
+///////////////////////////////////////////////////////////////////////////////
+//=============================================================================
+//=============================================================================
+
+//=============================================================================
+// Message headers - These headers are used by the user space clients
+//=============================================================================
+
+
+//=============================================================================
+// Name: req_allocdev
+// Description: Request a device allocation using a manifest
+//=============================================================================
+// Request device
+struct req_allocdev
+{
+   stTransactionID_t  tranID;   // transaction ID to identify result [IN]
+   void              *context;  // optional token [IN]v
+   size_t             size;     // size of payload [IN]
+   btByte             buf;      // first char of variably length payload [IN]
+};
+
+#define ALLOC_DEVHDRSZ  ( offsetof(struct req_allocdev, buf) )
+
+//=============================================================================
+// Name: req_registrar
+// Description: Send a request to the registrar
+//=============================================================================
+// Request device
+struct req_registrar
+{
+   stTransactionID_t  tranID;   // transaction ID to identify result [IN]
+   void              *context;  // optional token [IN]
+   size_t             size;     // size of payload [IN]
+   btByte             buf;      // first char of variably length payload [IN]
+};
+#define REGISTRAR_REQ_HDRSZ  ( offsetof(struct req_registrar, buf) )
+
+//=============================================================================
+// Name: rsp_device
+// Description: Response to a device specific request
+//=============================================================================
+struct rsp_device
+{
+   btInt              result;    // result code [OUT]
+   void              *devHandle; // device handle. NULL if no device [OUT]
+   size_t             size;      // size of payload [IN]
+   btByte             buf;       // first char of variably length payload [IN]
+};
+#define REQDEVICE_RSP_HDRSZ  ( offsetof(struct rsp_device, buf) )
+
+//=============================================================================
+// Name: req_reldev
+// Description: Request to release a device allocated via an alloc
+// COMMENTS:
+//=============================================================================
+struct req_reldev
+{
+   void  *tranID;       // transaction ID to identify result [IN/OUT]
+   void  *data;         // optional payload [IN/OUT]
+   btInt  result;       // result code [OUT]
+   void  *devHandle;    // device handle [IN]
+};
+
+
+END_C_DECLS
+
+END_NAMESPACE(AAL)
+
+#endif // __AALSDK_KERNEL_AALRM_CLIENT_H__
+
diff --git a/drivers/fpga/aal/include/aalsdk/kernel/aalrm_server-services.h b/drivers/fpga/aal/include/aalsdk/kernel/aalrm_server-services.h
new file mode 100644
index 000000000000..caa86774c087
--- /dev/null
+++ b/drivers/fpga/aal/include/aalsdk/kernel/aalrm_server-services.h
@@ -0,0 +1,193 @@
+//******************************************************************************
+// This  file  is  provided  under  a  dual BSD/GPLv2  license.  When using or
+//         redistributing this file, you may do so under either license.
+//
+//                            GPL LICENSE SUMMARY
+//
+//  Copyright(c) 2008-2017, Intel Corporation.
+//
+//  This program  is  free software;  you  can redistribute it  and/or  modify
+//  it  under  the  terms of  version 2 of  the GNU General Public License  as
+//  published by the Free Software Foundation.
+//
+//  This  program  is distributed  in the  hope that it  will  be useful,  but
+//  WITHOUT   ANY   WARRANTY;   without   even  the   implied   warranty    of
+//  MERCHANTABILITY  or  FITNESS  FOR  A  PARTICULAR  PURPOSE.  See  the   GNU
+//  General Public License for more details.
+//
+//  The  full  GNU  General Public License is  included in  this  distribution
+//  in the file called README.GPLV2-LICENSE.TXT.
+//
+//  Contact Information:
+//  Henry Mitchel, henry.mitchel at intel.com
+//  77 Reed Rd., Hudson, MA  01749
+//
+//                                BSD LICENSE
+//
+//  Copyright(c) 2008-2017, Intel Corporation.
+//
+//  Redistribution and  use  in source  and  binary  forms,  with  or  without
+//  modification,  are   permitted  provided  that  the  following  conditions
+//  are met:
+//
+//    * Redistributions  of  source  code  must  retain  the  above  copyright
+//      notice, this list of conditions and the following disclaimer.
+//    * Redistributions in  binary form  must  reproduce  the  above copyright
+//      notice,  this  list of  conditions  and  the  following disclaimer  in
+//      the   documentation   and/or   other   materials   provided  with  the
+//      distribution.
+//    * Neither   the  name   of  Intel  Corporation  nor  the  names  of  its
+//      contributors  may  be  used  to  endorse  or promote  products derived
+//      from this software without specific prior written permission.
+//
+//  THIS  SOFTWARE  IS  PROVIDED  BY  THE  COPYRIGHT HOLDERS  AND CONTRIBUTORS
+//  "AS IS"  AND  ANY  EXPRESS  OR  IMPLIED  WARRANTIES,  INCLUDING,  BUT  NOT
+//  LIMITED  TO, THE  IMPLIED WARRANTIES OF  MERCHANTABILITY  AND FITNESS  FOR
+//  A  PARTICULAR  PURPOSE  ARE  DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT
+//  OWNER OR CONTRIBUTORS BE LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,
+//  SPECIAL,  EXEMPLARY,  OR  CONSEQUENTIAL   DAMAGES  (INCLUDING,   BUT   NOT
+//  LIMITED  TO,  PROCUREMENT  OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF USE,
+//  DATA,  OR PROFITS;  OR BUSINESS INTERRUPTION)  HOWEVER  CAUSED  AND ON ANY
+//  THEORY  OF  LIABILITY,  WHETHER  IN  CONTRACT,  STRICT LIABILITY,  OR TORT
+//  (INCLUDING  NEGLIGENCE  OR OTHERWISE) ARISING  IN ANY WAY  OUT  OF THE USE
+//  OF  THIS  SOFTWARE, EVEN IF ADVISED  OF  THE  POSSIBILITY  OF SUCH DAMAGE.
+//******************************************************************************
+//****************************************************************************
+//        FILE: aalrm_server-services.h
+//     CREATED: 02/20/2008
+//      AUTHOR: Joseph Grecco - Intel
+//
+// PURPOSE: This file contains public definitions for the
+//          AAL Resource Manager Kernel Module Service Interfaces
+// HISTORY:
+// COMMENTS:
+// WHEN:          WHO:     WHAT:
+// 02/20/08       JG       Initial version created
+// 11/11/2008     JG       Added legal header
+// 01/04/2009     HM       Updated Copyright
+// 02/09/2009     JG       Added support for RMSS cancel transaction
+//****************************************************************************
+#ifndef __AALSDK_KERNEL_AALRM_SERVER_SERVICES_H__
+#define __AALSDK_KERNEL_AALRM_SERVER_SERVICES_H__
+#include <aalsdk/kernel/aalbus.h>
+#include <aalsdk/kernel/aalrm_client.h>
+#include <aalsdk/kernel/AALTransactionID_s.h>
+#include <aalsdk/kernel/aalinterface.h>
+
+BEGIN_NAMESPACE(AAL)
+
+//-----------------------------------------------------------------------------
+// Public Interface
+//-----------------------------------------------------------------------------
+#define  AALRMS_API_MAJVERSION     (0x00000001)
+#define  AALRMS_API_MINVERSION     (0x00000000)
+#define  AALRMS_API_RELEASE        (0x00000000)
+
+#define  AALRMS_API_INTC           (0x0000000000002000)
+
+// API IIDs TODO should come from aal ids
+#define AAL_RMSAPI_IID_01         (0x2)
+
+
+//=============================================================================
+//=============================================================================
+//                 Resource Manager Server Service interface
+//=============================================================================
+//=============================================================================
+
+//=============================================================================
+// Name: aalrms_req_tranID
+// Description:
+//=============================================================================
+struct aalrms_req_tranID{
+   void *m_context;
+};
+
+
+//=============================================================================
+// Name: aalrms_reqdev_cmplt_t
+// Description: Request device completion callback and completion object.
+//              Defines the callback signature for the completion function
+//              called when request_device completes.
+// Inputs: preqdev_cmplt - pointer to completion object
+//         tranID - Transaction ID for the request
+//=============================================================================
+typedef void (*aalrms_reqdev_cmplt_t)( int result,
+                                       struct rsp_device   *pretdev,
+                                       struct req_allocdev *origreq,
+                                       struct aalrms_req_tranID tranID );
+
+//=============================================================================
+// Name: aalrms_registrarreq_cmplt_t
+// Description: Request completion callback and completion object.
+//              Defines the callback signature for the completion function
+//              called when request_device completes.
+// Inputs: preqdev_cmplt - pointer to completion object
+//         tranID - Transaction ID for the request
+//=============================================================================
+typedef void (*aalrms_registrarreq_cmplt_t)( int result,
+                                             struct req_registrar *resp,
+                                             struct req_registrar *origreq,
+                                             struct aalrms_req_tranID tranID  );
+
+
+
+//=============================================================================
+// Name: aalrm_server_cmplt_t
+// Description: General purpose callback function signature
+//=============================================================================
+typedef void (*aalrm_server_cmplt_t)( int errno,
+                                      struct req_registrar *resp,
+                                      struct req_registrar *origreq,
+                                      struct aalrms_req_tranID tranID  );
+
+
+//=============================================================================
+// Name: aalrm_server_service
+// Description: Service interface for the AAL RMS service. This
+//              interface defines the methods used by clients of the RMS
+//              service.
+//=============================================================================
+struct aalrm_server_service{
+
+   //==========================================================================
+   // Name: request_device
+   // Description: Request a device be allocated by RMS
+   // Inputs: req_allocdev - request with manifest
+   //         tranID - Transaction ID for the request
+   //==========================================================================
+   int (*request_device)( struct req_allocdev* req,
+                          aalrms_reqdev_cmplt_t completionfcn,
+                          struct aalrms_req_tranID tranID );
+
+   //==========================================================================
+   // Name: registrar_request
+   // Description: Send a request to Registrar
+   // Inputs: req_allocdev - request with manifest
+   //         pSession - owner
+   //         tranID - Transaction ID for the request
+   //==========================================================================
+   int (*registrar_request)(  struct req_registrar *preq,
+                              aalrms_registrarreq_cmplt_t completionfcn,
+                              struct aalrms_req_tranID tranID  );
+
+   //==========================================================================
+   // Name: cancel_all_requests
+   // Description: Cancel all requests that match transaction ID context
+   // Inputs: tranID - Transaction ID for the request(s) to cancel
+   //==========================================================================
+   void (*cancel_all_requests)(  struct aalrms_req_tranID *tranID  );
+};
+
+
+// Convenient macros for using the interface
+#define i_rmserver(i) (*((struct aalrm_server_service*)((struct aal_interface *)i)->m_iptr))
+#define rms_reqdev(i) ((struct aalrm_server_service*)((struct aal_interface *)i)->m_iptr)->request_device
+#define rms_regdev(i) ((struct aalrm_server_service*)((struct aal_interface *)i)->m_iptr)->registrar_request
+#define rms_reldev(i) ((struct aalrm_server_service*)((struct aal_interface *)i)->m_iptr)->release_device
+#define rms_cancelreqs(i) ((struct aalrm_server_service*)((struct aal_interface *)i)->m_iptr)->cancel_all_requests
+
+END_NAMESPACE(AAL)
+
+#endif // __AALSDK_KERNEL_AALRM_SERVER_SERVICES_H__
+
diff --git a/drivers/fpga/aal/include/aalsdk/kernel/aalrm_server.h b/drivers/fpga/aal/include/aalsdk/kernel/aalrm_server.h
new file mode 100644
index 000000000000..dbc78c19d590
--- /dev/null
+++ b/drivers/fpga/aal/include/aalsdk/kernel/aalrm_server.h
@@ -0,0 +1,224 @@
+//******************************************************************************
+// This  file  is  provided  under  a  dual BSD/GPLv2  license.  When using or
+//         redistributing this file, you may do so under either license.
+//
+//                            GPL LICENSE SUMMARY
+//
+//  Copyright(c) 2008-2017, Intel Corporation.
+//
+//  This program  is  free software;  you  can redistribute it  and/or  modify
+//  it  under  the  terms of  version 2 of  the GNU General Public License  as
+//  published by the Free Software Foundation.
+//
+//  This  program  is distributed  in the  hope that it  will  be useful,  but
+//  WITHOUT   ANY   WARRANTY;   without   even  the   implied   warranty    of
+//  MERCHANTABILITY  or  FITNESS  FOR  A  PARTICULAR  PURPOSE.  See  the   GNU
+//  General Public License for more details.
+//
+//  The  full  GNU  General Public License is  included in  this  distribution
+//  in the file called README.GPLV2-LICENSE.TXT.
+//
+//  Contact Information:
+//  Henry Mitchel, henry.mitchel at intel.com
+//  77 Reed Rd., Hudson, MA  01749
+//
+//                                BSD LICENSE
+//
+//  Copyright(c) 2008-2017, Intel Corporation.
+//
+//  Redistribution and  use  in source  and  binary  forms,  with  or  without
+//  modification,  are   permitted  provided  that  the  following  conditions
+//  are met:
+//
+//    * Redistributions  of  source  code  must  retain  the  above  copyright
+//      notice, this list of conditions and the following disclaimer.
+//    * Redistributions in  binary form  must  reproduce  the  above copyright
+//      notice,  this  list of  conditions  and  the  following disclaimer  in
+//      the   documentation   and/or   other   materials   provided  with  the
+//      distribution.
+//    * Neither   the  name   of  Intel  Corporation  nor  the  names  of  its
+//      contributors  may  be  used  to  endorse  or promote  products derived
+//      from this software without specific prior written permission.
+//
+//  THIS  SOFTWARE  IS  PROVIDED  BY  THE  COPYRIGHT HOLDERS  AND CONTRIBUTORS
+//  "AS IS"  AND  ANY  EXPRESS  OR  IMPLIED  WARRANTIES,  INCLUDING,  BUT  NOT
+//  LIMITED  TO, THE  IMPLIED WARRANTIES OF  MERCHANTABILITY  AND FITNESS  FOR
+//  A  PARTICULAR  PURPOSE  ARE  DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT
+//  OWNER OR CONTRIBUTORS BE LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,
+//  SPECIAL,  EXEMPLARY,  OR  CONSEQUENTIAL   DAMAGES  (INCLUDING,   BUT   NOT
+//  LIMITED  TO,  PROCUREMENT  OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF USE,
+//  DATA,  OR PROFITS;  OR BUSINESS INTERRUPTION)  HOWEVER  CAUSED  AND ON ANY
+//  THEORY  OF  LIABILITY,  WHETHER  IN  CONTRACT,  STRICT LIABILITY,  OR TORT
+//  (INCLUDING  NEGLIGENCE  OR OTHERWISE) ARISING  IN ANY WAY  OUT  OF THE USE
+//  OF  THIS  SOFTWARE, EVEN IF ADVISED  OF  THE  POSSIBILITY  OF SUCH DAMAGE.
+//******************************************************************************
+//****************************************************************************
+//        FILE: aalrm_server.h
+//     CREATED: 02/25/2008
+//      AUTHOR: Joseph Grecco - Intel
+//
+// PURPOSE: This file containe public definitions for the
+//          AAL Resource Manager Server Kernel Module Interface
+// HISTORY:
+// COMMENTS:
+// WHEN:          WHO:     WHAT:
+// 02/25/08       JG       Initial version created
+// 11/11/2008     JG       Added legal header
+// 01/04/2009     HM       Updated Copyright
+//****************************************************************************
+#ifndef __AALSDK_KERNEL_AALRM_SERVER_H__
+#define __AALSDK_KERNEL_AALRM_SERVER_H__
+#include <aalsdk/kernel/aaltypes.h>
+#include <aalsdk/kernel/aalrm.h>
+
+
+BEGIN_NAMESPACE(AAL)
+
+BEGIN_C_DECLS
+
+#define RMS_DEV_NAME "aalrms"
+
+//=============================================================================
+//=============================================================================
+//                  Resource Manager Service Messages
+//=============================================================================
+//=============================================================================
+
+//-----------------------------------------------------------------------------
+// Messages structures -
+//       Type -  Request - indicates that the message is requesting a service
+//              Response - indicates that the message is in response to a
+//                         service request
+//                 Event - indicates that the messages is informational
+//        DIR -  IN - indicates that the message is sent into the target.
+//               OUT - indicates that the message is received from the target
+//     Object - The destination [IN] or source [OUT] of the message
+// Command ID - Constant value placed in the id field
+//-----------------------------------------------------------------------------
+
+//=============================================================================
+// Name: Request device
+// Type[Dir]: Request [IN]
+// Object: User Resource Manager Service
+// Command ID: reqid_URMS_RequestDevice
+// Input:    Payload - aalrms_requestdevice
+//        req_handle - Request handle. Returned in response
+// Description: Request a device
+//=============================================================================
+struct aalrms_requestdevice
+{
+      btPID   pid;        // ID of the process requesting the device
+      size_t  size;       // Size of this payload
+      void   *manifest;   // Additional information
+};
+
+
+//=============================================================================
+// Name: Request device response
+// Type[Dir]: Response [OUT]
+// Object: User Resource Manager Service
+// Command ID: rspid_URMS_RequestDevice
+// Input: res_handle - Resource handle
+//        req_handle - handle of original reqid_URMS_RequestDevice
+// Description: Response to a reqid_URMS_RequestDevice
+//=============================================================================
+//none
+
+
+
+//=============================================================================
+// Name: Registrar Request
+// Type[Dir]: Request [IN]
+// Object: Registrar Service
+// Command ID: reqid_RS_Registrar
+// Input:    Payload - Registrar request block
+//        req_handle - Handle of request used in response
+// Description: Registrar  request
+//=============================================================================
+//none
+
+
+
+//=============================================================================
+// Name: Registrar Request response
+// Type[Dir]: Response [OUT]
+// Object: User Resource Manager Service
+// Command ID: rspid_URMS_RequestDevice
+// Input:    Payload - Response payload
+//        req_handle - handle of original reqid_RS_Registrar
+// Description: Response to a reqid_RS_Registrar
+//=============================================================================
+//none
+
+
+
+//=============================================================================
+// Name: Set Configuration Update Events
+// Type[Dir]: Request [IN]
+// Object: Kernel Resource Manager Service
+// Command ID: reqid_KRMS_SetConfigUpdates
+// Input: data - Flags enabling mode (See KRMS_UPDATE_MODE_xxxx)
+// Description: Enable/Disable config update events
+//=============================================================================
+//none
+#define KRMS_UPDATE_MODE_EVENTS  (1 << 0)
+#define KRMS_UPDATE_MODE_FILE    (1 << 1)
+
+#define KRMS_UPDATE_MODE_NONE    (0)
+
+
+
+//=============================================================================
+// Name: Service shutdown request
+// Type[Dir]: Request [IN]
+// Object: Kernel Resource Manager Service
+// Command ID: reqid_Shutdown
+// Input:  none.
+// Description: Signal that the service should shutdown. Causes the kernel
+//              services to quiesce with respect to the user mode service.
+//              Causes the message queues to be flushed.
+//=============================================================================
+//none
+
+
+
+//=============================================================================
+// Name: Service shutdown response
+// Type[Dir]: Response [OUT]
+// Object: Kernel Resource Manager Service
+// Command ID: rspid_Shutdown
+// Input: none.
+// Description: Final event from the message delivery queue. Messages will no
+//              longer be delivered from the service and all subsequent
+//              requests to the KRMS will fail.
+//=============================================================================
+//none
+
+
+//=============================================================================
+// Name: Service restart request
+// Type[Dir]: Request [IN]
+// Object: Kernel Resource Manager Service
+// Command ID: reqid_Restart
+// Input:  none.
+// Description: Request that the KRMS restart
+//=============================================================================
+//none
+
+
+//=============================================================================
+// Name: Service restart response
+// Type[Dir]: Response [OUT]
+// Object: Kernel Resource Manager Service
+// Command ID: rspid_Started
+// Input: none.
+// Description: System restarted.  System is in the same state as an new open()
+//=============================================================================
+//none
+
+END_C_DECLS
+
+END_NAMESPACE(AAL)
+
+#endif // __AALSDK_KERNEL_AALRM_SERVER_H__
+
diff --git a/drivers/fpga/aal/include/aalsdk/kernel/aaltypes.h b/drivers/fpga/aal/include/aalsdk/kernel/aaltypes.h
new file mode 100644
index 000000000000..89912cd8ba3f
--- /dev/null
+++ b/drivers/fpga/aal/include/aalsdk/kernel/aaltypes.h
@@ -0,0 +1,675 @@
+//******************************************************************************
+// This  file  is  provided  under  a  dual BSD/GPLv2  license.  When using or
+//         redistributing this file, you may do so under either license.
+//
+//                            GPL LICENSE SUMMARY
+//
+//  Copyright(c) 2012-2017, Intel Corporation.
+//
+//  This program  is  free software;  you  can redistribute it  and/or  modify
+//  it  under  the  terms of  version 2 of  the GNU General Public License  as
+//  published by the Free Software Foundation.
+//
+//  This  program  is distributed  in the  hope that it  will  be useful,  but
+//  WITHOUT   ANY   WARRANTY;   without   even  the   implied   warranty    of
+//  MERCHANTABILITY  or  FITNESS  FOR  A  PARTICULAR  PURPOSE.  See  the   GNU
+//  General Public License for more details.
+//
+//  The  full  GNU  General Public License is  included in  this  distribution
+//  in the file called README.GPLV2-LICENSE.TXT.
+//
+//  Contact Information:
+//  Henry Mitchel, henry.mitchel at intel.com
+//  77 Reed Rd., Hudson, MA  01749
+//
+//                                BSD LICENSE
+//
+//  Copyright(c) 2012-2017, Intel Corporation.
+//
+//  Redistribution and  use  in source  and  binary  forms,  with  or  without
+//  modification,  are   permitted  provided  that  the  following  conditions
+//  are met:
+//
+//    * Redistributions  of  source  code  must  retain  the  above  copyright
+//      notice, this list of conditions and the following disclaimer.
+//    * Redistributions in  binary form  must  reproduce  the  above copyright
+//      notice,  this  list of  conditions  and  the  following disclaimer  in
+//      the   documentation   and/or   other   materials   provided  with  the
+//      distribution.
+//    * Neither   the  name   of  Intel  Corporation  nor  the  names  of  its
+//      contributors  may  be  used  to  endorse  or promote  products derived
+//      from this software without specific prior written permission.
+//
+//  THIS  SOFTWARE  IS  PROVIDED  BY  THE  COPYRIGHT HOLDERS  AND CONTRIBUTORS
+//  "AS IS"  AND  ANY  EXPRESS  OR  IMPLIED  WARRANTIES,  INCLUDING,  BUT  NOT
+//  LIMITED  TO, THE  IMPLIED WARRANTIES OF  MERCHANTABILITY  AND FITNESS  FOR
+//  A  PARTICULAR  PURPOSE  ARE  DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT
+//  OWNER OR CONTRIBUTORS BE LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,
+//  SPECIAL,  EXEMPLARY,  OR  CONSEQUENTIAL   DAMAGES  (INCLUDING,   BUT   NOT
+//  LIMITED  TO,  PROCUREMENT  OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF USE,
+//  DATA,  OR PROFITS;  OR BUSINESS INTERRUPTION)  HOWEVER  CAUSED  AND ON ANY
+//  THEORY  OF  LIABILITY,  WHETHER  IN  CONTRACT,  STRICT LIABILITY,  OR TORT
+//  (INCLUDING  NEGLIGENCE  OR OTHERWISE) ARISING  IN ANY WAY  OUT  OF THE USE
+//  OF  THIS  SOFTWARE, EVEN IF ADVISED  OF  THE  POSSIBILITY  OF SUCH DAMAGE.
+//******************************************************************************
+//****************************************************************************
+//        FILE: aaltypes.h
+//     CREATED: 04/04/2012
+//      AUTHOR: Tim Whisonant
+//
+// PURPOSE:  This file contains type definitions for the
+//           Accelerator Abstraction Layer (AAL)
+//
+// HISTORY:
+// COMMENTS:
+// WHEN:          WHO:     WHAT:
+// 04/04/2012     TSW      Initial version
+// 10/24/2012     TSW      Cleanup for faplib
+//****************************************************************************
+#include <aalsdk/kernel/aaldefs.h>
+
+#ifdef __AAL_KERNEL__
+#ifndef __AALSDK_KERNEL_AALTYPES_H__
+#define __AALSDK_KERNEL_AALTYPES_H__
+
+
+BEGIN_NAMESPACE(AAL)
+
+/// @addtogroup BasicTypes
+/// @{
+
+
+#ifndef __AALSDK_DATA_MODEL_LP32
+# define __AALSDK_DATA_MODEL_LP32  0
+#endif // __AALSDK_DATA_MODEL_LP32
+#ifndef __AALSDK_DATA_MODEL_ILP32 
+# define __AALSDK_DATA_MODEL_ILP32 1
+#endif // __AALSDK_DATA_MODEL_ILP32
+#ifndef __AALSDK_DATA_MODEL_ILP64
+# define __AALSDK_DATA_MODEL_ILP64 2
+#endif // __AALSDK_DATA_MODEL_ILP64
+#ifndef __AALSDK_DATA_MODEL_LLP64 
+# define __AALSDK_DATA_MODEL_LLP64 3
+#endif // __AALSDK_DATA_MODEL_LLP64
+#ifndef __AALSDK_DATA_MODEL_LP64
+# define __AALSDK_DATA_MODEL_LP64  4
+#endif // __AALSDK_DATA_MODEL_LP64
+
+// The Windows compiler doesn't define these, so we compensate here.
+#if defined( __AAL_WINDOWS__ )
+# if   defined( _WIN64 )
+#    ifndef __LLP64__
+#       define __LLP64__ 1
+#    endif // __LLP64__
+# elif defined( _WIN32 )
+#    ifndef __ILP32__
+#       define __ILP32__ 1
+#    endif // __ILP32__
+# endif // _WIN64
+#endif // __AAL_WINDOWS__
+
+#ifndef __AALSDK_DATA_MODEL
+# if defined( __LP32__ )
+#   define __AALSDK_DATA_MODEL __AALSDK_DATA_MODEL_LP32
+#   define sizeof_void_ptr 4
+# elif defined( __ILP32__ )
+#   define __AALSDK_DATA_MODEL __AALSDK_DATA_MODEL_ILP32
+#   define sizeof_void_ptr 4
+# elif defined( __ILP64__ )
+#   define __AALSDK_DATA_MODEL __AALSDK_DATA_MODEL_ILP64
+#   define sizeof_void_ptr 8
+# elif defined( __LLP64__ )
+#   define __AALSDK_DATA_MODEL __AALSDK_DATA_MODEL_LLP64
+#   define sizeof_void_ptr 8
+# elif defined( __LP64__ )
+#   define __AALSDK_DATA_MODEL __AALSDK_DATA_MODEL_LP64
+#   define sizeof_void_ptr 8
+# endif
+#endif // __AALSDK_DATA_MODEL
+
+#ifndef __AALSDK_DATA_MODEL
+# error Could not detect data model of current platform. (__AALSDK_DATA_MODEL)
+#endif // __AALSDK_DATA_MODEL
+
+
+#if defined( __AAL_WINDOWS__ )
+# ifndef __PHYS_ADDR_DEFINED
+# define __PHYS_ADDR_DEFINED 1
+// UINT_PTR defined in ntintsafe.h
+     typedef UINT_PTR btPhysAddr;
+# endif // __PHYS_ADDR_DEFINED
+# ifndef __PHYS_ADDR_CAST
+#    define __PHYS_ADDR_CAST(p) ( (UINT_PTR)(p) )
+# endif // __PHYS_ADDR_CAST
+
+# ifndef __VIRT_ADDR_DEFINED
+# define __VIRT_ADDR_DEFINED 1
+// PUCHAR defined in ntdef.h
+     typedef PUCHAR btVirtAddr;
+# endif // __VIRT_ADDR_DEFINED
+
+# ifdef HAVE_UINTPTR_T
+     typedef uintptr_t btUIntPtr;
+# else
+#    define HAVE_UINTPTR_T 1
+// UINT_PTR defined in ntintsafe.h
+     typedef UINT_PTR btUIntPtr;
+# endif // HAVE_UINTPTR_T
+# ifndef __UINTPTR_T_CAST
+#    define __UINTPTR_T_CAST(n) ( (UINT_PTR)(n) )
+# endif // __UINTPTR_T_CAST
+
+# ifndef __UINT64_T_DEFINED
+# define __UINT64_T_DEFINED 1
+// UINT64 defined in ntintsafe.h
+     END_NAMESPACE(AAL)
+     typedef UINT64 uint64_t;
+     BEGIN_NAMESPACE(AAL)
+# endif // __UINT64_T_DEFINED
+
+# ifndef __SIZE_T_CAST
+// size_t defined in ntintsafe.h
+#    define __SIZE_T_CAST(s) ( (size_t)(s) )
+# endif // __SIZE_T_CAST
+
+#else
+# ifndef __VIRT_ADDR_DEFINED
+# define __VIRT_ADDR_DEFINED 1
+     typedef unsigned char * btVirtAddr;
+# endif // __VIRT_ADDR_DEFINED
+#endif // OS
+CASSERT(sizeof_void_ptr == sizeof(btVirtAddr));
+
+
+#if ( __AALSDK_DATA_MODEL_LLP64 == __AALSDK_DATA_MODEL )
+# ifndef __UINT64_T_CONST
+#    define __UINT64_T_CONST(c) c##ULL
+# endif // __UINT64_T_CONST()
+# ifndef PRIu64
+#    define PRIu64              "llu"
+# endif // PRIu64
+# ifndef PRIx64
+#    define PRIx64              "llx"
+# endif // PRIx64
+# ifndef PRIX64
+#    define PRIX64              "llX"
+# endif // PRIX64
+#elif defined( __AAL_LINUX__ ) && defined( __x86_64__ )
+// Linux deviates from the LP64 model here.
+# ifndef __UINT64_T_CONST
+#    define __UINT64_T_CONST(c) c##ULL
+# endif // __UINT64_T_CONST()
+# ifndef PRIu64
+#    define PRIu64              "llu"
+# endif // PRIu64
+# ifndef PRIx64
+#    define PRIx64              "llx"
+# endif // PRIx64
+# ifndef PRIX64
+#    define PRIX64              "llX"
+# endif // PRIX64
+#elif ( __AALSDK_DATA_MODEL_ILP64 == __AALSDK_DATA_MODEL ) || ( __AALSDK_DATA_MODEL_LP64 == __AALSDK_DATA_MODEL )
+# ifndef __UINT64_T_CONST
+#    define __UINT64_T_CONST(c) c##UL
+# endif // __UINT64_T_CONST()
+# ifndef PRIu64
+#    define PRIu64              "lu"
+# endif // PRIu64
+# ifndef PRIx64
+#    define PRIx64              "lx"
+# endif // PRIx64
+# ifndef PRIX64
+#    define PRIX64              "lX"
+# endif // PRIX64
+#else
+// Default to unsigned long long for the rest
+# ifndef __UINT64_T_CONST
+#    define __UINT64_T_CONST(c) c##ULL
+# endif // __UINT64_T_CONST()
+# ifndef PRIu64
+#    define PRIu64              "llu"
+# endif // PRIu64
+# ifndef PRIx64
+#    define PRIx64              "llx"
+# endif // PRIx64
+# ifndef PRIX64
+#    define PRIX64              "llX"
+# endif // PRIX64
+#endif // __AALSDK_DATA_MODEL
+
+
+#if ( __AALSDK_DATA_MODEL_LLP64 == __AALSDK_DATA_MODEL )
+// (long long's and pointers are the same size)
+
+# ifndef __PHYS_ADDR_DEFINED
+# define __PHYS_ADDR_DEFINED 1
+     typedef unsigned long long int btPhysAddr;
+# endif // __PHYS_ADDR_DEFINED
+# ifndef __PHYS_ADDR_CAST
+#    define __PHYS_ADDR_CAST(p) ( (unsigned long long int)(p) )
+# endif // __PHYS_ADDR_CAST
+# ifndef __PHYS_ADDR_CONST
+#    define __PHYS_ADDR_CONST(c) c##ULL
+# endif // __PHYS_ADDR_CONST
+# ifndef PRIuPHYS_ADDR
+#    define PRIuPHYS_ADDR        "llu"
+# endif // PRIuPHYS_ADDR
+# ifndef PRIxPHYS_ADDR
+#    define PRIxPHYS_ADDR        "llx"
+# endif // PRIxPHYS_ADDR
+# ifndef PRIXPHYS_ADDR
+#    define PRIXPHYS_ADDR        "llX"
+# endif // PRIXPHYS_ADDR
+
+# ifdef HAVE_UINTPTR_T
+     typedef uintptr_t btUIntPtr;
+# else
+#    define HAVE_UINTPTR_T 1
+     typedef unsigned long long int btUIntPtr;
+# endif // HAVE_UINTPTR_T
+# ifndef __UINTPTR_T_CAST
+#    define __UINTPTR_T_CAST(n) ( (unsigned long long int)(n) )
+# endif // __UINTPTR_T_CAST
+# ifndef __UINTPTR_T_CONST
+#    define __UINTPTR_T_CONST(c) c##ULL
+# endif // __UINTPTR_T_CONST
+# ifndef PRIuUINTPTR_T
+#    define PRIuUINTPTR_T        "llu"
+# endif // PRIuUINTPTR_T
+# ifndef PRIxUINTPTR_T
+#    define PRIxUINTPTR_T        "llx"
+# endif // PRIxUINTPTR_T
+# ifndef PRIXUINTPTR_T
+#    define PRIXUINTPTR_T        "llX"
+# endif // PRIXUINTPTR_T
+
+# ifndef __SIZE_T_CAST
+#    define __SIZE_T_CAST(s) ( (unsigned long long int)(s) )
+# endif // __SIZE_T_CAST
+# ifndef __SIZE_T_CONST
+#    define __SIZE_T_CONST(c) c##ULL
+# endif // __SIZE_T_CONST
+# ifndef PRIuSIZE_T
+#    define PRIuSIZE_T        "llu"
+# endif // PRIuSIZE_T
+# ifndef PRIxSIZE_T
+#    define PRIxSIZE_T        "llx"
+# endif // PRIxSIZE_T
+# ifndef PRIXSIZE_T
+#    define PRIXSIZE_T        "llX"
+# endif // PRIXSIZE_T
+// (long long's and pointers are the same size)
+
+#else
+
+// __AALSDK_DATA_MODEL_LP32
+// __AALSDK_DATA_MODEL_ILP32
+// __AALSDK_DATA_MODEL_ILP64
+// __AALSDK_DATA_MODEL_LP64
+// (long's and pointers are the same size)
+# ifndef __PHYS_ADDR_DEFINED
+# define __PHYS_ADDR_DEFINED 1
+     typedef unsigned long int btPhysAddr;
+# endif // __PHYS_ADDR_DEFINED
+# ifndef __PHYS_ADDR_CAST
+#    define __PHYS_ADDR_CAST(p)  ( (unsigned long int)(p) )
+# endif // __PHYS_ADDR_CAST
+# ifndef __PHYS_ADDR_CONST
+#    define __PHYS_ADDR_CONST(c) c##UL
+# endif // __PHYS_ADDR_CONST
+# ifndef PRIuPHYS_ADDR
+#    define PRIuPHYS_ADDR        "lu"
+# endif // PRIuPHYS_ADDR
+# ifndef PRIxPHYS_ADDR
+#    define PRIxPHYS_ADDR        "lx"
+# endif // PRIxPHYS_ADDR
+# ifndef PRIXPHYS_ADDR
+#    define PRIXPHYS_ADDR        "lX"
+# endif // PRIXPHYS_ADDR
+
+# ifdef HAVE_UINTPTR_T
+     typedef uintptr_t btUIntPtr;
+# else
+#    define HAVE_UINTPTR_T 1
+     typedef unsigned long int btUIntPtr;
+# endif // HAVE_UINTPTR_T
+# ifndef __UINTPTR_T_CAST
+#    define __UINTPTR_T_CAST(n)  ( (unsigned long int)(n) )
+# endif // __UINTPTR_T_CAST
+# ifndef __UINTPTR_T_CONST
+#    define __UINTPTR_T_CONST(c) c##UL
+# endif // __UINTPTR_T_CONST
+# ifndef PRIuUINTPTR_T
+#    define PRIuUINTPTR_T        "lu"
+# endif // PRIuUINTPTR_T
+# ifndef PRIxUINTPTR_T
+#    define PRIxUINTPTR_T        "lx"
+# endif // PRIxUINTPTR_T
+# ifndef PRIXUINTPTR_T
+#    define PRIXUINTPTR_T        "lX"
+# endif // PRIXUINTPTR_T
+
+# ifndef __SIZE_T_CAST
+#    define __SIZE_T_CAST(s)  ( (unsigned long int)(s) )
+# endif // __SIZE_T_CAST
+# ifndef __SIZE_T_CONST
+#    define __SIZE_T_CONST(c) c##UL
+# endif // __SIZE_T_CONST
+# ifndef PRIuSIZE_T
+#    define PRIuSIZE_T        "lu"
+# endif // PRIuSIZE_T
+# ifndef PRIxSIZE_T
+#    define PRIxSIZE_T        "lx"
+# endif // PRIxSIZE_T
+# ifndef PRIXSIZE_T
+#    define PRIXSIZE_T        "lX"
+# endif // PRIXSIZE_T
+
+// (long's and pointers are the same size)
+#endif // __AALSDK_DATA_MODEL
+CASSERT(sizeof_void_ptr == sizeof(btPhysAddr));
+CASSERT(sizeof_void_ptr == sizeof(btUIntPtr));
+
+
+# ifndef PRIuID
+#    define PRIuID  "llu"
+# endif // PRIuID
+# ifndef PRIxID
+#    define PRIxID  "llx"
+# endif // PRIxID
+# ifndef PRIXID
+#    define PRIXID  "llX"
+# endif // PRIXID
+
+# ifndef PRIuIID
+#    define PRIuIID "llu"
+# endif // PRIuIID
+# ifndef PRIxIID
+#    define PRIxIID "llx"
+# endif // PRIxIID
+# ifndef PRIXIID
+#    define PRIXIID "llX"
+# endif // PRIXIID
+
+
+#ifndef __AALSDK_BASIC_TYPES_DEFINED
+#define __AALSDK_BASIC_TYPES_DEFINED
+
+/// Definition of basic types recognized by AAL.
+typedef enum eBasicTypes {
+   // Allows use as an array index, if needed
+   btBool_t = 0,              ///< btBool
+   btByte_t,                  ///< btByte
+   bt32bitInt_t,              ///< bt32bitInt
+   btInt_t,                   ///< btInt
+   btUnsigned32bitInt_t,      ///< btUnsigned32bitInt
+   btUnsignedInt_t,           ///< btUnsignedInt
+   bt64bitInt_t,              ///< bt64bitInt
+   btUnsigned64bitInt_t,      ///< btUnsigned64bitInt
+   btFloat_t,                 ///< btFloat
+   btString_t,                ///< btString
+   btNamedValueSet_t,         ///< NamedValueSet
+   bt32bitIntArray_t,         ///< bt32bitIntArray
+   btUnsigned32bitIntArray_t, ///< btUnsigned32bitIntArray
+   bt64bitIntArray_t,         ///< bt64bitIntArray
+   btUnsigned64bitIntArray_t, ///< btUnsigned64bitIntArray
+   btObjectType_t,            ///< btObjectType
+   btFloatArray_t,            ///< btFloatArray
+   btStringArray_t,           ///< btStringArray
+   btObjectArray_t,           ///< btObjectArray
+   btByteArray_t,             ///< btByteArray
+   // Always insert new types above this comment
+   btUnknownType_t,           ///< Type is unknown.
+   btEndOfNVS_t = 9999        ///< Special value for end of NamedValueSet.
+} eBasicTypes;
+
+/// Name types for NamedValueSet's
+typedef enum eNameTypes {
+   // Numbering provides backward compatibility for now
+   btNumberKey_t = 5,         ///< btNumberKey
+   btStringKey_t = 9          ///< btStringKey
+} eNameTypes;
+
+
+/// @brief UUID identifier for AAL objects, events, and error codes.
+///
+/// btID is an integer type which encapsulates a hierarchical representation of an ID space. The ID space
+/// is used to represent objects, events, and error codes in a uniform manner that is efficient, definitive in
+/// code (i.e. codes can be switched on), and unique in the binary space (so that if seen out of context they
+/// can still be identified).
+///
+/// A btID incorporates 5 fields:
+/// - Vendor: 16 bits that encode the PCI-SIG Vendor ID for a vendor.
+///   - Intels value is 0x8086.
+///   - The AAL system itself is 0x0000, as AAL may not always be completely Intel specific.
+///   - 0xFFFF is currently used as a special value for those wishing to test their code without requiring a PCI-SIG
+/// vendor ID.
+/// - Sub-System: 12 bits that encode a vendor specific system or subsystem. This address space belongs to the
+/// vendor.
+///   - AAL uses the sub-system field to identify AAL subsystems, such as the Factory, the Registrar, etc.
+/// - Exception: 1 bit that is set if an object represents an exception.
+/// - Type: 15 bits that represents an objects type, or in the special case of events, also whether the event is
+/// just an event, is a Transaction Event, is an exception event, or is an exception Transaction Event.
+/// - Item: 16 bits enumerating specific details about the ID.
+///
+/// For example, the specific Transaction Event returned after the SystemInit() call has executed is represented
+/// uniquely by the symbol tranevtSystemInit, which is an AAL_ID composed of:
+/// - Vendor:    AAL
+/// - Subsystem: sysAAS
+/// - Exception: No
+/// - Type:      Transaction Event
+/// - Item:      1 (Init)
+///
+/// It is expected that this hierarchical type system will be extended by vendors based upon their PCI-SIG
+/// Vendor ID.
+#if defined( __AAL_WINDOWS__ )
+   typedef ULONGLONG   btID;
+   typedef PVOID       btGenericInterface;   ///< Application casts to proper interface pointer.
+   typedef PVOID       btApplicationContext; ///< Generic context type. Application casts to proper implementation-specific pointer.
+// these Windows types defined in ntdef.h
+# ifdef __cplusplus
+   typedef bool        btBool;
+   typedef bool       *btBoolArray;
+# else
+   typedef UCHAR       btBool;
+   typedef PUCHAR     *btBoolArray;
+# endif // __cplusplus
+   typedef LPSTR       btString;
+   typedef LPSTR      *btStringArray;
+   typedef CHAR        btByte;
+   typedef PCHAR       btByteArray;
+   typedef PVOID       btObjectType;
+   typedef PVOID       btAny;
+   typedef PVOID      *btObjectArray;
+   typedef const PVOID btcObjectType;
+   typedef LPCSTR      btcString;
+   typedef LPCSTR     *btcStringArray;
+// these Windows types (plus ULONGLONG) defined in ntintsafe.h
+# ifndef __AAL_INT32_DEFINED
+# define __AAL_INT32_DEFINED 1
+     typedef INT32     bt32bitInt;                ///< Signed 32-bit integer.
+     typedef INT32    *bt32bitIntArray;           ///< Signed 32-bit integer array.
+     typedef UINT32    btUnsigned32bitInt;        ///< Unsigned 32-bit integer.
+     typedef UINT32   *btUnsigned32bitIntArray;   ///< Unsigned 32-bit integer array.
+# endif // __AAL_INT32_DEFINED
+# ifndef __AAL_INT64_DEFINED
+# define __AAL_INT64_DEFINED 1
+     typedef INT64     bt64bitInt;                ///< Signed 64-bit integer.
+     typedef INT64    *bt64bitIntArray;           ///< Signed 64-bit integer array.
+     typedef UINT64    btUnsigned64bitInt;        ///< Unsigned 64-bit integer.
+     typedef UINT64   *btUnsigned64bitIntArray;   ///< Unsigned 64-bit integer array.
+# endif // __AAL_INT64_DEFINED
+   typedef btUIntPtr   btPID;                     ///< Process Identifier
+   typedef btUIntPtr   btTID;                     ///< Thread Identifier
+   typedef HANDLE      btHANDLE;
+#else // ! __AAL_WINDOWS__
+   typedef unsigned long long btID;
+   typedef void              *btGenericInterface;   ///< Application casts to proper interface pointer.
+   typedef void              *btApplicationContext; ///< Generic context type. Application casts to proper implementation-specific pointer.
+# ifdef __cplusplus
+     typedef bool             btBool;
+     typedef bool            *btBoolArray;
+# else
+     typedef unsigned char    btBool;
+     typedef unsigned char   *btBoolArray;
+# endif // __cplusplus
+   typedef char              *btString;
+   typedef char             **btStringArray;
+   typedef char               btByte;
+   typedef char              *btByteArray;
+   typedef void              *btObjectType;
+   typedef void              *btAny;
+   typedef void             **btObjectArray;
+   typedef const void        *btcObjectType;
+   typedef const char        *btcString;
+   typedef const char       **btcStringArray;
+   typedef void              *btHANDLE;
+   typedef void              *HMODULE;
+#endif // OS
+typedef btID                  btIID;              ///< Integer interface identifier.
+typedef int                   btInt;
+typedef unsigned int          btUnsignedInt;
+typedef float                 btFloat;
+typedef float                *btFloatArray;
+typedef unsigned short int    btUnsigned16bitInt; ///< Unsigned 16-bit integer.
+
+#ifndef __AAL_INT32_DEFINED
+#define __AAL_INT32_DEFINED 1
+# if ( __AALSDK_DATA_MODEL_LP32 == __AALSDK_DATA_MODEL )
+     typedef long int                bt32bitInt;              ///< Signed 32-bit integer.
+     typedef long int               *bt32bitIntArray;         ///< Signed 32-bit integer array.
+     typedef unsigned long int       btUnsigned32bitInt;      ///< Unsigned 32-bit integer.
+     typedef unsigned long int      *btUnsigned32bitIntArray; ///< Unsigned 32-bit integer array.
+# elif ( __AALSDK_DATA_MODEL_ILP32 == __AALSDK_DATA_MODEL ) || ( __AALSDK_DATA_MODEL_LLP64 == __AALSDK_DATA_MODEL ) || ( __AALSDK_DATA_MODEL_LP64 == __AALSDK_DATA_MODEL )
+     typedef int                     bt32bitInt;              ///< Signed 32-bit integer.
+     typedef int                    *bt32bitIntArray;         ///< Signed 32-bit integer array.
+     typedef unsigned int            btUnsigned32bitInt;      ///< Unsigned 32-bit integer.
+     typedef unsigned int           *btUnsigned32bitIntArray; ///< Unsigned 32-bit integer array.
+# else
+// __AALSDK_DATA_MODEL_ILP64 requires int32 extension
+     typedef int32                   bt32bitInt;              ///< Signed 32-bit integer.
+     typedef int32                  *bt32bitIntArray;         ///< Signed 32-bit integer array.
+     typedef uint32                  btUnsigned32bitInt;      ///< Unsigned 32-bit integer.
+     typedef uint32                 *btUnsigned32bitIntArray; ///< Unsigned 32-bit integer array.
+# endif // __AALSDK_DATA_MODEL
+#endif // __AAL_INT32_DEFINED
+
+#ifndef __AAL_INT64_DEFINED
+#define __AAL_INT64_DEFINED 1
+# if ( __AALSDK_DATA_MODEL_LLP64 == __AALSDK_DATA_MODEL ) || ( defined( __AAL_LINUX__ ) && defined( __x86_64__ ) )
+     typedef long long int           bt64bitInt;              ///< Signed 64-bit integer.
+     typedef long long int          *bt64bitIntArray;         ///< Signed 64-bit integer array.
+     typedef unsigned long long int  btUnsigned64bitInt;      ///< Unsigned 64-bit integer.
+     typedef unsigned long long int *btUnsigned64bitIntArray; ///< Unsigned 64-bit integer array.
+# elif ( __AALSDK_DATA_MODEL_ILP64 == __AALSDK_DATA_MODEL ) || ( __AALSDK_DATA_MODEL_LP64 == __AALSDK_DATA_MODEL )
+     typedef long int                bt64bitInt;              ///< Signed 64-bit integer.
+     typedef long int               *bt64bitIntArray;         ///< Signed 64-bit integer array.
+     typedef unsigned long int       btUnsigned64bitInt;      ///< Unsigned 64-bit integer.
+     typedef unsigned long int      *btUnsigned64bitIntArray; ///< Unsigned 64-bit integer array.
+# else
+// Default to unsigned long long for the rest
+     typedef long long int           bt64bitInt;              ///< Signed 64-bit integer.
+     typedef long long int          *bt64bitIntArray;         ///< Signed 64-bit integer array.
+     typedef unsigned long long int  btUnsigned64bitInt;      ///< Unsigned 64-bit integer.
+     typedef unsigned long long int *btUnsigned64bitIntArray; ///< Unsigned 64-bit integer array.
+# endif // __AALSDK_DATA_MODEL
+#endif // __AAL_INT64_DEFINED
+
+# ifdef __AAL_LINUX__
+   typedef pid_t                     btPID;                   ///< Process Identifier
+// pthreads may define pthread_t as a 64-bit value.
+   typedef btUnsigned64bitInt        btTID;                   ///< Thread Identifier
+# endif // __AAL_LINUX__
+
+// Key types for NVS's
+typedef btcString          btStringKey;
+typedef btString           btmStringKey; // Modifiable version of btStringKey, no associated eNameTypes
+typedef btUnsigned64bitInt btNumberKey;  // WARNING: sizeof(btNumberKey) tracked in ResMgrUtilities::KeyNameFromDeviceAddress()
+
+typedef btUnsigned64bitInt btWSID;       ///< Workspace ID type.
+typedef btUnsigned64bitInt btWSSize;     ///< Workspace size type.
+
+typedef btUnsigned32bitInt btCSROffset;  ///< Configuration & Status Register offset.
+typedef btUnsigned64bitInt btCSRValue;   ///< Configuration & Status Register value.
+typedef btUnsigned32bitInt bt32bitCSR;   ///< 32-bit Configuration & Status Register value.
+typedef btUnsigned64bitInt bt64bitCSR;   ///< 64-bit Configuration & Status Register value.
+#ifndef AAL_INVALID_CSR_VALUE
+# define AAL_INVALID_CSR_VALUE ( (btCSRValue)-1 )
+#endif // AAL_INVALID_CSR_VALUE
+
+typedef btUnsigned64bitInt btTime;       ///< Generic time value.
+#ifndef AAL_INFINITE_WAIT
+# ifdef __cplusplus
+/// Signifies that a call which accepts a timeout value is to become a blocking call.
+#    define AAL_INFINITE_WAIT ( (AAL::btTime)-1 )
+# else
+#    define AAL_INFINITE_WAIT ( (btTime)-1 )
+# endif // __cplusplus
+#endif // AAL_INFINITE_WAIT
+
+#ifdef __cplusplus
+class IEvent;
+/// @brief btEventHandler is a user-provided callback routine used for dispatching events from the
+///   Event Delivery Service.
+///
+/// A default event handler is set during system initialization (AAL::SystemInit).  Event-specific
+/// handlers may also be set.
+typedef void (*btEventHandler)(IEvent const &TheEvent);
+#else
+typedef void (*btEventHandler)(void *TheEvent);
+#endif // __cplusplus
+
+#endif // __AALSDK_BASIC_TYPES_DEFINED
+
+
+/// @}
+
+
+CASSERT(true);
+CASSERT(!false);
+CASSERT(1 == sizeof(btBool)            );
+CASSERT(1 == sizeof(btByte)            );
+CASSERT(2 == sizeof(btUnsigned16bitInt));
+CASSERT(4 == sizeof(bt32bitInt)        );
+CASSERT(4 == sizeof(btUnsigned32bitInt));
+CASSERT(4 == sizeof(btFloat)           );
+CASSERT(8 == sizeof(bt64bitInt)        );
+CASSERT(8 == sizeof(btUnsigned64bitInt));
+
+CASSERT(sizeof_void_ptr == sizeof(btBoolArray)         );
+CASSERT(sizeof_void_ptr == sizeof(btFloatArray)        );
+CASSERT(sizeof_void_ptr == sizeof(btString)            );
+CASSERT(sizeof_void_ptr == sizeof(btStringArray)       );
+CASSERT(sizeof_void_ptr == sizeof(btByteArray)         );
+CASSERT(sizeof_void_ptr == sizeof(btObjectType)        );
+CASSERT(sizeof_void_ptr == sizeof(btObjectArray)       );
+CASSERT(sizeof_void_ptr == sizeof(btAny)               );
+CASSERT(sizeof_void_ptr == sizeof(btcObjectType)       );
+CASSERT(sizeof_void_ptr == sizeof(btcString)           );
+CASSERT(sizeof_void_ptr == sizeof(btcStringArray)      );
+CASSERT(sizeof_void_ptr == sizeof(btGenericInterface)  );
+CASSERT(sizeof_void_ptr == sizeof(btApplicationContext));
+
+#if   defined( __AAL_WINDOWS__ )
+
+// ntddk.h: NTKERNELAPI HANDLE PsGetCurrentProcessId(VOID);
+CASSERT(sizeof_void_ptr == sizeof(btPID));
+// ntddk.h: NTKERNELAPI HANDLE PsGetCurrentThreadId(VOID);
+CASSERT(sizeof_void_ptr == sizeof(btTID));
+
+#elif defined( __AAL_LINUX__ )
+
+// asm-generic/posix_types.h: typedef int __kernel_pid_t;
+// linux/types.h:             typedef __kernel_pid_t pid_t;
+CASSERT(sizeof(bt32bitInt)         == sizeof(btPID));
+CASSERT(sizeof(btUnsigned64bitInt) == sizeof(btTID));
+
+#endif // OS
+
+
+END_NAMESPACE(AAL)
+
+
+#endif // __AALSDK_KERNEL_AALTYPES_H__
+#endif // __AAL_KERNEL__
+
diff --git a/drivers/fpga/aal/include/aalsdk/kernel/aalui-events.h b/drivers/fpga/aal/include/aalsdk/kernel/aalui-events.h
new file mode 100644
index 000000000000..93ef29982c11
--- /dev/null
+++ b/drivers/fpga/aal/include/aalsdk/kernel/aalui-events.h
@@ -0,0 +1,671 @@
+//******************************************************************************
+// This  file  is  provided  under  a  dual BSD/GPLv2  license.  When using or
+//         redistributing this file, you may do so under either license.
+//
+//                            GPL LICENSE SUMMARY
+//
+//  Copyright(c) 2008-2017, Intel Corporation.
+//
+//  This program  is  free software;  you  can redistribute it  and/or  modify
+//  it  under  the  terms of  version 2 of  the GNU General Public License  as
+//  published by the Free Software Foundation.
+//
+//  This  program  is distributed  in the  hope that it  will  be useful,  but
+//  WITHOUT   ANY   WARRANTY;   without   even  the   implied   warranty    of
+//  MERCHANTABILITY  or  FITNESS  FOR  A  PARTICULAR  PURPOSE.  See  the   GNU
+//  General Public License for more details.
+//
+//  The  full  GNU  General Public License is  included in  this  distribution
+//  in the file called README.GPLV2-LICENSE.TXT.
+//
+//  Contact Information:
+//  Henry Mitchel, henry.mitchel at intel.com
+//  77 Reed Rd., Hudson, MA  01749
+//
+//                                BSD LICENSE
+//
+//  Copyright(c) 2008-2017, Intel Corporation.
+//
+//  Redistribution and  use  in source  and  binary  forms,  with  or  without
+//  modification,  are   permitted  provided  that  the  following  conditions
+//  are met:
+//
+//    * Redistributions  of  source  code  must  retain  the  above  copyright
+//      notice, this list of conditions and the following disclaimer.
+//    * Redistributions in  binary form  must  reproduce  the  above copyright
+//      notice,  this  list of  conditions  and  the  following disclaimer  in
+//      the   documentation   and/or   other   materials   provided  with  the
+//      distribution.
+//    * Neither   the  name   of  Intel  Corporation  nor  the  names  of  its
+//      contributors  may  be  used  to  endorse  or promote  products derived
+//      from this software without specific prior written permission.
+//
+//  THIS  SOFTWARE  IS  PROVIDED  BY  THE  COPYRIGHT HOLDERS  AND CONTRIBUTORS
+//  "AS IS"  AND  ANY  EXPRESS  OR  IMPLIED  WARRANTIES,  INCLUDING,  BUT  NOT
+//  LIMITED  TO, THE  IMPLIED WARRANTIES OF  MERCHANTABILITY  AND FITNESS  FOR
+//  A  PARTICULAR  PURPOSE  ARE  DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT
+//  OWNER OR CONTRIBUTORS BE LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,
+//  SPECIAL,  EXEMPLARY,  OR  CONSEQUENTIAL   DAMAGES  (INCLUDING,   BUT   NOT
+//  LIMITED  TO,  PROCUREMENT  OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF USE,
+//  DATA,  OR PROFITS;  OR BUSINESS INTERRUPTION)  HOWEVER  CAUSED  AND ON ANY
+//  THEORY  OF  LIABILITY,  WHETHER  IN  CONTRACT,  STRICT LIABILITY,  OR TORT
+//  (INCLUDING  NEGLIGENCE  OR OTHERWISE) ARISING  IN ANY WAY  OUT  OF THE USE
+//  OF  THIS  SOFTWARE, EVEN IF ADVISED  OF  THE  POSSIBILITY  OF SUCH DAMAGE.
+//******************************************************************************
+//****************************************************************************
+//        FILE: aalui-events.h
+//     CREATED: Dec. 3, 2008
+//      AUTHOR: Joseph Grecco, Intel Corporation.
+//
+// PURPOSE: This implements the external events for the
+//          Accelerator Abstraction Layer (AAL)
+//          Universal Interface Driver
+// HISTORY:
+// WHEN:          WHO:     WHAT:
+// 12/03/2008     JG       Initial Version started
+// 12/27/2008     JG       Support for AFU Response payload
+// 01/04/2009     HM       Updated Copyright
+// 03/20/2009     JG/HM    Global change to AFU_Response that generically puts
+//                            payloads after the structure with a pointer to
+//                            them. Ptr must be converted kernel to user.
+// 03/27/2009     JG       Added support for MGMT AFU interface
+// 05/15/2009     HM       Changed error code in uid_afurespID_e forced update
+// 06/05/2009     JG       Added shutdown
+// 06/27/2009     JG       Added timeout parameter to shutdown
+//                         (unused but passed through)
+// 08/06/2009     AC       Fixed a bug for payload buffer allocate failing
+// 12/27/2009     JG       Added support for csrmap event
+// 03/06/2012     JG       Put a check into uidrv_event_afutrancmplt_create
+//                          to check for NULL ptaskComplete
+//****************************************************************************
+#ifndef __AALSDK_KERNEL_AALUI_EVENTS_H__
+#define __AALSDK_KERNEL_AALUI_EVENTS_H__
+#include <aalsdk/kernel/kosal.h>
+#include <aalsdk/kernel/aaldevice.h>
+#include <aalsdk/kernel/aalqueue.h>
+#include <aalsdk/kernel/ccipdriver.h>
+
+BEGIN_NAMESPACE(AAL)
+
+//=============================================================================
+//=============================================================================
+// Name: uidrv_event_shutdown_event
+// Description: UI driver shutdown event.
+//=============================================================================
+//=============================================================================
+struct uidrv_event_shutdown_event
+{
+#define qip_to_ui_evtp_uishutdown(pqi) kosal_container_of(pqi, struct uidrv_event_shutdown_event, m_qitem)
+#define ui_evtp_uishutdown_to_qip(evt) ( &AALQI(evt) )
+   //
+   // Including the macro effectively causes this object to be derived from
+   // aal_q_item
+   //
+   _DECLARE_AALQ_TYPE;
+
+   uid_errnum_e          m_errnum;
+   stTransactionID_t     m_tranID;
+   btObjectType          m_context;
+   btVirtAddr            m_payload;
+   struct aalui_Shutdown m_shutdown;
+};
+
+//=============================================================================
+// Name: uidrv_event_shutdown_event_create
+// Inputs: reason - reason for the shutdown
+//         timeleft - If a timeout was given in the request how much is left
+//                    for user space shutdown.(i.e.,timeout-timeused in kernel)
+// Description: Constructor
+//=============================================================================
+static inline
+struct uidrv_event_shutdown_event *
+uidrv_event_shutdown_event_create(ui_shutdownreason_e reason,
+                                  btTime              timeleft,
+                                  stTransactionID_t  *tranID,
+                                  btObjectType        context,
+                                  uid_errnum_e        errnum)
+{
+   struct uidrv_event_shutdown_event *This =
+      (struct uidrv_event_shutdown_event *)kosal_kmalloc( sizeof(struct uidrv_event_shutdown_event) );
+
+   if ( NULL == This ) {
+      return NULL;
+   }
+   memset(This, 0, sizeof(struct uidrv_event_shutdown_event));
+
+   This->m_errnum             = errnum;
+   This->m_context            = context;
+   This->m_tranID             = *tranID;
+   This->m_shutdown.m_reason  = reason;
+   This->m_shutdown.m_timeout = timeleft;
+   This->m_payload            = (btVirtAddr)&This->m_shutdown;
+
+   AALQ_QLEN(This) = sizeof(struct aalui_Shutdown);
+   AALQ_QID(This)  = rspid_UID_Shutdown;
+
+   // Initialize the queue item
+   kosal_list_init(&AALQ_QUEUE(This));
+   return This;
+}
+
+//=============================================================================
+// Name: uidrv_event_shutdown_event_destroy
+// Description: Destructor
+//=============================================================================
+static inline
+void
+uidrv_event_shutdown_event_destroy(struct uidrv_event_shutdown_event *This)
+{
+   kosal_kfree(This, sizeof(struct uidrv_event_shutdown_event));
+}
+
+
+
+//=============================================================================
+//=============================================================================
+// Name: uidrv_event_afu_response_event
+// Description: AFU Reponse event. Sent to report various AFU responses
+//=============================================================================
+//=============================================================================
+struct uidrv_event_afu_response_event
+{
+#define qip_to_ui_evtp_afuresponse(pqi) kosal_container_of(pqi, struct uidrv_event_afu_response_event, m_qitem)
+#define ui_evtp_afuresponse_to_qip(evt) ( &AALQI(evt) )
+   //
+   // Including the macro effectively causes this object to be derived from
+   // aal_q_item
+   //
+   _DECLARE_AALQ_TYPE;
+
+   btObjectType      m_devhandle;
+   uid_errnum_e      m_errnum;
+   stTransactionID_t m_tranID;
+   btObjectType      m_context;
+
+   union{
+      struct aalui_AFUResponse *m_response;
+      btVirtAddr                m_payload;
+   };
+
+};
+#if 0
+//=============================================================================
+// Name: uidrv_event_afu_afucsrgetset_create
+// Description: Constructor
+//=============================================================================
+static inline
+struct uidrv_event_afu_response_event *
+uidrv_event_afu_afucsrgetset_create(btObjectType        devhandle,
+                                    csr_read_write_blk *pcsrrwb,
+                                    btUnsigned64bitInt  index,
+                                    stTransactionID_t  *tranID,
+                                    btObjectType        context,
+                                    uid_errnum_e        errnum)
+{
+   // Response buffer structure defined as Response followed by payload
+   struct big
+   {
+     struct aalui_AFUResponse  rsp;
+     struct csr_read_write_blk csrBlk;
+   } *pbig;
+
+   btWSSize size = sizeof(struct csr_offset_value) *  (pcsrrwb->num_to_get +  pcsrrwb->num_to_set);
+   btWSSize payloadsize = (sizeof(struct big) + size);
+
+   struct uidrv_event_afu_response_event *This =
+      (struct uidrv_event_afu_response_event *)kosal_kmalloc( sizeof(struct uidrv_event_afu_response_event) );
+   if ( NULL == This ) {
+      return NULL;
+   }
+   memset(This, 0, sizeof(struct uidrv_event_afu_response_event));
+
+   This->m_devhandle = devhandle;
+   This->m_errnum    = errnum;
+   This->m_context   = context;
+   This->m_tranID    = *tranID;
+
+   AALQ_QLEN(This) = 0;
+   This->m_payload = NULL;
+
+   // Allocate the RWB (NOTE: m_payload is unioned with the m_response pointer)
+   This->m_response = (struct aalui_AFUResponse *)kosal_kmalloc(payloadsize);
+   pbig = (struct big *)This->m_response;
+
+   if ( unlikely( NULL == This->m_payload ) ) {
+      This->m_errnum = uid_errnumNoMem;
+   } else {
+      This->m_response->respID = uid_afurespSetGetCSRComplete;
+      This->m_response->evtData = index;
+      This->m_response->pcsrBlk = &pbig->csrBlk;
+
+      This->m_response->pcsrBlk->num_to_get = pcsrrwb->num_to_get;
+      This->m_response->pcsrBlk->num_to_set = pcsrrwb->num_to_set;
+      kosal_printk("Num CSR get %" PRIu64 ", Num CSR Set %" PRIu64 "\n\n", This->m_response->pcsrBlk->num_to_get, This->m_response->pcsrBlk->num_to_set);
+      memcpy(This->m_response->pcsrBlk->csr_array,pcsrrwb->csr_array, (size_t)size);
+   }
+
+   AALQ_QLEN(This) = payloadsize;
+   AALQ_QID(This)  = rspid_AFU_Response;
+
+   // Initialize the queue item
+   kosal_list_init(&AALQ_QUEUE(This));
+   return This;
+}
+#endif
+
+//=============================================================================
+// Name: uidrv_event_afutrancmplt_create
+// Description: Constructor
+//=============================================================================
+static inline
+struct uidrv_event_afu_response_event *
+uidrv_event_afutrancmplt_create(btObjectType               devhandle,
+                                stTransactionID_t         *tranID,
+                                btObjectType               context,
+                                struct aalui_AFUResponse  *responsep,
+                                struct aalui_taskComplete *taskcomplete,
+                                btByteArray                pAFUDSMParms,
+                                btUnsignedInt              parmsSize,
+                                uid_errnum_e               eno)
+{
+   struct uidrv_event_afu_response_event *This =
+      (struct uidrv_event_afu_response_event *)kosal_kmalloc( sizeof(struct uidrv_event_afu_response_event) );
+
+   if ( NULL == This ) {
+      return NULL;
+   }
+   memset(This, 0, sizeof(struct uidrv_event_afu_response_event));
+
+   This->m_devhandle = devhandle;
+   This->m_errnum     = eno;
+   This->m_context   = context;
+   This->m_tranID    = *tranID;
+
+   AALQ_QLEN(This) = 0;
+   This->m_payload = NULL;
+
+   //-------------------------------------------------------------
+   // Load the response data if present
+   //  - Uses the payload field so that the generic event delivery
+   //    code in uidrv_process_message() is consistent
+   //-------------------------------------------------------------
+   if(responsep != NULL){
+       // Allocate the response
+      struct big
+      {
+         struct aalui_AFUResponse  rsp;
+         struct aalui_taskComplete tcp;
+         btByte                    dsmparms;
+      };
+
+      // also implicitly sets m_response
+      struct big *pbig = (struct big *)kosal_kmalloc(sizeof(struct big)+parmsSize);
+      This->m_payload  = (btVirtAddr)pbig;
+
+      if ( unlikely( NULL == This->m_payload ) ) {
+         This->m_errnum = uid_errnumNoMem;
+      } else {
+
+         // Copy in the aaluid_AFUResponse (pointer will have to be changed)
+         pbig->rsp = *responsep;
+         pbig->rsp.payloadsize = 0;
+
+         // Copy in the contents of the aalui_taskComplete
+         if(NULL != taskcomplete){
+            pbig->tcp = *taskcomplete;
+            pbig->rsp.payloadsize += sizeof(aalui_taskComplete);
+            kosal_printk("context %p, mode %d delim=%d\n\n",
+                         pbig->tcp.context,
+                         pbig->tcp.mode,
+                         pbig->tcp.delim);
+
+         }
+
+         // Copy in the contents of the aalui_taskComplete
+         if(NULL != pAFUDSMParms){
+            memcpy(&pbig->dsmparms, pAFUDSMParms, parmsSize);
+            pbig->rsp.payloadsize += parmsSize;
+         }
+ 
+         kosal_printk("uidrv_event_afutrancmplt_create: pbig=%p, ptaskComplete=%p\n\n",
+                         pbig,
+                         &pbig->tcp);
+         AALQ_QLEN(This) = sizeof(struct aalui_AFUResponse) + pbig->rsp.payloadsize;
+      }
+   }
+   AALQ_QID(This)    = rspid_AFU_Response;
+
+   // Initialize the queue item
+   kosal_list_init(&AALQ_QUEUE(This));
+   return This;
+}
+
+//=============================================================================
+// Name: uidrv_event_afutranstate_create
+// Description: Constructor for SPL2 transaction state change.
+//=============================================================================
+static inline
+struct uidrv_event_afu_response_event *
+uidrv_event_afutranstate_create(btObjectType              devhandle,
+                                stTransactionID_t        *tranID,
+                                btObjectType              context,
+                                struct aalui_AFUResponse *responsep,
+                                struct aalui_WSMParms    *pAFUDSMParms,
+                                uid_errnum_e              eno)
+{
+   struct uidrv_event_afu_response_event *This =
+      (struct uidrv_event_afu_response_event *)kosal_kmalloc( sizeof(struct uidrv_event_afu_response_event) );
+
+   if ( NULL == This ) {
+      return NULL;
+   }
+   memset(This, 0, sizeof(struct uidrv_event_afu_response_event));
+
+   This->m_devhandle = devhandle;
+   This->m_errnum    = eno;
+   This->m_context   = context;
+   This->m_tranID    = *tranID;
+
+   AALQ_QLEN(This) = 0;
+   This->m_payload = NULL;
+
+   //-------------------------------------------------------------
+   // Load the response data if present
+   //  - Uses the payload field so that the generic event delivery
+   //    code in uidrv_process_message() is consistent
+   //-------------------------------------------------------------
+   if(responsep != NULL){
+       // Allocate the response
+      struct big
+      {
+         struct aalui_AFUResponse rsp;
+         struct aalui_WSMParms    wsm;
+      };
+
+      // also implicitly sets m_response
+      struct big *pbig = (struct big *)kosal_kmalloc(sizeof(struct big));
+      This->m_payload  = (btVirtAddr)pbig;
+
+      if ( unlikely( NULL == This->m_payload ) ) {
+         This->m_errnum = uid_errnumNoMem;
+      } else {
+
+         // Copy in the aaluid_AFUResponse (pointer will have to be changed)
+         pbig->rsp = *responsep;
+         pbig->rsp.payloadsize = sizeof(struct aalui_WSMParms);
+         pbig->wsm = *pAFUDSMParms;
+
+         kosal_printk("uidrv_event_afutranstate_create(): pbig=%p, payload=%p\n\n",
+                         pbig, &pbig->wsm);
+         AALQ_QLEN(This) = sizeof(struct big);
+      }
+   }
+   AALQ_QID(This) = rspid_AFU_Response;
+
+   // Initialize the queue item
+   kosal_list_init(&AALQ_QUEUE(This));
+   return This;
+}
+
+
+//=============================================================================
+// Name: uidrv_event_afu_afuinavlidrequest_create
+// Description: Constructor
+//=============================================================================
+static inline
+struct uidrv_event_afu_response_event *
+uidrv_event_afu_afuinavlidrequest_create(btObjectType       devhandle,
+                                         stTransactionID_t *tranID,
+                                         btObjectType       context,
+                                         uid_errnum_e       eno)
+{
+
+   struct uidrv_event_afu_response_event *This =
+      (struct uidrv_event_afu_response_event *)kosal_kmalloc( sizeof(struct uidrv_event_afu_response_event) );
+
+   if ( NULL == This ) {
+      return NULL;
+   }
+   memset(This, 0, sizeof(struct uidrv_event_afu_response_event));
+
+   This->m_devhandle = devhandle;
+   This->m_errnum    = eno;
+   This->m_context   = context;
+   This->m_tranID    = *tranID;
+
+   // Allocate the RWB (NOTE: m_payload is union-ed with the m_response pointer)
+   This->m_response = (struct aalui_AFUResponse *)kosal_kmalloc(sizeof(struct aalui_AFUResponse));
+   if ( unlikely( NULL == This->m_response ) ) {
+       This->m_errnum = uid_errnumNoMem;
+   } else {
+       This->m_response->respID  = uid_afurespUndefinedRequest;
+       This->m_response->evtData = 0;
+       This->m_response->payloadsize = 0;
+       AALQ_QLEN(This) = sizeof(struct aalui_AFUResponse );
+   }
+
+   AALQ_QID(This) = rspid_AFU_Response;
+
+   // Initialize the queue item
+   kosal_list_init(&AALQ_QUEUE(This));
+   return This;
+}
+
+//=============================================================================
+// Name: uidrv_event_afuresponse_destroy
+// Description: Destructor
+//=============================================================================
+static inline
+void
+uidrv_event_afuresponse_destroy(struct uidrv_event_afu_response_event *This)
+{
+   if ( NULL != This->m_payload ) {
+      kosal_kfree(This->m_payload, AALQ_QLEN(This));
+   }
+   kosal_kfree(This, sizeof(struct uidrv_event_afu_response_event));
+}
+
+
+
+//=============================================================================
+//=============================================================================
+// Name: uidrv_event_afu_workspace_event
+// Description: Event sent by the PIP to signal that an AFU workspace operation
+//              has  completed
+//=============================================================================
+//=============================================================================
+struct uidrv_event_afu_workspace_event
+{
+#define qip_to_ui_evtp_afuwsevent(pqi)  kosal_container_of(pqi, struct uidrv_event_afu_workspace_event, m_qitem)
+#define ui_evtp_afucwsevent_to_qip(evt) ( &AALQI(evt) )
+   //
+   // Including the macro effectively causes this object to be derived from
+   // aal_q_item
+   //
+   _DECLARE_AALQ_TYPE;
+
+   btObjectType          m_devhandle;
+   btVirtAddr            m_payload;
+   struct aalui_WSMEvent m_WSEvent;
+   uid_errnum_e          m_errnum;
+   stTransactionID_t     m_tranID;
+   btObjectType          m_context;
+};
+
+
+//=============================================================================
+// Name: uidrv_event_afu_afucsrmap_create
+// Description: Constructor
+//=============================================================================
+static inline
+struct uidrv_event_afu_workspace_event *
+uidrv_event_afu_afuallocws_create(btObjectType      devhandle,
+                                  btWSID            wsid,
+                                  btVirtAddr        ptr,
+                                  btPhysAddr        physptr,
+                                  btWSSize          size,
+                                  stTransactionID_t tranID,
+                                  btObjectType      context,
+                                  uid_errnum_e      errnum)
+{
+   struct uidrv_event_afu_workspace_event *This =
+      (struct uidrv_event_afu_workspace_event *)kosal_kmalloc(sizeof(struct uidrv_event_afu_workspace_event));
+
+   if ( NULL == This ) {
+      return NULL;
+   }
+
+   This->m_devhandle                = devhandle;
+   This->m_WSEvent.evtID            = uid_wseventAllocate;
+   This->m_WSEvent.wsParms.wsid     = wsid;
+   This->m_WSEvent.wsParms.ptr      = ptr;
+   This->m_WSEvent.wsParms.physptr  = physptr;
+   This->m_WSEvent.wsParms.size     = size;
+   This->m_payload                  = (btVirtAddr)&This->m_WSEvent;
+   This->m_errnum                   = errnum;
+   This->m_context                  = context;
+   This->m_tranID                   = tranID;
+
+
+   AALQ_QID(This)                   = rspid_WSM_Response;
+
+   // Payload
+   AALQ_QLEN(This) = sizeof(struct aalui_WSMEvent);
+
+   // Initialize the queue item
+   kosal_list_init(&AALQ_QUEUE(This));
+   return This;
+}
+
+
+//=============================================================================
+// Name: uidrv_event_afu_afufreecws_create
+// Description: Constructor
+//=============================================================================
+static inline
+struct uidrv_event_afu_workspace_event *
+uidrv_event_afu_afufreecws_create(btObjectType      devhandle,
+                                  stTransactionID_t tranID,
+                                  btObjectType      context,
+                                  uid_errnum_e      eno)
+{
+   struct uidrv_event_afu_workspace_event *This =
+      (struct uidrv_event_afu_workspace_event *)kosal_kmalloc( sizeof(struct uidrv_event_afu_workspace_event) );
+   if ( NULL == This ) {
+      return NULL;
+   }
+
+   This->m_devhandle     = devhandle;
+   This->m_WSEvent.evtID = uid_wseventFree;
+   This->m_payload       = (btVirtAddr)&This->m_WSEvent;
+   This->m_errnum        = eno;
+   This->m_context       = context;
+   This->m_tranID        = tranID;
+
+   // no payload
+   AALQ_QID(This)  = rspid_WSM_Response;
+   AALQ_QLEN(This) = sizeof(struct aalui_WSMEvent);
+
+   // Initialize the queue item
+   kosal_list_init(&AALQ_QUEUE(This));
+   return This;
+}
+
+//=============================================================================
+// Name: uidrv_event_afu_afugetphysws_create
+// Description: Constructor
+//=============================================================================
+static inline
+struct uidrv_event_afu_workspace_event *
+uidrv_event_afu_afugetphysws_create(btObjectType      devhandle,
+                                    btPhysAddr        ptr,
+                                    stTransactionID_t tranID,
+                                    btObjectType      context,
+                                    uid_errnum_e      errnum)
+{
+   struct uidrv_event_afu_workspace_event *This =
+      (struct uidrv_event_afu_workspace_event *)kosal_kmalloc( sizeof(struct uidrv_event_afu_workspace_event) );
+   if ( NULL == This ) {
+      return NULL;
+   }
+
+   This->m_devhandle               = devhandle;
+   This->m_WSEvent.evtID           = uid_wseventGetPhys;
+   This->m_WSEvent.wsParms.physptr = ptr;
+   This->m_payload                 = (btVirtAddr)&This->m_WSEvent;
+   This->m_errnum                  = errnum;
+   This->m_context                 = context;
+   This->m_tranID                  = tranID;
+
+   // no payload
+   AALQ_QID(This)  = rspid_WSM_Response;
+   AALQ_QLEN(This) = sizeof(struct aalui_WSMEvent);
+
+   // Initialize the queue item
+   kosal_list_init(&AALQ_QUEUE(This));
+   return This;
+}
+
+#if 0
+//=============================================================================
+// Name: uidrv_event_afu_afugetcsrmap_create
+// Description: Constructor
+//=============================================================================
+static inline
+struct uidrv_event_afu_workspace_event *
+uidrv_event_afu_afugetcsrmap_create(btObjectType      devhandle,
+                                    btWSID            wsid,
+                                    btPhysAddr        physptr,
+                                    btWSSize          size,
+                                    btWSSize          csrsize,
+                                    btWSSize          csrspacing,
+                                    stTransactionID_t tranID,
+                                    btObjectType      context,
+                                    uid_errnum_e      errnum)
+{
+   struct uidrv_event_afu_workspace_event *This =
+      (struct uidrv_event_afu_workspace_event *)kosal_kmalloc( sizeof(struct uidrv_event_afu_workspace_event) );
+
+   if ( NULL == This ) {
+      return NULL;
+   }
+
+   This->m_devhandle                   = devhandle;
+   This->m_WSEvent.evtID               = uid_wseventCSRMap;
+   This->m_WSEvent.wsParms.wsid        = wsid;
+   This->m_WSEvent.wsParms.ptr         = NULL;
+   This->m_WSEvent.wsParms.physptr     = physptr;
+   This->m_WSEvent.wsParms.size        = size;
+   This->m_WSEvent.wsParms.itemsize    = csrsize;
+   This->m_WSEvent.wsParms.itemspacing = csrspacing;
+   This->m_payload                     = (btVirtAddr)&This->m_WSEvent;
+   This->m_errnum                      = errnum;
+   This->m_context                     = context;
+   This->m_tranID                      = tranID;
+
+   // Payload
+   AALQ_QID(This)  = rspid_WSM_Response;
+   AALQ_QLEN(This) = sizeof(struct aalui_WSMEvent);
+
+   // Initialize the queue item
+   kosal_list_init(&AALQ_QUEUE(This));
+   return This;
+}
+
+
+//=============================================================================
+// Name: uidrv_event_afucwsevent_destroy
+// Description: Destructor
+//=============================================================================
+static inline
+void
+uidrv_event_afucwsevent_destroy(struct uidrv_event_afu_workspace_event *This)
+{
+   kosal_kfree(This, sizeof(struct uidrv_event_afu_workspace_event));
+}
+#endif
+
+END_NAMESPACE(AAL)
+
+#endif // __AALSDK_KERNEL_AALUI_EVENTS_H__
+
diff --git a/drivers/fpga/aal/include/aalsdk/kernel/aalui.h b/drivers/fpga/aal/include/aalsdk/kernel/aalui.h
new file mode 100644
index 000000000000..bc25662a13f1
--- /dev/null
+++ b/drivers/fpga/aal/include/aalsdk/kernel/aalui.h
@@ -0,0 +1,475 @@
+//******************************************************************************
+// This  file  is  provided  under  a  dual BSD/GPLv2  license.  When using or
+//         redistributing this file, you may do so under either license.
+//
+//                            GPL LICENSE SUMMARY
+//
+//  Copyright(c) 2008-2017, Intel Corporation.
+//
+//  This program  is  free software;  you  can redistribute it  and/or  modify
+//  it  under  the  terms of  version 2 of  the GNU General Public License  as
+//  published by the Free Software Foundation.
+//
+//  This  program  is distributed  in the  hope that it  will  be useful,  but
+//  WITHOUT   ANY   WARRANTY;   without   even  the   implied   warranty    of
+//  MERCHANTABILITY  or  FITNESS  FOR  A  PARTICULAR  PURPOSE.  See  the   GNU
+//  General Public License for more details.
+//
+//  The  full  GNU  General Public License is  included in  this  distribution
+//  in the file called README.GPLV2-LICENSE.TXT.
+//
+//  Contact Information:
+//  Henry Mitchel, henry.mitchel at intel.com
+//  77 Reed Rd., Hudson, MA  01749
+//
+//                                BSD LICENSE
+//
+//  Copyright(c) 2008-2017, Intel Corporation.
+//
+//  Redistribution and  use  in source  and  binary  forms,  with  or  without
+//  modification,  are   permitted  provided  that  the  following  conditions
+//  are met:
+//
+//    * Redistributions  of  source  code  must  retain  the  above  copyright
+//      notice, this list of conditions and the following disclaimer.
+//    * Redistributions in  binary form  must  reproduce  the  above copyright
+//      notice,  this  list of  conditions  and  the  following disclaimer  in
+//      the   documentation   and/or   other   materials   provided  with  the
+//      distribution.
+//    * Neither   the  name   of  Intel  Corporation  nor  the  names  of  its
+//      contributors  may  be  used  to  endorse  or promote  products derived
+//      from this software without specific prior written permission.
+//
+//  THIS  SOFTWARE  IS  PROVIDED  BY  THE  COPYRIGHT HOLDERS  AND CONTRIBUTORS
+//  "AS IS"  AND  ANY  EXPRESS  OR  IMPLIED  WARRANTIES,  INCLUDING,  BUT  NOT
+//  LIMITED  TO, THE  IMPLIED WARRANTIES OF  MERCHANTABILITY  AND FITNESS  FOR
+//  A  PARTICULAR  PURPOSE  ARE  DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT
+//  OWNER OR CONTRIBUTORS BE LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,
+//  SPECIAL,  EXEMPLARY,  OR  CONSEQUENTIAL   DAMAGES  (INCLUDING,   BUT   NOT
+//  LIMITED  TO,  PROCUREMENT  OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF USE,
+//  DATA,  OR PROFITS;  OR BUSINESS INTERRUPTION)  HOWEVER  CAUSED  AND ON ANY
+//  THEORY  OF  LIABILITY,  WHETHER  IN  CONTRACT,  STRICT LIABILITY,  OR TORT
+//  (INCLUDING  NEGLIGENCE  OR OTHERWISE) ARISING  IN ANY WAY  OUT  OF THE USE
+//  OF  THIS  SOFTWARE, EVEN IF ADVISED  OF  THE  POSSIBILITY  OF SUCH DAMAGE.
+//******************************************************************************
+//****************************************************************************
+//        FILE: aalui.h
+//     CREATED: Sep 28, 2008
+//      AUTHOR: Joseph Grecco, Intel Corporation.
+//
+// PURPOSE: Definitions for the AAL Universal Interface Driver
+// HISTORY:
+// WHEN:          WHO:     WHAT:
+// 9/28/2008      JG       Initial version started
+// 11/11/2008     JG       Added legal header
+// 12/10/2008     JG       Added support for bound wsmgr
+// 12/13/2008     HM       Adde uid_errnumNoMap to uid_errnum_e
+// 12/16/2008     JG       Began support for abort and shutdown
+//                         Added Support for WSID object
+//                         Major interface changes.
+// 12/18/2008     HM       Added aalui_PIPmessage
+// 12/27/2008     JG       Added AFU response payloads
+// 01/04/2009     HM       Updated Copyright
+// 01/05/2009     JG       Support for additional information in AFUReponse
+//                         event.
+// 03/17/2009     JG       Added GetSet CSR
+// 03/20/2009     JG/HM    Global change to AFU_Response that generically puts
+//                            payloads after the structure with a pointer to
+//                            them. Ptr must be converted kernel to user.
+// 03/27/2009     JG       Added support for MGMT AFU interface
+// 05/11/2009     HM       Tweaked definition of MGMT AFU interface structure
+// 05/15/2009     HM       Changed error code in uid_afurespID_e
+// 05/19/2009     HM       Added values to uid_afurespID_e, and changed
+//                            mafu_request.payload to char*
+// 06/05/2009     JG       Added shutdown
+// 11/05/2009     HM       Changed size field in struct aalui_WSMParms from
+//                            int to size_t. Needs to be big enough to handle
+//                            any sized object.
+// 12/09/2009     JG       Pulled out AFU PIP commands aalui_afucmd_e
+//                         and moved it to fappip,h and defined them as FAP
+//                         pip specific.
+// 12/27/2009     JG       Added support for CSR Map
+// 03/05/2012     JG       Added support for uid_afurespTaskStarted for SPL2
+// 03/12/2012     JG       Removed linked payloads from AFUResponse
+//****************************************************************************
+#ifndef __AALSDK_KERNEL_AALUI_H__
+#define __AALSDK_KERNEL_AALUI_H__
+#include <aalsdk/kernel/aaltypes.h>
+#include <aalsdk/kernel/AALTransactionID_s.h>
+#include <aalsdk/kernel/AALWorkspace.h>
+#include <aalsdk/kernel/iaaldevice.h>
+
+BEGIN_NAMESPACE(AAL)
+
+BEGIN_C_DECLS
+
+//-----------------------------------------------------------------------------
+// Request message IDs
+//-----------------------------------------------------------------------------
+typedef enum
+{
+   // Management
+   reqid_UID_Bind=1,                // Use default API Version
+   reqid_UID_ExtendedBindInfo,      // Pass additional Bind parms
+   reqid_UID_UnBind,                // Release a device
+
+   // Provision
+   reqid_UID_Activate,              // Activate the device
+   reqid_UID_Deactivate,            // Deactivate the device
+
+   // Administration
+   reqid_UID_Shutdown,              // Request that the Service session shutdown
+
+   reqid_UID_SendAFU,               // Send AFU a message
+   reqid_UID_SendWSM,               // Send to Workspace Manager
+
+   // Response and Event IDs
+   rspid_UID_Shutdown=0xF000,       // Service is shutdown
+   rspid_UID_UnbindComplete,        // Release Device Response
+   rspid_UID_BindComplete,          // Bind has completed
+
+   rspid_UID_Activate,              // Activate the device
+   rspid_UID_Deactivate,            // Deactivate the device
+
+   rspid_AFU_Response,              // Response from AFU request
+   rspid_AFU_Event,                 // Event from AFU
+
+   rspid_PIP_Event,                 // Event from PIP
+
+   rspid_WSM_Response,              // Event from Workspace manager
+
+   rspid_UID_Response,
+   rspid_UID_Event,
+
+} uid_msgIDs_e;
+
+typedef enum
+{
+   uid_errnumOK = 0,
+   uid_errnumBadDevHandle,                       // 1
+   uid_errnumCouldNotClaimDevice,                // 2
+   uid_errnumNoAppropriateInterface,             // 3
+   uid_errnumDeviceHasNoPIPAssigned,             // 4
+   uid_errnumCouldNotBindPipInterface,           // 5
+   uid_errnumCouldNotUnBindPipInterface,         // 6
+   uid_errnumNotDeviceOwner,                     // 7
+   uid_errnumSystem,                             // 8
+   uid_errnumAFUTransaction,                     // 9
+   uid_errnumAFUTransactionNotFound,             // 10
+   uid_errnumDuplicateStartingAFUTransactionID,  // 11
+   uid_errnumBadParameter,                       // 12
+   uid_errnumNoMem,                              // 13
+   uid_errnumNoMap,                              // 14
+   uid_errnumBadMapping,                         // 15
+   uid_errnumPermission,                         // 16
+   uid_errnumInvalidOpOnMAFU,                    // 17
+   uid_errnumPointerOutOfWorkspace,              // 18
+   uid_errnumNoAFUBindToChannel,                 // 19
+   uid_errnumCopyFromUser,                       // 20
+   uid_errnumDescArrayEmpty,                     // 21
+   uid_errnumCouldNotCreate,                     // 22
+   uid_errnumInvalidRequest,                     // 23
+   uid_errnumInvalidDeviceAddr,                  // 24
+   uid_errnumCouldNotDestroy,                    // 25
+   uid_errnumDeviceBusy,                         // 26
+   uid_errnumNoAFU                               // 27
+} uid_errnum_e;
+
+
+
+//=============================================================================
+// Name: aalui_extbindargs
+// TYpe pDir]; Request[IN] Response[OUT]
+// Description: Extended bind arguments.
+// Comments: This object is used to specify arguments to the PIP during the
+//           bind operation and to receive attributes back in the bind complete
+//=============================================================================
+struct aalui_extbindargs
+{
+   btUnsigned64bitInt m_apiver;        // Version of message handler
+   btUnsigned64bitInt m_pipver;        // Version of PIP interface
+   btUnsigned32bitInt m_mappableAPI;   // Permits direct CSR mapping
+   btObjectType       m_pipattrib;     // Attribute block (TBD)
+};
+
+
+
+//=============================================================================
+// Name: aalui_Shutdown
+// Type[Dir]: Request[IN]
+// Object: UI Driver
+// Description: Request to the AFU
+// Comments:
+//=============================================================================
+typedef enum
+{
+   ui_shutdownReasonNormal=0,
+   ui_shutdownReasonMaint,
+   ui_shutdownFailure,
+   ui_shutdownReasonRestart
+} ui_shutdownreason_e;
+
+struct aalui_Shutdown {
+   ui_shutdownreason_e m_reason;
+   btTime              m_timeout;
+};
+
+
+//=============================================================================
+// Name: aalui_AFUmessage
+// Type[Dir]: Request [IN]
+// Object: AFU Engine
+// Command ID: reqid_UID_SendAFU
+// Input: apiver - Version (ID) of the message protocol using
+//        pipver - Version (ID) of PIP expected
+//           cmd - Command
+//       payload - Payload of message
+// Description: Used when sending a message to an AFU
+// Comments: The API and PIP versions are provided as an additional check
+//           that the message sent is using the appropriate protocol.
+//=============================================================================
+#define AALUI_AFUCMD_STARTMAFU   0xF001
+
+struct aalui_AFUmessage
+{
+   btUnsigned64bitInt  apiver;     // Version of message handler [IN]
+   btUnsigned64bitInt  pipver;     // Version of PIP interface [IN]
+   btUnsigned64bitInt  cmd;        // Command [IN]
+   btWSSize            size;       // size of payload [IN]
+   btVirtAddr          payload;    // data [IN/OUT]
+};
+
+//=============================================================================
+// Name: aalui_taskComplete
+// Type[Dir]: Request[IN] Event/Response [OUT]
+// Object: AFU engine
+// Description: Single or mult0 descriptor AFU task completed
+// Comments:
+//=============================================================================
+typedef struct aalui_taskComplete
+{
+   btObjectType       context;
+   stTransactionID_t  afutskTranID;
+   btByte             data[32];
+   TTASK_MODE         mode;
+   btUnsigned16bitInt delim;
+} aalui_taskComplete;
+
+//=============================================================================
+// Name: csr_offset_value
+// Type[Dir]: Request[IN] Event/Response [OUT]
+// Object: AFU engine
+// Description: Describes a CSR object and its Value
+// Comments: Used for setting and getting AFU CSRs
+//=============================================================================
+typedef struct csr_offset_value
+{
+   btCSROffset csr_offset; // CSR index: 0, 1, 2, ...
+   btCSRValue  csr_value;  // Value
+} csr_offset_value;
+
+//=============================================================================
+// Name: csr_read_write_blk
+// Type[Dir]: Request[IN] Event/Response [OUT]
+// Object: AFU engine
+// Description: Block of csr_offset_value objects used for getting and setting
+//              blocks of CSRs
+// Comments: Used for setting and getting AFU CSRs
+//=============================================================================
+typedef struct csr_read_write_blk
+{
+   btWSSize         num_to_get;   // length of get array. if 0, do not get.
+   btWSSize         num_to_set;   // length of set array. if 0, do not set.
+   csr_offset_value csr_array[1]; // array of csr_ofset_value's, GET first, then SET
+} csr_read_write_blk;
+#define csr_rwb_getarray(p) (p)->csr_array
+#define csr_rwb_setarray(p) ( (p)->csr_array + (p)->num_to_get )
+
+
+//=============================================================================
+// Name: aalui_AFUResponse
+// Type[Dir]: Event/Response [OUT]
+// Object: AFU engine
+// Command ID: reqid_UID_SendAFU
+// fields: context - user defined data associated with descriptor
+//         afutskTranID - transaction ID of AFU task
+//         respID - ID code of response
+//         mode - mode the descriptor ran
+//         data - 32 buyte data returned by AFU
+// Description: Returned AFU response to a request
+// Comments:
+//=============================================================================
+typedef enum
+{
+   uid_afurespUndefinedResponse=0,
+   uid_afurespInputDescriptorComplete,
+   uid_afurespOutputDescriptorComplete,
+   uid_afurespEndofTask,
+   uid_afurespTaskStarted,
+   uid_afurespTaskStopped,
+   uid_afurespSetContext,
+   uid_afurespTaskComplete,
+   uid_afurespSetGetCSRComplete,
+   uid_afurespAFUCreateComplete,
+   uid_afurespAFUDestroyComplete,
+   uid_afurespActivateComplete,
+   uid_afurespDeactivateComplete,
+   uid_afurespInitializeComplete,
+   uid_afurespFreeComplete,
+   uid_afurespUndefinedRequest,
+   uid_afurespFirstUserResponse = 0xf000
+} uid_afurespID_e;
+
+struct aalui_AFUResponse
+{
+   btUnsigned32bitInt  respID;
+   btUnsigned64bitInt  evtData;
+   btUnsignedInt       payloadsize;
+   csr_read_write_blk *pcsrBlk;
+};
+#define aalui_AFURespPayload(__ptr) ( ((btVirtAddr)(__ptr)) + sizeof(struct aalui_AFUResponse) )
+
+
+//=============================================================================
+// Name:        aalui_PIPmessage
+// Type[Dir]:   Request [IN]
+// Object:      PIP
+// Command ID:  reqid_UID_SendPIP
+// Input:       apiver - Version (ID) of the message protocol using
+//              pipver - Version (ID) of PIP expected
+//              cmd - Command
+//              payload - Payload of message
+// Description: Used when sending a message to a PIP
+// Comments:    The API and PIP versions are provided as an additional check
+//              that the message sent is using the appropriate protocol.
+//=============================================================================
+struct aalui_PIPmessage
+{
+   btUnsigned64bitInt apiver;     // Version of message handler [IN]
+   btUnsigned64bitInt pipver;     // Version of PIP interface [IN]
+   btUnsigned64bitInt cmd;        // Command [IN]
+   btVirtAddr         payload;    // data [IN/OUT]
+};
+
+
+//=============================================================================
+// Name: aalui_WSMParms
+// Object: Kernel Workspace Manager Service
+// Command ID: reqid_UID_SendWSM
+// Input: wsid  - Workspace ID
+//        ptr   - Pointer to start of workspace
+//        physptr - Physical address
+//        size  - size in bytes of workspace
+// Description: Parameters describing a workspace
+// Comments: Used in WSM interface
+//=============================================================================
+struct aalui_WSMParms
+{
+   btWSID     wsid;        // Workspace ID
+   btVirtAddr ptr;         // Virtual Workspace pointer
+   btPhysAddr physptr;     // Depends on use
+   btWSSize   size;        // Workspace size
+   btWSSize   itemsize;    // Workspace item size
+   btWSSize   itemspacing; // Workspace item spacing
+   TTASK_MODE type;        // Task mode this workspace is compatible with
+};
+
+
+//=============================================================================
+// Name: aalui_WSMEvent
+// Type[Dir]: Event/Response [OUT]
+// Object: Kernel Workspace Manager Service
+// Command ID: reqid_UID_SendWSM
+// fields: wsid - Workspace ID
+//         ptr  - Pointer tostart of workspace
+//         size - size in bytes of workspace
+// Description: Parameters describing a workspace
+// Comments: Used in WSM interface
+//=============================================================================
+typedef enum
+{
+   uid_wseventAllocate=0,
+   uid_wseventFree,
+   uid_wseventGetPhys,
+   uid_wseventCSRMap,
+   uid_wseventMMIOMap
+} uid_wseventID_e;
+
+struct aalui_WSMEvent
+{
+   uid_wseventID_e       evtID;
+   struct aalui_WSMParms wsParms;
+};
+
+
+//=============================================================================
+// Name: aalui_ioctlreq
+// Description: IOCTL message block
+//=============================================================================
+struct aalui_ioctlreq
+{
+   uid_msgIDs_e       id;      // ID of UI request [IN]
+   stTransactionID_t  tranID;  // Transaction ID to identify result [IN]
+   btObjectType       context; // Optional token [IN]
+   uid_errnum_e       errcode; // Driver specific error number
+   btHANDLE           handle;  // Device handle
+   btWSSize           size;    // Size of payload section [IN]
+//   btVirtAddr         payload; // Pointer to optional payload [IN]
+};
+
+// TODO CASSERT( sizeof(struct aalui_ioctlreq) 
+
+#define aalui_ioAFUmessagep(i)  	(struct aalui_AFUmessage *)(((char *)i) + sizeof(struct aalui_ioctlreq) )
+#define aalui_ioctlPayload(i)   	(void *)(((char *)i) + sizeof(struct aalui_ioctlreq) )
+#define aalui_ioctlPayloadSize(i)   ((i)->size)
+
+#if   defined( __AAL_LINUX__ )
+# define AALUID_IOCTL_SENDMSG       _IOR ('x', 0x00, struct aalui_ioctlreq)
+# define AALUID_IOCTL_GETMSG_DESC   _IOR ('x', 0x01, struct aalui_ioctlreq)
+# define AALUID_IOCTL_GETMSG        _IOWR('x', 0x02, struct aalui_ioctlreq)
+# define AALUID_IOCTL_BINDDEV       _IOWR('x', 0x03, struct aalui_ioctlreq)
+# define AALUID_IOCTL_ACTIVATEDEV   _IOWR('x', 0x04, struct aalui_ioctlreq)
+# define AALUID_IOCTL_DEACTIVATEDEV _IOWR('x', 0x05, struct aalui_ioctlreq)
+#elif defined( __AAL_WINDOWS__ )
+# ifdef __AAL_USER__
+#    include <winioctl.h>
+# endif // __AAL_USER__
+
+// CTL_CODE() bits:
+//     Common[31]
+// DeviceType[30:16]
+//     Access[15:14]
+//     Custom[13]
+//   Function[12:2] (or [10:0] << 2)
+//     Method[1:0]
+
+# define UAIA_DRV_ID                  0x2
+# define UAIA_DEVICE_TYPE             FILE_DEVICE_BUS_EXTENDER
+# define UAIA_ACCESS                  FILE_ANY_ACCESS
+# define UAIA_CUSTOM                  1
+# define UAIA_METHOD                  METHOD_BUFFERED
+
+// field extractors
+# define AAL_IOCTL_DRV_ID(__ctl_code) (((__ctl_code) >> 10) & 0x7)
+# define AAL_IOCTL_FN(__ctl_code)     (((__ctl_code) >> 2) & 0xff)
+
+                  // 0 - 0xff
+# define UAIA_IOCTL(__index)          CTL_CODE(UAIA_DEVICE_TYPE, (UAIA_CUSTOM << 11) | (UAIA_DRV_ID << 8) | (__index), UAIA_METHOD, UAIA_ACCESS)
+
+# define AALUID_IOCTL_SENDMSG         UAIA_IOCTL(0x00)
+# define AALUID_IOCTL_GETMSG_DESC     UAIA_IOCTL(0x01)
+# define AALUID_IOCTL_GETMSG          UAIA_IOCTL(0x02)
+# define AALUID_IOCTL_BINDDEV         UAIA_IOCTL(0x03)
+# define AALUID_IOCTL_ACTIVATEDEV     UAIA_IOCTL(0x04)
+# define AALUID_IOCTL_DEACTIVATEDEV   UAIA_IOCTL(0x05)
+# define AALUID_IOCTL_POLL            UAIA_IOCTL(0x06)
+# define AALUID_IOCTL_MMAP            UAIA_IOCTL(0x07)
+
+#endif // OS
+
+END_C_DECLS
+
+END_NAMESPACE(AAL)
+
+#endif // __AALSDK_KERNEL_AALUI_H__
+
diff --git a/drivers/fpga/aal/include/aalsdk/kernel/aalwsservice.h b/drivers/fpga/aal/include/aalsdk/kernel/aalwsservice.h
new file mode 100644
index 000000000000..adac679899b2
--- /dev/null
+++ b/drivers/fpga/aal/include/aalsdk/kernel/aalwsservice.h
@@ -0,0 +1,236 @@
+//******************************************************************************
+// This  file  is  provided  under  a  dual BSD/GPLv2  license.  When using or
+//         redistributing this file, you may do so under either license.
+//
+//                            GPL LICENSE SUMMARY
+//
+//  Copyright(c) 2008-2017, Intel Corporation.
+//
+//  This program  is  free software;  you  can redistribute it  and/or  modify
+//  it  under  the  terms of  version 2 of  the GNU General Public License  as
+//  published by the Free Software Foundation.
+//
+//  This  program  is distributed  in the  hope that it  will  be useful,  but
+//  WITHOUT   ANY   WARRANTY;   without   even  the   implied   warranty    of
+//  MERCHANTABILITY  or  FITNESS  FOR  A  PARTICULAR  PURPOSE.  See  the   GNU
+//  General Public License for more details.
+//
+//  The  full  GNU  General Public License is  included in  this  distribution
+//  in the file called README.GPLV2-LICENSE.TXT.
+//
+//  Contact Information:
+//  Henry Mitchel, henry.mitchel at intel.com
+//  77 Reed Rd., Hudson, MA  01749
+//
+//                                BSD LICENSE
+//
+//  Copyright(c) 2008-2017, Intel Corporation.
+//
+//  Redistribution and  use  in source  and  binary  forms,  with  or  without
+//  modification,  are   permitted  provided  that  the  following  conditions
+//  are met:
+//
+//    * Redistributions  of  source  code  must  retain  the  above  copyright
+//      notice, this list of conditions and the following disclaimer.
+//    * Redistributions in  binary form  must  reproduce  the  above copyright
+//      notice,  this  list of  conditions  and  the  following disclaimer  in
+//      the   documentation   and/or   other   materials   provided  with  the
+//      distribution.
+//    * Neither   the  name   of  Intel  Corporation  nor  the  names  of  its
+//      contributors  may  be  used  to  endorse  or promote  products derived
+//      from this software without specific prior written permission.
+//
+//  THIS  SOFTWARE  IS  PROVIDED  BY  THE  COPYRIGHT HOLDERS  AND CONTRIBUTORS
+//  "AS IS"  AND  ANY  EXPRESS  OR  IMPLIED  WARRANTIES,  INCLUDING,  BUT  NOT
+//  LIMITED  TO, THE  IMPLIED WARRANTIES OF  MERCHANTABILITY  AND FITNESS  FOR
+//  A  PARTICULAR  PURPOSE  ARE  DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT
+//  OWNER OR CONTRIBUTORS BE LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,
+//  SPECIAL,  EXEMPLARY,  OR  CONSEQUENTIAL   DAMAGES  (INCLUDING,   BUT   NOT
+//  LIMITED  TO,  PROCUREMENT  OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF USE,
+//  DATA,  OR PROFITS;  OR BUSINESS INTERRUPTION)  HOWEVER  CAUSED  AND ON ANY
+//  THEORY  OF  LIABILITY,  WHETHER  IN  CONTRACT,  STRICT LIABILITY,  OR TORT
+//  (INCLUDING  NEGLIGENCE  OR OTHERWISE) ARISING  IN ANY WAY  OUT  OF THE USE
+//  OF  THIS  SOFTWARE, EVEN IF ADVISED  OF  THE  POSSIBILITY  OF SUCH DAMAGE.
+//******************************************************************************
+//****************************************************************************
+//  FILE: aalwsservice.h
+//  Author:  Alvin Chen, Intel Corporation
+//  Created: 08/12/2008
+//
+//  Description:
+//      Accelerator Abstraction Layer (AAL)
+//      Kernel Workspace Manager Service Module
+//
+// WHEN:          WHO:     WHAT:
+// 08/12/2008     AC       Initial version started
+// 11/11/2008     JG       Added legal header
+// 11/25/2008     HM       Large merge
+// 12/16/2008     JG       Began support for abort and shutdown
+//                            Added Support for WSID object
+//                            Major interface changes.
+// 01/04/2009     HM       Updated Copyright
+// 12/27/2009     JG       Added CSR WS type
+// 11/12/2010     AG       check for NULL pws in AAL_CHECK_WORKSPACE macro
+// 02/26/2013     AG       Add wsid tracking and validation routines
+// 03/12/2013     JG       Added Windows MMAP wsids
+//****************************************************************************
+#ifndef __AALSDK_KERNEL_AALWSSERVICE_H__
+#define __AALSDK_KERNEL_AALWSSERVICE_H__
+#include <aalsdk/kernel/kosal.h>
+
+BEGIN_NAMESPACE(AAL)
+
+/////////////////////////////////////////////////////////////////////////////////
+/////////////////////////////////////////////////////////////////////////////////
+// API IIDs TODO should come from aal ids
+#define AAL_WSAPI_IID_01         (0x21)
+
+////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+#define AAL_CL_SIZE                     64
+#define AAL_PGTABLE_CL_SIZE             0x80
+
+/////////////////////////////////////////////////////////////////////////////////////
+// *   Local Definitions
+/////////////////////////////////////////////////////////////////////////////////////
+#define AAL_WKSP_MAX_SUPERPAGES_NUM_BITS    (10)
+#define AAL_WKSP_MAX_SUPERPAGES_NUM         (1 << AAL_WKSP_MAX_SUPERPAGES_NUM_BITS)    /* 1K, Defined in HW SPEC. */
+#define AAL_WKSP_MAX_SUPERPAGE_SIZE_BITS    (23)
+#define AAL_WKSP_MAX_SUPERPAGE_SIZE         (1 << AAL_WKSP_MAX_SUPERPAGE_SIZE_BITS )   /* 8M, Defined in HW SPEC. */
+#define AAL_WKSP_MAX_SIZE                   ((btUnsigned64bitInt)AAL_WKSP_MAX_SUPERPAGE_SIZE * (btUnsigned64bitInt)AAL_WKSP_MAX_SUPERPAGES_NUM) /* we support 8G per WS */
+
+//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+#define AAL_CHECK_WORKSPACE( pws )          ( NULL != pws && (btUnsigned32bitInt)pws->m_superpage[0] == pws->m_id )
+
+
+
+//=============================================================================
+//=============================================================================
+//                                WORKSPACE
+//=============================================================================
+//=============================================================================
+
+//=============================================================================
+// Name: aal_wsid
+// Description: Wrapper object for the workspace ID
+//=============================================================================
+enum wstype
+{
+   WSM_TYPE_VIRTUAL,
+   WSM_TYPE_PHYSICAL,
+   WSM_TYPE_CSR,
+   WSM_TYPE_MMIO
+};
+struct aal_wsid
+{
+   struct aal_device *m_device;     // Device
+   btWSID             m_id;         // ID, and pointer to workspace structure
+   btHANDLE           m_dmahandle;  // Optional DMA Handle
+   btWSID             m_handle;     // Handle passed up to user mode
+   kosal_map_handle   m_maphandle;  // Used by OS User mode mapping
+   enum wstype        m_type;       // Type of allocation
+   btWSSize           m_size;       // Size of workspace
+   kosal_list_head    m_list;       // Device owner list it is on
+   /* chain of allocated workspace IDs; head is in ui_driver */
+   kosal_list_head    m_alloc_list;
+};
+
+
+#ifdef __i386__
+#define wsidobjp_to_wid(id)    ((unsigned long long)id)
+#define wsid_to_wsidobjp(id)   ((struct aal_wsid *) ( id ) )
+
+#define pgoff_to_wsidobj(off)  ((struct aal_wsid *)  (( (unsigned long )(off)) << PAGE_SHIFT))
+
+#else
+
+#     define wsid_to_maphandle(pwsid)     ( pwsid->m_maphandle )
+
+#  if   defined ( __AAL_WINDOWS__ )
+// Do nothing for Windows
+#     define wsid_to_wsidHandle(id) ( (btWSID)(id) )
+#     define pwsid_to_wsidHandle( pwsid ) ( (btWSID)( pwsid->m_handle ) )
+
+#     define wsid_to_wsidobjp(id)      ( (struct aal_wsid *)id )
+
+#     define pgoff_to_wsidobj(off)     ( (struct aal_wsid *)(off))
+
+#  elif defined ( __AAL_LINUX__ )
+
+
+#     define wsid_to_wsidHandle(wsid)  ((btWSID)( (wsid) <<21 ))
+//#     define wsidHandle_to_wsid(h)     ( ((btWSID)(off)) >>21 )
+
+//#     define pgoff_to_wsid(off)        ( ((btWSID)(off)) >>19 )
+#     define pgoff_to_wsidHandle(off)  ((btWSID)off<<12)
+
+#     define pwsid_to_wsidHandle(pwsid) ((btWSID)(pwsid->m_handle))
+
+
+// DEPRECATING
+#     define pgoff_to_wsidobj(off)  ( (struct aal_wsid *)( (off) | 0xfff0000000000000ULL) )
+#     define wsidobjp_to_wid(id)    ( (btWSID)(id) << PAGE_SHIFT )
+#     define wsid_to_wsidobjp(id)   ( (struct aal_wsid *)( ( (btWSID)(id) >> PAGE_SHIFT ) | 0xfff0000000000000ULL ) )
+
+
+#  endif
+#endif
+
+struct aaldev_ownerSession; //forward reference
+
+
+
+//=============================================================================
+// Name: aalwsservice
+// Description: Service interface for the AAL workspace manager service. This
+//              interface defines the methods used by clients of the workspace
+//              service.
+//=============================================================================
+struct aal_wsservice
+{
+    ///////////////////////////////////////////////////////////////////////////////////
+    // Allocate the workspace with fixed size
+    // Output: the workspace ID
+    int (*allocate)(    const struct aal_wsservice * const pthis,
+                        const btWSSize size,
+                        btWSID *const wsid /* out: wsid */
+                        );
+    int (*vallocate)(   const struct aal_wsservice * const pthis,
+                        const btWSSize                     size,
+                        btWSID * const                     wsid,   /* out: wsid */
+                        const btWSSize                     pgsize  /* in: page size */
+                        );
+
+    ///////////////////////////////////////////////////////////////////////////////////
+    // Free the workspace
+    int (*free) (struct aal_wsservice *pthis, btWSID wsid);
+    int (*vfree)(struct aal_wsservice *pthis, btWSID wsid);
+
+
+#if defined( __AAL_LINUX__ )
+    //////////////////////////////////////////////////////////////////////////////////////////////////////////
+    // Map the workspace into user space
+    int (*mmap)( struct aal_wsservice *pthis, btWSID wsid, struct vm_area_struct *pvam);
+#endif // OS
+
+    ////////////////////////////////////////////////////////////////////////////////////////////////////////////
+    // Get the page table base address
+    void * (*get_pgtable)(  const struct aal_wsservice *pthis,
+                            const btWSID                wsid,
+                            btWSSize * const            pgtblsize,
+                            btWSSize * const            pgsizeorder );
+
+    void * (*get_workspace)(    const struct aal_wsservice   *pthis,
+                                const btWSID                  wsid,
+                                btWSSize *const               size );
+
+    void * (*validate_pointer)( const struct aal_wsservice   *pthis,
+                                const btWSID                  wsid,
+                                const btVirtAddr              uvptr,
+                                btWSSize *const               size );
+};
+
+
+END_NAMESPACE(AAL)
+
+#endif // __AALSDK_KERNEL_AALWSSERVICE_H__
+
diff --git a/drivers/fpga/aal/include/aalsdk/kernel/ahmpip.h b/drivers/fpga/aal/include/aalsdk/kernel/ahmpip.h
new file mode 100644
index 000000000000..80ef13c98be0
--- /dev/null
+++ b/drivers/fpga/aal/include/aalsdk/kernel/ahmpip.h
@@ -0,0 +1,844 @@
+//******************************************************************************
+// This  file  is  provided  under  a  dual BSD/GPLv2  license.  When using or
+//         redistributing this file, you may do so under either license.
+//
+//                            GPL LICENSE SUMMARY
+//
+//  Copyright(c) 2008-2017, Intel Corporation.
+//
+//  This program  is  free software;  you  can redistribute it  and/or  modify
+//  it  under  the  terms of  version 2 of  the GNU General Public License  as
+//  published by the Free Software Foundation.
+//
+//  This  program  is distributed  in the  hope that it  will  be useful,  but
+//  WITHOUT   ANY   WARRANTY;   without   even  the   implied   warranty    of
+//  MERCHANTABILITY  or  FITNESS  FOR  A  PARTICULAR  PURPOSE.  See  the   GNU
+//  General Public License for more details.
+//
+//  The  full  GNU  General Public License is  included in  this  distribution
+//  in the file called README.GPLV2-LICENSE.TXT.
+//
+//  Contact Information:
+//  Henry Mitchel, henry.mitchel at intel.com
+//  77 Reed Rd., Hudson, MA  01749
+//
+//                                BSD LICENSE
+//
+//  Copyright(c) 2008-2017, Intel Corporation.
+//
+//  Redistribution and  use  in source  and  binary  forms,  with  or  without
+//  modification,  are   permitted  provided  that  the  following  conditions
+//  are met:
+//
+//    * Redistributions  of  source  code  must  retain  the  above  copyright
+//      notice, this list of conditions and the following disclaimer.
+//    * Redistributions in  binary form  must  reproduce  the  above copyright
+//      notice,  this  list of  conditions  and  the  following disclaimer  in
+//      the   documentation   and/or   other   materials   provided  with  the
+//      distribution.
+//    * Neither   the  name   of  Intel  Corporation  nor  the  names  of  its
+//      contributors  may  be  used  to  endorse  or promote  products derived
+//      from this software without specific prior written permission.
+//
+//  THIS  SOFTWARE  IS  PROVIDED  BY  THE  COPYRIGHT HOLDERS  AND CONTRIBUTORS
+//  "AS IS"  AND  ANY  EXPRESS  OR  IMPLIED  WARRANTIES,  INCLUDING,  BUT  NOT
+//  LIMITED  TO, THE  IMPLIED WARRANTIES OF  MERCHANTABILITY  AND FITNESS  FOR
+//  A  PARTICULAR  PURPOSE  ARE  DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT
+//  OWNER OR CONTRIBUTORS BE LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,
+//  SPECIAL,  EXEMPLARY,  OR  CONSEQUENTIAL   DAMAGES  (INCLUDING,   BUT   NOT
+//  LIMITED  TO,  PROCUREMENT  OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF USE,
+//  DATA,  OR PROFITS;  OR BUSINESS INTERRUPTION)  HOWEVER  CAUSED  AND ON ANY
+//  THEORY  OF  LIABILITY,  WHETHER  IN  CONTRACT,  STRICT LIABILITY,  OR TORT
+//  (INCLUDING  NEGLIGENCE  OR OTHERWISE) ARISING  IN ANY WAY  OUT  OF THE USE
+//  OF  THIS  SOFTWARE, EVEN IF ADVISED  OF  THE  POSSIBILITY  OF SUCH DAMAGE.
+//******************************************************************************
+//****************************************************************************
+//        FILE: ahmpip.h
+//     CREATED: 03/26/2008
+//      AUTHOR: Alvin Chen,    Intel Corporation
+//              Henry Mitchel, Intel Corporation
+//              Joseph Grecco, Intel Corporation
+//
+// PURPOSE: Common interfaces for PIP driver.
+//
+// HISTORY:
+// COMMENTS:
+// WHEN:          WHO:     WHAT:
+// 03/26/08       AC       Initial version created
+// 11/11/2008     JG       Added legal header
+// 11/25/2008     HM       Large merge
+// 12/10/2008     JG       Added support for bound wsmgr
+// 12/16/2008     JG       Began support for abort and shutdown
+//                            Added Support for WSID object
+//                            Major interface changes.
+// 12/23/2008     JG       Fixed mult session bug where owner session was in
+//                            global PIP
+//                            Removed some legacy structures
+// 12/27/2008     JG       Support for TransactionID/tskID maps
+// 01/04/2009     HM       Updated Copyright
+// 02/02/2009     JG       Fixed bug in ahm_alloc_aperture where the
+//                            memset_io caused problems with 5000x
+// 02/26/2009     JG       Began dynamic config implementation
+// 07/03/2009     HM       Fixed bug in ahm_free_aperture caused by earlier
+//                            conversion from oversized CSR buffer to ensure
+//                            alignment to perfect sizing using get_free_pages
+// 01/22/2010     JG       Added assert_splch_reset() to properly follow
+//                            reset protocol
+// 01/27/2010     AC       Remove clearing WR region for assert_splch_reset
+// 02/11/2010     JG       Support for kernel 2.6.31
+// 09/27/2010     JG       Separated out SPL interface specifics to improve
+//                             share-ability and abstraction
+// 04/19/2012     TSW      Deprecate __func__ in favor of platform-agnostic
+//                          __AAL_FUNC__.
+//****************************************************************************
+#ifndef __AALSDK_KERNEL_AHMPIP_H__
+#define __AALSDK_KERNEL_AHMPIP_H__
+#include <aalsdk/kernel/kosal.h>
+
+#include <aalsdk/kernel/ahmpipdefs.h>
+#include <aalsdk/kernel/aalbus.h>
+#include <aalsdk/kernel/aalbus-device.h>
+#include <aalsdk/kernel/splpip.h>
+#include <aalsdk/kernel/fappip.h>
+
+
+#if (1 == ENABLE_DEBUG)
+#define GEN_DPRINTF(m...) do { \
+    printk (KERN_DEBUG ":%s ", __AAL_FUNC__); \
+    printk (m); \
+} while (0)
+#else
+#define GEN_DPRINTF( m...) do {} while (0)
+#endif // ENABLE_DEBUG
+
+
+////////////////////////////////////////////////////////////////////////////////////
+////////////////////////////////////////////////////////////////////////////////////
+//                             Macros
+////////////////////////////////////////////////////////////////////////////////////
+////////////////////////////////////////////////////////////////////////////////////
+
+BEGIN_NAMESPACE(AAL)
+
+
+struct ahm_device;
+//=============================================================================
+// Name: ahm_channel
+// Description: Represents a physical AHM channel
+//=============================================================================
+struct ahm_channel {
+   struct device           m_nativedev;      // Native device
+   struct ahm_device      *m_pdev;           // Pointer to the board device
+   struct aal_device      *m_pafudev;        // Pointer to the AAL device
+
+   int                     m_index;          // the channel index in ahm_device array
+   kosal_semaphore         m_sem;            // channel semphore
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,19)
+   struct delayed_work     task_handler;
+#else
+   struct work_struct      task_handler;
+#endif
+
+#ifdef _USE_INTERRUPTS
+   int               m_intr_index;     /* interrupt table index */
+#endif
+
+
+   // hw task queues
+   uint16_t                m_next_tgp;      // Next available task group index
+
+   // SPL AFU config descriptor contains CSR space descriptor
+   struct spl_afu_config_s m_config;
+
+   // input descriptor buffer
+   kosal_list_head         m_iready_list;
+   kosal_semaphore         m_iready_sem;
+   kosal_list_head         m_irunning_list;
+   kosal_semaphore         m_irunning_sem;
+   kosal_semaphore         m_isem;
+   void                   *m_idesc_base;
+   void                   *m_idescs;
+   void                   *m_iheader;     // pointer to the first used descriptor
+   void                   *m_itail;       // pointer to the first empty descriptor
+   void                   *m_pgtblcache;  // pointer to the previous pagetable
+   size_t                  m_pgtblcache_size;
+
+   // output descriptor buffer
+   kosal_list_head         m_oready_list;
+   kosal_semaphore         m_oready_sem;
+   kosal_list_head         m_orunning_list;
+   kosal_semaphore         m_orunning_sem;
+   kosal_semaphore         m_osem;
+   void                   *m_odesc_base;
+   void                   *m_odescs;
+   void                   *m_oheader;     /* pointer to the first used descriptor */
+   void                   *m_otail;       /* pointer to the first empty descriptor */
+
+   ///////////////////////////////////////////////////////////////////////////////////
+   int (*reset)( struct ahm_channel *ch);
+   int (*flush_desc_queue)( struct ahm_channel *ch);
+};
+
+#define ahmch_to_aaldevp(dev)   ((dev)->m_pafudev)
+
+
+#define ahmchp_spl_configp(dev)                 (&(dev)->m_config)
+
+// Macros to access Control CSR space
+#define ahmchp_ctrl_csr_rbase(dev)              ((dev)->m_config.m_ctrl_csr_rbase)
+#define ahmchp_ctrl_csr_rsize(dev)              ((dev)->m_config.m_ctrl_csr_readsize)
+#define ahmchp_ctrl_read_csr_size(dev)          ((dev)->m_config.m_ctrl_read_csr_size)
+#define ahmchp_ctrl_read_csr_spacing(dev)       ((dev)->m_config.m_ctrl_read_csr_spacing)
+
+#define ahmchp_ctrl_csr_wbase(dev)              ((dev)->m_config.m_ctrl_csr_wbase)
+#define ahmchp_ctrl_csr_wsize(dev)              ((dev)->m_config.m_ctrl_csr_writesize)
+#define ahmchp_ctrl_write_csr_size(dev)         ((dev)->m_config.m_ctrl_write_csr_size)
+#define ahmchp_ctrl_write_csr_spacing(dev)      ((dev)->m_config.m_ctrl_write_csr_spacing)
+
+// Macros to access Compute CSR space
+#define ahmchp_csr_rbase(dev)                   ((dev)->m_config.m_csr_rbase)
+#define ahmchp_csr_rsize(dev)                   ((dev)->m_config.m_csr_readsize)
+#define ahmchp_read_csr_size(dev)               ((dev)->m_config.m_read_csr_size)
+#define ahmchp_read_csr_spacing(dev)            ((dev)->m_config.m_read_csr_spacing)
+
+#define ahmchp_csr_wbase(dev)                   ((dev)->m_config.m_csr_wbase)
+#define ahmchp_csr_wsize(dev)                   ((dev)->m_config.m_csr_writesize)
+#define ahmchp_write_csr_size(dev)              ((dev)->m_config.m_write_csr_size)
+#define ahmchp_write_csr_spacing(dev)           ((dev)->m_config.m_write_csr_spacing)
+
+//=============================================================================
+// Name: ahm_device
+// Description: AHM specific device object definition
+//=============================================================================
+struct ahm_device
+{
+
+
+   struct aal_device_id     m_AHM_id;        // ID for the board
+
+   // native device - used to tie into Linux DDK
+   struct device            m_nativedev;     // Native linux device
+
+   // Context used by owner of AHM. Not used by SPL PIP
+   void                    *m_context;       // Context used by owner
+
+   // Aperture
+   void __iomem            *m_base;          // aperture base
+   void __iomem            *m_rbase;         // read CSRs
+   size_t                   m_rsize;         // size of window
+   void __iomem            *m_wbase;         // write CSRs, must be 2M aligned
+   size_t                   m_wsize;         // size of window
+
+   //
+   // Work Queue used to service transactions on the board
+   //
+   struct workqueue_struct *m_wq;
+
+   ///////////////////////////////////////////////////////////////////////
+
+
+   kosal_semaphore          dev_sem;
+
+   // implementation specific part, subject to change in the future
+   struct ahm_channel       m_chs[AHMPIP_AHM_CHANNEL_NUMBER];
+   unsigned int             m_numchannels;
+
+   // Callback used for implementation specific initialization
+   SPL_CH_INIT              m_pafu_init;
+
+   // irq
+   int                      m_irq;
+
+
+
+   // CSR mutators that take index numbers
+   CSR_GET_T            get_csr_idx;
+   CSR_SET_T            set_csr_idx;
+
+   // CSR mutators that take offsets (deprecated)
+   CSR_GET_T            get_csr;
+   CSR_SET_T            set_csr;
+   char                 m_name[];
+};
+
+#define ahmdev_to_ahmchp(d,c)      (&(d)->m_chs[c])
+
+
+////////////////////////////////////////////////////////////////////////////////////
+//  inline functions define
+////////////////////////////////////////////////////////////////////////////////////
+//=============================================================================
+// Name: ahm_set_page_reserved
+// Description: Mark range of pages to reserved
+// Interface: public
+// Inputs: none.
+// Outputs: none.
+// Comments:
+//=============================================================================
+static void inline
+ahm_set_page_reserved (struct page *base, size_t size)
+{
+   struct page *page;
+   unsigned long offset;
+   void *vbase;
+
+   vbase = page_address (base);
+
+   for (offset = 0; offset < size; offset += PAGE_SIZE) {
+      page = virt_to_page (vbase + offset);
+      SetPageReserved (page);
+   }
+}
+
+//=============================================================================
+// Name: ahm_clr_page_reserved
+// Description: Clear reserved of pages
+// Interface: public
+// Inputs: none.
+// Outputs: none.
+// Comments:
+//=============================================================================
+static void inline
+ahm_clr_page_reserved (struct page *base, size_t size)
+{
+   struct page *page;
+   unsigned long offset;
+
+   for (offset = 0; offset < size; offset += PAGE_SIZE) {
+      page = virt_to_page (page_address (base) + offset);
+      ClearPageReserved (page);
+   }
+}
+
+// CSR base must be 2M aligned
+#define CSR_BASE(base)  ( ( (unsigned long)base & 0x1FFFFF ) ?  (void __iomem *)( ( (unsigned long)base & ~0x1FFFFF) + AHMPIP_APERTURE_SIZE ) : base )
+//=============================================================================
+// Name: ahm_alloc_aperture
+// Description: Allocate the aperature window
+// Interface: private
+// Inputs: none
+// Outputs: none.
+// Comments: CSR base must be 2M (AHMPIP_APERTURE_SIZE) aligned
+//=============================================================================
+static inline void __iomem *
+ahm_alloc_aperture ( void )
+{
+   void __iomem *base = NULL;
+   char *addr = NULL;
+
+   int i=0;
+
+   unsigned int order = 0;
+#if defined(_FLUSH_APERTURE)
+   unsigned long m;
+#endif
+
+   GEN_DPRINTF ( "Using dynamic aperature allocation & mapping\n");
+   order = get_order (AHMPIP_APERTURE_SIZE );
+   base = (void __iomem *) __get_free_pages (GFP_KERNEL, order);
+   if( unlikely( base == NULL )) {
+     GEN_DPRINTF ( "Could not allocate aperature %p\n",base);
+     return NULL;
+   }
+
+   //////////////////////////////////////////////////////////////////////
+   // check if the aperture is 2M aligned.
+   if( unlikely( (unsigned long)base & 0x1FFFFF ) ) {
+      GEN_DPRINTF ( "Error: CSR base must be 2M aligned: 0x%p\n",base);
+      free_pages ((unsigned long)base, order);
+      return NULL;
+   }
+
+   /* set page as reserved to enable mapping CSR into user space */
+   ahm_set_page_reserved (virt_to_page (base), 1 << (order + PAGE_SHIFT));
+
+#if defined(_FLUSH_APERTURE)
+   /* clflush the whole aperture */
+   for (m = (unsigned long) base;
+      m < (unsigned long)(base + AHMPIP_APERTURE_SIZE);
+      m += SMP_CACHE_BYTES)
+   __asm__ ("clflush (%0)" ::"r" (m));
+   __asm__ ("mfence" ::);
+#endif
+
+   /* Do initializing, otherwise the same memory may be allocated, and the
+    previous data still available. This will cause issue when re-load the
+    driver module.
+   */
+   if(base != NULL) {
+      GEN_DPRINTF ( "doing memset %p\n",base);
+      //memset_io( base, 0, AHMPIP_APERTURE_SIZE * 2 );
+      for(addr = base, i = 0; i < AHMPIP_APERTURE_SIZE; i++){
+         *(addr++) = 0;
+      }
+   }
+
+   return base;
+}
+//=============================================================================
+// Name: ahm_free_aperture
+// Description: Free the aperature window
+// Interface: private
+// Inputs: none
+// Outputs: none.
+// Comments:
+//=============================================================================
+static inline void
+ahm_free_aperture( void __iomem *base )
+{
+   unsigned int order;
+
+   order = get_order (AHMPIP_APERTURE_SIZE);
+   /* clear page's reserved flag */
+   ahm_clr_page_reserved (virt_to_page (base), 1 << (order + PAGE_SHIFT));
+   free_pages ((unsigned long)base, order);
+}
+///////////////////////////////////////////////////////////////////////////////////////
+///////////////////////////////////////////////////////////////////////////////////////
+/* ========== csr access ========== */
+#define _ahm_csr_get(dev, off)      ( (dev)->get_csr((dev), (off)) )
+#define _ahm_csr_set(dev, off, val) ( (dev)->set_csr((dev), (off), (val) ) )
+
+#ifdef _32BIT_CSR
+#define ahm_csr_get ahm_csr_get32
+#define ahm_csr_set ahm_csr_set32
+
+#else
+
+// Note index versions will be replacing offset versions
+#define ahm_csr_get_idx ahm_csr_get64_idx
+#define ahm_csr_get ahm_csr_get64
+#define ahm_csr_set_idx ahm_csr_set64_idx
+#define ahm_csr_set ahm_csr_set64
+
+#endif
+
+
+//=============================================================================
+// Name: assert_splch_reset
+// Description: Get  32 Bit CSR value
+// Interface: private
+// Inputs: ch - channel
+// Outputs: value.
+// Comments:
+//=============================================================================
+static inline void assert_splch_reset(struct ahm_channel *ch )
+{
+   struct ahm_device  *pdev = ch->m_pdev;
+   uint64_t *addr;
+
+   // Special case where read CSR area is actually written to
+   addr = pdev->m_rbase + AHMPIP_GCSR_AFUn_VERSION_ID(ch->m_index);
+   *addr = 0;
+
+   addr = pdev->m_rbase + AHMPIP_GCSR_SPL_CHn_STATUS(ch->m_index);
+   *addr = 0;
+
+   pdev->set_csr(pdev, AHMPIP_GCSR_SPL_CHn_CTRL(ch->m_index),AHMPIP_SPL_CHCMD_RESET);
+
+   mdelay(1);
+}
+
+//=============================================================================
+// Name: ahm_csr_get32
+// Description: Get  32 Bit CSR value
+// Interface: private
+// Inputs: hdl - device
+//         off - CSR register value relative to CSR_BASE
+// Outputs: value.
+// Comments:
+//=============================================================================
+static inline uint32_t
+ahm_csr_get32 (splpip_handle_t hdl, unsigned long off)
+{
+   struct ahm_device *dev = (struct ahm_device *)hdl;
+
+   uint32_t *addr = ((struct ahm_device *)dev)->m_rbase + off;
+
+#if defined(_CSR_DELAY)
+   udelay (_CSR_DELAY);
+#endif
+
+   return *addr;
+}
+
+
+
+//=============================================================================
+// Name: ahm_csr_get64_idx
+// Description: Get 64 Bit CSR value
+// Interface: private
+// Inputs: hdl - device
+//         idx - CSR register index relative to base.
+// Outputs: value.
+// Comments:
+//=============================================================================
+static inline uint64_t
+ahm_csr_get64_idx(splpip_handle_t hdl, unsigned long idx)
+{
+   struct ahm_device *dev = (struct ahm_device *)hdl;
+
+   // Get the pointer to the CSR via the index
+   uint64_t *addr = dev->m_rbase + (idx << 7);
+
+   printk (KERN_DEBUG "ahm_csr_get64_idx :%s[%d] rbase = %p idx = %lx  CSR @ %p value %lld",
+           __AAL_FUNC__,current->tgid, dev->m_rbase, idx ,addr, *addr );
+#if defined(_CSR_DELAY)
+   udelay (_CSR_DELAY);
+#endif
+
+   return *addr;
+}
+
+
+//=============================================================================
+// Name: ahm_csr_get64
+// Description: Get 64 Bit CSR value
+// Interface: private
+// Inputs: hdl - device
+//         off - CSR register value relative to CSR_BASE
+// Outputs: value.
+// Comments:
+//=============================================================================
+static inline uint64_t
+ahm_csr_get64(splpip_handle_t hdl, unsigned long off)
+{
+         struct ahm_device *dev = (struct ahm_device *)hdl;
+
+   uint64_t *addr = dev->m_rbase + off;
+
+//   printk (KERN_DEBUG "ahm_csr_get64 :%s[%d] rbase = %p off = %lx  CSR @ %p value %lld", __AAL_FUNC__,current->tgid, dev->m_rbase, off ,addr, *addr );
+#if defined(_CSR_DELAY)
+   udelay (_CSR_DELAY);
+#endif
+
+   return *addr;
+}
+
+//=============================================================================
+// Name: ahm_csr_set32
+// Description: Set 32 Bit CSR value
+// Interface: private
+// Inputs: hdl - device
+//         off - CSR register value relative to CSR_BASE
+// Outputs: none.
+// Comments: Copies value to read section to emulate HW update
+//=============================================================================
+static inline void
+ahm_csr_set32 (splpip_handle_t hdl, unsigned long off, uint32_t val)
+{
+  struct ahm_device *dev = (struct ahm_device *)hdl;
+
+   uint32_t *addr;
+
+#if defined(_CSR_DELAY)
+   udelay (_CSR_DELAY);
+#endif
+
+   addr = dev->m_wbase + off;
+   *addr = val;
+
+   if(off < AHMPIP_AFU_BASE ) {
+      addr = dev->m_rbase + off;
+      *addr = val;
+   }
+}
+
+//=============================================================================
+// Name: ahm_csr_set64_idx
+// Description: Set 64 Bit CSR value
+// Interface: private
+// Inputs: hdl - device
+//         idx - CSR register index relative to CSR_BASE
+//         val - value to set it to
+// Outputs: none.
+// Comments: Copies value to read section to emulate HW update
+//=============================================================================
+static inline void
+ahm_csr_set64_idx(  splpip_handle_t hdl, unsigned long idx, uint64_t val)
+{
+//   printk (KERN_DEBUG "ahm_csr_set64_idx %p",hdl);
+   struct ahm_device *dev = (struct ahm_device *)hdl;
+   uint64_t *addr;
+
+//   printk (KERN_DEBUG "ahm_csr_set64_idx  dev %p",dev);
+//   printk (KERN_DEBUG "ahm_csr_set64_idx :%s[%d] wbase = %p idx = %lx  CSR @ %p", __AAL_FUNC__,current->tgid, dev->m_wbase, idx , addr );
+#if defined(_CSR_DELAY)
+   udelay (_CSR_DELAY);
+#endif
+
+   addr = dev->m_wbase + (idx<<7);
+   *addr = val;
+//   printk (KERN_DEBUG "MIRROR ahm_csr_set64_idx :%s[%d] wbase = %p idx = %lx  CSR @ %p value %lld", __AAL_FUNC__,current->tgid, dev->m_wbase, idx , addr, *addr );
+   if( (idx<<7) < AHMPIP_AFU_BASE ) {
+     addr = dev->m_rbase + (idx<<7);
+     *addr = val;
+   }
+
+//   printk (KERN_DEBUG "DONE ahm_csr_set64_idx :%s[%d] wbase = %p idx = %lx  CSR @ %p value %lld", __AAL_FUNC__,current->tgid, dev->m_wbase, idx , addr, *addr );
+}
+
+
+//=============================================================================
+// Name: ahm_csr_set64
+// Description: Set 64 Bit CSR value
+// Interface: private
+// Inputs: hdl - device
+//         off - CSR register value relative to CSR_BASE
+// Outputs: none.
+// Comments: Copies value to read section to emulate HW update
+//=============================================================================
+static inline void
+ahm_csr_set64 (  splpip_handle_t hdl, unsigned long off, uint64_t val)
+{
+//   printk (KERN_DEBUG "ahm_csr_set64 %p",hdl);
+   struct ahm_device *dev = (struct ahm_device *)hdl;
+   uint64_t *addr;
+//   printk (KERN_DEBUG "ahm_csr_set64  dev %p",dev);
+//   printk (KERN_DEBUG "ahm_csr_set64 :%s[%d] wbase = %p off = %lx  CSR @ %p", __AAL_FUNC__,current->tgid, dev->m_wbase, off , addr );
+#if defined(_CSR_DELAY)
+   udelay (_CSR_DELAY);
+#endif
+
+   addr = dev->m_wbase + off;
+   *addr = val;
+//   printk (KERN_DEBUG "MIRROR ahm_csr_set64 :%s[%d] wbase = %p off = %lx  CSR @ %p value %lld", __AAL_FUNC__,current->tgid, dev->m_wbase, off , addr, *addr );
+   if(off < AHMPIP_AFU_BASE ) {
+     addr = dev->m_rbase + off;
+     *addr = val;
+   }
+
+//   printk (KERN_DEBUG "DONE ahm_csr_set64 :%s[%d] wbase = %p off = %lx  CSR @ %p value %lld", __AAL_FUNC__,current->tgid, dev->m_wbase, off , addr, *addr );
+}
+
+//=============================================================================
+// Name: ahmpip_free_desc_buff
+// Description: destroys the descriptor buffer
+// Interface: public
+// Inputs: base pointer of the descriptor buffer.
+// Outputs: none.
+// Comments: Called by subordinate module
+//=============================================================================
+inline static void ahmpip_free_desc_buff( void *base )
+{
+   unsigned int order = 0;
+
+   order = get_order( AHMPIP_AHM_DESCRIPTOR_SIZE );
+   /* clear page's reserved flag */
+   ahm_clr_page_reserved (virt_to_page (base), 1 << (order + PAGE_SHIFT));
+   free_pages ((unsigned long) base, order);
+}
+
+
+////////////////////////////////////////////////////////////////////////////////////
+//  export functions
+////////////////////////////////////////////////////////////////////////////////////
+
+extern int ahmpip_free_ahm_device(  struct ahm_device *pdev);
+extern int ahmpip_init_ahm_device(  struct ahm_device *pdev,
+                                    struct aal_bus *pbus,
+                                    struct aal_device_id *devID,
+                                    struct aal_class_id *classID,
+                                    u_int64_t pipGUID
+                                 );
+
+#ifdef _USE_INTERRUPTS
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,19)
+irqreturn_t ahmpip_work_intr (int irq, void *arg);
+#else
+irqreturn_t ahmpip_work_intr (int irq, void *arg, struct pt_regs *regs);
+#endif
+
+extern int ahmpip_get_irq( int user_irq );
+extern void ahmpip_init_intr_table( struct ahm_device *pdev );
+#endif
+
+
+/*
+ * common macros
+ */
+
+/*
+ * uintptr_t should be used instead
+ */
+#ifndef POINTER_TO_UINT64
+#define POINTER_TO_UINT64(p)  ((uint64_t) ((unsigned long) (p)))
+#endif
+#ifndef UINT64_TO_POINTER
+#define UINT64_TO_POINTER(u)  ((void *) ((unsigned long) (u)))
+#endif
+
+
+/*
+ * FIXME: the device interface should be refined as driver
+ * registration/unregistration routines to support multiple instances of the
+ * same device class
+ */
+
+
+//=============================================================================
+// Name: acpm_session
+// Description: Object that represents an instance of a session between an
+//              owner of a device and the device itself. It holds state such
+//              as the task list and AHM PIP interface. The AHM PIP interface
+//              holds the owner session context and the PIP function interfaces.
+// Comments: This object is specific to the AHM PIP. The ownerSession contains
+//           the generic session context shared between the AHM PIP and the
+//           AAL kernel services.
+//=============================================================================
+struct acpm_session
+{
+  struct ahm_device           *dev;   // Board level device
+
+  // PIP contains all of the interfaces we use for communications
+  struct ahm_ipip             *ipipp;
+
+  // Owner Session hold shared session instance information
+  struct aaldev_ownerSession  *m_pownerSess;
+
+  // Tasks structires
+  kosal_list_head              task_list;
+  kosal_semaphore              task_sem;
+  uint16_t                     m_tidgroup;
+  uint16_t                     m_nexttid;
+
+  // Used to translate AAL TranID numbers to taskid
+  kosal_list_head              tidmap_list;
+
+};
+#define ahmsessp_to_pipp(s)   ((struct ahm_ipip         *)s->ipipp)
+
+
+
+/* ========== memory area ========== */
+
+#define ACPM_MEM_AREA_INVALID (0ULL)
+
+struct acpm_mem_area
+{
+  kosal_list_head   ma_list;  /* session list */
+  atomic_t          ma_cnt;   /* reference count */
+  uint64_t          ma_id;
+  size_t            ma_size;
+  unsigned long     ma_cookie;
+  void              *ma_base;
+  struct page       *ma_page;
+  unsigned int      ma_order;
+};
+
+static inline int
+acpm_mem_area_sanity_check (struct acpm_mem_area *ma)
+{
+   return (POINTER_TO_UINT64(ma) == ma->ma_id) ? 0 : -EINVAL;
+}
+
+extern void __acpm_mem_area_free  (struct acpm_mem_area *);
+extern int acpm_mem_area_alloc (struct acpm_mem_area **, size_t);
+
+static inline void
+acpm_mem_area_ref (struct acpm_mem_area *ma)
+{
+   atomic_inc (&ma->ma_cnt);
+}
+
+static inline void
+acpm_mem_area_unref (struct acpm_mem_area *ma)
+{
+   if (atomic_dec_and_test (&ma->ma_cnt)){
+      __acpm_mem_area_free (ma);
+   }
+}
+
+static inline void
+acpm_mem_area_free (struct acpm_mem_area *ma)
+{
+   acpm_mem_area_unref (ma);
+}
+
+
+//=============================================================================
+// Name: acpm_hwtask
+// Description: Object that describes a descriptor on a task queue
+//=============================================================================
+#define ACPM_HWTASKID_INVALID (0ULL)
+struct acpm_hwtask
+{
+   kosal_list_head         ht_list;           // tasks belonging to the same session
+   kosal_list_head         ht_ready_queue;    // ready queue
+   kosal_list_head         ht_compl_queue;    // completion queue
+   kosal_list_head         ht_running_queue;  // running queue
+   atomic_t                ht_cnt;            // reference count
+   uint16_t                ht_id;
+   uint32_t                ht_status;
+   uint32_t                ht_ch;             // the channel this task will submit to
+   TDESC_TYPE              ht_type;           // INPUT or OUTPUT
+   uint16_t                ht_delim;          // Delimiter
+   uint8_t                 ht_mode;           // SLAVE: '2'    MASTER PHYS: '0'     MASTER VIRT: '1'
+   void                   *ht_context;        // Descriptor context - User data associated with the descriptor
+   stTransactionID_t       ht_tasktranID;     // Task transaction ID. This is a duplicate of mapped value
+
+   // AFU configuration data
+   uint64_t                ht_buff;
+   uint64_t                ht_pgtblbase;
+   size_t                  ht_size;
+   unsigned int            ht_pgtblsize;      // Must be CLs
+   unsigned int            ht_pgsizeorder;
+
+   /* reference to session */
+   kosal_semaphore         ht_sess_sem;
+   struct acpm_session    *ht_sess;
+
+   // Fields related to the return event notification
+   stTransactionID_t        tranID;           // Transaction ID to identify result
+   void                    *context;          // Optional token from user when sending this message
+   uint16_t                 no_notify;        // 1 - do not notify client on completion
+
+   struct aal_uiapi         *uiAPIp;          // UI  driver interface to return on
+   void                     *MessageContext;
+
+   /* reference to input/output descriptor header */
+   struct ahm_output_desc_header  *ht_odesc;
+   struct ahm_input_desc_header    *ht_idesc;
+};
+
+static inline int
+acpm_hwtask_sanity_check (struct acpm_hwtask *ht)
+{
+   return (POINTER_TO_UINT64(ht) == ht->ht_id) ? 0 : -EINVAL;
+}
+
+extern int  acpm_hwtask_create    (struct acpm_hwtask **, struct acpm_session *sess);
+extern void acpm_hwtask_destroy   (struct acpm_hwtask *);
+extern int  __acpm_hwtask_destroy (struct acpm_hwtask *);
+
+extern int  acpm_hwtask_submit    (struct acpm_hwtask *);
+extern void acpm_hwtask_abort     (struct acpm_hwtask *);
+
+static inline void
+acpm_hwtask_ref (struct acpm_hwtask *ht)
+{
+   atomic_inc (&ht->ht_cnt);
+}
+
+static inline void
+acpm_hwtask_unref (struct acpm_hwtask *ht)
+{
+   if (atomic_dec_and_test (&ht->ht_cnt)){
+       __acpm_hwtask_destroy (ht);
+   }
+}
+
+/////////////////////////////////////////////////////////////////////////////////////
+#define RING_LEN  (8)
+#define RING_FLEN(x, y, b)  (((x) > (y)) ? ((b)+(y)-(x)) : ((y) - (x)))
+#define RING_FWD(x, s, b)   (((x) + (s)) % (b))
+#define RING_BWD(x, s, b)   RING_FWD((x), ((b)-(s)), (b))
+
+extern int                   acpm_session_destroy(struct acpm_session *);
+extern struct acpm_session * acpm_session_create(struct aaldev_ownerSession *);
+
+
+END_NAMESPACE(AAL)
+
+#endif // __AALSDK_KERNEL_AHMPIP_H__
+
diff --git a/drivers/fpga/aal/include/aalsdk/kernel/ahmpipdefs.h b/drivers/fpga/aal/include/aalsdk/kernel/ahmpipdefs.h
new file mode 100644
index 000000000000..b51d1ff52281
--- /dev/null
+++ b/drivers/fpga/aal/include/aalsdk/kernel/ahmpipdefs.h
@@ -0,0 +1,634 @@
+//******************************************************************************
+// This  file  is  provided  under  a  dual BSD/GPLv2  license.  When using or
+//         redistributing this file, you may do so under either license.
+//
+//                            GPL LICENSE SUMMARY
+//
+//  Copyright(c) 2007-2017, Intel Corporation.
+//
+//  This program  is  free software;  you  can redistribute it  and/or  modify
+//  it  under  the  terms of  version 2 of  the GNU General Public License  as
+//  published by the Free Software Foundation.
+//
+//  This  program  is distributed  in the  hope that it  will  be useful,  but
+//  WITHOUT   ANY   WARRANTY;   without   even  the   implied   warranty    of
+//  MERCHANTABILITY  or  FITNESS  FOR  A  PARTICULAR  PURPOSE.  See  the   GNU
+//  General Public License for more details.
+//
+//  The  full  GNU  General Public License is  included in  this  distribution
+//  in the file called README.GPLV2-LICENSE.TXT.
+//
+//  Contact Information:
+//  Henry Mitchel, henry.mitchel at intel.com
+//  77 Reed Rd., Hudson, MA  01749
+//
+//                                BSD LICENSE
+//
+//  Copyright(c) 2007-2017, Intel Corporation.
+//
+//  Redistribution and  use  in source  and  binary  forms,  with  or  without
+//  modification,  are   permitted  provided  that  the  following  conditions
+//  are met:
+//
+//    * Redistributions  of  source  code  must  retain  the  above  copyright
+//      notice, this list of conditions and the following disclaimer.
+//    * Redistributions in  binary form  must  reproduce  the  above copyright
+//      notice,  this  list of  conditions  and  the  following disclaimer  in
+//      the   documentation   and/or   other   materials   provided  with  the
+//      distribution.
+//    * Neither   the  name   of  Intel  Corporation  nor  the  names  of  its
+//      contributors  may  be  used  to  endorse  or promote  products derived
+//      from this software without specific prior written permission.
+//
+//  THIS  SOFTWARE  IS  PROVIDED  BY  THE  COPYRIGHT HOLDERS  AND CONTRIBUTORS
+//  "AS IS"  AND  ANY  EXPRESS  OR  IMPLIED  WARRANTIES,  INCLUDING,  BUT  NOT
+//  LIMITED  TO, THE  IMPLIED WARRANTIES OF  MERCHANTABILITY  AND FITNESS  FOR
+//  A  PARTICULAR  PURPOSE  ARE  DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT
+//  OWNER OR CONTRIBUTORS BE LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,
+//  SPECIAL,  EXEMPLARY,  OR  CONSEQUENTIAL   DAMAGES  (INCLUDING,   BUT   NOT
+//  LIMITED  TO,  PROCUREMENT  OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF USE,
+//  DATA,  OR PROFITS;  OR BUSINESS INTERRUPTION)  HOWEVER  CAUSED  AND ON ANY
+//  THEORY  OF  LIABILITY,  WHETHER  IN  CONTRACT,  STRICT LIABILITY,  OR TORT
+//  (INCLUDING  NEGLIGENCE  OR OTHERWISE) ARISING  IN ANY WAY  OUT  OF THE USE
+//  OF  THIS  SOFTWARE, EVEN IF ADVISED  OF  THE  POSSIBILITY  OF SUCH DAMAGE.
+//******************************************************************************
+//****************************************************************************
+//        FILE: ahmpipdefs.h module interface
+//     CREATED: 11-12-07
+//      AUTHOR: Jospeh Grecco - Intel Corp.
+//
+// PURPOSE: FAP PIP module hardware interface, i.e., the interface to device
+// HISTORY:
+// COMMENTS:
+// WHEN:          WHO:     WHAT:
+// 12/27/2008     JG       removed cacheline alignment from desc headers
+// 01/04/2009     HM       Updated Copyright
+// 02/07/2009     HM       Cleaned up descriptions of descriptor fields
+// 03/17/2009     JG       Added macros for AFU CSRs
+// 05/17/2009     Alvin    Update the output descriptor structure
+//                            according to the HW changes
+// 02/11/2010     JG       Support for kernel 2.6.31
+// 06/13/2010     AC       Fixed the AFU CSR address with offset, not the AFU CSR sequence
+// 09/19/2010     HM       Added AHMPIP_AHM_CL_SHIFT
+// 10/21/2011     JG       Added code for Windows compatibility
+//****************************************************************************
+#ifndef __AALSDK_KERNEL_AHMPIPDEFS_H__
+#define __AALSDK_KERNEL_AHMPIPDEFS_H__
+
+#ifdef __AAL_USER__
+#include <stdint.h>
+#include <aalsdk/AALTypes.h>
+#else
+#include <aalsdk/kernel/aaltypes.h>
+#endif // __AAL_USER__
+
+BEGIN_NAMESPACE(AAL)
+
+//=============================================================================
+// PIP Memory map
+//=============================================================================
+// Write memory region offset from CSR Base
+#define AHMPIP_APERTURE_WRITEOFF    (0)
+#define AHMPIP_APERTURE_WRITESIZE   (1 << 20)
+
+// Read memory region
+#define AHMPIP_APERTURE_READOFF     (AHMPIP_APERTURE_WRITESIZE)
+#define AHMPIP_APERTURE_READSIZE    (1 << 20)
+
+#define AHMPIP_APERTURE_SIZE  (AHMPIP_APERTURE_READSIZE + AHMPIP_APERTURE_WRITESIZE)
+
+#define AHMPIP_AHM_CHANNEL_NUMBER            (4)
+#define AHMPIP_SPL_MAXCHANNELS               AHMPIP_AHM_CHANNEL_NUMBER
+#define AHMPIP_AHM_CL_SIZE                   (64)  /* Cache line size Bytes*/
+#define AHMPIP_AHM_CL_SHIFT                  (6)   /* Cache line bit shift value*/
+#define AHMPIP_AHM_DESCRIPTOR_MAX_SIZE       (1024 * AHMPIP_AHM_CL_SIZE)
+#define AHMPIP_AHM_DESCRIPTOR_MIN_SIZE       (2 * AHMPIP_AHM_CL_SIZE)
+#define AHMPIP_AHM_DESCRIPTOR_SIZE           AHMPIP_AHM_DESCRIPTOR_MAX_SIZE
+
+//////////////////////////////////////////////////////////////////////////////////////////////
+static inline
+unsigned char * ahmpip_desc_forward( unsigned char *base, unsigned char *ptr, int n  )
+{
+    if( (ptr + n*AHMPIP_AHM_CL_SIZE) < (base + AHMPIP_AHM_DESCRIPTOR_SIZE) ) {
+        return ptr + n*AHMPIP_AHM_CL_SIZE;
+    }
+    else {
+        return (ptr + n*AHMPIP_AHM_CL_SIZE) - AHMPIP_AHM_DESCRIPTOR_SIZE;
+    }
+}
+
+
+//==============================================================================
+// Control Status Registers (CSR)
+//==============================================================================
+
+// Global CSR offset
+#define AHMPIP_GCSR_BASE            (0x00000)
+
+
+// System Protocol Layer Base
+#define AHMPIP_SPL_BASE             (0x01000)
+
+// SPL configuration Channel Base
+#define AHMPIP_SPL_CFG_BASE         (0x02000)
+
+// SPL Channel Base offset
+#define  AHMPIP_SPL_CH_BASE         (0x02000)
+#define  AHMPIP_SPL_CH_SIZE         (0x01000)
+
+//SPL Channel n Base offset
+#define  AHMPIP_SPL_CHn_BASE(n)     (AHMPIP_SPL_CH_BASE + ((n)*AHMPIP_SPL_CH_SIZE))
+
+// Configuration AFU Base
+#define  AHMPIP_AFU_CFG_BASE        (0x10000)
+// AFU Base offset
+#define  AHMPIP_AFU_BASE            AHMPIP_AFU_CFG_BASE
+#define  AHMPIP_AFU_SIZE            (0x10000)
+
+// AFU n Base offset
+#define  AHMPIP_REGISTER_SIZE       (0x80)
+#define  AHMPIP_AFUn_BASE(n)        (AHMPIP_AFU_BASE + ((n)*AHMPIP_AFU_SIZE))
+#define  AHMPIP_MAX_REGISTERS       (AHMPIP_AFU_SIZE/AHMPIP_REGISTER_SIZE)
+#define  AHMPIP_MAX_AFU_CSR_INDEX   (AHMPIP_MAX_REGISTERS-1)
+#define  AHMPIP_AFUn_CSR(n,offset)  (AHMPIP_AFUn_BASE(n) + (offset))
+
+// Peformance Monitoring Base
+#define  AHMPIP_PERFMON_BASE        (0xA0000)
+
+// Debug Base
+#define AHMPIP_DBG_BASE             (0xB0000)
+
+// Onboard Memory Base
+#define AHMPIP_LCL_MEM_BASE         (0xC0000)
+
+// GCSR_BASE : Global CSR Base Address : Base address of the Global CSR window
+// Bit    Attr   Default Description
+// 63:32  RV     0x00    Reserved
+// 31:12  RW     0x00    Global CSR Base Address : Defines the base address of the
+//                       window in system memory to which the CSR space is mapped.
+//                       This address must be 4K page aligned, hence the lower
+//                       12bits are all zeros
+// 11:0   RV     0x00    Reserved
+#define AHMPIP_GCSR_BASE_ADDR       (AHMPIP_GCSR_BASE + 0x00000)
+
+// GCSR_SIZE : Global CSR Window Size
+// Bit    Attr   Default Description
+// 63:32  RV     0x00    Reserved
+// 31:20  RV     0x00    Reserved
+// 19:0   RW     0x4000 Global CSR Window Size : Specifies the size of the whole
+//                       CSR window. The default = 1MB = 0x4000 CLs
+#define AHMPIP_GCSR_SIZE             (AHMPIP_GCSR_BASE + 0x0080)
+
+// AHM_CONTROL :  Accelerator Hardwware Module Control. Implements the coarse
+//                global control functions of the AHM.
+// Bit    Attr   Default Description
+// 63:18  RV     0x00    Reserved
+//   17   RV     0x00    Reserved
+//   16   RV     0x00    Reserved
+// 15:1   RV     0x00    Reserved
+//   0    RW     0x00    AHM Hard Reset: Writing this bit causes the whole AHM
+//                       (including the PHY, FPL, SPL and management AFU, other AFUs) and all
+//                       other components( i.e. CPLD, PROM, SRAM etc) on the AHM to be reset. This
+//                       method uses the Ct_SPLtoAFU#_Reset_n signal to reset components outside
+//                       of the FPGA. The following sequence is used to reset the AHM via this
+//                       method.
+//                          1.  Software writes AHM_CONTROL[0]=1
+//                          2.  AHM hardware stops issuing new requests on the FSB and completes
+//                              all pending transactions and then resets all internal logic. This
+//                              state is identical to the initial power on state which means that the
+//                              AHM will need to be reconfigured i.e. CSR_BAR init, Interrupt init
+//                              etc.
+//                          3.  AHM hardware resets all CSRs including the GCSR_BASE registers. No
+//                              CSR update is performed to reflect the reset values of the CSRs.
+//                       Software waits for 250msec before initiating the initialization sequence.
+#define AHMPIP_GCSR_AHM_CONTROL             (AHMPIP_GCSR_BASE + 0x0100)
+
+// AHM_CORE_VERSION_ID : Version ID used to identify the RTL release. Used by the
+//                       driver to check the version of the FSB PHY,
+//                       FSB Protocol and SPL modules. Reading this
+//                       register results in a 32bit value in the following format
+//                       ProjID-Year-Mon-Day-Version-
+//                       Type. Once the CSR initialization process is complete the
+//                       hardware updates this CSR to system memory so that the
+//                       driver can identify that the AHM has completed the CSR init
+//                       process.
+// Bit      Attr   Default    Description
+// 63:32    RV     0x00       Reserved
+// 31:28    RO     0x#        Project ID : One nibble to encode project name
+// 27:24    RO     0x#        One nibble representing the year the RTL was released e.g.
+//                            0x6 indicates the year 2006
+// 23:20    RO     0x#        One nibble representing the month the RTL was released,
+//                            e.g. 0xA indicates the 10th month of the year i.e. October
+// 19:12    RO     0x##       Two nibbles representing the day the RTL was released. E.g.
+//                            0x13 indicates the 19th day of the month
+// 11:8     RO     0x#        Version : One nibble to indicate any other release
+//                            information required to differentiate multiple releases within
+//                            the single day. Subsequent releases within the same day will
+//                            have sequentially increasing numbers
+// 7:4      RO     0x#        Release Type :
+//                               0x0 : Regular release
+//                               0x1 : Debug release
+//                               Others : Reserved
+// 3:1      RV     0x0        Reserved
+//  0       RO     0x0        Valid : Indicates the validity of the contents of this register.
+//                               0 : AHM_CORE_VERSION_ID invalid
+//                               1 : AHM_CORE_VERSION_ID valid
+#define AHMPIP_GCSR_AHM_CORE_VERSION_ID   (AHMPIP_SPL_BASE + 0x0000)
+#define AHMPIP_GLOBAL_ID (0x0000000008913011)
+
+#define AHMPIP_AHM_CORE_VERSION_VALID(n)  ( (n &        0x01) )
+#define AHMPIP_AHM_CORE_VERSION_REL(n)    ( (n &       0x0f0) >>  4 )
+#define AHMPIP_AHM_CORE_VERSION_VER(n)    ( (n &      0x0f00) >>  8 )
+#define AHMPIP_AHM_CORE_VERSION_DAY(n)    ( (n &    0x0ff000) >> 12 )
+#define AHMPIP_AHM_CORE_VERSION_MONTH(n)  ( (n &   0x0f00000) >> 20 )
+#define AHMPIP_AHM_CORE_VERSION_YEAR(n)   ( (n &  0x0f000000) >> 24 )
+#define AHMPIP_AHM_CORE_VERSION_NAME(n)   ( (n & 0x0f0000000) >> 28 )
+
+
+// AHM_CORE_PARAMS : Accelerator Parameters : Specifies the configuration of the
+//              accelerator hardware. Upon successful initialization.
+//              Note : Not supported in first release of hardware
+// Bit     Attr   Default    Description
+// 63:32   RV     0x00       Reserved
+// 31:8    RV     0x00       Reserved
+// 7:4     RO     0x##       Number of AFUs : Specifies the number of AFUs
+//                           supported in the version of the hardware
+// 3:1     RV     0x0        Reserved
+// 0:0     RO     0x0        Valid : Indicates the validity of the AHM_PARAMS
+//                           register. This bit is set once the GCSR BAR initialization has
+//                           successfully completed. The driver polls on this bit during
+//                           initialization to get information about the accelerator
+//                           hardware.
+//                           0x0 : AHM_PARAMS invalid
+//                           0x1 : AHM_PARAMS valid
+#define AHMPIP_GCSR_AHM_CORE_PARAMS             (AHMPIP_SPL_BASE + 0x0080)
+
+
+// AHM_STATUS : Accelerator Status : Indicates the status of the accelerator
+//              hardware
+//              Note : Not supported in first release of hardware
+// Bit    Attr  Default    Description
+// 63:2   RV    0x0        Reserved
+// 1      RO    0x0        Reserved
+// 0      RO    0x0        Reserved
+#define AHMPIP_GCSR_AHM_STATUS            (AHMPIP_SPL_BASE + 0x0100)
+
+
+// AHM_INTR_TABLE : AHM Interrupt Vector Table : This table is built using 7 CSRs
+//                  that each hold an interrupt vector. The software initializes this table with the available
+//                  interrupt vectors and also programs the SPL channels with indexes that enable the
+//                  SPL to issue interrupt requests with different vectors. Refer to Section
+// Bit     Attr    Default   Description
+// 63:2    RV      0x0       Reserved
+// 31      RW      0         Valid : Indicates the validity of the rest of the fields in the
+//                           register. This bit is set to 0 for unimplemented entries of the
+//                           table
+// 19:13   RW      0         Used in Address[19:4] of the interrupt; corresponds to the
+//                           interrupt target (the zzzz field)
+// 12:8    RW      0         Used in Address[3:0] of the interrupt; corresponds to the Y
+//                           field.
+// 7:0     RW      0         Used in the data[7:0] of the interrupt; corresponds to the
+//                           vector
+
+// Global Interrupt Control Base
+#define AHMPIP_INTR_TABLE_BASE      (AHMPIP_SPL_BASE + 0x0180)
+#define AHMPIP_INTR_TABLE_SIZE      (0x0080)
+
+// Interrupt vector table entries
+#define AHMPIP_GCSR_AHM_INTR_TABLE_ENTRYS       (7)
+#define AHMPIP_GCSR_AHM_INTR_TABLE_VECT(x)      (AHMPIP_INTR_TABLE_BASE + (x*AHMPIP_INTR_TABLE_SIZE))
+#define AHMPIP_GCSR_AHM_INTR_TABLE_VECT0        AHMPIP_GCSR_AHM_INTR_TABLE_VECT(0)
+#define AHMPIP_GCSR_AHM_INTR_TABLE_VECT1        AHMPIP_GCSR_AHM_INTR_TABLE_VECT(1)
+#define AHMPIP_GCSR_AHM_INTR_TABLE_VECT2        AHMPIP_GCSR_AHM_INTR_TABLE_VECT(2)
+#define AHMPIP_GCSR_AHM_INTR_TABLE_VECT3        AHMPIP_GCSR_AHM_INTR_TABLE_VECT(3)
+#define AHMPIP_GCSR_AHM_INTR_TABLE_VECT4        AHMPIP_GCSR_AHM_INTR_TABLE_VECT(4)
+#define AHMPIP_GCSR_AHM_INTR_TABLE_VECT5        AHMPIP_GCSR_AHM_INTR_TABLE_VECT(5)
+#define AHMPIP_GCSR_AHM_INTR_TABLE_VECT6        AHMPIP_GCSR_AHM_INTR_TABLE_VECT(6)
+
+// SPL_CONTROL : SPL Control Register
+// Bit    Attr   Default  Description
+// 63:2   RV     0x0      Reserved
+// 32:9   RV     0        Reserved
+//  8     RV     0        Reserved
+// 7:4    RV     0        Reserved
+// 3:0    RV     0        Reserved
+#define AHMPIP_GCSR_SPL_CONTROL                  (AHMPIP_SPL_BASE + 0x0500)
+
+// SPL_STATUS : SPL Status. Indicates the status/configuration of the SPL.
+// Bit   Attr   Default  Description
+// 63:20  RV     0x0      Reserved
+// 19:12  RV       0      Reserved
+// 11: 8  RV       0      Reserved
+// 7:4    RO       0      Indicates the number of AFUs that are connected to
+//                        the SPL. The SPL uses the Ct_AFU#toSPL_AFU_Presence signal to determine if
+//                        a AFU is present. An AFU that is present drives this signal high.
+//                        0000: No AFUs implemented
+//                        0001: AFU0 implemented
+//                        1011: AFU0, AFU1, AFU3 are implmented, the other AFUs are not implemented.
+// 3:1     RV       0      Reserved
+// 0       RO       0      Valid: Indicates the validity of the contents of
+//                         this register.
+//                         0: SPL_CONFIG_STATUS invalid
+//                         1: SPL_CONFIG_STATUS valid
+#define AHMPIP_GCSR_SPL_STATUS              (AHMPIP_SPL_BASE + 0x0580)
+#define AHMPIP_NO_AFUS                      0x0
+#define AHMPIP_VALID_SPL_STATUS_IMP         0x1
+#define AHMPIP_AFU0_IMP                     (0x1<<4)
+#define AHMPIP_AFU1_IMP                     (0x1<<5)
+#define AHMPIP_AFU2_IMP                     (0x1<<6)
+#define AHMPIP_AFU3_IMP                     (0x1<<7)
+#define AHMPIP_AFUn_IMP(n)                  (0x1<<(4+n))
+
+// SPL_CH#_CTRL : SPL Channel Control : Provides access to the SPL DMA engine
+// Bit     Attr   Default    Description
+// 63:8    RV     0x00       Reserved
+// 7:0     RV     0          Command: Specifies commands for the SPL Channel.
+//
+//                           0x0: NOP. Has no effect on the SPL Channel.
+//                           0x1: SPL Channel Enable. Enable SPL Channel. Not
+//                                meant to be used dynamically, should be used only
+//                                during startup.
+//                           0x2: SPL Channel Disable. Disable SPL Channel. Not
+//                                meant to be used dynamically, should be used only
+//                                during startup.
+//                           0x3: SPL Channel Reset. Causes the SPL and the
+//                                associated AFU to  be reset. All descriptors in
+//                                flight will be lost, no status update is
+//                                performed for the lost descriptors. The AFU# ID
+//                                needs ot be updated.
+//                           Others: Reserved.
+#define AHMPIP_GCSR_SPL_CHn_CTRL(n)             (AHMPIP_SPL_CHn_BASE(n) + 0x0000)
+#define AHMPIP_SPL_CHCMD_ENABLE                 (0x1)
+#define AHMPIP_SPL_CHCMD_DISABLE                (0x2)
+#define AHMPIP_SPL_CHCMD_RESET                  (0x3)
+
+
+// SPL_CH#_STATUS : SPL Channel Status register : Reflects the state of the SPL CH#
+// Bit   Attr   Default  Description
+// 63:4  RV     0        Rserved
+// 3:2   RV     0        Rserved
+// 1     RO     0        SPL Channel Reset Complete: Indicates the completion
+//                       of a SPL Channel reset sequeue initiated via SPL_CH#_CTRL[7:0]
+//
+//                       0x0: SPL channel reset not initiated, OR, if SPL
+//                            channel
+//                       0x1: SPL channel reset completed
+// 0     RO     0        SPL Channel Status: Indicates if the SPL channel is
+//                       enabled or disabled.
+//                       0x0: SPL Channel disabled
+//                       0x0: SPL Channel enabled
+#define AHMPIP_GCSR_SPL_CHn_STATUS(n)           (AHMPIP_SPL_CHn_BASE(n) + 0x0080)
+#define AHMPIP_SPL_CHSTS_DISABLED               (0x0)
+#define AHMPIP_SPL_CHSTS_ENABLED                (0x1)
+#define AHMPIP_SPL_CHSTS_RESET_COMPLETED        (0x2)
+
+// SPL_CH#_IN_DESC_BASE: Base address of the Input descriptor queue for CH#
+// Bit   Attr   Default  Description
+// 63:40 RV     0        Rserved
+// 39:0  RW     0        Input Descriptor Queue Base Address: the Input
+//                       descriptor queue base address(physical). This address has to be 64KB
+//                       aligned.
+#define AHMPIP_GCSR_SPL_CHn_IN_DESC_BASE(n)    (AHMPIP_SPL_CHn_BASE(n) + 0x0100)
+
+// SPL_CH#_IN_DESC_SIZE: Size of the Input descriptor queue for CH#
+// Bit   Attr   Default  Description
+// 63:16 RV     0        Rserved
+// 15:0  RW     0        Input Descriptor Queue Size: Specifies the size of
+//                       the input descriptor queue in bytes. The size has to be a multiple of a CL
+//                       which means that bits[5:0] are always zero
+//
+//                       Min: 0x80:     128B = 2CL
+//                       Max: 0xFFFF:   64KB = 1024CL
+#define AHMPIP_GCSR_SPL_CHn_IN_DESC_SIZE(n)    (AHMPIP_SPL_CHn_BASE(n) + 0x0180)
+
+// SPL_CH#_IN_DESC_TAIL: Tail pointer of the Input descriptor queue for CH#
+// Bit   Attr   Default  Description
+// 63:40 RV     0        Rserved
+// 39:0  RW     0        Input Descriptor Queue Tail Pointer: This register
+//                       holds the value of the tail pointer for the input descriptor queue. The
+//                       tail pointer points to the start of the first invalid cacheline which is
+//                       the location for the next enqueued descriptor. Software writes the physical
+//                       address of cacheline into this register but HW uses only bits[15:6] as an
+//                       offset relative to the SPL_CH#_IN_DESC_BASE. This register is updated by
+//                       software when the new descriptor has been added to the input descriptor
+//                       queue. Refer to Section 1.1 for more deatails.
+#define AHMPIP_GCSR_SPL_CHn_IN_DESC_TAIL(n)    (AHMPIP_SPL_CHn_BASE(n) + 0x0200)
+
+// SPL_CH#_IN_DESC_HEAD: Head pointer of the Input descriptor queue for CH#
+// Bit   Attr   Default  Description
+// 63:40 RV     0        Rserved
+// 39:0  RW     0        Input Descriptor Queue Head Pointer: This register
+//                       holds the value of the head pointer for the input descriptor queue. The
+//                       head pointer points to the descriptor that is
+//                       currently being processed by the AHM. This register is updated by
+//                       Hardware when it completes processing a descriptor.
+//                       Hardware updates only bits[15:6]. The bits[15:6] are
+//                       used as an offset relative to the SPL_CH#_IN_DESC_BASE.
+#define AHMPIP_GCSR_SPL_CHn_IN_DESC_HEAD(n)    (AHMPIP_SPL_CHn_BASE(n) + 0x0280)
+
+
+// SPL_CH#_OUT_DESC_BASE: Base address of the Output descriptor queue for CH#
+// Bit   Attr   Default  Description
+// 63:40 RV     0        Rserved
+// 39:0  RW     0        Output Descriptor Queue Base Address: the Output
+//                       descriptor queue base address(physical). This address has to be 64KB
+//                       aligned.
+#define AHMPIP_GCSR_SPL_CHn_OUT_DESC_BASE(n)    (AHMPIP_SPL_CHn_BASE(n) + 0x0300)
+
+// SPL_CH#_OUT_DESC_SIZE: Size of the Output descriptor queue for CH#
+// Bit   Attr   Default  Description
+// 63:16 RV     0        Rserved
+// 15:0  RW     0        Output Descriptor Queue Size: Specifies the size of
+//                       the Output descriptor queue in bytes. The size has to be a multiple of a CL
+//                       which means that bits[5:0] are always zero
+//
+//                       Min: 0x80:     128B = 2CL
+//                       Max: 0xFFFF:   64KB = 1024CL
+#define AHMPIP_GCSR_SPL_CHn_OUT_DESC_SIZE(n)    (AHMPIP_SPL_CHn_BASE(n) + 0x0380)
+
+// SPL_CH#_OUT_DESC_TAIL: Tail pointer of the Output descriptor queue for CH#
+// Bit   Attr   Default  Description
+// 63:40 RV     0        Rserved
+// 39:0  RW     0        Output Descriptor Queue Tail Pointer: This register
+//                       holds the value of the tail pointer for the Output descriptor queue. The
+//                       tail pointer points to the start of the first invalid cacheline which is
+//                       the location for the next enqueued descriptor. Software writes the physical
+//                       address of cacheline into this register but HW uses only bits[15:6] as an
+//                       offset relative to the SPL_CH#_OUT_DESC_BASE. This register is updated by
+//                       software when the new descriptor has been added to the input descriptor
+//                       queue. Refer to Section 1.1 for more deatails.
+#define AHMPIP_GCSR_SPL_CHn_OUT_DESC_TAIL(n)    (AHMPIP_SPL_CHn_BASE(n) + 0x0400)
+
+// SPL_CH#_OUT_DESC_HEAD: Head pointer of the Output descriptor queue for CH#
+// Bit   Attr   Default  Description
+// 63:40 RV     0        Rserved
+// 39:0  RW     0        Output Descriptor Queue Head Pointer: This register
+//                       holds the value of the head pointer for the output descriptor queue. The
+//                       head pointer points to the descriptor that is
+//                       currently being processed by the AHM. This register is updated by
+//                       Hardware when it completes processing a descriptor.
+//                       Hardware updates only bits[15:6]. The bits[15:6] are
+//                       used as an offset relative to the SPL_CH#_OUT_DESC_BASE.
+#define AHMPIP_GCSR_SPL_CHn_OUT_DESC_HEAD(n)    (AHMPIP_SPL_CHn_BASE(n) + 0x0480)
+
+// SPL_CH#_INTR_PENDING:  Task Completion Interrupt Pending: Indicates if a
+//                        interrupt issued by the SPL channel to indicate the completion of one or
+//                        more tasks is pending.
+// Bit   Attr   Default  Description
+// 63:36 RV     0         Rserved
+// 15:6  RO     0         Completed task pointer: Head pointer value of the
+//                        output descriptor queue. The value written in this field should point to
+//                        the last descriptor (i.e. output descriptor with EOT set) of the last
+//                        completed task that requires an interrupt to be issued. This fiedl is
+//                        updated by hardware only upon completion of a task that requires and
+//                        interrrupt to be issued.
+// 5:1   RV     0         Rserved
+// 0     RO     0         Interrupt Pending: This bit indicates whether an
+//                        outstanding interrupt has been issued and is waiting to be serviced by the
+//                        software. This bit is set (i.e. 0x1) by hardware upon completion of a task
+//                        that requires and interrupt to be issued. The hardware uses this bit to
+//                        determine if a pending interrupt has been serviced. The software clears
+//                        this bit when the interrupt has been serviced. The hardware clears is no
+//                        tallowed to issue any subsequent interrupts till this bit is cleared.
+//                        Software clears this bit/register by writing SPL_CH#_INTR_CLR register. See
+//                        SPL_CH#_INTR_CLR[0] for algorithm used to clear this register.
+#define AHMPIP_GCSR_SPL_CHn_INTR_PENDING(n)        (AHMPIP_SPL_CHn_BASE(n) + 0x0500)
+
+// SPL_CH#_INTR_CLR: Task Completion Interrrupt Pending Clear: Register that
+//                   indicates to the hardware that the software has finished servicing the
+//                   interrupt that indicates completion of a task.
+// Bit   Attr   Default  Description
+// 63:16 RV     0         Rserved
+// 15:6  RW     0         Completed task pointer: This field contains the
+//                        value of the output descriptor head pointer at the time that the software
+//                        read the SPL_CH#_INTR_PENDING. Software writes this count which is used by
+//                        hardware to identify if any more tasks were completed by hardware since the
+//                        software read the SPL_CH#_INTR_PENDING register.
+// 5:1   RV     0         Rserved
+// 0     RW     0         Interrupt Pending Clear: Software writes this bit to
+//                        indicate it has completed processing an interrupt.
+//                        HW algorithm to process SPL_CH#_INTR_CLR and SPL_CH#_INTR_PENDING
+//                            if (SPL_CH#_INTR_CLR[0] = 1 && SPL_CH#_INTR_PENDING[15:6]==SPL_CH#_INTR_CLR[15:6] )
+//                                a. SPL_CH#_INTR_PENDING = 0
+//                                b. SPL_CH#_INTR_CLR = 0
+//                                c. HW does NOT issue interrupt since no new tasks have completed
+//                                   since SW last serviced the interrupt.
+//                            else
+//                                a. SPL_CH#_INTR_PENDING[0] = 1
+//                                b. Update SPL_CHE#_INTR_PENDING[15:6] with latest completion task count
+//                                c. HW issue new interrupt since more tasks have been completed
+//                                   since SW serviced the last interrupt.
+#define AHMPIP_GCSR_SPL_CHn_INTR_CLR(n)           (AHMPIP_SPL_CHn_BASE(n) + 0x0580)
+
+// SPL_CH#_INTR_INDX: SPL Channel Interrupt Index register: Specifies the
+//                    interrupt index for a SPL interrupt request to the FSB module. The FSB
+//                    module uses this index as a lookup into a table to get the actual interrupt
+//                    vector issued on the FSB. This is a channel specific register which allows
+//                    the SPL to issue interrupts with different vector for the various channels.
+//                    This will make software service of the interrupts more efficient.
+// Bit   Attr   Default  Description
+// 63:32  RV     0         Rserved
+// 31:3   RV     0         Rserved
+// 2:0    RW     0         3 bit index allows SPL to issue interrupts with
+//                         unique vectors for each channel. This index is used by the SPL in its
+//                         internal request to the FSB module.
+#define AHMPIP_GCSR_SPL_CHn_INTR_INDX(n)          (AHMPIP_SPL_CHn_BASE(n) + 0x0600)
+
+
+// AFU#_VERSION_ID: Used by SW to identify the AFUs present in the hardware. This enables the SW to load
+//                  the AFU specific services depending on the specific AFU.
+// Bit   Attr   Default  Description
+// 63:0   RO     0x00    This is a unique (preferably random) 64bit ID the enables the software to identify
+//                       the AFU. The validity of this register is indicated by SPL_STATUS[12][13][14][15]
+//                       depending on the CH#. This register is updated (in HW and system memory) when a
+//                       "AHM reset" or "SPL Channel Reset" or "AFU reset" occurs.
+//                  NOTE:This ID has to be a non zero value if Ct_AFU#toSPL Presence signal is asserted.
+#define AHMPIP_GCSR_AFUn_VERSION_ID(n)              (AHMPIP_AFUn_BASE(n) + 0x0000)
+
+
+// AFUn_CTRL: Control register used to implement functionality like AFU reset.
+// Bit   Attr   Default  Description
+// 63:20  RV     0         Reserved
+// 19:4   RW     0         Task Abort TID (Optional): This field contains the Task ID (TID) of the task to be aborted.
+//                         SW writes this field along with AFU_CONTROL[1]=1. Upon completion of the abort the AFU resets
+//                         this bit along with this whole register.
+//  3:2   RV     0         Reserved
+//  1     RW     0         Task abort (Optional): This bit is used to abort a task (based on TID). SW writes this bit if
+//                         it wants to abort the task that is currently being worked on by the HW. The current task is based
+//                         on the input descriptor being processed. The AFU should implement all HW hooks necessary perform the
+//                         abort as described below:
+#define AHMPIP_GCSR_AFUn_CTRL(n)                    (AHMPIP_AFUn_BASE(n) + 0x0080)
+
+#define AHMPIP_AFU_CTRL_ABORT_TASK(t)               ((t<<3) & 0x1 )
+
+#ifndef __linux__
+#define __attribute__(p)
+#pragma pack(1)
+#endif
+
+//==================================
+//  ahmpip_desc - Descriptor structure
+//==================================
+struct ahm_input_desc_header {
+   btUnsigned16bitInt  m_size;             // Descriptor size in CL
+   btUnsigned16bitInt  m_ctrl;             // Control Bits
+#define AHM_IN_DESC_MASTER         1
+#define AHM_IN_DESC_DMA            (1<<1)
+#define AHM_IN_DESC_VIRT           (1<<2)
+#define AHM_IN_DESC_PGTBL_PRE      (1<<3)
+#define AHM_IN_DESC_COMP_INTR_EN   (1<<4)
+#define AHM_IN_DESC_SOT            (1<<5)
+#define AHM_IN_DESC_MOT            (1<<6)
+#define AHM_IN_DESC_EOT            (1<<7)
+   btByte              m_pgsize;             // VMM Super-Page size in CL
+   btUnsigned64bitInt  m_pgtbl;              // VMM Page table Physical Address
+   btUnsigned16bitInt  m_pgtblsize;          // VMM Page Table size, 1=64 entries
+   btByte              m_rsvd8_1;            // reserved
+   btUnsigned64bitInt  m_input;              // Physical Byte Address of Input Buffer
+   btUnsigned64bitInt  m_isize:18;           // Input buffer size in CL
+   btUnsigned64bitInt  m_rsv6:6;           
+   btUnsigned64bitInt  m_status:16;          // Status
+#define AHM_IN_DESC_COMPLETE(s)  ( (s) & 1 )
+#define AHM_IN_DESC_PENDING(s)   ( !(AHM_IN_DESC_COMPLETE(s)) )
+#define AHM_IN_DESC_ERROR(s)     ( (s) & (1<<1) )
+#define AHM_IN_DESC_SUCCESS(s)   ( !( AHM_IN_DESC_ERROR(s) ))
+   btUnsigned64bitInt  m_func_id:4;          // Function ID
+   btUnsigned64bitInt  m_tid:16;             // Task ID
+   btUnsigned64bitInt  m_rsvd4:4;            // Reserved
+} __attribute__ ((packed));
+
+
+
+struct ahm_output_desc_header {
+   btUnsigned64bitInt  m_dsize:18;            // Number of CL's written to this buffer
+   btUnsigned64bitInt  m_rsv6_1:6;            
+   btUnsigned64bitInt  m_ctrl:16;             // Control Bits
+#define AHM_OUT_DESC_COMP_INTR_EN   (1<<4)  /* Completion Interrupt Enable */
+#define AHM_OUT_DESC_SOT            (1<<5)
+#define AHM_OUT_DESC_MOT            (1<<6)
+#define AHM_OUT_DESC_EOT            (1<<7)
+   btUnsigned64bitInt  m_rsvd24:24;           // reserved
+   btUnsigned64bitInt  m_rsvd64_1;         // reserved
+   btUnsigned64bitInt  m_output;           // Physical Byte Address of Output Buffer
+   btUnsigned64bitInt  m_osize:18;              // Output Buffer size in CL
+   btUnsigned64bitInt  m_rsv6_2:6;            
+   btUnsigned64bitInt  m_status:16;           // Status
+#define AHM_OUT_DESC_COMPLETE(s) ( (s) & 1 )
+#define AHM_OUT_DESC_PENDING(s)  ( !(AHM_IN_DESC_COMPLETE(s)) )
+#define AHM_OUT_DESC_ERROR(s)    ( (s) & (1<<1) )
+#define AHM_OUT_DESC_SUCCESS(s)  ( !( AHM_IN_DESC_ERROR(s) ))
+   btUnsigned64bitInt  m_func_id:4;         // Function ID
+   btUnsigned64bitInt  m_tid:16;           // Task ID
+   btUnsigned64bitInt  m_rsvd4:4;          // Reserved
+} __attribute__ ((packed));
+
+#define AHM_OUT_AFU_STATUS(p)    (unsigned char*)p+sizeof(struct ahm_output_desc_header)
+#define AHM_AFU_AFU_STATUS_LEN   32
+
+#define AHMPIP_MAX_BUFFER_SIZE               ( ((1<<16) - 1) * AHMPIP_AHM_CL_SIZE )
+
+
+END_NAMESPACE(AAL)
+
+#endif // __AALSDK_KERNEL_AHMPIPDEFS_H__
+
diff --git a/drivers/fpga/aal/include/aalsdk/kernel/ccidefs.h b/drivers/fpga/aal/include/aalsdk/kernel/ccidefs.h
new file mode 100644
index 000000000000..87faf5d272c7
--- /dev/null
+++ b/drivers/fpga/aal/include/aalsdk/kernel/ccidefs.h
@@ -0,0 +1,165 @@
+//******************************************************************************
+// This  file  is  provided  under  a  dual BSD/GPLv2  license.  When using or
+//         redistributing this file, you may do so under either license.
+//
+//                            GPL LICENSE SUMMARY
+//
+//  Copyright(c) 2011-2017, Intel Corporation.
+//
+//  This program  is  free software;  you  can redistribute it  and/or  modify
+//  it  under  the  terms of  version 2 of  the GNU General Public License  as
+//  published by the Free Software Foundation.
+//
+//  This  program  is distributed  in the  hope that it  will  be useful,  but
+//  WITHOUT   ANY   WARRANTY;   without   even  the   implied   warranty    of
+//  MERCHANTABILITY  or  FITNESS  FOR  A  PARTICULAR  PURPOSE.  See  the   GNU
+//  General Public License for more details.
+//
+//  The  full  GNU  General Public License is  included in  this  distribution
+//  in the file called README.GPLV2-LICENSE.TXT.
+//
+//  Contact Information:
+//  Henry Mitchel, henry.mitchel at intel.com
+//  77 Reed Rd., Hudson, MA  01749
+//
+//                                BSD LICENSE
+//
+//  Copyright(c) 2011-2017, Intel Corporation.
+//
+//  Redistribution and  use  in source  and  binary  forms,  with  or  without
+//  modification,  are   permitted  provided  that  the  following  conditions
+//  are met:
+//
+//    * Redistributions  of  source  code  must  retain  the  above  copyright
+//      notice, this list of conditions and the following disclaimer.
+//    * Redistributions in  binary form  must  reproduce  the  above copyright
+//      notice,  this  list of  conditions  and  the  following disclaimer  in
+//      the   documentation   and/or   other   materials   provided  with  the
+//      distribution.
+//    * Neither   the  name   of  Intel  Corporation  nor  the  names  of  its
+//      contributors  may  be  used  to  endorse  or promote  products derived
+//      from this software without specific prior written permission.
+//
+//  THIS  SOFTWARE  IS  PROVIDED  BY  THE  COPYRIGHT HOLDERS  AND CONTRIBUTORS
+//  "AS IS"  AND  ANY  EXPRESS  OR  IMPLIED  WARRANTIES,  INCLUDING,  BUT  NOT
+//  LIMITED  TO, THE  IMPLIED WARRANTIES OF  MERCHANTABILITY  AND FITNESS  FOR
+//  A  PARTICULAR  PURPOSE  ARE  DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT
+//  OWNER OR CONTRIBUTORS BE LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,
+//  SPECIAL,  EXEMPLARY,  OR  CONSEQUENTIAL   DAMAGES  (INCLUDING,   BUT   NOT
+//  LIMITED  TO,  PROCUREMENT  OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF USE,
+//  DATA,  OR PROFITS;  OR BUSINESS INTERRUPTION)  HOWEVER  CAUSED  AND ON ANY
+//  THEORY  OF  LIABILITY,  WHETHER  IN  CONTRACT,  STRICT LIABILITY,  OR TORT
+//  (INCLUDING  NEGLIGENCE  OR OTHERWISE) ARISING  IN ANY WAY  OUT  OF THE USE
+//  OF  THIS  SOFTWARE, EVEN IF ADVISED  OF  THE  POSSIBILITY  OF SUCH DAMAGE.
+//******************************************************************************
+//****************************************************************************
+//        FILE: ccidefs.h
+//     CREATED: 12/05/2011
+//      AUTHOR: Henry Mitchel
+//
+// PURPOSE:  This file contains external definitions for the
+//           Accelerator Abstraction Layer (AAL)
+//           SPL 2 CCI HW interface.
+//
+//           CCI User Mode fundamental definitions file
+//
+// HISTORY:
+// COMMENTS:
+// WHEN:          WHO:     WHAT:
+// 12/05/2011     HM       Initial version started
+// 02/06/2012     JG       AAL integration
+// 07/30/2014     JG       CCI 3 support
+//****************************************************************************
+#ifndef __AALSDK_KERNEL_CCIDEFS_H__
+#define __AALSDK_KERNEL_CCIDEFS_H__
+#include <aalsdk/kernel/aaltypes.h>
+
+BEGIN_NAMESPACE(AAL)
+
+
+/*
+ * CCI-specific constants based on QLP2 implementation
+ *
+ * DSM == Device Status Memory, i.e. a place for the device to communicate to the host
+ *
+ * All 64-bit CSR's are written in 32-bit halves, upper half first. HW takes writing
+ *    of lower 32-bit half as signal that both are written and the entire value is valid.
+ *    Note that because these CSRs are in the PCIe configuration space, they are serialized,
+ *    so that the above assumption is accurate.
+ */
+
+
+/******************************************************************************
+ * Length of Cache Line figures prominently in many calculations
+ ******************************************************************************/
+#define  lenCL    64
+
+/******************************************************************************
+ * 32-bit Feature ID CSR
+ ******************************************************************************/
+#define byte_offset_PCIE_FEATURE_HDR_F2  0x208
+struct PCIE_FEATURE_HDR_F2 {
+   union {
+      btUnsigned32bitInt csr;              // the entire csr as a 32-bit entity
+      struct {
+         btUnsigned32bitInt rsvd1:16;
+         btUnsigned32bitInt FeatureID:4;   // 0: old CCI, 1: old SPL, 2: new CCI-AFU protocol of self-discovery
+                                           //    based on the DSM mechanism described above
+         btUnsigned32bitInt rsvd:12;
+      };
+   };
+}; // struct PCIE_FEATURE_HDR_F2
+static const int FeatureID_CCI2 = 2;
+static const int FeatureID_CCI3 = 3;
+
+#define byte_offset_PCIE_FEATURE_HDR_F3  0x308
+struct PCIE_FEATURE_HDR_F3 {
+   union {
+      btUnsigned32bitInt csr;              // the entire csr as a 32-bit entity
+      struct {
+         btUnsigned32bitInt rsvd1:16;
+         btUnsigned32bitInt protocol:4;    // 0 = CCI; 1 = SPL
+                                           //    based on the DSM mechanism described above
+         btUnsigned32bitInt rsvd:12;
+      };
+   };
+}; // struct PCIE_FEATURE_HDR_F3
+
+
+static const int PCIE_FEATURE_HDR3_PROTOCOL_CCI3 = 0;
+static const int PCIE_FEATURE_HDR3_PROTOCOL_SPL  = 1;
+
+/******************************************************************************
+ * CCI-AFU DSM (Device Status Memory) definition
+ ******************************************************************************/
+/*
+ * Written with 64-bit physical address of the CCI-AFU's DSM
+ *
+ * CCI-AFU will then respond with an ID at that location to identify itself
+ *
+ * See spl2defs.h for the details of the structure of the DSM and its ID
+ */
+//#define byte_offset_CCIAFU_DSM_BASE    0x910
+
+// In documentation, SPL is used instead of the more accurate CCIAFU designation
+//static const int byte_offset_SPL_DSM_BASE      =  byte_offset_CCIAFU_DSM_BASE;
+// The intention is to make byte_offset_SPL_DSM_BASE initialized by
+//    byte_offset_CCIAFU_DSM_BASE, but it causes 'error: initializer element is not constant'
+//    error sometimes -- I don't know why.
+#define byte_offset_SPL_DSM_BASE       0x1000
+
+/*
+ * Actual structure of CCIAFU Device Status Memory area is unknown to CCI,
+ *    except for the first cache-line, defined here
+ */
+struct CCIAFU_DSM {
+   union {                                // SPL_ID
+      btUnsigned64bitInt CL_0[8];         //    first cache-line
+      btUnsigned32bitInt cci_afu_id;      // if cci_afu_id == SPL2_ID, then this cci_afu is SPL 2
+   };
+};
+
+END_NAMESPACE(AAL)
+
+#endif // __AALSDK_KERNEL_CCIDEFS_H__
+
diff --git a/drivers/fpga/aal/include/aalsdk/kernel/ccip_defs.h b/drivers/fpga/aal/include/aalsdk/kernel/ccip_defs.h
new file mode 100644
index 000000000000..cf76312d9d68
--- /dev/null
+++ b/drivers/fpga/aal/include/aalsdk/kernel/ccip_defs.h
@@ -0,0 +1,1738 @@
+//******************************************************************************
+// This  file  is  provided  under  a  dual BSD/GPLv2  license.  When using or
+//         redistributing this file, you may do so under either license.
+//
+//                            GPL LICENSE SUMMARY
+//
+//  Copyright(c) 2015-2017, Intel Corporation.
+//
+//  This program  is  free software;  you  can redistribute it  and/or  modify
+//  it  under  the  terms of  version 2 of  the GNU General Public License  as
+//  published by the Free Software Foundation.
+//
+//  This  program  is distributed  in the  hope that it  will  be useful,  but
+//  WITHOUT   ANY   WARRANTY;   without   even  the   implied   warranty    of
+//  MERCHANTABILITY  or  FITNESS  FOR  A  PARTICULAR  PURPOSE.  See  the   GNU
+//  General Public License for more details.
+//
+//  The  full  GNU  General Public License is  included in  this  distribution
+//  in the file called README.GPLV2-LICENSE.TXT.
+//
+//  Contact Information:
+//  Henry Mitchel, henry.mitchel at intel.com
+//  77 Reed Rd., Hudson, MA  01749
+//
+//                                BSD LICENSE
+//
+//  Copyright(c) 2015-2017, Intel Corporation.
+//
+//  Redistribution and  use  in source  and  binary  forms,  with  or  without
+//  modification,  are   permitted  provided  that  the  following  conditions
+//  are met:
+//
+//    * Redistributions  of  source  code  must  retain  the  above  copyright
+//      notice, this list of conditions and the following disclaimer.
+//    * Redistributions in  binary form  must  reproduce  the  above copyright
+//      notice,  this  list of  conditions  and  the  following disclaimer  in
+//      the   documentation   and/or   other   materials   provided  with  the
+//      distribution.
+//    * Neither   the  name   of  Intel  Corporation  nor  the  names  of  its
+//      contributors  may  be  used  to  endorse  or promote  products derived
+//      from this software without specific prior written permission.
+//
+//  THIS  SOFTWARE  IS  PROVIDED  BY  THE  COPYRIGHT HOLDERS  AND CONTRIBUTORS
+//  "AS IS"  AND  ANY  EXPRESS  OR  IMPLIED  WARRANTIES,  INCLUDING,  BUT  NOT
+//  LIMITED  TO, THE  IMPLIED WARRANTIES OF  MERCHANTABILITY  AND FITNESS  FOR
+//  A  PARTICULAR  PURPOSE  ARE  DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT
+//  OWNER OR CONTRIBUTORS BE LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,
+//  SPECIAL,  EXEMPLARY,  OR  CONSEQUENTIAL   DAMAGES  (INCLUDING,   BUT   NOT
+//  LIMITED  TO,  PROCUREMENT  OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF USE,
+//  DATA,  OR PROFITS;  OR BUSINESS INTERRUPTION)  HOWEVER  CAUSED  AND ON ANY
+//  THEORY  OF  LIABILITY,  WHETHER  IN  CONTRACT,  STRICT LIABILITY,  OR TORT
+//  (INCLUDING  NEGLIGENCE  OR OTHERWISE) ARISING  IN ANY WAY  OUT  OF THE USE
+//  OF  THIS  SOFTWARE, EVEN IF ADVISED  OF  THE  POSSIBILITY  OF SUCH DAMAGE.
+//******************************************************************************
+//****************************************************************************
+/// @file ccip_defs.h
+/// @brief  Public definitions for CCI-P compliant devices.
+/// @ingroup aalkernel_ccip
+/// @verbatim
+///        FILE: ccip_defs.h
+///     CREATED: Oct 28, 2015
+///      AUTHOR: Ananda Ravuri, Intel <ananda.ravuri@intel.com>
+///              Joseph Grecco, Intel <joe.grecco@intel.com>
+///
+/// PURPOSE:   This file contains the definitions for the CCI-P compliant FPGA
+///            devices.
+/// HISTORY:
+/// COMMENTS:
+/// WHEN:          WHO:     WHAT:
+/// 10/28/15       JG       Created from prototype written by AR@endverbatim
+//****************************************************************************
+#ifndef __AALKERNEL_CCIP_DEFS_H_
+#define __AALKERNEL_CCIP_DEFS_H_
+#include "aalsdk/kernel/kosal.h"
+
+#if !defined(MODULE_FLAGS)
+#define MODULE_FLAGS CCIPCIE_DBG_MOD // Prints all
+#endif
+
+#include <aalsdk/kernel/aaltypes.h>
+
+
+BEGIN_NAMESPACE(AAL)
+
+
+/// @addtogroup aalkernel_ccip
+/// @{
+
+/// MMIO space Size
+/// Simulation  mmio size
+#define CCIP_MMIO_SIZE              ( 0x120000 )
+
+// Max number of pci bars to scan
+#define CCIP_MAX_PCIBAR             5
+
+#define CCIP_UMSG_SIZE              (0x1000)
+
+// Clear Error CSRs
+#define  CLEAR_ALL_ERRORS 0xFFFFFFFFFFFFFFFF
+
+///=================================================================
+/// Enumerations
+///=================================================================
+enum e_CCIP_DEV_FEATURE_ID {
+	CCIP_DEVFID_Configuration,
+	CCIP_DEVFID_FME,
+	CCIP_DEVFID_PORT,
+	CCIP_DEVFID_SIGTAP,
+};
+
+
+/// CCIP Device type ID
+enum e_CCIP_DEVTPPE_ID {
+   CCIP_DFType_rsvd      = 0x0,
+   CCIP_DFType_afu       = 0x1,
+   CCIP_DFType_bbb       = 0x2,
+   CCIP_DFType_private   = 0x3
+};
+
+// FPGA Management Engine (FME)
+//-----------------------------
+
+// Device Feature ID
+enum e_CCIP_DFL_ID {
+   CCIP_FME_DFLID_THERM  = 0x1,
+   CCIP_FME_DFLID_POWER  = 0x2,
+   CCIP_FME_DFLID_GPERF  = 0x3,
+   CCIP_FME_DFLID_GERR   = 0x4,
+   CCIP_FME_DFLID_PR     = 0x5,
+   CCIP_PORT_DFLID_ERROR = 0x10,
+   CCIP_PORT_DFLID_USMG  = 0x11,
+   CCIP_PORT_DFLID_PR    = 0x12,
+   CCIP_PORT_DFLID_STP   = 0x13
+};
+
+// Device Feature revision ID
+enum e_CCIP_DFL_rev {
+   CCIP_DFL_rev0    = 0x0,
+   CCIP_DFL_rev1    = 0x1,
+   CCIP_DFL_rev2    = 0x2,
+   CCIP_DFL_rev3    = 0x3,
+   CCIP_DFL_rev4    = 0x4
+};
+
+
+// AFU power states
+enum e_AFU_Power_State {
+   AFU_Power_Normal = 0x0,
+   AFU_Power_AP1 = 0x1,
+   AFU_Power_AP2 = 0x2,
+   AFU_Power_AP6 = 0x6
+};
+
+// Cache Event codes
+enum e_Cache_Event_Code {
+   Cache_Read_Hit = 0x0,
+   Cache_Write_Hit = 0x1,
+   Cache_Read_Miss = 0x2,
+   Cache_Write_Miss = 0x3,
+   Cache_Rsvd = 0x4,
+   Cache_Hold_Req = 0x5,
+   Cache_Data_WrtPort_Conten = 0x6,
+   Cache_Tag_WrtPort_Conten = 0x7,
+   Cache_Tx_Req_stall = 0x8,
+   Cache_Rx_Stalls = 0x9,
+   Cache_Evictions = 0xA
+
+};
+
+// Fabric event codes
+enum e_Fabric_Event_Code {
+   Fabric_PCIe0_Read = 0x0,
+   Fabric_PCIe0_Write = 0x1,
+   Fabric_PCIe1_Read = 0x2,
+   Fabric_PCIe1_Write = 0x3,
+   Fabric_UPI_Read = 0x4,
+   Fabric_UPI_Write = 0x5
+};
+
+// VT-D event codes
+enum e_vtd_Event_Code {
+   AFU0_MemRead_Trans        = 0x0,
+   AFU1_MemRead_Trans        = 0x1,
+   AFU0_MemWrite_Trans       = 0x2,
+   AFU1_MemWrite_Trans       = 0x3,
+   AFU0_DevTLBRead_Hit       = 0x4,
+   AFU1_DevTLBRead_Hit       = 0x5,
+   AFU0_DevTLBWrite_Hit      = 0x6,
+   AFU1_DevTLBWrite_Hit      = 0x7,
+};
+
+/// CCI-P port id
+enum e_CCIP_Port_Id {
+   CCIP_Port_Id0 = 0x0,
+   CCIP_Port_Id1 = 0x1,
+   CCIP_Port_Rsvd = 0x2,
+   CCIP_Port_Rsvd1 = 0x3
+};
+
+/// Partial Reconfiguration ID
+enum e_FME_PR_REGION_ID {
+   CCIP_PR_Region0 = 0x0,
+   CCIP_PR_Region1 = 0x1,
+   CCIP_PR_rsvd1 = 0x2,
+   CCIP_PR_rsvd2 = 0x3
+
+};
+
+/// Partial Reconfiguration status
+enum e_CCIP_PORT_PR_status {
+   CCIP_PORT_PR_Idle = 0x0,
+   CCIP_PORT_PR_RecStart = 0x1,
+   CCIP_PORT_PR_ReSet = 0x2,
+   CCIP_PORT_WaitFreeze = 0x3,
+   CCIP_PORT_WaitPR = 0x4,
+   CCIP_PORT_SendFrst_Data = 0x5,
+   CCIP_PORT_WaitPRReady = 0x6,
+   CCIP_PORT_PushFIFO_IP = 0x7,
+   CCIP_PORT_WaitPR_Resp = 0x8,
+   CCIP_PORT_PR_Complete = 0x9,
+   CCIP_PORT_PR_UnFreeze = 0xA,
+   CCIP_PORT_PR_DeAssert = 0xB
+};
+
+/// Partial Reconfiguration  mega function status codes
+enum e_CCIP_PR_ControllerBlock_status {
+   CCIP_PR_CLB_pwrup = 0x0,
+   CCIP_PR_CLB_error = 0x1,
+   CCIP_PR_CLB_crc_err = 0x2,
+   CCIP_PR_CLB_Incomp_bts_err = 0x3,
+   CCIP_PR_CLB_opr_inPros = 0x4,
+   CCIP_PR_CLB_por_pass = 0x5,
+   CCIP_PR_CLB_rsvd1 = 0x6,
+   CCIP_PR_CLB_rsvd2 = 0x7
+};
+
+///=================================================================
+/// IDs used by the devices and objects
+///=================================================================
+
+// FPGA Management Engine GUID
+#define CCIP_FME_GUIDL              (0x82FE38F0F9E17764ULL)
+#define CCIP_FME_GUIDH              (0xBFAf2AE94A5246E3ULL)
+#define CCIP_FME_PIPIID             (0x4DDEA2705E7344D1ULL)
+
+#define CCIP_DEV_FME_SUBDEV         ((btUnsigned16bitInt)(-1))
+#define CCIP_DEV_PORT_SUBDEV(s)     (s + 0x10)
+#define CCIP_DEV_AFU_SUBDEV(s)      (s + 0x20)
+
+#define PORT_SUBDEV(s)              (s - 0x10 )
+#define AFU_SUBDEV(s)               (s - 0x20 )
+
+/// FPGA Port GUID
+#define CCIP_PORT_GUIDL             (0x9642B06C6B355B87ULL)
+#define CCIP_PORT_GUIDH             (0x3AB49893138D42EBULL)
+#define CCIP_PORT_PIPIID            (0x5E82B04A50E59F20ULL)
+
+/// AFU GUID
+#define CCIP_AFU_PIPIID             (0x26F67D4CAD054DFCULL)
+
+/// Signal Tap GUID
+#define CCIP_STAP_GUIDL             (0xB6B03A385883AB8DULL)
+#define CCIP_STAP_GUIDH             (0x022F85B12CC24C9DULL)
+#define CCIP_STAP_PIPIID            (0xA710C842F06E45E0ULL)
+
+
+/// Partial Reconfiguration GUID
+#define CCIP_PR_GUIDL               (0x83B54FD5E5216870ULL)
+#define CCIP_PR_GUIDH               (0xA3AAB28579A04572ULL)
+#define CCIP_PR_PIPIID              (0x7C4D41EA156C4D81ULL)
+
+
+/// FME Power  GUID
+#define CCIP_PWR_GUIDL               (0x99DE979A70CEE6C9ULL)
+#define CCIP_PWR_GUIDH               (0x93136515D527451AULL)
+#define CCIP_PWR_PIPIID              (0xBBD60200C0A80117ULL)
+
+
+/// Vender ID and Device ID
+#define CCIP_FPGA_VENDER_ID         0x8086
+
+/// PCI Device ID
+#define PCIe_DEVICE_ID_RCiEP0       0xBCBD
+#define PCIe_DEVICE_ID_RCiEP1       0xBCBE
+
+/// VF Device
+#define PCIe_DEVICE_ID_VF           0xBCBF
+
+/// QPI Device ID
+#define PCIe_DEVICE_ID_RCiEP2       0xBCBC
+
+
+
+/// MMIO Space map
+#define FME_DFH_AFUIDL  0x8
+#define FME_DFH_AFUIDH  0x10
+#define FME_DFH_NEXTAFU 0x18
+
+
+/******************************************************************************
+ *  FPGA  Header and CSR
+ *
+ *   Description:
+ *
+ ******************************************************************************/
+
+/// Device Feature Header CSR
+struct CCIP_DFH {
+
+   union {
+      btUnsigned64bitInt csr;
+      struct {
+         btUnsigned64bitInt Feature_ID :12;      // Feature ID
+         btUnsigned64bitInt Feature_rev :4;      // Feature revision
+         btUnsigned64bitInt next_DFH_offset :24; // Next Device Feature header offset
+         btUnsigned64bitInt eol :1;              // End of Device feature list
+         btUnsigned64bitInt rsvd :19;            // Reserved
+         btUnsigned64bitInt Type :4;             // Type of Device
+
+      }; //end struct
+   }; // end union
+
+}; //end struct CCIP_DFH
+CASSERT(sizeof(struct CCIP_DFH) == 8);
+
+/// AFU ID low CSR
+struct CCIP_AFU_ID_L {
+
+   union {
+      btUnsigned64bitInt csr;
+      struct {
+         btUnsigned64bitInt afu_id_l :64;    // AFU ID low
+
+      }; // end struct
+   }; // end union
+
+}; //end struct CCIP_AFU_ID_L
+CASSERT(sizeof(struct CCIP_AFU_ID_L) == 8);
+
+/// AFU ID high CSR
+struct CCIP_AFU_ID_H {
+
+   union {
+      btUnsigned64bitInt csr;
+      struct {
+         btUnsigned64bitInt afu_id_h :64;    // AFU ID low
+
+      }; // end struct
+   }; // end union
+
+}; //end struct CCIP_AFU_ID_L
+CASSERT(sizeof(struct CCIP_AFU_ID_H) == 8);
+
+
+/// Next AFU offset CSR
+struct CCIP_NEXT_AFU {
+
+   union {
+      btUnsigned64bitInt csr;
+      struct {
+         btUnsigned64bitInt afu_id_offset :24;   // Next AFU DFH byte offset
+         btUnsigned64bitInt rsvd :40;            // Reserved
+
+      }; // end struct
+   }; // end union
+
+}; // end struct CCIP_NEXT_AFU
+CASSERT(sizeof(struct CCIP_NEXT_AFU) == 8);
+
+/// FME Scratch pad CSR
+struct CCIP_SCRATCHPAD {
+   union {
+      btUnsigned64bitInt csr;
+      struct {
+         btUnsigned64bitInt scratch_pad :64;   //Scratch pad Register
+
+      }; // end struct
+   }; // end union
+
+}; // end struct CCIP_SCRATCHPAD
+CASSERT(sizeof(struct CCIP_SCRATCHPAD) == 8);
+
+// Fabric capability
+struct CCIP_FAB_CAPABILITY {
+
+   union {
+      btUnsigned64bitInt csr;
+      struct {
+         btUnsigned64bitInt fabric_verid :8;             // Fabric version ID
+         btUnsigned64bitInt socket_id :1;                // Socket id
+         btUnsigned64bitInt rsvd1 :3;                    // Reserved
+         btUnsigned64bitInt pci0_link_avile :1;          // pci0 link available yes /no
+         btUnsigned64bitInt pci1_link_avile :1;          // pci1 link available yes /no
+         btUnsigned64bitInt qpi_link_avile :1;           // Coherent (QPI/UPI) link available yes /no
+         btUnsigned64bitInt rsvd2 :1;                    // Reserved
+         btUnsigned64bitInt iommu_support :1;            // IOMMU or VT-d supported  yes/no
+         btUnsigned64bitInt num_ports :3;                // Number of ports
+         btUnsigned64bitInt rsvd3 :4;                    // Reserved
+         btUnsigned64bitInt address_width_bits :6;       // Address width supported in bits  BXT -0x26 , SKX -0x30
+         btUnsigned64bitInt rsvd4 :2;                    // Reserved
+         btUnsigned64bitInt cache_size :12;              // Size of cache supported in kb
+         btUnsigned64bitInt cache_assoc :4;              // Cache Associativity
+         btUnsigned64bitInt rsvd5 :15;                   // Reserved
+         btUnsigned64bitInt lock_bit :1;                 // Lock bit
+      }; // end struct
+   }; // end union
+
+}; // struct CCIP_FME_CAPABILITY
+
+CASSERT(sizeof(struct CCIP_FAB_CAPABILITY) == 8);
+
+/// FPGA Port offset CSR
+struct CCIP_PORT_AFU_OFFSET {
+
+   union {
+      btUnsigned64bitInt csr;
+      struct {
+         btUnsigned64bitInt port_offset :24;          // Port offset
+         btUnsigned64bitInt rsvd1 :8;                 // Reserved
+         btUnsigned64bitInt port_bar :3;              // Port BAR
+         btUnsigned64bitInt rsvd2 :20;                // Reserved
+         btUnsigned64bitInt afu_access_control :1;    // afu access type
+         btUnsigned64bitInt rsvd3 :4;                 // Reserved
+         btUnsigned64bitInt port_imp :1;              // Port Implemented
+         btUnsigned64bitInt rsvd4 :3;                 // Reserved
+      }; // end struct
+   }; // end union
+
+}; // end struct CCIP_PORT_AFU_OFFSET
+CASSERT(sizeof(struct CCIP_PORT_AFU_OFFSET) == 8);
+
+// Fabric status
+struct CCIP_FAB_STATUS {
+
+   union {
+      btUnsigned64bitInt csr;
+      struct {
+         btUnsigned64bitInt upilink_status :4;       // UPI Link Status
+         btUnsigned64bitInt rsvd1 :4;                // Reserved
+
+         btUnsigned64bitInt pcie0link_status :1;    // PCIe0 link status
+         btUnsigned64bitInt rsvd2 :3;               // Reserved
+
+         btUnsigned64bitInt pcie1link_status :1;    // PCIe1 link status
+         btUnsigned64bitInt rsvd3 :51;              // Reserved
+      }; // end struct
+   }; // end union
+
+}; // struct CCIP_FAB_STATUS
+CASSERT(sizeof(struct CCIP_FAB_STATUS) == 8);
+
+/// Blue bitstream ID  CSR
+struct CCIP_BBS_ID {
+
+   union {
+      btUnsigned64bitInt csr;
+      struct {
+         btUnsigned64bitInt bbs_id :64;   // BBS ID
+
+      }; // end struct
+   }; // end union
+
+}; //end struct CCIP_BBS_ID
+CASSERT(sizeof(struct CCIP_BBS_ID) == 8);
+
+
+/// Blue bitstream metadata  CSR
+struct CCIP_BBS_MD {
+
+   union {
+      btUnsigned64bitInt csr;
+      struct {
+         btUnsigned64bitInt bbs_md :64;   // BBS Meta data
+
+      }; // end struct
+   }; // end union
+
+}; //end struct CCIP_BBS_MD
+CASSERT(sizeof(struct CCIP_BBS_MD) == 8);
+
+/// FPGA Protected Range Base Address
+struct CCIP_FME_GENPROTRANGE2_BASE {
+
+   union {
+      btUnsigned64bitInt csr;
+      struct {
+         btUnsigned64bitInt rsvd1 :16;                  // Reserved
+         btUnsigned64bitInt protected_base_addrss:4;    // Base Address of memory range
+         btUnsigned64bitInt rsvd2 :44;                  // Reserved
+      }; // end struct
+   }; // end union
+
+}; // end struct CCIP_FME_GENPROTRANGE2_BASE
+CASSERT(sizeof(struct CCIP_FME_GENPROTRANGE2_BASE) == 8);
+
+/// FPGA Protected Range Base limit address
+struct CCIP_FME_GENPROTRANGE2_LIMIT {
+
+   union {
+      btUnsigned64bitInt csr;
+      struct {
+         btUnsigned64bitInt rsvd1 :16;                   // Reserved
+         btUnsigned64bitInt protected_limit_addrss:4;    // Limit Address of memory range
+         btUnsigned64bitInt rsvd2 :44;                   // Reserved
+      }; // end struct
+   }; // end union
+
+}; // end struct CCIP_FME_GENPROTRANGE2_LIMIT
+CASSERT(sizeof(struct CCIP_FME_GENPROTRANGE2_LIMIT) == 8);
+
+
+/// DXE LOCK
+struct CCIP_DXE_LOCK {
+
+   union {
+      btUnsigned64bitInt csr;
+      struct {
+         btUnsigned64bitInt dxe_lock:64;   // DXE LOCK
+      }; // end struct
+   }; // end union
+
+}; // end struct CCIP_DXE_LOCK
+CASSERT(sizeof(struct CCIP_DXE_LOCK) == 8);
+
+
+// HSSI Control
+struct CCIP_HSSI_CTRL {
+
+   union {
+      btUnsigned64bitInt csr;
+      struct {
+         btUnsigned64bitInt data:32;       // Data
+         btUnsigned64bitInt address:16;    // Address
+         btUnsigned64bitInt command:16;    // Command
+      }; // end struct
+   }; // end union
+
+}; // end struct CCIP_HSSI_CTRL
+CASSERT(sizeof(struct CCIP_HSSI_CTRL) == 8);
+
+
+// HSSI status
+struct CCIP_HSSI_STAT{
+
+   union {
+      btUnsigned64bitInt csr;
+      struct {
+         btUnsigned64bitInt data:32;      // Data
+         btUnsigned64bitInt ack:1;        // acknowledge
+         btUnsigned64bitInt spare:1;      // Spare
+         btUnsigned64bitInt rsvd:30;      // Reserved
+      }; // end struct
+   }; // end union
+
+}; // end struct CCIP_HSSI_STAT
+CASSERT(sizeof(struct CCIP_HSSI_STAT) == 8);
+
+/******************************************************************************
+ *  FPGA Management Engine  Header
+ *  CCI-P version =1
+ *  CCI-P minor version =0
+ *  Type = afu
+ *  Header Description:
+ *
+ ******************************************************************************/
+///============================================================================
+/// Name: CCIP_FME_HDR
+/// @brief   FPGA Management Engine  Header
+///  Version: 1
+///  Type:  Private
+///  Feature: AFU
+///============================================================================
+struct CCIP_FME_HDR {
+
+   // FME  Header
+   struct CCIP_DFH                                 dfh;                   // Offset 0
+
+   // FME afu id  low
+   struct CCIP_AFU_ID_L                            afu_id_l;              // Offset 0x8
+
+   // FME afu id  high
+   struct CCIP_AFU_ID_H                            afu_id_h;              // Offset 0x10
+
+   // Next AFU offset
+   struct CCIP_NEXT_AFU                            next_afu;               // Offset 0x18
+
+   // Reserved
+   btUnsigned64bitInt                              rsvd_fmehdr;            // Offset 0x20
+
+   // FME Scratch pad
+   struct CCIP_SCRATCHPAD                          scratchpad;             // Offset 0x28
+
+   // Fabric capability
+   struct CCIP_FAB_CAPABILITY                      fab_capability;          // Offset 0x30
+
+   // Beginning of the list of offsets to
+   //the Port regions
+   struct CCIP_PORT_AFU_OFFSET                     port_offsets[4];         // Offset 0x38
+
+   // fabric status csr
+   struct CCIP_FAB_STATUS                          fab_status ;              // Offset 0x58
+
+   // Bitstream ID
+   struct CCIP_BBS_ID                              bbs_id ;                  // Offset 0x60
+
+   // Bitstream medadata
+   struct CCIP_BBS_MD                              bbs_md ;                  // Offset 0x68
+
+   struct CCIP_FME_GENPROTRANGE2_BASE              genprotrannge2_base ;     // Offset 0x70
+
+   struct CCIP_FME_GENPROTRANGE2_LIMIT             enprotrannge2_limit ;     // Offset 0x78
+
+   //DXE LOCK
+   struct CCIP_DXE_LOCK                            dxe_lock ;                 // Offset 0x80
+
+   //HSSI Lock
+   struct CCIP_HSSI_CTRL                           hssi_ctrl ;                // Offset 0x88
+
+   // HSSI Status
+   struct CCIP_HSSI_STAT                           hssi_status;               // Offset 0x90
+
+
+}; //end struct CCIP_FME_HDR
+CASSERT(sizeof(struct CCIP_FME_HDR) == (8 * 19));
+
+///============================================================================
+/// Name: CCIP_FME_DFL_THERM
+/// @brief   FPGA Management Engine  Thermal  Management Feature
+///  Feature ID: 0x1
+///  Feature Type: = Private
+///  Feature Revision: 0
+///============================================================================
+
+
+// Temperature Threshold
+struct CCIP_TEMP_THRESHOLD {
+
+   union {
+      btUnsigned64bitInt csr;
+      struct {
+         btUnsigned64bitInt tmp_thshold1 :7;                // temperature Threshold 1
+         btUnsigned64bitInt tmp_thshold1_status :1;         // temperature Threshold 1 enable /disable
+         btUnsigned64bitInt tmp_thshold2 :7;                // temperature Threshold 2
+         btUnsigned64bitInt tmp_thshold2_status :1;         // temperature Threshold 2 enable /disable
+         btUnsigned64bitInt rsvd4 :8;                       // Reserved
+         btUnsigned64bitInt therm_trip_thshold :7;          // Thermeal Trip Threshold
+         btUnsigned64bitInt rsvd3 :1;                       // Reserved
+         btUnsigned64bitInt thshold1_status :1;             // Threshold 1 Status
+         btUnsigned64bitInt thshold2_status :1;             // Threshold 2 Status
+         btUnsigned64bitInt rsvd5 :1;                       // Reserved
+         btUnsigned64bitInt therm_trip_thshold_status :1;   // Thermeal Trip Threshold status
+         btUnsigned64bitInt rsvd2 :8;                       // Reserved
+         btUnsigned64bitInt thshold_policy :1;              // threshold policy
+         btUnsigned64bitInt rsvd :19;                       // Reserved
+
+     }; //end struct
+   }; // end union
+
+}; // end struct CCIP_TMP_THRESHOLD
+
+
+// Temperature Sensor Read values
+struct CCIP_TEMP_RDSSENSOR_FMT1 {
+
+   union {
+      btUnsigned64bitInt csr;
+      struct {
+         btUnsigned64bitInt tmp_reading :7;               // Reads out FPGA temperature in celsius.
+         btUnsigned64bitInt rsvd2 :1;                     // Reserved
+         btUnsigned64bitInt tmp_reading_seq_num :16;      // Temperature reading sequence number
+         btUnsigned64bitInt tmp_reading_valid :1;         // Temperature reading is valid
+         btUnsigned64bitInt rsvd1 :7;                     // Reserved
+         btUnsigned64bitInt dbg_mode :8;                  // Debug mode
+         btUnsigned64bitInt rsvd :24;                     // Reserved
+
+      }; // end struct
+   } ; // end union
+
+}; // end struct CCIP_TMP_RDSSENSOR_FMT1
+
+// Temperature sensor read values
+struct CCIP_TEMP_RDSSENSOR_FMT2 {
+
+   union {
+      btUnsigned64bitInt csr;
+      struct {
+         btUnsigned64bitInt rsvd :64;  // TBD
+      }; // end struct
+   }; // end union
+
+}; // end struct CCIP_TMP_RDSSENSOR_FMT2
+
+
+struct CCIP_FME_DFL_THERM {
+
+   // Thermal  Management Feature Header
+   struct CCIP_DFH                     ccip_fme_tmp_dflhdr ;
+
+   struct CCIP_TEMP_THRESHOLD          ccip_tmp_threshold;
+   struct CCIP_TEMP_RDSSENSOR_FMT1     ccip_tmp_rdssensor_fm1;
+   struct CCIP_TEMP_RDSSENSOR_FMT2     ccip_tmp_rdssensor_fm2;
+
+}; //end struct CCIP_FME_TMP_DFL
+CASSERT(sizeof(struct CCIP_FME_DFL_THERM) == (4*8));
+
+
+///============================================================================
+/// Name: CCIP_FME_DFL_PM
+/// @brief   FPGA Management Engine Power Management Feature
+///  Feature ID: 0x2
+///  Feature Type: = Private
+///  Feature Revision: 0
+///============================================================================
+
+//Power Management Status
+struct CCIP_PM_STATUS {
+
+   union {
+      btUnsigned64bitInt csr;
+      struct {
+         btUnsigned64bitInt pwr_consumed :18;        // power consumed
+         btUnsigned64bitInt fpga_latency_report :1;  // FPGA Latency Tolerance Reporting (LTR)
+         btUnsigned64bitInt rsvd3 :45;               // Reserved
+      }; // end struct
+   }; // end union
+
+} ; // end struct CCIP_PM_STATUS
+CASSERT(sizeof(struct CCIP_PM_STATUS) == (1*8));
+
+
+//Power Management AP Thresholds
+struct CCIP_PM_AP_THRESHOLDS {
+
+   union {
+      btUnsigned64bitInt csr;
+      struct {
+         btUnsigned64bitInt threshold1 :10;           //Threshold 1
+         btUnsigned64bitInt threshold2 :10;           //Threshold 2
+         btUnsigned64bitInt threshold3 :10;           //Threshold 3
+         btUnsigned64bitInt threshold4 :10;           //Threshold 4
+         btUnsigned64bitInt rsvd :24;                 // Reserved
+      }; // end struct
+   }; // end union
+
+} ; // end struct CCIP_PM_AP_THRESHOLDS
+CASSERT(sizeof(struct CCIP_PM_AP_THRESHOLDS) == (1*8));
+
+
+struct CCIP_FME_DFL_PM {
+
+   // FME Power Management Feature header
+   struct CCIP_DFH                      ccip_fme_pm_dflhdr;
+
+   // PM Status
+   struct CCIP_PM_STATUS                pm_status;
+
+   // PM AP thresholds
+   struct CCIP_PM_AP_THRESHOLDS         pm_ap_thresholds;
+  
+}; // end struct CCIP_PM_MAXVR
+CASSERT(sizeof(struct CCIP_FME_DFL_PM) == (8* 3));
+
+///============================================================================
+/// Name: CCIP_FME_DFL_FPMON
+/// @brief   FPGA Management Engine Performance Monitor Feature
+///  Feature ID: 0x3
+///  Feature Type: = Private
+///  Feature Revision: 0
+///============================================================================
+struct CCIP_FME_DFL_FPMON {
+
+   //Performance Fabric control Header
+   struct CCIP_DFH ccip_fme_fpmon_dflhdr;
+
+   // FPGA performance counters
+   struct CCIP_FPMON_CH_CTL {
+
+      union {
+         btUnsigned64bitInt csr;
+         struct {
+            btUnsigned64bitInt rsvd2 :8;           // Reserved
+            btUnsigned64bitInt freeze :1;          // Freeze
+            btUnsigned64bitInt rsvd1 :7;           // Reserved
+            btUnsigned64bitInt cache_event :4;     // Cache Event code
+            btUnsigned64bitInt cci_chsel :1;       // CCI channel selection
+            btUnsigned64bitInt rsvd :43;           // Reserved
+         }; // end struct
+      }; // end union
+
+   }ccip_fpmon_ch_ctl; // end struct CCIP_FPMON_CH_CTL
+
+   // FPGA  Cache port0
+   struct CCIP_FPMON_CH_CTR_0 {
+
+      union {
+         btUnsigned64bitInt csr;
+         struct {
+            btUnsigned64bitInt cache_counter : 48;    // Cache counter
+            btUnsigned64bitInt rsvd : 12;             // Reserved
+            btUnsigned64bitInt event_code : 4;        // Event code
+         }; // end struct
+      }; // end union
+
+   }ccip_fpmon_ch_ctr_0; // end CIP_FPMON_CH_CTR_0
+
+   // FPGA Cache port1
+   struct CCIP_FPMON_CH_CTR_1 {
+
+      union {
+         btUnsigned64bitInt csr;
+         struct {
+            btUnsigned64bitInt cache_counter : 48;    // Cache counter
+            btUnsigned64bitInt rsvd : 12;             // Reserved
+            btUnsigned64bitInt event_code : 4;        // Event Code
+         }; // end struct
+      }; // end union
+
+   }ccip_fpmon_ch_ctr_1; // end struct CCIP_FPMON_CH_CTR_1
+
+   // FPGA  Fabric control
+   struct CCIP_FPMON_FAB_CTL {
+
+      union {
+         btUnsigned64bitInt csr;
+         struct {
+            btUnsigned64bitInt rsvd3 :8;                 // Reserved
+            btUnsigned64bitInt freeze :1;                // Freeze
+            btUnsigned64bitInt rsvd2 :7;                 // Reserved
+            btUnsigned64bitInt fabric_evt_code :4;       // Fabric Event Code
+            btUnsigned64bitInt port_id :2;               // CCI-P Port ID
+            btUnsigned64bitInt rsvd1 :1;                 // Reserved
+            btUnsigned64bitInt ccip_port_filter :1;      // CCI-P Port Filter enable /disable
+            btUnsigned64bitInt rsvd :40;                 // Reserved
+         }; // end stuct
+      }; // end unon
+
+   }ccip_fpmon_fab_ctl; // end struct CCIP_FPMON_FAB_CTL
+
+   // FPGA  Fabric control
+   struct CCIP_FPMON_FAB_CTR {
+
+      union {
+         btUnsigned64bitInt csr;
+         struct {
+            btUnsigned64bitInt fabric_counter : 60;   // Fabric event counter
+            btUnsigned64bitInt event_code : 4;        // Event code
+         }; // end struct
+      }; //end union
+
+   }ccip_fpmon_fab_ctr; //end struct CCIP_FPMON_FAB_CTR
+
+   // FPGA  Fabric control
+   struct CCIP_FPMON_CLK_CTRS {
+
+      union {
+         btUnsigned64bitInt csr;
+         struct {
+            btUnsigned64bitInt afu_interf_clock :64;     // AFU interface clock
+         }; // end struct
+      }; //end union
+
+
+   }ccip_fpmon_clk_ctrs; // end struct CCIP_FPMON_CLK_CTRS
+
+   // FPGA  VTD control
+   struct CCIP_FPMON_VTD_CTL {
+
+      union {
+         btUnsigned64bitInt csr;
+         struct {
+            btUnsigned64bitInt rsvd : 8;              // Reserved
+            btUnsigned64bitInt freeze : 1;            // Freeze and un freeze
+            btUnsigned64bitInt rsvd1 : 7;             // Reserved
+            btUnsigned64bitInt vtd_evtcode : 4;       // VTD Event code
+            btUnsigned64bitInt rsvd3 : 44;            // Reserved
+         }; // end struct
+      }; //end union
+
+   }ccip_fpmon_vtd_ctl; //end struct CCIP_FPMON_VTD_CTL
+
+   // FPGA  VTD counter
+   struct CCIP_FPMON_VTD_CTR {
+
+      union {
+         btUnsigned64bitInt csr;
+         struct {
+            btUnsigned64bitInt vtd_counter : 48;      // vt-d event counter
+            btUnsigned64bitInt rsvd : 12;             // Reserved
+            btUnsigned64bitInt event_code : 4;        // Event code
+         }; // end struct
+      }; //end union
+
+   }ccip_fpmon_vtd_ctr; //end struct CCIP_FPMON_VTD_CTR
+};
+CASSERT(sizeof(struct CCIP_FME_DFL_FPMON) == (9*8));
+
+// FME Errors
+
+struct CCIP_FME_ERROR0 {
+
+   union {
+      btUnsigned64bitInt csr;
+      struct {
+         btUnsigned64bitInt fabric_err :1;               // Fabric error
+         btUnsigned64bitInt fabFifo_uoflow :1;           // Fabric fifo underflow overflow
+         btUnsigned64bitInt pcie0_poison_detected :1;    // PCIe0 Poison Detected
+         btUnsigned64bitInt pcie1_poison_detected :1;    // PCIE1 Poison Detected
+         btUnsigned64bitInt iommu_parity_error :1;       // IOMMU Parity Error
+         btUnsigned64bitInt afuerr_access_mismatch :1;   // AFU error mismatch
+         btUnsigned64bitInt mbp_event :1;                // MBP Event
+         btUnsigned64bitInt rsvd :57;                    // Reserved
+      }; // end struct
+   }; // end union
+
+}; // end struct CCIP_FME_ERROR
+CASSERT(sizeof(struct CCIP_FME_ERROR0) == (1 *8));
+
+
+struct CCIP_FME_PCIE0_ERROR {
+
+   union {
+      btUnsigned64bitInt csr;
+      struct {
+         btUnsigned64bitInt formattype_err :1;              // TLP Format/type error
+         btUnsigned64bitInt MWAddr_err :1;                  // TLP MW Address error
+         btUnsigned64bitInt MWAddrLength_err :1;            // TLP MW Length error
+         btUnsigned64bitInt MRAddr_err :1;                  // TLP MR Address error
+         btUnsigned64bitInt MRAddrLength_err :1;            // TLP MR Length error
+         btUnsigned64bitInt cpl_tag_err :1;                 // TLP CPL TAP error
+         btUnsigned64bitInt cpl_status_err :1;              // TLP CPL status error
+         btUnsigned64bitInt cpl_timeout_err :1;             // TLP CPL Timeout error
+         btUnsigned64bitInt rsvd :54;                       // Reserved
+
+         btUnsigned64bitInt vfnumb_err :1;                  // VF number error
+         btUnsigned64bitInt funct_type_err :1;              // PF or VF error
+
+      }; // end struct
+   }; // end union
+
+}; // end struct CCIP_FME_PCIE0_ERROR
+CASSERT(sizeof(struct CCIP_FME_PCIE0_ERROR) == (1 *8));
+
+
+struct CCIP_FME_PCIE1_ERROR {
+
+   union {
+      btUnsigned64bitInt csr;
+      struct {
+         btUnsigned64bitInt formattype_err :1;              // TLP Format/type error
+         btUnsigned64bitInt MWAddr_err :1;                  // TLP MW Address error
+         btUnsigned64bitInt MWAddrLength_err :1;            // TLP MW Length error
+         btUnsigned64bitInt MRAddr_err :1;                  // TLP MR Address error
+         btUnsigned64bitInt MRAddrLength_err :1;            // TLP MR Length error
+         btUnsigned64bitInt cpl_tag_err :1;                 // TLP CPL TAP error
+         btUnsigned64bitInt cpl_status_err :1;              // TLP CPL status error
+         btUnsigned64bitInt cpl_timeout_err :1;             // TLP CPL Timeout error
+         btUnsigned64bitInt rsvd :56;                       // Reserved
+      }; // end struct
+   }; // end union
+
+}; // end struct CCIP_FME_PCIE1_ERROR
+CASSERT(sizeof(struct CCIP_FME_PCIE1_ERROR) == (1 *8));
+
+struct CCIP_FME_FIRST_ERROR {
+
+   union {
+      btUnsigned64bitInt csr;
+      struct {
+         btUnsigned64bitInt err_reg_status :60;          // Error Register trigger bit
+         btUnsigned64bitInt errReg_id :4;                // Error Register trigger first
+      }; // end struct
+   }; // end union
+
+}; // end struct CCIP_FME_ERROR
+CASSERT(sizeof(struct CCIP_FME_FIRST_ERROR) == (1 *8));
+
+struct CCIP_FME_NEXT_ERROR {
+
+   union {
+      btUnsigned64bitInt csr;
+      struct {
+         btUnsigned64bitInt err_reg_status :60;          // Error Register trigger bit
+         btUnsigned64bitInt errReg_id :4;                // Error Register trigger first
+      }; // end struct
+   }; // end union
+
+}; // end struct CCIP_FME_ERROR
+CASSERT(sizeof(struct CCIP_FME_NEXT_ERROR) == (1 *8));
+
+
+
+struct CCIP_FME_RAS_GERROR {
+
+   union {
+      btUnsigned64bitInt csr;
+      struct {
+         btUnsigned64bitInt temp_trash_ap1 :1;                // thremal threshold AP1
+         btUnsigned64bitInt temp_trash_ap2 :1;                // thremal threshold AP2
+         btUnsigned64bitInt pcie_error :1;                    // pcie Error
+         btUnsigned64bitInt afufatal_error :1;                // afu fatal error
+         btUnsigned64bitInt prochot_error :1;                 // proc hot error
+         btUnsigned64bitInt afu_access_mismatch :1;           // afu access PF/VF mismatch
+         btUnsigned64bitInt injected_warn_error :1;           // Injected warning  error
+         btUnsigned64bitInt pcie_poison_error :1;             // PCIe poison port  error
+         btUnsigned64bitInt gb_crc_err :1;                    // Green bitstream CRC Error
+         btUnsigned64bitInt temp_trash_ap6 :1;                // thremal threshold AP6
+         btUnsigned64bitInt power_trash_ap1 :1;               // Power threshold AP1
+         btUnsigned64bitInt power_trash_ap2 :1;               // Power threshold AP6
+         btUnsigned64bitInt mbp_error :1;                     // MBP error Error
+         btUnsigned64bitInt rsvd2 :51;                        // Reserved
+      }; // end struct
+   }; // end union
+
+}; // end struct CCIP_FME_RAS_GERROR
+CASSERT(sizeof(struct CCIP_FME_RAS_GERROR) == (1 *8));
+
+
+struct CCIP_FME_RAS_BERROR {
+
+   union {
+      btUnsigned64bitInt csr;
+      struct {
+         btUnsigned64bitInt ktilink_fatal_err :1;                  // KTI Link layer error detected
+         btUnsigned64bitInt tagcch_fatal_err :1;                   // tag-n-cache error detected
+         btUnsigned64bitInt cci_fatal_err :1;                      // CCI error detected
+         btUnsigned64bitInt ktiprpto_fatal_err :1;                 // KTI Protocol error detected
+         btUnsigned64bitInt dma_fatal_err :1;                      // DMA error detected
+         btUnsigned64bitInt iommu_fatal_err :1;                    // IOMMU detected
+         btUnsigned64bitInt injected_fatal_err :1;                 // Injected fatal error
+         btUnsigned64bitInt rsvd :1;                               // Reserved
+         btUnsigned64bitInt iommu_catast_err :1;                   // Catastrophic IOMMU Error
+         btUnsigned64bitInt crc_catast_err :1;                     // Catastrophic CRC Error
+         btUnsigned64bitInt therm_catast_err :1;                   // Catastrophic Thermal Error
+         btUnsigned64bitInt injected_catast_err :1;                // Catastrophic Thermal Error
+         btUnsigned64bitInt rsvd1 :52;                             // Reserved
+      }; // end struct
+   }; // end union
+
+}; // end struct CCIP_FME_RAS_BERROR
+CASSERT(sizeof(struct CCIP_FME_RAS_BERROR) == (1 *8));
+
+
+struct CCIP_FME_RAS_WARNERROR {
+
+   union {
+      btUnsigned64bitInt csr;
+      struct {
+         btUnsigned64bitInt event_warn_err :1;                  // Green bitstream fatal event
+         btUnsigned64bitInt rsvd :63;                           // Reserved
+      }; // end struct
+   }; // end union
+
+}; // end struct CCIP_FME_RAS_WARNERROR
+CASSERT(sizeof(struct CCIP_FME_RAS_WARNERROR) == (1 *8));
+
+
+struct CCIP_FME_RAS_ERROR_INJ {
+
+   union {
+      btUnsigned64bitInt csr;
+      struct {
+         btUnsigned64bitInt catast_error :1;                  // sets this bit to enact a Catastrophic error
+         btUnsigned64bitInt fatal_error :1;                   // sets this bit to enact a Fatal error
+         btUnsigned64bitInt warning_error :1;                 // sets this bit to enact a Warning error
+         btUnsigned64bitInt rsvd :61;                         // Reserved
+      }; // end struct
+   }; // end union
+
+}; // end struct CCIP_FME_RAS_ERROR_INJ
+CASSERT(sizeof(struct CCIP_FME_RAS_ERROR_INJ) == (1 *8));
+
+///============================================================================
+/// Name: CCIP_FME_DFL_GERROR
+/// @brief   FPGA Management Engine Performance Global Error Feature
+///  Feature ID: 0x4
+///  Feature Type: = Private
+///  Feature Revision: 0
+///============================================================================
+struct CCIP_FME_DFL_GERROR {
+
+   // FME Global Error header
+   struct CCIP_DFH                        ccip_gerror_dflhdr;
+
+   // FME pcie0 error mask
+   struct CCIP_FME_ERROR0                 fme_err_mask;
+
+   // FME pcie0 error
+   struct CCIP_FME_ERROR0                 fme_err;
+
+   // FME pcie0 error mask
+   struct CCIP_FME_PCIE0_ERROR            pcie0_err_mask;
+
+   // FME pcie0 error
+   struct CCIP_FME_PCIE0_ERROR            pcie0_err;
+
+   // FME pcie1 error mask
+   struct CCIP_FME_PCIE1_ERROR            pcie1_err_mask;
+
+   // FME pcie1 error
+   struct CCIP_FME_PCIE1_ERROR            pcie1_err;
+
+   // FME first error
+   struct CCIP_FME_FIRST_ERROR            fme_first_err;
+
+   // FME next error
+   struct CCIP_FME_NEXT_ERROR             fme_next_err;
+
+   // FME RAS Green BS error Mask
+   struct CCIP_FME_RAS_GERROR             ras_gerr_mask;
+
+   // FME RAS Green BS error
+   struct CCIP_FME_RAS_GERROR             ras_gerr;
+
+   // FME RAS blue bitstream error mask
+   struct CCIP_FME_RAS_BERROR             ras_berror_mask;
+
+   // FME RAS blue bitstream error
+   struct CCIP_FME_RAS_BERROR             ras_berror;
+
+   // FME RAS warning error mask
+   struct CCIP_FME_RAS_WARNERROR          ras_warnerror_mask;
+
+   // FME RAS warning error
+   struct CCIP_FME_RAS_WARNERROR          ras_warnerror;
+
+   // FME RAS error injection
+   struct CCIP_FME_RAS_ERROR_INJ          ras_error_inj;
+
+}; //end CCIP_FME_GERROR_feature
+CASSERT(sizeof(struct CCIP_FME_DFL_GERROR) ==(16* 8));
+
+///============================================================================
+/// Name: CCIP_FME_DFL_PR
+/// @brief   FPGA Management Engine Partial Reconfiguration Feature
+///  Feature ID: 0x5
+///  Feature Type: = Private
+///  Feature Revision: 0
+///============================================================================
+
+struct CCIP_FME_PR_KEY {
+
+   union {
+      btUnsigned64bitInt csr;
+      struct {
+         btUnsigned64bitInt key :64;
+      }; // end struct
+   }; // end union
+
+}; // end struct CCIP_FME_PR_KEY
+CASSERT(sizeof(struct CCIP_FME_PR_KEY) == (1 *8));
+
+//Partial Reconfiguration control  CSR
+struct CCIP_FME_PR_CONTROL {
+
+   union {
+      btUnsigned64bitInt csr;
+      struct {
+         btUnsigned64bitInt pr_reset :1;                       // Reset PR Engine
+         btUnsigned64bitInt rsvd3 :3;                          // Reserved
+         btUnsigned64bitInt pr_reset_ack :1;                   // Reset PR Engine Ack
+         btUnsigned64bitInt rsvd4 :3;                          // Reserved
+         btUnsigned64bitInt pr_regionid :2;                    // PR Region ID
+         btUnsigned64bitInt rsvd1 :2;                          // Reserved
+         btUnsigned64bitInt pr_start_req :1;                   // PR Start Request
+         btUnsigned64bitInt pr_push_complete :1;               // PR Data push complete
+         btUnsigned64bitInt pr_kind :1;                        // PR Data push complete
+         btUnsigned64bitInt rsvd :49;                          // Reserved
+      }; // end struct
+   }; //end union
+}; // end struct CCIP_FME_PR_CONTROL
+CASSERT(sizeof(struct CCIP_FME_PR_CONTROL) == (1 *8));
+
+//Partial Reconfiguration Status  CSR
+struct CCIP_FME_PR_STATUS {
+
+   union {
+      btUnsigned64bitInt csr;
+      struct {
+         btUnsigned64bitInt pr_credit :9;                // PR Credits
+         btUnsigned64bitInt rsvd2 :7;                    // Reserved
+         btUnsigned64bitInt pr_status :1;                // PR status
+         btUnsigned64bitInt rsvd :3;                     // Reserved
+         btUnsigned64bitInt pr_contoller_status :3;      // Altra PR Controller Block status
+         btUnsigned64bitInt rsvd1 :1;                    // Reserved
+         btUnsigned64bitInt pr_host_status :4;           // PR Host status
+         btUnsigned64bitInt rsvd3 :36;                   // Reserved
+      }; // end struct
+   }; // end union
+};// end struct CCIP_FME_PR_STATUS
+CASSERT(sizeof(struct CCIP_FME_PR_STATUS) == (1 *8));
+
+//Partial Reconfiguration data  CSR
+struct CCIP_FME_PR_DATA {
+   union {
+      btUnsigned64bitInt csr;
+      struct {
+         btUnsigned64bitInt pr_data_raw :32;             // PR data from the raw binary file
+         btUnsigned64bitInt rsvd :32;                    // Reserved
+      }; // end struct
+   }; // end union
+}; // end struct CCIP_FME_PR_DATA
+CASSERT(sizeof(struct CCIP_FME_PR_DATA) == (1 *8));
+
+
+//Partial Reconfiguration data  CSR
+ struct CCIP_FME_PR_ERROR {
+    union {
+       btUnsigned64bitInt csr;
+       struct {
+          btUnsigned64bitInt PR_operation_err :1;           // Previous errors detected by PR Host
+          btUnsigned64bitInt PR_CRC_err :1;                 // CRC errors detected
+          btUnsigned64bitInt PR_bitstream_err :1;           // InCompatible errors detected
+          btUnsigned64bitInt PR_IP_err :1;                  // PR protocol error
+          btUnsigned64bitInt PR_FIFIO_err :1;               // PR FIFO error
+          btUnsigned64bitInt PR_timeout_err :1;             // PR Timeout error
+          btUnsigned64bitInt PR_secure_load_err :1;         // PR Security error
+          btUnsigned64bitInt rsvd : 57;                     // Reserved
+       }; // end struct
+    }; // end union
+ }; // end struct CCIP_FME_PR_ERROR
+ CASSERT(sizeof(struct CCIP_FME_PR_ERROR) == (1 *8));
+
+struct CCIP_FME_DFL_PR {
+
+   // FME PR device feature header
+   struct CCIP_DFH                 ccip_pr_dflhdr;
+
+   //Partial Reconfiguration control  CSR
+   struct CCIP_FME_PR_CONTROL      ccip_fme_pr_control;
+
+   //Partial Reconfiguration Status  CSR
+   struct CCIP_FME_PR_STATUS       ccip_fme_pr_status;
+
+   //Partial Reconfiguration data  CSR
+   struct CCIP_FME_PR_DATA         ccip_fme_pr_data;
+
+   //Partial Reconfiguration data  CSR
+   struct CCIP_FME_PR_ERROR        ccip_fme_pr_err;
+
+   // FME PR Publish HASH
+   struct CCIP_FME_PR_KEY fme_pr_pub_harsh0 ;
+   struct CCIP_FME_PR_KEY fme_pr_pub_harsh1 ;
+   struct CCIP_FME_PR_KEY fme_pr_pub_harsh2 ;
+   struct CCIP_FME_PR_KEY fme_pr_pub_harsh3 ;
+
+   // FME PR Private HASH
+   struct CCIP_FME_PR_KEY fme_pr_priv_harsh0 ;
+   struct CCIP_FME_PR_KEY fme_pr_priv_harsh1 ;
+   struct CCIP_FME_PR_KEY fme_pr_priv_harsh2 ;
+   struct CCIP_FME_PR_KEY fme_pr_priv_harsh3 ;
+
+   // FME PR License
+   struct CCIP_FME_PR_KEY fme_pr_license0 ;
+   struct CCIP_FME_PR_KEY fme_pr_license1 ;
+   struct CCIP_FME_PR_KEY fme_pr_license2 ;
+   struct CCIP_FME_PR_KEY fme_pr_license3 ;
+
+   // FME PR Session Key
+   struct CCIP_FME_PR_KEY fme_pr_seskey0 ;
+   struct CCIP_FME_PR_KEY fme_pr_seskey1 ;
+   struct CCIP_FME_PR_KEY fme_pr_seskey2 ;
+   struct CCIP_FME_PR_KEY fme_pr_seskey3 ;
+
+   // PR Interface ID
+   struct CCIP_FME_PR_KEY fme_pr_intfc_id0_l;
+   struct CCIP_FME_PR_KEY fme_pr_intfc_id0_h;
+
+   struct CCIP_FME_PR_KEY fme_pr_intfc_id1_l;
+   struct CCIP_FME_PR_KEY fme_pr_intfc_id1_h ;
+
+   struct CCIP_FME_PR_KEY fme_pr_intfc_id2_l;
+   struct CCIP_FME_PR_KEY fme_pr_intfc_id2_h ;
+
+   struct CCIP_FME_PR_KEY fme_pr_intfc_id3_l;
+   struct CCIP_FME_PR_KEY fme_pr_intfc_id3_h ;
+
+}; //end struct  CCIP_FME_GERROR_feature
+CASSERT(sizeof(struct CCIP_FME_DFL_PR) ==(29* 8));
+
+/******************************************************************************
+ *  FPGA port header
+ *  Type  = afu
+ *  CCI-P version =0x1
+ *  CCI-P minor version =0x0
+ *  Header Description:
+ *
+ ******************************************************************************/
+
+struct CCIP_USER_CLK_FREQ {
+
+   union {
+      btUnsigned64bitInt csr;
+      struct {
+         btUnsigned64bitInt usr_clk_frq :64;
+
+      }; // end struct
+   }; // end union
+
+}; // end struct CCIP_USER_CLK_FREQ
+CASSERT(sizeof(struct CCIP_USER_CLK_FREQ) == (1 *8));
+
+
+// Port status
+struct CCIP_PORT_STATUS {
+   union {
+      btUnsigned64bitInt csr;
+      struct {
+         btUnsigned64bitInt port_freeze :1;           // Port freeze
+         btUnsigned64bitInt rsvd1 :7;                 // Reserved
+         btUnsigned64bitInt afu_pwr_state :4;         // Reports AFU Power state
+         btUnsigned64bitInt ap1_event :1;             // AP1 event
+         btUnsigned64bitInt ap2_event :1;             // AP2 event
+         btUnsigned64bitInt rsvd :46;                 // Reserved
+      }; // end struct
+   }; // end union
+
+}; // end struct CCIP_PORT_STATUS
+CASSERT(sizeof(struct CCIP_PORT_STATUS) == (1 *8));
+
+// Port status
+struct CCIP_PORT_HDR {
+
+   // port  header
+   struct CCIP_DFH                  ccip_port_dfh;
+
+   // Port afu id  low
+   struct CCIP_AFU_ID_L             ccip_port_afuidl;
+
+   // Port afu id  low
+   struct CCIP_AFU_ID_H             ccip_port_afuidh;
+
+   // Next AFU offset
+   struct CCIP_NEXT_AFU             ccip_port_next_afu;
+
+   // Reserved
+   btUnsigned64bitInt               rsvd_porthdr;
+
+   // Port Scratch pad
+   struct CCIP_SCRATCHPAD           ccip_port_scratchpad;
+
+   //  Port scratch pad
+   struct CCIP_PORT_CAPABILITY {
+
+      union {
+         btUnsigned64bitInt csr;
+         struct {
+            btUnsigned64bitInt port_id :2;         // CCI-P port ID
+            btUnsigned64bitInt rsvd1 :6;           // Reserved
+            btUnsigned64bitInt mmio_size :16;      // MMIO size
+            btUnsigned64bitInt rsvd3 :8;           // Reserved
+            btUnsigned64bitInt interrupts :4;      //Interrupts supported
+            btUnsigned64bitInt rsvd :28;           // Reserved
+         }; // end struct
+      }; // end union
+
+   }ccip_port_capability; // end  CCIP_PORT_CAPABILITY
+
+   // Port control
+   struct CCIP_PORT_CONTROL {
+      union {
+         btUnsigned64bitInt csr;
+         struct {
+            btUnsigned64bitInt port_sftreset_control :1;       // port soft reset control
+            btUnsigned64bitInt rsvd1 :1;                       // Reserved
+            btUnsigned64bitInt afu_latny_rep :1;               // AFU Latency Tolerance Reorting
+            btUnsigned64bitInt rsvd2 :1;                       // Reserved
+            btUnsigned64bitInt ccip_outstanding_request :1;    // NO outstanding CCI-P requests, set to 1
+            btUnsigned64bitInt rsvd :59;                       // Reserved
+         }; // end struct
+      }; // end union
+
+   }ccip_port_control; // end struct CCIP_PORT_CONTROL
+
+   // Port status
+   struct CCIP_PORT_STATUS ccip_port_status;
+
+   // Reserved
+   btUnsigned64bitInt port_rsvd1_hdr;
+
+   struct CCIP_USER_CLK_FREQ user_clk_freq_cmd0;
+   struct CCIP_USER_CLK_FREQ user_clk_freq_cmd1;
+
+   struct CCIP_USER_CLK_FREQ user_clk_freq_sts0;
+   struct CCIP_USER_CLK_FREQ user_clk_freq_sts1;
+
+}; // end struct CCIP_FME_HDR
+CASSERT(sizeof(struct CCIP_PORT_HDR) == (14 *8));
+
+
+/******************************************************************************
+ *  64-bit FPGA Port Error  Feature List
+ *  Feature ID =0x10
+ *  Feature Description Port Error Management
+ *  Feature Type = Private
+ *  offset 0x40 bytes form Device Feature Header
+ ******************************************************************************/
+
+// CCIP Port Error CSR
+struct CCIP_PORT_ERROR {
+      union {
+         btUnsigned64bitInt csr;
+         struct {
+            btUnsigned64bitInt tx_ch0_overflow :1;             // Tx Channel0 : Overflow
+            btUnsigned64bitInt tx_ch0_invalidreq :1;           // Tx Channel0 : Invalid request encoding
+            btUnsigned64bitInt tx_ch0_req_cl_len3 :1;          // Tx Channel0 : Request with cl_len=3
+            btUnsigned64bitInt tx_ch0_req_cl_len2 :1;          // Tx Channel0 : Request with cl_len=2
+            btUnsigned64bitInt tx_ch0_req_cl_len4 :1;          // Tx Channel0 : Request with cl_len=4
+
+            btUnsigned64bitInt rsvd :4;                        // Reserved
+            btUnsigned64bitInt afummio_rdrecv_portreset :1;    // AFU MMIO RD received while PORT is in reset
+            btUnsigned64bitInt afummio_wrrecv_portreset :1;    // AFU MMIO WR received while PORT is in reset
+            btUnsigned64bitInt rsvd5 :5;                       // Reserved
+
+            btUnsigned64bitInt tx_ch1_overflow :1;             // Tx Channel1 : Overflow
+            btUnsigned64bitInt tx_ch1_invalidreq :1;           // Tx Channel1 : Invalid request encoding
+            btUnsigned64bitInt tx_ch1_req_cl_len3 :1;          // Tx Channel1 : Request with cl_len=3
+            btUnsigned64bitInt tx_ch1_req_cl_len2 :1;          // Tx Channel1 : Request with cl_len=2
+            btUnsigned64bitInt tx_ch1_req_cl_len4 :1;          // Tx Channel1 : Request with cl_len=4
+
+            btUnsigned64bitInt tx_ch1_insuff_datapayload :1;   // Tx Channel1 : Insufficient data payload
+            btUnsigned64bitInt tx_ch1_datapayload_overrun:1;   // Tx Channel1 : Data payload overrun
+            btUnsigned64bitInt tx_ch1_incorr_addr  :1;         // Tx Channel1 : Incorrect address
+            btUnsigned64bitInt tx_ch1_sop_detcted  :1;         // Tx Channel1 : NON-Zero SOP Detected
+            btUnsigned64bitInt rsvd1 :7;                       // Reserved
+
+            btUnsigned64bitInt mmioread_timeout :1;            // MMIO Read Timeout in AFU
+            btUnsigned64bitInt tx_ch2_fifo_overflow :1;        // Tx Channel2 : FIFO overflow
+            btUnsigned64bitInt unexp_mmio_resp :1;             // MMIO read is not matching pending request
+
+            btUnsigned64bitInt rsvd2 :5;                       // Reserved
+
+            btUnsigned64bitInt num_pending_req_overflow :1;    // Number of pending Requests: counter overflow
+            btUnsigned64bitInt llpr_smrr_err :1;               // Request with Address violating SMM Range
+            btUnsigned64bitInt llpr_smrr2_err :1;              // Request with Address violating second SMM Range
+            btUnsigned64bitInt llpr_mesg_err :1;               // Request with Address violating ME Stolen message
+            btUnsigned64bitInt genport_range_err :1;           // Request with Address violating Generic protect range
+            btUnsigned64bitInt legrange_low_err :1;            // Request with Address violating Legacy Range low
+            btUnsigned64bitInt legrange_hight_err :1;          // Request with Address violating Legacy Range High
+            btUnsigned64bitInt vgmem_range_err :1;             // Request with Address violating VGA memory range
+            btUnsigned64bitInt page_fault_err :1;              // Page fault
+            btUnsigned64bitInt pmr_err :1;                     // PMR Error
+            btUnsigned64bitInt ap6_event :1;                   // AP6 event
+            btUnsigned64bitInt vfflr_accesseror:1;             // VF FLR detected on Port with PF access control.
+
+            btUnsigned64bitInt rsvd3 :12;                      // Reserved
+         }; // end struct
+      }; // end union
+
+};
+CASSERT(sizeof(struct CCIP_PORT_ERROR) == (1 *8));
+
+
+struct CCIP_PORT_DFL_ERR {
+
+   // Port Error Header
+   struct CCIP_DFH                  ccip_port_err_dflhdr;
+
+   // Port error Mask
+   struct CCIP_PORT_ERROR           ccip_port_error_mask;
+
+   //Port Error
+   struct CCIP_PORT_ERROR           ccip_port_error;
+
+   //Port First Error
+   struct CCIP_PORT_ERROR           ccip_port_first_error;
+
+   // port malformed request0
+   struct CCIP_PORT_MALFORMED_REQ_0 {
+
+      union {
+         btUnsigned64bitInt csr;
+         struct {
+            btUnsigned64bitInt malfrd_req_lsb :64;    // LSB header bit first malformed request
+         }; // end struct
+      }; // end union
+
+   }ccip_port_malformed_req_0; // end struct CCIP_PORT_MALFORMED_REQ_0
+
+   // port  malformed request1
+   struct CCIP_PORT_MALFORMED_REQ_1 {
+
+      union {
+         btUnsigned64bitInt csr;
+         struct {
+            btUnsigned64bitInt malfrd_req_msb :64;    // MSB header bit first malformed request
+         }; // end struct
+      }; // end union
+
+   }ccip_port_malformed_req_1;  // end struct CCIP_PORT_MALFORMED_REQ_1
+
+   // Port Debug
+   struct CCIP_PORT_DEBUG {
+
+      union {
+         btUnsigned64bitInt csr;
+         struct {
+            btUnsigned64bitInt port_debug :64;    // port debug register
+         }; // end struct
+      }; // end union
+
+   }ccip_port_debug;  // end struct CCIP_PORT_DEBUG
+
+
+}; // end struct CCIP_PORT_DFL_ERR
+CASSERT(sizeof(struct CCIP_PORT_DFL_ERR ) == (7 *8));
+
+/******************************************************************************
+ *  FPGA Port USMG Feature
+ *  Feature ID =0x11
+ *  Feature Description Port USMG
+ *  Feature Type = Private
+ *
+ ******************************************************************************/
+struct CCIP_PORT_DFL_UMSG {
+
+   // Port usmg Header
+   struct CCIP_DFH ccip_port_umsg_dflhdr;
+
+   // umsg capability
+   struct CCIP_UMSG_CAPABILITY {
+
+      union {
+         btUnsigned64bitInt csr;
+         struct {
+            btUnsigned64bitInt no_umsg_alloc_port :8;    // number of umsg allocated to this port
+            btUnsigned64bitInt status_umsg_engine :1;    // enable umsg engine for this ort 1-enable 0-disable
+            btUnsigned64bitInt umsg_init_status :1;      // usmg initialization status
+            btUnsigned64bitInt umsg_trans_error :1;      // IOMMU not able to translate of the umsg base address
+            btUnsigned64bitInt rsvd :53;                 // Reserved
+         }; // end struct
+      }; // end union
+
+   }ccip_umsg_capability; // end struct CCIP_UMSG_CAPABILITY
+
+
+   // umsg base address
+   struct CCIP_UMSG_BASE_ADDRESS {
+
+      union {
+         btUnsigned64bitInt csr;
+         struct {
+            btUnsigned64bitInt umsg_base_address :48;    // UMAS segment start physical byte address
+            btUnsigned64bitInt rsvd :16;                 // Reserved
+
+         }; // end struct
+      }; // end union
+
+   }ccip_umsg_base_address; // end struct CCIP_UMSG_BASE_ADDRESS
+
+
+   // umsg mode
+   struct CCIP_UMSG_MODE {
+
+      union {
+         btUnsigned64bitInt csr;
+         struct {
+            btUnsigned64bitInt umsg_hit :8;          // UMSG hit enable / disable
+            btUnsigned64bitInt rsvd :56;             // Reserved
+         }; // ens struct
+      }; // end union
+
+   }ccip_umsg_mode; // end struct CCIP_UMSG_MODE
+
+
+}; // end struct CCIP_PORT_UMSG_feature
+CASSERT(sizeof(struct CCIP_PORT_DFL_UMSG) == (4 *8));
+
+
+/******************************************************************************
+ *  64-bit FPGA Port/afu Partial Reconfiguration Feature list
+ *  Feature ID =0x12
+ *  Feature Description Port/ AFU partial reconfiguration
+ *  Feature Type = Private
+ *
+ ******************************************************************************/
+struct CCIP_PORT_DFL_PR {
+
+   // Port usmg Header
+   struct CCIP_DFH ccip_port_pr_dflhdr;
+
+   // Partial Receconfiguration Control
+   struct CCIP_PORT_PR_CONTROL {
+
+      union {
+         btUnsigned64bitInt csr;
+         struct {
+            btUnsigned64bitInt pr_start_req :1; // PR start Request
+            btUnsigned64bitInt rsvd :63;
+         }; // end struct
+      }; // end union
+
+   }ccip_port_pr_control; // end struct CCIP_PORT_PR_CONTROL
+
+
+   // Partial Reconfiguration status
+   struct CCIP_PORT_PR_STATUS {
+      union {
+         btUnsigned64bitInt csr;
+         struct {
+            btUnsigned64bitInt pr_credit :9;             // Credits
+            btUnsigned64bitInt rsvd2 :3;                 // Reserved
+            btUnsigned64bitInt pr_acces_grant :1;        // PR access Grant
+            btUnsigned64bitInt pr_access :1;             // PR access enabled
+            btUnsigned64bitInt rsvd3 :2;                 // Reserved
+            btUnsigned64bitInt pr_timeout_error :1;      // PR port timeout error
+            btUnsigned64bitInt pr_engine_error :1;       // PR Engine error
+            btUnsigned64bitInt pr_data_ovrferr :1;       // PR data overfow error
+            btUnsigned64bitInt rsvd4 :1;                 // Reserved
+            btUnsigned64bitInt pr_mega_fstatus :3;       // Altra PR Mega-function status
+            btUnsigned64bitInt rsvd1 :1;                 // Reserved
+            btUnsigned64bitInt pr_status :4;             // PR Status
+            btUnsigned64bitInt rsvd :35;                 // Reserved
+         }; // end struct
+      };  // end union
+
+   }ccip_port_pr_status; // end struct CCIP_PORT_PR_STATUS
+
+   // Partial Receconfiguration Data
+   struct CCIP_PORT_PR_DATA {
+
+      union {
+         btUnsigned64bitInt csr;
+         struct {
+            btUnsigned64bitInt pr_data_raw :32;          // PR data from the raw-binary file
+            btUnsigned64bitInt rsvd :32;                 // Reserved
+         }; // end struct
+      }; // end union
+
+   }ccip_port_pr_data; // end struct CCIP_PORT_PR_DATA
+
+   struct CCIP_PORT_PR_PBUDGET {
+
+      union {
+         btUnsigned64bitInt csr;
+         struct {
+            btUnsigned64bitInt pwr_format :48;           // AFU Power budget format
+            btUnsigned64bitInt rsvd :16;                 // Reserved
+
+         }; // end struct
+      }; // end union
+
+   }ccip_port_pr_pbudget; // end struct CCIP_PORT_PR_PBUDGET
+
+
+   // User Clock Frequency
+   struct CCIP_USR_CLK_FREQ {
+
+      union {
+         btUnsigned64bitInt csr;
+         struct {
+            btUnsigned64bitInt rsvd :64;                   // Reserved
+         }; // end union
+      }; // end stuct
+
+   }ccip_usr_clk_freq; // end struct CCIP_USR_CLK_FREQ
+
+
+}; // end struct CCIP_PORT_UMSG_feature
+CASSERT(sizeof(struct CCIP_PORT_DFL_PR) == (6 *8));
+
+
+/******************************************************************************
+ *  FPGA Port signal tap  feature list
+ *  Feature ID =0x13
+ *  Feature Description Port signal Tap
+ *  Feature Type = Private
+ *
+ ******************************************************************************/
+
+
+// Port Signal Tap Error
+struct CCIP_PORT_STAP_ERROR {
+   union {
+      btUnsigned64bitInt csr;
+      struct {
+         btUnsigned64bitInt rw_timeout :1;             // SLD HUB end-point read/write timeout.
+         btUnsigned64bitInt stp_inreset :1;            // Remote SignalTap in Reset/ disabled .
+         btUnsigned64bitInt unsupport_read :1;         // Unsupported Read
+         btUnsigned64bitInt mmio_timeout :1;           // MMIO timeout detected
+         btUnsigned64bitInt txffio_count :4;           // Tx FFIO count
+         btUnsigned64bitInt rxffio_count :4;           // Rx FFIO count
+         btUnsigned64bitInt txffio_overflow :4;        // Tx FFIO overflow
+         btUnsigned64bitInt txffio_underflow :4;       // Tx FFIO underflow
+         btUnsigned64bitInt rxffio_overflow :4;        // Rx FFIO overflow
+         btUnsigned64bitInt rxffio_underflow :4;       // Rx FFIO underflow
+         btUnsigned64bitInt num_mmiowr :12;            // Number of MMIO Writes
+         btUnsigned64bitInt num_mmioreq :12;           // Number of MMIO Reads
+         btUnsigned64bitInt num_mmioresp :12;          // Number of MMIO Responses
+
+      }; // end struct
+   }; // end union
+
+}; // end struct CCIP_PORT_STAP_ERROR
+CASSERT(sizeof(struct CCIP_PORT_STAP_ERROR) == (1 *8));
+
+struct CCIP_PORT_DFL_STAP {
+
+   // Port usmg Header
+   struct CCIP_DFH ccip_port_stap_dflhdr;
+
+   // Remote Signal Tap Error
+   struct CCIP_PORT_STAP_ERROR stap_error;
+
+}; // end struct CCIP_PORT_STAP
+CASSERT(sizeof(struct CCIP_PORT_DFL_STAP) == (2*8));
+
+
+/******************************************************************************
+ *  FPGA AFU Header
+ *  Feature ID = AFU
+ *  Feature Description: AFU header
+ *  Feature Type = Private
+ *
+ ******************************************************************************/
+struct CCIP_AFU_Header {
+
+   // FME  Header
+   struct CCIP_DFH  ccip_dfh;
+
+   // FME afu id  low
+   struct CCIP_AFU_ID_L ccip_afu_id_l;
+
+   // FME afu id  low
+   struct CCIP_AFU_ID_H  ccip_afu_id_h;
+
+   // Next AFU offset
+   struct CCIP_NEXT_AFU  ccip_next_afu;
+} ;
+CASSERT(sizeof(struct CCIP_AFU_Header) == (4*8));
+
+
+/// @} group aalkernel_ccip
+
+
+
+END_NAMESPACE(AAL)
+
+#endif /* __AALKERNEL_CCIP_SIM_DEF_H_ */
diff --git a/drivers/fpga/aal/include/aalsdk/kernel/ccipdriver.h b/drivers/fpga/aal/include/aalsdk/kernel/ccipdriver.h
new file mode 100644
index 000000000000..cb78746155ef
--- /dev/null
+++ b/drivers/fpga/aal/include/aalsdk/kernel/ccipdriver.h
@@ -0,0 +1,632 @@
+//******************************************************************************
+// This  file  is  provided  under  a  dual BSD/GPLv2  license.  When using or
+//         redistributing this file, you may do so under either license.
+//
+//                            GPL LICENSE SUMMARY
+//
+//  Copyright(c) 2015-2017, Intel Corporation.
+//
+//  This program  is  free software;  you  can redistribute it  and/or  modify
+//  it  under  the  terms of  version 2 of  the GNU General Public License  as
+//  published by the Free Software Foundation.
+//
+//  This  program  is distributed  in the  hope that it  will  be useful,  but
+//  WITHOUT   ANY   WARRANTY;   without   even  the   implied   warranty    of
+//  MERCHANTABILITY  or  FITNESS  FOR  A  PARTICULAR  PURPOSE.  See  the   GNU
+//  General Public License for more details.
+//
+//  The  full  GNU  General Public License is  included in  this  distribution
+//  in the file called README.GPLV2-LICENSE.TXT.
+//
+//  Contact Information:
+//  Henry Mitchel, henry.mitchel at intel.com
+//  77 Reed Rd., Hudson, MA  01749
+//
+//                                BSD LICENSE
+//
+//  Copyright(c) 2015-2017, Intel Corporation.
+//
+//  Redistribution and  use  in source  and  binary  forms,  with  or  without
+//  modification,  are   permitted  provided  that  the  following  conditions
+//  are met:
+//
+//    * Redistributions  of  source  code  must  retain  the  above  copyright
+//      notice, this list of conditions and the following disclaimer.
+//    * Redistributions in  binary form  must  reproduce  the  above copyright
+//      notice,  this  list of  conditions  and  the  following disclaimer  in
+//      the   documentation   and/or   other   materials   provided  with  the
+//      distribution.
+//    * Neither   the  name   of  Intel  Corporation  nor  the  names  of  its
+//      contributors  may  be  used  to  endorse  or promote  products derived
+//      from this software without specific prior written permission.
+//
+//  THIS  SOFTWARE  IS  PROVIDED  BY  THE  COPYRIGHT HOLDERS  AND CONTRIBUTORS
+//  "AS IS"  AND  ANY  EXPRESS  OR  IMPLIED  WARRANTIES,  INCLUDING,  BUT  NOT
+//  LIMITED  TO, THE  IMPLIED WARRANTIES OF  MERCHANTABILITY  AND FITNESS  FOR
+//  A  PARTICULAR  PURPOSE  ARE  DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT
+//  OWNER OR CONTRIBUTORS BE LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,
+//  SPECIAL,  EXEMPLARY,  OR  CONSEQUENTIAL   DAMAGES  (INCLUDING,   BUT   NOT
+//  LIMITED  TO,  PROCUREMENT  OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF USE,
+//  DATA,  OR PROFITS;  OR BUSINESS INTERRUPTION)  HOWEVER  CAUSED  AND ON ANY
+//  THEORY  OF  LIABILITY,  WHETHER  IN  CONTRACT,  STRICT LIABILITY,  OR TORT
+//  (INCLUDING  NEGLIGENCE  OR OTHERWISE) ARISING  IN ANY WAY  OUT  OF THE USE
+//  OF  THIS  SOFTWARE, EVEN IF ADVISED  OF  THE  POSSIBILITY  OF SUCH DAMAGE.
+//******************************************************************************
+//****************************************************************************
+//        FILE: ccipdriver.h
+//     CREATED: Nov. 2, 2015
+//      AUTHOR: Joseph Grecco, Intel  <joe.grecco@intel.com>
+//
+// PURPOSE: Definitions for the CCIP device driver
+// HISTORY:
+// COMMENTS:
+// WHEN:          WHO:     WHAT:
+// 11/02/15       JG       Initial version.
+//****************************************************************************
+#ifndef __AALSDK_CCIP_DRIVER_H__
+#define __AALSDK_CCIP_DRIVER_H__
+#include <aalsdk/kernel/AALWorkspace.h>
+#include <aalsdk/kernel/AALTransactionID_s.h>
+
+BEGIN_NAMESPACE(AAL)
+
+BEGIN_C_DECLS
+
+
+//-----------------------------------------------------------------------------
+// Request message IDs
+//-----------------------------------------------------------------------------
+typedef enum
+{
+   uid_errnumOK = 0,
+   uid_errnumBadDevHandle,                       // 1
+   uid_errnumCouldNotClaimDevice,                // 2
+   uid_errnumNoAppropriateInterface,             // 3
+   uid_errnumDeviceHasNoPIPAssigned,             // 4
+   uid_errnumCouldNotBindPipInterface,           // 5
+   uid_errnumCouldNotUnBindPipInterface,         // 6
+   uid_errnumNotDeviceOwner,                     // 7
+   uid_errnumSystem,                             // 8
+   uid_errnumAFUTransaction,                     // 9
+   uid_errnumAFUTransactionNotFound,             // 10
+   uid_errnumDuplicateStartingAFUTransactionID,  // 11
+   uid_errnumBadParameter,                       // 12
+   uid_errnumNoMem,                              // 13
+   uid_errnumNoMap,                              // 14
+   uid_errnumBadMapping,                         // 15
+   uid_errnumPermission,                         // 16
+   uid_errnumInvalidOpOnMAFU,                    // 17
+   uid_errnumPointerOutOfWorkspace,              // 18
+   uid_errnumNoAFUBindToChannel,                 // 19
+   uid_errnumCopyFromUser,                       // 20
+   uid_errnumDescArrayEmpty,                     // 21
+   uid_errnumCouldNotCreate,                     // 22
+   uid_errnumInvalidRequest,                     // 23
+   uid_errnumInvalidDeviceAddr,                  // 24
+   uid_errnumCouldNotDestroy,                    // 25
+   uid_errnumDeviceBusy,                         // 26
+   uid_errnumTimeout,                            // 27
+   uid_errnumNoAFU,                              // 28
+   uid_errnumAFUNotActivated,                    // 29
+   uid_errnumDeActiveTimeout,                    // 30
+   uid_errnumPRTimeout,                          // 31
+   uid_errnumPROperation,                        // 32
+   uid_errnumPRCRC,                              // 33
+   uid_errnumPRIncompatibleBitstream,            // 34
+   uid_errnumPRIPProtocal,                       // 35
+   uid_errnumPRFIFO,                             // 36
+   uid_errnumAFUActivationFail,                  // 37
+   uid_errnumPRDeviceBusy,                       // 38
+   uid_errnumPRSecureLoad,                       // 39
+   uid_errnumPRPowerMgrTimeout,                  // 40
+   uid_errnumPRPowerMgrCoreIdleFail,             // 41
+   uid_errnumNoPRPowerMgrDemon,                  // 42
+   uid_errnumSigtapRevokeTimeout,                // 43
+   uid_errnumBadSocket,                          // 44
+   uid_errnumRdMsrCmdFail,                       // 45
+   uid_errnumFPGAPowerRequestTooLarge,           // 46
+   uid_errnumAP6Detected,                        // 47
+   uid_errnumIncompatibleBlueBitstream           // 48
+
+} uid_errnum_e;
+
+typedef enum
+{
+   // Management
+   reqid_UID_Bind=1,                      // Use default API Version
+   reqid_UID_ExtendedBindInfo,            // Pass additional Bind parms
+   reqid_UID_UnBind,                      // Release a device
+
+   // Provision
+   reqid_UID_Activate,                    // Activate the device
+   reqid_UID_Deactivate,                  // Deactivate the device
+
+   // Administration
+   reqid_UID_Shutdown,                    // Request that the Service session shutdown
+
+   reqid_UID_SendAFU,                     // Send AFU a message
+
+   // Response and Event IDs
+   rspid_UID_Shutdown=0xF000,             // Service is shutdown
+   rspid_UID_UnbindComplete,              // Release Device Response
+   rspid_UID_BindComplete,                // Bind has completed
+
+   rspid_UID_Activate,                    // Activate the device
+   rspid_UID_Deactivate,                  // Deactivate the device
+
+   rspid_AFU_Response,                    // Response from AFU request
+   rspid_AFU_Event,                       // Event from AFU
+
+   rspid_AFU_PR_Release_Request_Event,    // Event from PR to request the Service release
+   rspid_AFU_PR_Revoke_Event,             // Event from PR to Revoke AFU
+
+   rspid_PR_Power_Request_Event,          // Event to Power Manger Demon
+
+   rspid_PIP_Event,                       // Event from PIP
+
+   rspid_WSM_Response,                    // Event from Workspace manager
+
+   rspid_UID_Response,
+   rspid_UID_Event,
+
+} uid_msgIDs_e;
+
+typedef enum
+{
+   ccipdrv_afucmdWKSP_ALLOC=1,
+   ccipdrv_afucmdPort_afuReset,
+   ccipdrv_afucmdPort_afuEnable,
+   ccipdrv_afucmdPort_afuQuiesceAndHalt,
+   ccipdrv_afucmdWKSP_FREE,
+   ccipdrv_afucmdGet_UmsgBase,
+   ccipdrv_getMMIORmap,
+   ccipdrv_getFeatureRegion,
+   ccipdrv_afucmdGetNumUmsgs,
+   ccipdrv_afucmdSetUmsgMode,
+   ccipdrv_getPerfMonitor,
+   ccipdrv_activateAFU,
+   ccipdrv_deactivateAFU,
+   ccipdrv_configureAFU,
+   ccipdrv_getFMEError,
+   ccipdrv_SetFMEErrorMask,
+   ccipdrv_ClearFMEError,
+   ccipdrv_ClearAllFMEErrors,
+   ccipdrv_getPower,
+   ccipdrv_gertThermal,
+   ccipdrv_getPortError,
+   ccipdrv_SetPortErrorMask,
+   ccipdrv_ClearPortError,
+   ccipdrv_ClearAllPortErrors,
+   ccipdrv_PwrMgrResponse
+
+} ccipdrv_afuCmdID_e;
+
+struct aalui_CCIdrvMessage
+{
+//   btUnsigned64bitInt  apiver;     // Version of message handler [IN]
+//   btUnsigned64bitInt  pipver;     // Version of PIP interface [IN]
+   btUnsigned64bitInt  cmd;         // Command [IN]
+   btWSSize            size;        // size of payload [IN]
+   btByte              payload[];   // data [IN/OUT]
+};
+
+#if   defined( __AAL_LINUX__ )
+# define AALUID_IOCTL_SENDMSG       _IOR ('x', 0x00, struct ccipui_ioctlreq)
+# define AALUID_IOCTL_GETMSG_DESC   _IOR ('x', 0x01, struct ccipui_ioctlreq)
+# define AALUID_IOCTL_GETMSG        _IOWR('x', 0x02, struct ccipui_ioctlreq)
+# define AALUID_IOCTL_BINDDEV       _IOWR('x', 0x03, struct ccipui_ioctlreq)
+# define AALUID_IOCTL_ACTIVATEDEV   _IOWR('x', 0x04, struct ccipui_ioctlreq)
+# define AALUID_IOCTL_DEACTIVATEDEV _IOWR('x', 0x05, struct ccipui_ioctlreq)
+#elif defined( __AAL_WINDOWS__ )
+# ifdef __AAL_USER__
+#    include <winioctl.h>
+# endif // __AAL_USER__
+
+// CTL_CODE() bits:
+//     Common[31]
+// DeviceType[30:16]
+//     Access[15:14]
+//     Custom[13]
+//   Function[12:2] (or [10:0] << 2)
+//     Method[1:0]
+
+# define UAIA_DRV_ID                  0x2
+# define UAIA_DEVICE_TYPE             FILE_DEVICE_BUS_EXTENDER
+# define UAIA_ACCESS                  FILE_ANY_ACCESS
+# define UAIA_CUSTOM                  1
+# define UAIA_METHOD                  METHOD_BUFFERED
+
+// field extractors
+# define AAL_IOCTL_DRV_ID(__ctl_code) (((__ctl_code) >> 10) & 0x7)
+# define AAL_IOCTL_FN(__ctl_code)     (((__ctl_code) >> 2) & 0xff)
+
+// 0 - 0xff
+# define UAIA_IOCTL(__index)          CTL_CODE(UAIA_DEVICE_TYPE, (UAIA_CUSTOM << 11) | (UAIA_DRV_ID << 8) | (__index), UAIA_METHOD, UAIA_ACCESS)
+
+# define AALUID_IOCTL_SENDMSG         UAIA_IOCTL(0x00)
+# define AALUID_IOCTL_GETMSG_DESC     UAIA_IOCTL(0x01)
+# define AALUID_IOCTL_GETMSG          UAIA_IOCTL(0x02)
+# define AALUID_IOCTL_BINDDEV         UAIA_IOCTL(0x03)
+# define AALUID_IOCTL_ACTIVATEDEV     UAIA_IOCTL(0x04)
+# define AALUID_IOCTL_DEACTIVATEDEV   UAIA_IOCTL(0x05)
+# define AALUID_IOCTL_POLL            UAIA_IOCTL(0x06)
+# define AALUID_IOCTL_MMAP            UAIA_IOCTL(0x07)
+
+#endif // OS
+
+//=============================================================================
+// Name: ccipui_ioctlreq
+// Description: IOCTL message block
+//=============================================================================
+struct ccipui_ioctlreq
+{
+   uid_msgIDs_e       id;           // ID of UI request [IN]
+   stTransactionID_t  tranID;       // Transaction ID to identify result [IN]
+   btObjectType       context;      // Optional token [IN]
+   uid_errnum_e       errcode;      // Driver specific error number
+   btHANDLE           handle;       // Device handle
+   btWSSize           size;         // Size of payload section [IN]
+   btByte             payload[];    // Beginning of optional payload [IN]
+};
+
+// TODO CASSERT( sizeof(struct ccipui_ioctlreq)
+
+#define aalui_ioAFUmessagep(i)   (struct aalui_CCIdrvMessage *)(i->payload )
+#define aalui_ioctlPayload(i)    ((void *)(i->payload))
+#define aalui_ioctlPayloadSize(i)   ((i)->size)
+
+
+struct ahm_req
+{
+   union {
+      // mem_alloc
+      struct {
+         btWSID   m_wsid;     // IN
+         btWSSize m_size;     // IN
+         btWSSize m_pgsize;
+      } wksp;
+
+      // Special workspace IDs for CSR Aperture mapping
+      // XXX These must match aaldevice.h:AAL_DEV_APIMAP_CSR*
+#define WSID_CSRMAP_READAREA  0x00000001
+#define WSID_CSRMAP_WRITEAREA 0x00000002
+#define WSID_MAP_MMIOR        0x00000003
+#define WSID_MAP_UMSG         0x00000004
+      // mem_get_cookie
+      struct {
+         btWSID             m_wsid;   /* IN  */
+         btUnsigned64bitInt m_cookie; /* OUT */
+      } wksp_cookie;
+
+      struct {
+         btVirtAddr         vaddr; /* IN   */
+         btWSSize           size;   /* IN   */
+         btUnsigned64bitInt mem_id; /* OUT  */
+      } mem_uv2id;
+
+      // PR reconfiguration
+      struct {
+        btVirtAddr               vaddr;           /* IN   */
+        btWSSize                 size;            /* IN   */
+        btTime                   reconfTimeout;   /* IN   */
+        btUnsigned64bitInt       reconfAction;    /* IN   */
+      } pr_config;
+
+      // Power Manager
+      struct {
+        btInt                    pr_pwrmgmt_status;       /* IN   */
+      } pr_pwrmgmt;
+
+      // Error
+      struct {
+        btUnsigned64bitInt       error0;           /* IN   */
+        btUnsigned64bitInt       pcie0_err;        /* IN   */
+        btUnsigned64bitInt       pcie1_err;        /* IN   */
+        btUnsigned64bitInt       first_error;      /* IN   */
+        btUnsigned64bitInt       next_error;       /* IN   */
+        btUnsigned64bitInt       ras_gerr;         /* IN   */
+        btUnsigned64bitInt       ras_berror;       /* IN   */
+        btUnsigned64bitInt       ras_warnerror;    /* IN   */
+      } error_csr;
+
+   } u;
+};
+
+
+struct ccidrvreq
+{
+   struct ahm_req    ahmreq;
+   stTransactionID_t afutskTranID;
+   btTime            pollrate;
+};
+
+typedef enum
+{
+   ReConf_Action_Honor_request  =0x0,
+   ReConf_Action_Honor_Owner    =0x1,
+   ReConf_Action_InActive       =0x80
+}aalconf_reconfig_action_e;
+
+// Mask off Inactive Flag
+#define RECONF_ACTION_HONOR_PARAMETER(p)    (p & (btUnsigned64bitInt)~(ReConf_Action_InActive))
+#define RECONF_ACTION_ACTIVATE_PARAMETER(p) (p & ReConf_Action_InActive)
+
+///////////////////////////////////////////////////////////////////////////////
+///////////////////////////////////////////////////////////////////////////////
+////////////////////                                     //////////////////////
+/////////////////          EVENT SUPPORT FUNCTIONS         ////////////////////
+////////////////////                                     //////////////////////
+///////////////////////////////////////////////////////////////////////////////
+///////////////////////////////////////////////////////////////////////////////
+
+//=============================================================================
+// Name: aalui_AFUResponse
+// Type[Dir]: Event/Response [OUT]
+// Object: AFU engine
+// Command ID: reqid_UID_SendAFU
+// fields: context - user defined data associated with descriptor
+//         afutskTranID - transaction ID of AFU task
+//         respID - ID code of response
+//         mode - mode the descriptor ran
+//         data - 32 buyte data returned by AFU
+// Description: Returned AFU response to a request
+// Comments:
+//=============================================================================
+typedef enum
+{
+   uid_afurespUndefinedResponse=0,
+   uid_afurespInputDescriptorComplete,
+   uid_afurespOutputDescriptorComplete,
+   uid_afurespEndofTask,
+   uid_afurespTaskStarted,
+   uid_afurespTaskStopped,
+   uid_afurespSetContext,
+   uid_afurespTaskComplete,
+   uid_afurespSetGetCSRComplete,
+   uid_afurespAFUCreateComplete,
+   uid_afurespAFUDestroyComplete,
+   uid_afurespActivateComplete,
+   uid_afurespDeactivateComplete,
+   uid_afurespConfigureComplete,
+   uid_afurespInitializeComplete,
+   uid_afurespFreeComplete,
+   uid_afurespUndefinedRequest,
+   uid_afurespPwrMgrResponce,
+   uid_afurespFirstUserResponse = 0xf000
+} uid_afurespID_e;
+
+struct aalui_AFUResponse
+{
+   btUnsigned32bitInt  respID;
+   btUnsigned64bitInt  evtData;
+   btUnsignedInt       payloadsize;
+};
+#define aalui_AFURespPayload(__ptr) ( ((btVirtAddr)(__ptr)) + sizeof(struct aalui_AFUResponse) )
+
+
+//=============================================================================
+// Name: aalui_PREvent
+// Description: Partial reconfiguration release request event.
+//=============================================================================
+//=============================================================================
+struct aalui_PREvent {
+   btUnsigned32bitInt         respID;
+   btUnsigned64bitInt         evtData;
+   btUnsigned64bitInt         reconfTimeout;
+};
+
+//=============================================================================
+// Name: aalui_PwrMgrReconfEvent
+// Description: Partial reconfiguration release request event.
+//=============================================================================
+//=============================================================================
+struct aalui_PwrMgrReconfEvent {
+   btUnsigned32bitInt         m_respID;
+   btUnsigned64bitInt         m_evtData;
+   stTransactionID_t          m_tranID;
+
+   btInt                      m_SocketID;
+   btInt                      m_BusID;
+   btInt                      m_DeviceID;
+   btInt                      m_FunctionID;
+   btInt                      m_Reconf_PwrRequired;
+};
+
+//=============================================================================
+// Name: aalui_Shutdown
+// Type[Dir]: Request[IN]
+// Object: UI Driver
+// Description: Request to the AFU
+// Comments:
+//=============================================================================
+typedef enum
+{
+   ui_shutdownReasonNormal=0,
+   ui_shutdownReasonMaint,
+   ui_shutdownFailure,
+   ui_shutdownReasonRestart
+} ui_shutdownreason_e;
+
+
+//=============================================================================
+// Name: aalui_Shutdown
+// Description: UI driver shutdown event.
+//=============================================================================
+//=============================================================================
+struct aalui_Shutdown {
+   ui_shutdownreason_e m_reason;
+   btTime              m_timeout;
+};
+
+
+//=============================================================================
+// Name: aalui_WSMParms
+// Object: Kernel Workspace Manager Service
+// Command ID: reqid_UID_SendWSM
+// Input: wsid  - Workspace ID
+//        ptr   - Pointer to start of workspace
+//        physptr - Physical address
+//        size  - size in bytes of workspace
+// Description: Parameters describing a workspace
+// Comments: Used in WSM interface
+//=============================================================================
+struct aalui_WSMParms
+{
+   btWSID     wsid;        // Workspace ID
+   btVirtAddr ptr;         // Virtual Workspace pointer
+   btPhysAddr physptr;     // Depends on use
+   btWSSize   size;        // Workspace size
+   btWSSize   itemsize;    // Workspace item size
+   btWSSize   itemspacing; // Workspace item spacing
+   TTASK_MODE type;        // Task mode this workspace is compatible with
+};
+
+
+//=============================================================================
+// Name: aalui_WSMEvent
+// Type[Dir]: Event/Response [OUT]
+// Object: Kernel Workspace Manager Service
+// Command ID: reqid_UID_SendWSM
+// fields: wsid - Workspace ID
+//         ptr  - Pointer tostart of workspace
+//         size - size in bytes of workspace
+// Description: Parameters describing a workspace
+// Comments: Used in WSM interface
+//=============================================================================
+typedef enum
+{
+   uid_wseventAllocate=0,
+   uid_wseventFree,
+   uid_wseventGetPhys,
+   uid_wseventMMIOMap
+} uid_wseventID_e;
+
+struct aalui_WSMEvent
+{
+   uid_wseventID_e       evtID;
+   struct aalui_WSMParms wsParms;
+};
+
+//=============================================================================
+// Name: aalui_taskComplete
+// Type[Dir]: Request[IN] Event/Response [OUT]
+// Object: AFU engine
+// Description: Single or mult0 descriptor AFU task completed
+// Comments:
+//=============================================================================
+typedef struct aalui_taskComplete
+{
+   btObjectType       context;
+   stTransactionID_t  afutskTranID;
+   btByte             data[32];
+   TTASK_MODE         mode;
+   btUnsigned16bitInt delim;
+} aalui_taskComplete;
+
+//=============================================================================
+// Name: ccipdrv_DeviceAttributes
+// Request[IN] Response[OUT]
+// Description: Debice attirpbues.
+// Comments: This object is used to notify the device owner of attributes
+//           any specific attributes the device publishes
+//=============================================================================
+struct ccipdrv_DeviceAttributes
+{
+   btWSSize           m_size;             // Size of the attibute block
+   btUnsigned32bitInt m_mappableAPI;      // Permits direct CSR mapping To be Deprecated
+   btByte             m_devattrib[];      // Attribute block (TBD)
+};
+
+
+//=============================================================================
+// Name: CCIP_ERROR
+// Description: Parameters describing errors
+// Comments: Used in Error interface
+//=============================================================================
+struct  CCIP_ERROR
+{
+   btUnsigned64bitInt error0_mask;           // Error0  csr
+   btUnsigned64bitInt error0;                // Error0 mask csr
+
+   btUnsigned64bitInt pcie0_error_mask;      // PCIE0 Error  csr
+   btUnsigned64bitInt pcie0_error;           // PCIE0 Error mask csr
+
+   btUnsigned64bitInt pcie1_error_mask;      // PCIE1 Error csr
+   btUnsigned64bitInt pcie1_error;           // PCIE1 Error mask csr
+
+   btUnsigned64bitInt first_error;           // First error csr
+   btUnsigned64bitInt next_error;            // Next error csr
+
+   btUnsigned64bitInt malreq0;               // Port Malformed request 0
+   btUnsigned64bitInt malreq1;               // Port Malformed request 0
+
+   btUnsigned64bitInt ras_gerr_mask;         // RAS Green BS error Mask
+   btUnsigned64bitInt ras_gerr;              // RAS Green BS error
+
+   btUnsigned64bitInt ras_berror_mask;       // RAS blue bitstream error mask
+   btUnsigned64bitInt ras_berror;            // RAS blue bitstream error
+
+   btUnsigned64bitInt ras_warnerror_mask;    // RAS warning error mask
+   btUnsigned64bitInt ras_warnerror;         // RAS warning error
+};
+
+//=============================================================================
+// Name: CCIP_THERMAL_PWR
+// Description: Parameters describing power and thermal values
+// Comments: Used in power and thermal interface
+//=============================================================================
+struct  CCIP_THERMAL_PWR
+{
+   btUnsigned64bitInt tmp_threshold;     // Thermal threshold
+   btUnsigned64bitInt tmp_rdsensor1;    // Sensor1 reading temperature value
+   btUnsigned64bitInt tmp_rdsensor2;    // Sensor2 reading temperature value
+   btUnsigned64bitInt pwr_status;        // Power consumed by fpga
+};
+
+//=============================================================================
+// Name: PERFCOUNTER_EVENT
+// Request[IN] Response[OUT]
+// Description: performance counters.
+// Comments: This object is used to notify the device owner of attributes
+//           any specific attributes the device publishes
+//=============================================================================
+struct  PERFCOUNTER_EVENT
+{
+   char  name[45];
+   btUnsigned64bitInt value;
+};
+
+struct  CCIP_PERF_COUNTERS
+{
+   //Cache
+   struct  PERFCOUNTER_EVENT num_counters;
+   struct  PERFCOUNTER_EVENT version;
+   struct  PERFCOUNTER_EVENT read_hit;
+   struct  PERFCOUNTER_EVENT write_hit;
+   struct  PERFCOUNTER_EVENT read_miss;
+   struct  PERFCOUNTER_EVENT write_miss;
+   struct  PERFCOUNTER_EVENT evictions;
+
+   //Fabric
+   struct  PERFCOUNTER_EVENT pcie0_read;
+   struct  PERFCOUNTER_EVENT pcie0_write;
+   struct  PERFCOUNTER_EVENT pcie1_read;
+   struct  PERFCOUNTER_EVENT pcie1_write;
+   struct  PERFCOUNTER_EVENT upi_read;
+   struct  PERFCOUNTER_EVENT upi_write;
+
+   // VTD
+   struct  PERFCOUNTER_EVENT AFU0_MemRead_Trans;
+   struct  PERFCOUNTER_EVENT AFU0_MemWrite_Trans;
+   struct  PERFCOUNTER_EVENT AFU0_DevTLBRead_Hit;
+   struct  PERFCOUNTER_EVENT AFU0_DevTLBWrite_Hit;
+
+
+};
+END_C_DECLS
+
+END_NAMESPACE(AAL)
+
+
+#endif // __AALSDK_CCIP_DRIVER_H__
+
diff --git a/drivers/fpga/aal/include/aalsdk/kernel/fappip.h b/drivers/fpga/aal/include/aalsdk/kernel/fappip.h
new file mode 100644
index 000000000000..1ca9de37f1eb
--- /dev/null
+++ b/drivers/fpga/aal/include/aalsdk/kernel/fappip.h
@@ -0,0 +1,231 @@
+//******************************************************************************
+// This  file  is  provided  under  a  dual BSD/GPLv2  license.  When using or
+//         redistributing this file, you may do so under either license.
+//
+//                            GPL LICENSE SUMMARY
+//
+//  Copyright(c) 2007-2017, Intel Corporation.
+//
+//  This program  is  free software;  you  can redistribute it  and/or  modify
+//  it  under  the  terms of  version 2 of  the GNU General Public License  as
+//  published by the Free Software Foundation.
+//
+//  This  program  is distributed  in the  hope that it  will  be useful,  but
+//  WITHOUT   ANY   WARRANTY;   without   even  the   implied   warranty    of
+//  MERCHANTABILITY  or  FITNESS  FOR  A  PARTICULAR  PURPOSE.  See  the   GNU
+//  General Public License for more details.
+//
+//  The  full  GNU  General Public License is  included in  this  distribution
+//  in the file called README.GPLV2-LICENSE.TXT.
+//
+//  Contact Information:
+//  Henry Mitchel, henry.mitchel at intel.com
+//  77 Reed Rd., Hudson, MA  01749
+//
+//                                BSD LICENSE
+//
+//  Copyright(c) 2007-2017, Intel Corporation.
+//
+//  Redistribution and  use  in source  and  binary  forms,  with  or  without
+//  modification,  are   permitted  provided  that  the  following  conditions
+//  are met:
+//
+//    * Redistributions  of  source  code  must  retain  the  above  copyright
+//      notice, this list of conditions and the following disclaimer.
+//    * Redistributions in  binary form  must  reproduce  the  above copyright
+//      notice,  this  list of  conditions  and  the  following disclaimer  in
+//      the   documentation   and/or   other   materials   provided  with  the
+//      distribution.
+//    * Neither   the  name   of  Intel  Corporation  nor  the  names  of  its
+//      contributors  may  be  used  to  endorse  or promote  products derived
+//      from this software without specific prior written permission.
+//
+//  THIS  SOFTWARE  IS  PROVIDED  BY  THE  COPYRIGHT HOLDERS  AND CONTRIBUTORS
+//  "AS IS"  AND  ANY  EXPRESS  OR  IMPLIED  WARRANTIES,  INCLUDING,  BUT  NOT
+//  LIMITED  TO, THE  IMPLIED WARRANTIES OF  MERCHANTABILITY  AND FITNESS  FOR
+//  A  PARTICULAR  PURPOSE  ARE  DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT
+//  OWNER OR CONTRIBUTORS BE LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,
+//  SPECIAL,  EXEMPLARY,  OR  CONSEQUENTIAL   DAMAGES  (INCLUDING,   BUT   NOT
+//  LIMITED  TO,  PROCUREMENT  OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF USE,
+//  DATA,  OR PROFITS;  OR BUSINESS INTERRUPTION)  HOWEVER  CAUSED  AND ON ANY
+//  THEORY  OF  LIABILITY,  WHETHER  IN  CONTRACT,  STRICT LIABILITY,  OR TORT
+//  (INCLUDING  NEGLIGENCE  OR OTHERWISE) ARISING  IN ANY WAY  OUT  OF THE USE
+//  OF  THIS  SOFTWARE, EVEN IF ADVISED  OF  THE  POSSIBILITY  OF SUCH DAMAGE.
+//******************************************************************************
+//****************************************************************************
+//        FILE: fappip.h module interface
+//     CREATED: Q1 2007
+//      AUTHOR: Michael Liao, Joseph Grecco and Alvin Chen
+//
+// PURPOSE: Defines the module interface
+// HISTORY:
+// COMMENTS:
+// WHEN:          WHO:     WHAT:
+// 11-14-07       JG       Converted to FAPDRV
+// 12-03/07       JG       Added UNBLOCK ioctl
+// 10/22/08       JG       Converted to AAL 1.0
+// 11/11/2008     JG       Added legal header
+// 11/25/2008     HM       Large merge
+// 12/16/2008     JG       Began support for abort and shutdown
+//                            Added Support for WSID object
+//                            Major interface changes.
+// 12/20/2008     HM       Added structures to support CSR Get/Set, and Multi-
+//                            Descriptor Task Submit
+// 01/03/2009     HM       Moved SOT/MOT/EOT definitions to AALWorkspace.h
+// 01/04/2009     HM       Updated Copyright
+// 03/17/2009     JG       Moved AFU CSR out and removed old IOCTL defs
+// 03/17/2009     AC       Change pointer to array in submit_descriptor_req
+// 12/27/2009     JG       Added reserved WSIDs for CSR maps
+// 09/18/2010     HM       Formatting and comment cleanup
+// 03/05/2012     JG       Added SPL2 support
+//****************************************************************************
+#ifndef __AALSDK_KERNEL_FAPPIP_H__
+#define __AALSDK_KERNEL_FAPPIP_H__
+#include <aalsdk/kernel/AALWorkspace.h>
+
+BEGIN_NAMESPACE(AAL)
+
+BEGIN_C_DECLS
+
+
+///////////////////////////////////////////////////////////////////////////////////////
+// API IIDs TODO should come from aal ids
+// The type is btID, which is the same as btID         // HM 20081201
+#define AAL_AHMPIP_IID_1_0        (0xff00000000000010LL)
+#define AAL_AFUPIP_IID_1_0        (0xff00000000000110LL)
+
+#define AAL_AHMPIP_IID_0_7        (0xff00000000000007LL)
+#define AAL_ASMPIP_IID_1_0        (0xff00000000001000LL)
+
+// Message interfaces
+#define AAL_AFUAPI_IID_1_0        (0xfa00000000000010LL)
+#define AAL_AHMAPI_IID_1_0        (0xfa00000000000011LL)
+#define AAL_ASMAPI_IID_1_0        (0xfa00000000001001LL)
+
+#define AAL_AHMAPI_IID_0_7        (0xfa00000000000007LL)
+
+
+
+
+typedef enum
+{
+    fappip_afucmdWKSP_ALLOC=1,
+    fappip_afucmdWKSP_VALLOC,
+    fappip_afucmdWKSP_FREE,
+    fappip_afucmdWKSP_VFREE,
+    fappip_afucmdWKSP_GET_PHYS,
+
+    fappip_afucmdDESC_SUBMIT,
+    fappip_afucmdDESC_QUERY,
+    fappip_afucmdTASK_ABORT,
+    fappip_afucmdSTART_SPL2_TRANSACTION,
+    fappip_afucmdSET_SPL2_CONTEXT_WORKSPACE,
+    fappip_afucmdCSR_GETSET,
+    fappip_afucmdDESC_MULTISUBMIT,
+    fappip_afucmdSTOP_SPL2_TRANSACTION,
+    fappip_getCSRmap,
+    fappip_getMMIORmap,
+    fappip_getuMSGmap
+
+} fappip_afuCmdID_e;
+
+
+// Legacy defines deprecating
+#define AHM_WKSP_RESET          fappip_afucmdWKSP_RESET
+#define AHM_WKSP_ALLOC          fappip_afucmdWKSP_ALLOC
+#define AHM_WKSP_VALLOC         fappip_afucmdWKSP_VALLOC
+#define AHM_WKSP_FREE           fappip_afucmdWKSP_FREE
+#define AHM_WKSP_VFREE          fappip_afucmdWKSP_VFREE
+#define AHM_WKSP_GET_PHYS       fappip_afucmdWKSP_GET_PHYS
+
+#define AHM_DESC_SUBMIT         fappip_afucmdDESC_SUBMIT
+#define AHM_DESC_QUERY          fappip_afucmdDESC_QUERY
+#define AHM_TASK_ABORT          fappip_afucmdTASK_ABORT
+#define AHM_DESC_FREE           AHM_DESC_ABORT
+#define AHM_TASK_UNBLOCK        fappip_afucmdTASK_UNBLOCK
+
+#define AHM_CSR_GETSET          fappip_afucmdCSR_GETSET
+#define AHM_DESC_MULTISUBMIT    fappip_afucmdDESC_MULTISUBMIT
+
+///////////////////////////////////////////////////////////////////////////////////////
+enum
+{
+   ACPM_HWTASK_STATUS_IDLE = 0,
+   ACPM_HWTASK_STATUS_RUNNING,
+   ACPM_HWTASK_STATUS_ERROR,
+   ACPM_HWTASK_STATUS_DONE
+};
+
+
+struct ahm_req
+{
+   union {
+      // mem_alloc
+      struct {
+         btWSID   m_wsid;     // IN
+         btWSSize m_size;     // IN
+         btWSSize m_pgsize;
+      } wksp;
+
+// Special workspace IDs for CSR Aperture mapping
+// XXX These must match aaldevice.h:AAL_DEV_APIMAP_CSR*
+#define WSID_CSRMAP_READAREA  0x00000001
+#define WSID_CSRMAP_WRITEAREA 0x00000002
+#define WSID_MAP_MMIOR        0x00000003
+#define WSID_MAP_UMSG         0x00000004
+      // mem_get_cookie
+      struct {
+         btWSID             m_wsid;   /* IN  */
+         btUnsigned64bitInt m_cookie; /* OUT */
+      } wksp_cookie;
+
+      struct {
+         btVirtAddr         vaddr; /* IN   */
+         btWSSize           size;   /* IN   */
+         btUnsigned64bitInt mem_id; /* OUT  */
+      } mem_uv2id;
+   } u;
+};
+
+struct spl2req
+{
+   struct ahm_req    ahmreq;
+   stTransactionID_t afutskTranID;
+   btTime            pollrate;
+};
+
+// Alias for now
+#define cciv4req spl2req
+
+/*
+ * Used to submit a group of descriptors that constitute a single task.
+ */
+////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct desc_share_info
+{
+   btVirtAddr         m_uvptr;     /* In: User Virtual pointer to buffer inside wsid */
+   btVirtAddr         m_context;   /* In: Application context */
+   btWSID             m_wsid;      /* In: the workspace id. Should use buffer address to compute it. */
+   btWSID             m_vwsid;     /* In: the workspace for the virtual table. Should use buffer address to compute it.*/
+   TDESC_TYPE         m_type;      // IN    IN_DESC: '0'   OUT_DESC: '1'
+   btWSSize           m_len;       /* In: length of the buffer in bytes, currently unchecked. Maybe just make it cachelines? */
+   btUnsigned16bitInt m_no_notify; /* In: flag indicating whether an event should be sent on completion. 1 = no event */
+   btUnsigned16bitInt m_delim;     // In: SOT, MOT, EOT
+} desc_share_info_t;
+
+////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+typedef struct submit_descriptors_req
+{
+   TTASK_MODE               m_mode;            /* Slave, PMaster, VMaster. Will be repeated in each descriptor */
+   struct stTransactionID_t m_tranID;          /* Transaction ID for entire task */
+   btUnsigned16bitInt       m_nDesc;           /* number of descriptors in the array */
+   desc_share_info_t        m_arrDescInfo[1];  /* all descriptors, output first, in correct submission order*/
+} submit_descriptors_req_t;
+
+
+END_C_DECLS
+
+END_NAMESPACE(AAL)
+
+#endif // __AALSDK_KERNEL_FAPPIP_H__
+
diff --git a/drivers/fpga/aal/include/aalsdk/kernel/iaaldevice.h b/drivers/fpga/aal/include/aalsdk/kernel/iaaldevice.h
new file mode 100644
index 000000000000..24c3689ebcd9
--- /dev/null
+++ b/drivers/fpga/aal/include/aalsdk/kernel/iaaldevice.h
@@ -0,0 +1,444 @@
+//******************************************************************************
+// This  file  is  provided  under  a  dual BSD/GPLv2  license.  When using or
+//         redistributing this file, you may do so under either license.
+//
+//                            GPL LICENSE SUMMARY
+//
+//  Copyright(c) 2015-2017, Intel Corporation.
+//
+//  This program  is  free software;  you  can redistribute it  and/or  modify
+//  it  under  the  terms of  version 2 of  the GNU General Public License  as
+//  published by the Free Software Foundation.
+//
+//  This  program  is distributed  in the  hope that it  will  be useful,  but
+//  WITHOUT   ANY   WARRANTY;   without   even  the   implied   warranty    of
+//  MERCHANTABILITY  or  FITNESS  FOR  A  PARTICULAR  PURPOSE.  See  the   GNU
+//  General Public License for more details.
+//
+//  The  full  GNU  General Public License is  included in  this  distribution
+//  in the file called README.GPLV2-LICENSE.TXT.
+//
+//  Contact Information:
+//  Henry Mitchel, henry.mitchel at intel.com
+//  77 Reed Rd., Hudson, MA  01749
+//
+//                                BSD LICENSE
+//
+//  Copyright(c) 2015-2017, Intel Corporation.
+//
+//  Redistribution and  use  in source  and  binary  forms,  with  or  without
+//  modification,  are   permitted  provided  that  the  following  conditions
+//  are met:
+//
+//    * Redistributions  of  source  code  must  retain  the  above  copyright
+//      notice, this list of conditions and the following disclaimer.
+//    * Redistributions in  binary form  must  reproduce  the  above copyright
+//      notice,  this  list of  conditions  and  the  following disclaimer  in
+//      the   documentation   and/or   other   materials   provided  with  the
+//      distribution.
+//    * Neither   the  name   of  Intel  Corporation  nor  the  names  of  its
+//      contributors  may  be  used  to  endorse  or promote  products derived
+//      from this software without specific prior written permission.
+//
+//  THIS  SOFTWARE  IS  PROVIDED  BY  THE  COPYRIGHT HOLDERS  AND CONTRIBUTORS
+//  "AS IS"  AND  ANY  EXPRESS  OR  IMPLIED  WARRANTIES,  INCLUDING,  BUT  NOT
+//  LIMITED  TO, THE  IMPLIED WARRANTIES OF  MERCHANTABILITY  AND FITNESS  FOR
+//  A  PARTICULAR  PURPOSE  ARE  DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT
+//  OWNER OR CONTRIBUTORS BE LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,
+//  SPECIAL,  EXEMPLARY,  OR  CONSEQUENTIAL   DAMAGES  (INCLUDING,   BUT   NOT
+//  LIMITED  TO,  PROCUREMENT  OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF USE,
+//  DATA,  OR PROFITS;  OR BUSINESS INTERRUPTION)  HOWEVER  CAUSED  AND ON ANY
+//  THEORY  OF  LIABILITY,  WHETHER  IN  CONTRACT,  STRICT LIABILITY,  OR TORT
+//  (INCLUDING  NEGLIGENCE  OR OTHERWISE) ARISING  IN ANY WAY  OUT  OF THE USE
+//  OF  THIS  SOFTWARE, EVEN IF ADVISED  OF  THE  POSSIBILITY  OF SUCH DAMAGE.
+//******************************************************************************
+//****************************************************************************
+//        FILE: iaaldevice.h
+//     CREATED: 10/14/2014
+//      AUTHOR: Joseph Grecco - Intel
+//
+// PURPOSE: This file contains API definitions for AAL device objects
+// HISTORY:
+// COMMENTS:
+// WHEN:          WHO:     WHAT:
+//****************************************************************************
+#ifndef __AALSDK_KERNEL_AALDEVICE_INTERFACE_H__
+#define __AALSDK_KERNEL_AALDEVICE_INTERFACE_H__
+#include <aalsdk/kernel/kosal.h>
+
+#ifdef __AAL_USER__
+# include <aalsdk/AALTypes.h>
+# define __user
+#endif
+
+BEGIN_NAMESPACE(AAL)
+
+BEGIN_C_DECLS
+//-----------------------------------------------------------------------------
+// Typedefs and constants
+//-----------------------------------------------------------------------------
+
+// Defines for AFU mask
+#define   AAL_DEVIDMASK_AFU(n)  (0x1 <<n)
+#define   AAL_DEVID_MAFU        64
+
+//=============================================================================
+// Name:
+// Description: mappable API modes
+//=============================================================================
+// XXX These must match fappip.h:WSID_CSRMAP_*AREA
+#define AAL_DEV_APIMAP_NONE     0x00000000
+#define AAL_DEV_APIMAP_CSRREAD  0x00000001
+#define AAL_DEV_APIMAP_CSRWRITE 0x00000002
+#define AAL_DEV_APIMAP_MMIOR    0x00000004
+#define AAL_DEV_APIMAP_UMSG     0x00000008
+#define AAL_DEV_APIMAP_CSRRW    ( AAL_DEV_APIMAP_CSRREAD | AAL_DEV_APIMAP_CSRWRITE )
+
+
+//=============================================================================
+// Standard Format for GUID is either binary or a modified hex-encoded string
+// NOTE: See http://en.wikipedia.org/wiki/Globally_Unique_Identifier
+//=============================================================================
+typedef struct {
+   btUnsigned32bitInt Data1;
+   btUnsigned16bitInt Data2;
+   btUnsigned16bitInt Data3;
+   btByte             Data4[8];
+} AAL_GUID_t;
+
+//=============================================================================
+// Name: aal_bus_types_e
+// Description: AAL Bus types
+//=============================================================================
+enum aal_bus_types_e {
+   aal_bustype_unknown=0,
+   aal_bustype_FSB,
+   aal_bustype_QPI,
+   aal_bustype_PCIe,
+   aal_bustype_ASM,
+   aal_bustype_Prop,
+   aal_bustype_Host
+};
+
+//=============================================================================
+// Name: aal_device_type_e
+// Description: AAL device types
+//=============================================================================
+enum aal_device_type_e {
+   aal_devtype_unknown=0,
+   aal_devtypeAHM=1,
+   aal_devtypeAFU,
+   aal_devtypeMgmtAFU
+};
+
+
+//=============================================================================
+// Name: aal_device_request_e
+// Description: AAL common device requests
+//=============================================================================
+enum aal_device_request_e {
+   aaldev_reqActivate=1,
+   aaldev_reqDeactivate,
+   aaldev_reqCreateDevice,
+   aaldev_reqDestroyDevice,
+};
+
+//=============================================================================
+// Name: aal_device_addr
+// Description: Device address structure
+//=============================================================================
+struct aal_device_addr {
+   enum aal_bus_types_e m_bustype;     // Type of bus E.g., FSB, QPI, PCIe
+   union {
+	   btUnsigned32bitInt   m_busnum;      // Domain:Bus number
+	   struct {
+		   btUnsigned16bitInt	m_domain;
+		   btUnsigned16bitInt	m_bus;
+	   };
+   };
+   btUnsigned16bitInt   m_devicenum;   // device number
+   btUnsigned16bitInt   m_functnum;    // function number
+   btUnsigned16bitInt   m_subdevnum;   // Sub-device/channel number
+   btUnsigned16bitInt   m_instanceNum; // instance number
+   btUnsigned16bitInt   m_socketnum;   // Socket number
+};
+#define aaldevaddr_bustype(devaddr)         ((devaddr).m_bustype)
+#define aaldevaddr_busnum(devaddr)          ((devaddr).m_busnum)
+#define aaldevaddr_busdom(devaddr)          ((devaddr).m_domain)
+#define aaldevaddr_bus(devaddr)             ((devaddr).m_bus)
+#define aaldevaddr_devnum(devaddr)          ((devaddr).m_devicenum)
+#define aaldevaddr_fcnnum(devaddr)          ((devaddr).m_functnum)
+#define aaldevaddr_subdevnum(devaddr)       ((devaddr).m_subdevnum)
+#define aaldevaddr_instanceNum(devaddr)     ((devaddr).m_instanceNum)
+#define aaldevaddr_socketnum(devaddr)       ((devaddr).m_socketnum)
+
+//=============================================================================
+// Name: AAL Device_ID
+// Description: AAL device ID used to match a discovered device with a driver
+//=============================================================================
+struct aal_device_id {
+   struct aal_device_addr m_devaddr;     // Device address
+   enum aal_device_type_e m_devicetype;  // Device type
+
+   btUnsigned32bitInt     m_vendor;      // Vendor ID
+
+   btUnsigned64bitInt     m_pipGUID;     // PIP GUID  TODO must reconcile with btIID
+#define AAL_DEVICE_MAX_GUID_STRING_SIZE 80
+   char                   m_deviguid[AAL_DEVICE_MAX_GUID_STRING_SIZE]; // Should replace PIP Guid
+
+   btUnsigned64bitInt     m_ahmGUID;     // AHM GUID
+
+   btUnsigned64bitInt     m_afuGUIDl;    // AFU GUID low order
+   btUnsigned64bitInt     m_afuGUIDh;    // AFU GUID high order
+#define m_afuGUID m_afuGUIDl // AFU GUID low order (backward compat)
+};
+
+#define aal_device_id_terminator                                                            \
+{  .m_devaddr = { .m_bustype = 0, { .m_busnum = 0 }, .m_devicenum = 0, .m_subdevnum = 0,    \
+   .m_socketnum = 0 },                                                                      \
+   .m_devicetype = aal_devtype_unknown,                                                     \
+   .m_vendor   = 0,                                                                         \
+   .m_pipGUID  = 0,                                                                         \
+   .m_ahmGUID  = 0,                                                                         \
+   .m_afuGUIDl = 0,                                                                         \
+   .m_afuGUIDh = 0, }
+
+#define aaldevid_addr(devid)                 ((devid).m_devaddr)
+#define aaldevid_devaddr_bustype(devid)      ((aaldevid_addr(devid)).m_bustype)
+#define aaldevid_devaddr_busnum(devid)       ((aaldevid_addr(devid)).m_busnum)
+#define aaldevid_devaddr_busdom(devid)       ((aaldevid_addr(devid)).m_busnum)
+#define aaldevid_devaddr_bus(devid)          ((aaldevid_addr(devid)).m_bus)
+#define aaldevid_devaddr_devnum(devid)       ((aaldevid_addr(devid)).m_devicenum)
+#define aaldevid_devaddr_fcnnum(devid)       ((aaldevid_addr(devid)).m_functnum)
+#define aaldevid_devaddr_subdevnum(devid)    ((aaldevid_addr(devid)).m_subdevnum)
+#define aaldevid_devaddr_instanceNum(devid)  ((aaldevid_addr(devid)).m_instanceNum)
+#define aaldevid_devaddr_socketnum(devid)    ((aaldevid_addr(devid)).m_socketnum)
+
+#define aaldevid_afuguidl(devid) ((devid).m_afuGUIDl)
+#define aaldevid_afuguidh(devid) ((devid).m_afuGUIDh)
+#define aaldevid_devtype(devid)  ((devid).m_devicetype)
+#define aaldevid_pipguid(devid)  ((devid).m_pipGUID)
+#define aaldevid_vendorid(devid) ((devid).m_vendor)
+#define aaldevid_ahmguid(devid)  ((devid).m_ahmGUID)
+
+
+
+// EXPANDED IN-PLACE DEFINITION of AAL Device_ID as of 2011.3.6
+// struct aal_device_id devid;   // Device ID
+// {
+//    struct aal_device_addr     m_devaddr;     // Device address
+//    {
+//       enum aal_bus_types_e    m_bustype;     // Type of bus E.g., FSB, QPI, PCIe
+//       {
+//          aal_bustype_unknown=0,
+//          aal_bustype_FSB,
+//          aal_bustype_QPI,
+//          aal_bustype_PCIe,
+//          aal_bustype_ASM,
+//          aal_bustype_Prop,
+//          aal_bustype_Host
+//       }
+//       u_int32_t               m_busnum;      // Bus number
+//       u_int32_t               m_devicenum;   // device/channel number
+//       int32_t                 m_subdevnum;   // Sub-device/channel number
+//    }
+//
+//    enum aal_device_type_e     m_devicetype;  // Device type
+//    {
+//       aal_devtype_unknown=0,
+//       aal_devtypeAHM=1,
+//       aal_devtypeAFU,
+//       aal_devtypeMgmtAFU
+//    }
+//
+//    u_int32_t    m_vendor;      // Vendor ID
+//
+//    u_int64_t    m_pipGUID;     // PIP GUID  TODO must reconcile with btIID
+//    u_int64_t    m_ahmGUID;     // AHM GUID
+//    u_int64_t    m_afuGUID;     // AFU GUID
+// }
+
+
+//=============================================================================
+// Name:        device_attributes
+// Description: 
+// Comments:  
+//=============================================================================
+struct device_attributes {
+   btWSSize                 size;                      // size with attributes
+   struct aal_device_id     device_id;                 // AAL Bus device Identifer
+   btObjectType            *Handle;                    // Device Handle
+
+#define DEVICE_MAX_BASENAME_LEN   256                  // Maximum size of name base
+   btByte                  basename[DEVICE_MAX_BASENAME_LEN + 1]; // Base name of device
+
+   btUnsignedInt           maxOwners;                 // Max number of owners
+
+#define MAFU_CONFIGURE_UNLIMTEDSHARES  (~0U)
+   btUnsigned16bitInt      enableDirectAPI;
+   btWSSize                extended_attrib_size;   // Length of optional attributes
+   btWSSize                pub_attrib_size;        // Length of public attributes
+};
+
+#define AALBUS_INIT_DEVICE_ATTIBUTES(p)  memset( p, 0, sizeof( struct device_attributes));
+
+#if defined( __AAL_KERNEL__ )
+#define aalbus_destroy_device_attrib(p)  kosal_kfree(p, p->size) 
+#else 
+#define aalbus_destroy_device_attrib(p) free(p) 
+#endif
+
+#define aalbus_config_dev_pattributes(d) ( WdfObjectGetAALContext( d )->m_pdevAttributes )
+
+// Extended attributes follow the base attributes and is a variable length object.  Returns NULL if none
+#define aalbus_config_dev_pextattributes(t,p) (   p->extended_attrib_size != 0 ? ((t)((btByteArray)p+sizeof(struct device_attributes))) : NULL )
+
+// Public attributes follow the extended attributes (if any) and is a variable length object. Returns NULL if none.
+#define aalbus_config_dev_ppubattributes(t,p) ( p->pub_attrib_size != 0 ? ((t)( (btByteArray)p+sizeof(struct device_attributes) + p->extended_attrib_size) ) : NULL)
+
+
+//=============================================================================
+// Name: device_attrib
+// Description: Device attributes
+//=============================================================================
+struct device_attrib {
+   void                *Handle;       // Device Handle
+   btInt                state;        // 1 - if activated 0 - if quiescent
+
+   struct aal_device_id devid;        // Device ID
+
+   btUnsignedInt        numOwners;    // Number of owners
+   btUnsignedInt        maxOwners;    // Max number of owners
+   btPID                ownerlist[1]; // List of owning pids
+};
+
+
+// Device Add Owner result codes
+typedef enum aaldev_AddOwner_e{
+   aaldev_addowner_OK = 0,
+   aaldev_addowner_MaxOwners,
+   aaldev_addowner_DupOwner,
+   aaldev_addowner_NotOwner,
+   aaldev_addowner_InvalidDevice,
+   aaldev_addowner_Interrupted,        // a down_interruptible returned from a signal instead of acquiring the mutex
+   aaldev_addowner_SysErr = -1
+} aaldev_AddOwner_e;
+
+// Config update event types
+typedef enum krms_cfgUpDate_e{
+   krms_ccfgUpdate_DevAdded,
+   krms_ccfgUpdate_DevRemoved,
+   krms_ccfgUpdate_DevOwnerAdded,
+   krms_ccfgUpdate_DevOwnerUpdated,
+   krms_ccfgUpdate_DevOwnerRemoved,
+   krms_ccfgUpdate_DevActivated,
+   krms_ccfgUpdate_DevQuiesced
+}krms_cfgUpDate_e;
+
+struct aalrms_configUpDateEvent {
+   krms_cfgUpDate_e        id;         // Type of update
+   btPID                   pid;        // Used in owner Added/Removed
+   struct device_attrib    devattrs;   // Device attributes
+};
+
+#if defined( __AAL_KERNEL__ )
+// Forward Reference
+struct aal_device;
+struct aaldev_owner;
+
+// Prototype for call back used in doForeachOwner
+typedef btInt (*aaldev_OwnerProcessor_t)(struct aal_device *,
+                                         struct aaldev_owner *);
+
+//=============================================================================
+// Name: aaldev_ownerSession
+// Description: Represents an instance of a session between a device and its
+//              owner. This is the primary object shared between PIP and UIDrv.
+//=============================================================================
+struct aaldev_ownerSession {
+   // UI Message Adaptor
+   struct aal_uiapi  *m_uiapi;            // Message handler interface
+   btObjectType       m_UIHandle;         // UI Handle
+   btAny              m_ownerContext;     // Specific to binding owner
+
+
+   // PIP
+   btObjectType       m_PIPHandle; // PIP Handle
+   kosal_list_head    m_wshead;    // Head of the workspace list for this device
+   struct aal_device *m_device;    // Device owned by the session
+};
+
+#define aalsess_pipSendMessage(os)  (aaldev_pipmsgHandlerp((os)->m_device)->sendMessage)
+#define aalsess_pipmsgID(os)        ((aaldev_pipid((os)->m_device)))
+#define aalsess_uimsgHandlerp(os)   ((os)->m_uiapi)
+#define aalsess_aaldevicep(os)      ((os)->m_device)
+#define aalsess_aalpipp(os)         (aaldev_pipp( aalsess_aaldevicep(os) ) )
+#define aalsess_pipHandle(os)       ((os)->m_PIPHandle)
+#define aalsess_uiHandle(os)        ((os)->m_UIHandle)
+#define aalsess_add_ws(os,ih)       kosal_list_add_head(&ih, &(os)->m_wshead);
+
+//=============================================================================
+// Name: aaldevice_interface
+// Description: Public interface to aal_device
+// Interface: public
+// Comments:
+//=============================================================================
+typedef struct aaldevice_interface {
+#if defined( __AAL_WINDOWS__ )
+   INTERFACE      InterfaceHeader;        // TODO converge with Linux aal_interface
+
+   struct device_attributes     *( *getDevAttributes )( WDFDEVICE );  // Fix this too
+#endif
+   btAny( *getExtendedAttributes )( void );
+   btAny( *getPublicAttributes )( void );
+   btBool( *sendDeviceUpdate )( void );
+
+   aaldev_AddOwner_e    (*addOwner)(struct aal_device * ,
+                                    btPID ,
+                                    btObjectType ,
+                                    btAny,
+                                    pkosal_list_head );
+   aaldev_AddOwner_e     (*isOwner)(struct aal_device * ,
+                                    btPID );
+   aaldev_AddOwner_e (*removeOwner)(struct aal_device * ,
+                                    btPID );
+   aaldev_AddOwner_e (*updateOwner)(struct aal_device * ,
+                                    btPID ,
+                                    struct aaldev_ownerSession * ,
+                                    pkosal_list_head );
+   struct aaldev_ownerSession *
+                 (*getOwnerSession)(struct aal_device * ,
+                                    btPID );
+
+   struct aaldev_owner *
+                  (*doForeachOwner)(struct aal_device * ,
+                                    aaldev_OwnerProcessor_t );
+   btInt                 (*quiesce)(struct aal_device * ,
+                                    struct aaldev_owner * );
+   btInt                  (*remove)(struct aal_device * );
+   void            (*releasedevice)(pkosal_os_dev );
+}AAL_DEVICE_INTERFACE, *PAAL_DEVICE_INTERFACE;
+
+
+// Convenience macros
+#define dev_addOwner(p,id,m,o,s)    (p)->i.addOwner(p,id,m,o,s)
+#define dev_isOwner(p,id,m,s)     (p)->i.addOwner(p,id)
+#define dev_removeOwner(p,id)     (p)->i.removeOwner(p,id)
+#define dev_updateOwner(p,o,s,l)  (p)->i.updateOwner(p,o,s,l)
+#define dev_OwnerSession(p,o)     (p)->i.getOwnerSession(p,o)
+#define dev_doForeachOwner(p,f)   (p)->i.doForeachOwner(p,f)
+#define dev_quiesce(p,o)          (p)->i.quiesce(p,o)
+#define dev_removedevice(p)       (p)->i.remove(p)
+#define dev_hasRelease(p)         (NULL != (p)->i.releasedevice)
+#define dev_setrelease(p,f)       (p)->i.releasedevice=f
+#define dev_release(p,d)          (p)->i.releasedevice(d)
+#endif
+
+
+
+END_C_DECLS
+
+END_NAMESPACE(AAL)
+
+#endif // __AALSDK_KERNEL_AALDEVICE_INTERFACE_H__
+
diff --git a/drivers/fpga/aal/include/aalsdk/kernel/kosal.h b/drivers/fpga/aal/include/aalsdk/kernel/kosal.h
new file mode 100644
index 000000000000..ba29fdf3543c
--- /dev/null
+++ b/drivers/fpga/aal/include/aalsdk/kernel/kosal.h
@@ -0,0 +1,1079 @@
+//******************************************************************************
+// This  file  is  provided  under  a  dual BSD/GPLv2  license.  When using or
+//         redistributing this file, you may do so under either license.
+//
+//                            GPL LICENSE SUMMARY
+//
+//  Copyright(c) 2012-2017, Intel Corporation.
+//
+//  This program  is  free software;  you  can redistribute it  and/or  modify
+//  it  under  the  terms of  version 2 of  the GNU General Public License  as
+//  published by the Free Software Foundation.
+//
+//  This  program  is distributed  in the  hope that it  will  be useful,  but
+//  WITHOUT   ANY   WARRANTY;   without   even  the   implied   warranty    of
+//  MERCHANTABILITY  or  FITNESS  FOR  A  PARTICULAR  PURPOSE.  See  the   GNU
+//  General Public License for more details.
+//
+//  The  full  GNU  General Public License is  included in  this  distribution
+//  in the file called README.GPLV2-LICENSE.TXT.
+//
+//  Contact Information:
+//  Henry Mitchel, henry.mitchel at intel.com
+//  77 Reed Rd., Hudson, MA  01749
+//
+//                                BSD LICENSE
+//
+//  Copyright(c) 2012-2017, Intel Corporation.
+//
+//  Redistribution and  use  in source  and  binary  forms,  with  or  without
+//  modification,  are   permitted  provided  that  the  following  conditions
+//  are met:
+//
+//    * Redistributions  of  source  code  must  retain  the  above  copyright
+//      notice, this list of conditions and the following disclaimer.
+//    * Redistributions in  binary form  must  reproduce  the  above copyright
+//      notice,  this  list of  conditions  and  the  following disclaimer  in
+//      the   documentation   and/or   other   materials   provided  with  the
+//      distribution.
+//    * Neither   the  name   of  Intel  Corporation  nor  the  names  of  its
+//      contributors  may  be  used  to  endorse  or promote  products derived
+//      from this software without specific prior written permission.
+//
+//  THIS  SOFTWARE  IS  PROVIDED  BY  THE  COPYRIGHT HOLDERS  AND CONTRIBUTORS
+//  "AS IS"  AND  ANY  EXPRESS  OR  IMPLIED  WARRANTIES,  INCLUDING,  BUT  NOT
+//  LIMITED  TO, THE  IMPLIED WARRANTIES OF  MERCHANTABILITY  AND FITNESS  FOR
+//  A  PARTICULAR  PURPOSE  ARE  DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT
+//  OWNER OR CONTRIBUTORS BE LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,
+//  SPECIAL,  EXEMPLARY,  OR  CONSEQUENTIAL   DAMAGES  (INCLUDING,   BUT   NOT
+//  LIMITED  TO,  PROCUREMENT  OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF USE,
+//  DATA,  OR PROFITS;  OR BUSINESS INTERRUPTION)  HOWEVER  CAUSED  AND ON ANY
+//  THEORY  OF  LIABILITY,  WHETHER  IN  CONTRACT,  STRICT LIABILITY,  OR TORT
+//  (INCLUDING  NEGLIGENCE  OR OTHERWISE) ARISING  IN ANY WAY  OUT  OF THE USE
+//  OF  THIS  SOFTWARE, EVEN IF ADVISED  OF  THE  POSSIBILITY  OF SUCH DAMAGE.
+//******************************************************************************
+//****************************************************************************
+/// @file kosal.h
+/// @brief Defines the scalar type abstraction used by AAL.
+/// @ingroup kOSAL
+/// @verbatim
+/// Accelerator Abstraction Layer
+/// OS Kernel Abstraction Layer library definitions
+///
+///  AUTHORS:  Joseph Grecco, Intel Corporation
+///            Tim Whisonant, Intel Corporation
+///
+/// PURPOSE:
+/// HISTORY:
+/// WHEN:          WHO:     WHAT:
+/// 12/27/2012     JG       Initial version started
+//****************************************************************************
+#include <aalsdk/kernel/aaltypes.h>
+
+#ifndef PCI_VENDOR_ID_INTEL
+# define PCI_VENDOR_ID_INTEL 0x8086
+#endif // PCI_VENDOR_ID_INTEL
+
+#if defined( __AAL_KERNEL__ )
+
+#ifndef __AALSDK_KERNEL_KOSAL_H__
+#define __AALSDK_KERNEL_KOSAL_H__
+
+#ifdef __AAL_UNKNOWN_OS__
+# error Update kosal for unknown OS.
+#endif // __AAL_UNKNOWN_OS__
+
+
+//
+// Temporary Workarounds - TO BE REMOVED
+//
+#if   defined( __AAL_LINUX__ )
+
+#define UNREFERENCED_PARAMETER(p)
+
+#elif defined( __AAL_WINDOWS__ )
+
+#endif // OS
+
+
+//
+// Modules
+//
+#if   defined( __AAL_LINUX__ )
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+// Used for reference counting
+typedef struct module *kosal_ownermodule;
+
+#elif defined( __AAL_WINDOWS__ )
+
+// Undefined - Used for reference counting
+typedef void * kosal_ownermodule;
+
+#endif
+
+// Generic number of elements in an array macro
+#if !defined(NUM_ELEMENTS)
+#  define NUM_ELEMENTS(array) (sizeof(array)/sizeof(array[0]))
+#endif
+
+
+#ifdef __cplusplus
+# define KOSAL_INT       AAL::btInt
+# define KOSAL_UINT      AAL::btUnsignedInt
+# define KOSAL_U32       AAL::btUnsigned32bitInt
+# define KOSAL_U64       AAL::btUnsigned64bitInt
+# define KOSAL_PID       AAL::btPID
+# define KOSAL_TID       AAL::btTID
+# define KOSAL_BYTEARRAY AAL::btByteArray
+# define KOSAL_ANY       AAL::btAny
+# define KOSAL_TIME      AAL::btTime
+# define KOSAL_BOOL      AAL::btBool
+# define KOSAL_VIRT      AAL::btVirtAddr
+# define KOSAL_PHYS      AAL::btPhysAddr
+# define KOSAL_WSSIZE    AAL::btWSSize
+# define KOSAL_HANDLE    AAL::btHANDLE
+
+#else
+// C doesn't comprehend C++ namespaces.
+# define KOSAL_INT       btInt
+# define KOSAL_UINT      btUnsignedInt
+# define KOSAL_U32       btUnsigned32bitInt
+# define KOSAL_U64       btUnsigned64bitInt
+# define KOSAL_PID       btPID
+# define KOSAL_TID       btTID
+# define KOSAL_BYTEARRAY btByteArray
+# define KOSAL_ANY       btAny
+# define KOSAL_TIME      btTime
+# define KOSAL_BOOL      btBool
+# define KOSAL_VIRT      btVirtAddr
+# define KOSAL_PHYS      btPhysAddr
+# define KOSAL_WSSIZE    btWSSize
+# define KOSAL_HANDLE    btHANDLE
+
+#endif // __cplusplus
+
+
+//
+// Debug printing
+//
+#define KOSAL_DBG_MOD      ((KOSAL_UINT)1 <<  0)
+
+#define AALBUS_DBG_MOD     ((KOSAL_UINT)1 <<  0)
+#define AALBUS_DBG_FILE    ((KOSAL_UINT)1 <<  1)
+#define AALBUS_DBG_MMAP    ((KOSAL_UINT)1 <<  2)
+#define AALBUS_DBG_IOCTL   ((KOSAL_UINT)1 <<  3)
+#define AALBUS_DBG_POLL    ((KOSAL_UINT)1 <<  4)
+
+#define AALRMC_DBG_MOD     ((KOSAL_UINT)1 <<  0)
+#define AALRMC_DBG_FILE    ((KOSAL_UINT)1 <<  1)
+#define AALRMC_DBG_MMAP    ((KOSAL_UINT)1 <<  2)
+#define AALRMC_DBG_IOCTL   ((KOSAL_UINT)1 <<  3)
+
+#define AALRMS_DBG_MOD     ((KOSAL_UINT)1 <<  0)
+#define AALRMS_DBG_FILE    ((KOSAL_UINT)1 <<  1)
+#define AALRMS_DBG_MMAP    ((KOSAL_UINT)1 <<  2)
+#define AALRMS_DBG_IOCTL   ((KOSAL_UINT)1 <<  3)
+
+#define UIDRV_DBG_MOD      ((KOSAL_UINT)1 <<  0)
+#define UIDRV_DBG_FILE     ((KOSAL_UINT)1 <<  1)
+#define UIDRV_DBG_MMAP     ((KOSAL_UINT)1 <<  2)
+#define UIDRV_DBG_IOCTL    ((KOSAL_UINT)1 <<  3)
+
+#define CCIPCIE_DBG_MOD       ((KOSAL_UINT)1 <<  0)
+#define CCIPCIE_DBG_DEV       ((KOSAL_UINT)1 <<  1)
+#define CCIPCIE_DBG_AFU       ((KOSAL_UINT)1 <<  2)
+#define CCIPCIE_DBG_MAFU      ((KOSAL_UINT)1 <<  3)
+#define CCIPCIE_DBG_MMAP      ((KOSAL_UINT)1 <<  4)
+#define CCIPCIE_DBG_CMD       ((KOSAL_UINT)1 <<  5)
+#define CCIPCIE_DBG_CFG       ((KOSAL_UINT)1 <<  6)
+
+#define FAPDIAG_DBG_MOD    ((KOSAL_UINT)1 <<  0)
+
+
+#if (1 == ENABLE_DEBUG)
+extern KOSAL_UINT debug; // Bit mask defined by module, DRV_NAME similarly
+#endif // ENABLE_DEBUG
+
+#define KOSAL_PRINTK_DRV_NAME_FMT "10s"
+#define KOSAL_PRINTK_FILE_FMT     "21s"
+#define KOSAL_PRINTK_LINE_FMT      "4d"
+#define KOSAL_PRINTK_FN_FMT       "35s"
+
+#if   defined( __AAL_LINUX__ )
+# define KOSAL_PRINTK_PID_FMT "5d"
+# define KOSAL_PRINTK_TID_FMT "5llu"
+# define kosal_printk_level_here(_level, _file, _line, _fn, _fmt, ...)                                                                                                                                  \
+   printk(_level "[%" KOSAL_PRINTK_DRV_NAME_FMT ",%" KOSAL_PRINTK_FILE_FMT ",%" KOSAL_PRINTK_LINE_FMT ",%" KOSAL_PRINTK_FN_FMT "(),pid=%" KOSAL_PRINTK_PID_FMT ",tid=%" KOSAL_PRINTK_TID_FMT "] " _fmt, \
+             DRV_NAME, _file, _line, _fn, kosal_get_pid(), kosal_get_tid(), __VA_ARGS__)
+# if (1 == ENABLE_DEBUG)
+#    define kosal_printk_level(_level, _fmt, ...)                                                                                                                                                            \
+        printk(_level "[%" KOSAL_PRINTK_DRV_NAME_FMT ",%" KOSAL_PRINTK_FILE_FMT ",%" KOSAL_PRINTK_LINE_FMT ",%" KOSAL_PRINTK_FN_FMT "(),pid=%" KOSAL_PRINTK_PID_FMT ",tid=%" KOSAL_PRINTK_TID_FMT "] " _fmt, \
+        		DRV_NAME, __AAL_SHORT_FILE__, __LINE__, __AAL_FUNC__, kosal_get_pid(), kosal_get_tid(), ##__VA_ARGS__)
+
+# else
+#    define kosal_printk_level(_level, _fmt, ...) printk(_level "[%" KOSAL_PRINTK_DRV_NAME_FMT "] " _fmt, DRV_NAME, ##__VA_ARGS__)
+# endif // ENABLE_DEBUG
+#elif defined( __AAL_WINDOWS__ )
+// wdm.h
+# define KERN_EMERG   0
+# define KERN_ALERT   1
+# define KERN_CRIT    2
+# define KERN_ERR     3
+# define KERN_WARNING 4
+# define KERN_NOTICE  5
+# define KERN_INFO    6
+# define KERN_DEBUG   7
+# define KERN_DEFAULT 8
+# define KERN_CONT    9
+# define kosal_printk_level_here(_level, _file, _line, _fn, _fmt, ...)                                                                               \
+   DbgPrint("[%" KOSAL_PRINTK_DRV_NAME_FMT ",%" KOSAL_PRINTK_FILE_FMT ",%" KOSAL_PRINTK_LINE_FMT ",%" KOSAL_PRINTK_FN_FMT "(),pid=%u,tid=%u] " _fmt, \
+               DRV_NAME, _file, _line, _fn, kosal_get_pid(), kosal_get_tid(), __VA_ARGS__)
+# if (1 == ENABLE_DEBUG)
+#    define kosal_printk_level(_level, _fmt, ...)                                                                                                         \
+        DbgPrint("[%" KOSAL_PRINTK_DRV_NAME_FMT ",%" KOSAL_PRINTK_FILE_FMT ",%" KOSAL_PRINTK_LINE_FMT ",%" KOSAL_PRINTK_FN_FMT "(),pid=%u,tid=%u] " _fmt, \
+                    DRV_NAME, __AAL_SHORT_FILE__, __LINE__, __AAL_FUNC__, kosal_get_pid(), kosal_get_tid(), ## __VA_ARGS__)
+# else
+#    define kosal_printk_level(_level, _fmt, ...) DbgPrint("[%" KOSAL_PRINTK_DRV_NAME_FMT "] " _fmt, DRV_NAME, __VA_ARGS__)
+# endif // ENABLE_DEBUG
+#endif // OS
+
+#define kosal_printk(_fmt, ...) kosal_printk_level(KERN_ERR, _fmt, ## __VA_ARGS__)
+
+
+#if (1 == ENABLE_DEBUG)
+# define DPRINTF(_level, _fmt, ...)                                       \
+do                                                                        \
+{                                                                         \
+   if ( flag_is_set(debug, _level) ) { kosal_printk(_fmt, ##__VA_ARGS__); } \
+}while(0)
+#else
+# ifdef DPRINTF
+#    undef DPRINTF
+# endif // DPRINTF
+# define DPRINTF(_level, _fmt, ...) do{}while(0)
+#endif // ENABLE_DEBUG
+
+//=============================================================================
+//=============================================================================
+// PDEBUG & Friends, including PTRACE, PINFO, PNOTICE, PWARNING, PERR, PCRIT,...
+// These only exist if the module was built with the DEBUG flag
+//=============================================================================
+//=============================================================================
+//
+//------>>   unsigned debug; and DRV_NAME are expected to be #defined  <<------
+//------>>    and resolvable in each file that includes this header    <<------
+//
+//=============================================================================
+//=============================================================================
+// USAGE:
+//
+// For each logical module to be debugged individually, define a bit flag, as so:
+
+/* (sans comments, of course)
+#define MEMMGR_DBG_MOD   (1 << 0)
+#define MEMMGR_DBG_MEM   (1 << 1)
+#define MEMMGR_DBG_MMAP  (1 << 2)
+#define MEMMGR_DBG_IOCTL (1 << 3)
+*/
+
+//
+// And in the place where the int debug variable is defined, use a statement such
+//    as this:  [just use the stuff in the #if block -- it is there to prevent problems]
+
+/* (sans comments, of course)
+unsigned debug = 0
+// Type and Level selection flags
+   | PTRACE_FLAG
+   | PVERBOSE_FLAG
+   | PDEBUG_FLAG
+   | PINFO_FLAG
+   | PNOTICE_FLAG
+// Module selection flags
+   | MEMMGR_DBG_MOD
+   | MEMMGR_DBG_MEM
+   | MEMMGR_DBG_MMAP
+   | MEMMGR_DBG_IOCTL
+;
+*/
+
+//
+// Comment out any of the items you do not wish to trace.
+//
+// PTRACE_FLAG enables PTRACEIN/OUT and friends to show entry/exit of functions.
+//    Caveat: PTRACE prints at KERN_DEBUG level, so if syslog is blocking KERN_DEBUG and PTRACE is also blocked
+//
+// PVERBOSE_FLAG to PNOTICE_FLAG set the levels that are allowed to be printed, independently of the
+//    syslog level setting. The reason is that we generally debug with syslog set to DEBUG, but in fact that
+//    can be overly verbose. So, once the sub-system is working fairly well, I will disable the more verbose
+//    levels.
+//    Caveat: at the current time each level is a bitflag and so it is possible (although not likely what
+//       you would want to do) to print out VERBOSE and NOTICE levels but not DEBUG or INFO by setting the
+//       appropriate bits.
+//
+// Syslog levels of WARNING and above do not have module selection or specific level flags, since
+//    anything at that level is (presumably) important enough to always print and also not voluminous.
+//
+//=============================================================================
+//=============================================================================
+                                 // Disabling KERN_DEBUG in syslog also disables VERBOSE and TRACE
+#define PTRACE_FLAG     ((KOSAL_UINT)1 << 31)  // Add this to the debug flags if you want PTRACING
+                                 //    0x8000_0000
+#define PVERBOSE_FLAG   ((KOSAL_UINT)1 << 30)  // Add this to the debug flags if you want VERBOSE debugging
+                                 //    0x4000_0000
+#define PDEBUG_FLAG     ((KOSAL_UINT)1 << 29)  // Add this to the debug flags if you want DEBUG debugging
+                                 //    0x2000_0000
+#define PINFO_FLAG      ((KOSAL_UINT)1 << 28)  // Add this to the debug flags if you want INFO debugging
+                                 //    0x1000_0000
+#define PNOTICE_FLAG    ((KOSAL_UINT)1 << 27)  // Add this to the debug flags if you want NOTICE debugging
+                                 //    0x0800_0000
+
+#define PMEMORY_FLAG    ((KOSAL_UINT)1 << 26)  // Add this to the debug flags if you want memory alloc/free debugging
+                                 //    0x0400_0000
+#define PPCI_FLAG       ((KOSAL_UINT)1 << 25)  // Add this to the debug flags if you want PCI(e) OS calls debugging
+                                 //    0x0200_0000
+#define PPOLLING_FLAG   ((KOSAL_UINT)1 << 24)  // Add this to the debug flags if you want poll/spin calls debugging
+                                 //    0x0100_0000
+
+///////////////////////////////////////////////////////////////////////////////
+//
+// DEBUG PRINT MACROS that test debug flag for level before printing
+//
+// DRV_NAME must be defined; typically in the module-int.h file
+// MODULE_FLAGS must be defined to be one of the Module Selection Flags,
+//    e.g. MEMMGR_DBG_MOD. MODULE_FLAGS should be defined in each *.c file
+//    BEFORE #including <kosal.h>
+//    This makes all print statements in the file and in all header files
+//       included by the file all have consistent MODULE_FLAGS.
+//    Being able to properly handle #included files is a new feature that did
+//       not work well with the older system
+//
+///////////////////////////////////////////////////////////////////////////////
+
+#if (1 == ENABLE_DEBUG)
+// Prints if syslog >= KERN_DEBUG && specific module flag set
+# define PDEBUG(_fmt, ...) \
+   if ( flags_are_set(debug, MODULE_FLAGS|PDEBUG_FLAG) ) { kosal_printk_level(KERN_DEBUG, "d:" _fmt, ##__VA_ARGS__); }
+
+// Prints if syslog >= KERN_DEBUG && specific module flag set && VERBOSE flag set
+# define PVERBOSE(_fmt, ...) \
+   if ( flags_are_set(debug, MODULE_FLAGS|PVERBOSE_FLAG) ) { kosal_printk_level(KERN_DEBUG, "v:" _fmt, ##__VA_ARGS__); }
+
+// Prints if syslog >= KERN_INFO && specific module flag set
+# define PINFO(_fmt, ...) \
+   if ( flags_are_set(debug, MODULE_FLAGS|PINFO_FLAG) ) { kosal_printk_level(KERN_INFO, "i:" _fmt, ##__VA_ARGS__); }
+
+// Prints if syslog >= KERN_NOTICE && specific module flag set
+# define PNOTICE(_fmt, ...) \
+   if ( flags_are_set(debug, MODULE_FLAGS|PNOTICE_FLAG) ) { kosal_printk_level(KERN_NOTICE, "n:" _fmt, ##__VA_ARGS__); }
+
+// Prints if syslog >= KERN_DEBUG && specific module flag set
+# if (1 == ENABLE_ASSERT)
+#    define PMEMORY_HERE(_fmt, ...) \
+        if ( flags_are_set(debug, MODULE_FLAGS|PMEMORY_FLAG) ) { kosal_printk_level_here(KERN_DEBUG, __file, __line, __fn, "mem:" _fmt, __VA_ARGS__); }
+# else
+#    define PMEMORY_HERE(_fmt, ...)
+# endif // ENABLE_ASSERT
+# define PMEMORY(_fmt, ...) \
+   if ( flags_are_set(debug, MODULE_FLAGS|PMEMORY_FLAG) ) { kosal_printk_level(KERN_DEBUG, "mem:" _fmt, ##__VA_ARGS__); }
+
+// Prints if syslog >= KERN_DEBUG && specific module flag set
+# if (1 == ENABLE_ASSERT)
+#    define PPCI_HERE(_fmt, ...) \
+        if ( flags_are_set(debug, MODULE_FLAGS|PPCI_FLAG) ) { kosal_printk_level_here(KERN_DEBUG, __file, __line, __fn, "pci:" _fmt, __VA_ARGS__); }
+# else
+#    define PPCI_HERE(_fmt, ...)
+# endif // ENABLE_ASSERT
+# define PPCI(_fmt, ...) \
+   if ( flags_are_set(debug, MODULE_FLAGS|PPCI_FLAG) ) { kosal_printk_level(KERN_DEBUG, "pci:" _fmt, ##__VA_ARGS__); }
+
+// Prints if syslog >= KERN_DEBUG && specific module flag set
+# if (1 == ENABLE_ASSERT)
+#    define PPOLLING_HERE(_fmt, ...) \
+        if ( flags_are_set(debug, MODULE_FLAGS|PPOLLING_FLAG) ) { kosal_printk_level_here(KERN_DEBUG, __file, __line, __fn, "poll:" _fmt, __VA_ARGS__); }
+# else
+#    define PPOLLING_HERE(_fmt, ...)
+# endif // ENABLE_ASSERT
+# define PPOLLING(_fmt, ...) \
+   if ( flags_are_set(debug, MODULE_FLAGS|PPOLLING_FLAG) ) { kosal_printk_level(KERN_DEBUG, "poll:" _fmt, ##__VA_ARGS__); }
+
+#else
+# ifdef PDEBUG
+#    undef PDEBUG
+# endif // PDEBUG
+# define PDEBUG(_fmt, ...)        do{}while(0)
+# ifdef PVERBOSE
+#    undef PVERBOSE
+# endif // PVERBOSE
+# define PVERBOSE(_fmt, ...)      do{}while(0)
+# ifdef PINFO
+#    undef PINFO
+# endif // PINFO
+# define PINFO(_fmt, ...)         do{}while(0)
+# ifdef PNOTICE
+#    undef PNOTICE
+# endif // PNOTICE
+# define PNOTICE(_fmt, ...)       do{}while(0)
+# ifdef PMEMORY_HERE
+#    undef PMEMORY_HERE
+# endif // PMEMORY_HERE
+# define PMEMORY_HERE(_fmt, ...)  do{}while(0)
+# ifdef PMEMORY
+#    undef PMEMORY
+# endif // PMEMORY
+# define PMEMORY(_fmt, ...)       do{}while(0)
+# ifdef PPCI_HERE
+#    undef PPCI_HERE
+# endif // PPCI_HERE
+# define PPCI_HERE(_fmt, ...)     do{}while(0)
+# ifdef PPCI
+#    undef PPCI
+# endif // PPCI
+# define PPCI(_fmt, ...)          do{}while(0)
+# ifdef PPOLLING_HERE
+#    undef PPOLLING_HERE
+# endif // PPOLLING_HERE
+# define PPOLLING_HERE(_fmt, ...) do{}while(0)
+# ifdef PPOLLING
+#    undef PPOLLING
+# endif // PPOLLING
+# define PPOLLING(_fmt, ...)      do{}while(0)
+#endif // ENABLE_DEBUG
+
+///////////////////////////////////////////////////////////////////////////////
+//
+// DEBUG TRACE MACROS
+//
+///////////////////////////////////////////////////////////////////////////////
+
+#if (1 == ENABLE_DEBUG)
+// Prints if syslog >= KERN_INFO && PTRACE flag set
+# define PTRACEIN \
+   ( flag_is_set(debug, PTRACE_FLAG) ? kosal_printk_level(KERN_INFO, "t:Enter\n"), 1 : 0 )
+
+// Prints if syslog >= KERN_INFO && PTRACE flag set
+# define PTRACEOUT \
+   ( flag_is_set(debug, PTRACE_FLAG) ? kosal_printk_level(KERN_INFO, "t:Exit\n"), 1 : 0 )
+
+// Do not call this from a function -- it is internal worker for PTRACEOUT_type macros
+# define _PTRACEOUT_RET(_retval, _printf_fmt) \
+   ( flag_is_set(debug, PTRACE_FLAG) ? kosal_printk_level(KERN_INFO, "t:Exit %" #_printf_fmt "\n", _retval), 1 : 0 )
+
+// Prints if syslog >= KERN_INFO && PTRACE flag set
+// These are for specific types of return values, and will print them accordingly.
+# define PTRACEOUT_INT(_retval)  _PTRACEOUT_RET(_retval, d)
+# define PTRACEOUT_LINT(_retval) _PTRACEOUT_RET(_retval, ld)
+# define PTRACEOUT_PTR(_retval)  _PTRACEOUT_RET(_retval, p)
+
+#else
+# ifdef PTRACEIN
+#    undef PTRACEIN
+# endif // PTRACEIN
+# define PTRACEIN                do{}while(0)
+# ifdef PTRACEOUT
+#    undef PTRACEOUT
+# endif // PTRACEOUT
+# define PTRACEOUT               do{}while(0)
+# ifdef PTRACEOUT_INT
+#    undef PTRACEOUT_INT
+# endif // PTRACEOUT_INT
+# define PTRACEOUT_INT(_retval)  do{}while(0)
+# ifdef PTRACEOUT_LINT
+#    undef PTRACEOUT_LINT
+# endif // PTRACEOUT_LINT
+# define PTRACEOUT_LINT(_retval) do{}while(0)
+# ifdef PTRACEOUT_PTR
+#    undef PTRACEOUT_PTR
+# endif // PTRACEOUT_PTR
+# define PTRACEOUT_PTR(_retval)  do{}while(0)
+#endif // ENABLE_DEBUG
+
+//=============================================================================
+//=============================================================================
+// PINFO & Friends, including PNOTICE, PWARNING, PERR, PCRIT,...
+// These ALWAYS exist, and are used for standard always on printing
+//
+// DRV_NAME is expected to be #defined
+//
+//=============================================================================
+//=============================================================================
+
+#define PWARN(_fmt, ...)  ( kosal_printk_level(KERN_WARNING, "w:" _fmt, ##__VA_ARGS__) )
+#define PERR(_fmt, ...)   ( kosal_printk_level(KERN_ERR,     "e:" _fmt, ##__VA_ARGS__) )
+#define PCRIT(_fmt, ...)  ( kosal_printk_level(KERN_CRIT,    "c:" _fmt, ##__VA_ARGS__) )
+#define PALERT(_fmt, ...) ( kosal_printk_level(KERN_ALERT,   "a:" _fmt, ##__VA_ARGS__) )
+#define PEMERG(_fmt, ...) ( kosal_printk_level(KERN_EMERG,   "E:" _fmt, ##__VA_ARGS__) )
+
+//=============================================================================
+//=============================================================================
+//                         THOUGHTS FOR THE FUTURE
+//=============================================================================
+//=============================================================================
+//
+// CAVEAT: This is not a particularly clever implementation, and I do not yet (and may never) have an
+//    implementation that allows levels specific to individual modules, which is probably what is
+//    really needed. That would allow one to set VERBOSE for the current development module while
+//    only looking at DEBUG or INFO level on already debugged modules. I think that is the holy grail.
+// For example an easy way to do it would be to have separate debug variables for each sub-system.
+// And/Or, for up to N modules in each sub-system, define each module as a 32/N slice, and specify levels
+//    within that slice. E.g.
+//    Assuming 5 flags needed define:
+//       MEMMGR_MOD_TRACE
+//       MEMMGR_MOD_VERBOSE
+//       MEMMGR_MOD_DEBUG
+//       MEMMGR_MOD_INFO
+//       MEMMGR_MOD_NOTICE
+//           ...
+//       MEMMGR_MEM_TRACE
+//       MEMMGR_MEM_VERBOSE
+//       MEMMGR_MEM_DEBUG
+//       MEMMGR_MEM_INFO
+//       MEMMGR_MEM_NOTICE
+//    and select against each of these individually ...
+//
+//    Something like:
+//       #define MEMMGR_MOD 0
+//       #define MEMMGR_MEM 5
+//            ...
+//       #define PTRACE_SHIFT   0
+//       #define PVERBOSE_SHIFT 1
+//       #define PDEBUG_SHIFT   2
+//       #define PINFO_SHIFT    3
+//       #define PNOTICE_SHIFT  4
+//            ...
+//       PTRACEIN(MEMMGR_MEM);   // test against bit (1 << [(MEMMGR_MEM + PTRACE_SHIFT) = 5])
+//       PDEBUG  (MEMMGR_MEM);   // test against bit (1 << [(MEMMGR_MEM + PDEBUG_SHIFT) = 7])
+//
+//    and the debug variable definition becomes something like:
+//       int debug = 0
+//          | 1 << (MEMMGR_MOD + PTRACE_SHIFT)
+//          | 1 << (MEMMGR_MOD + PVERBOSE_SHIFT)
+//          | 1 << (MEMMGR_MOD + PDEBUG_SHIFT)
+//          | 1 << (MEMMGR_MOD + PINFO_SHIFT)
+//          | 1 << (MEMMGR_MOD + PNOTICE_SHIFT)
+//          | 1 << (MEMMGR_MEM + PTRACE_SHIFT)
+//          | 1 << (MEMMGR_MEM + PVERBOSE_SHIFT)
+//          | 1 << (MEMMGR_MEM + PDEBUG_SHIFT)
+//          | 1 << (MEMMGR_MEM + PINFO_SHIFT)
+//          | 1 << (MEMMGR_MEM + PNOTICE_SHIFT)
+//       ;
+//    You now have very fine grained control at the module and debug level...
+//
+// Prints if syslog >= KERN_DEBUG && specific module flag set
+//
+// Only one flag is passed in, which is the module flag, and expected to
+//    be one (or more -- but that kind of defeats the purpose) of 0, 5, 10, ...
+/*
+#define PDEBUG(module_flag, fmt, args...) do { \
+   if ( (debug & ( (module_flag) << PDEBUG_SHIFT)) ) { \
+      printk(KERN_DEBUG "d:" DRV_NAME ":%s[%d] " fmt, __AAL_FUNC__, current->tgid, ##args); \
+   } \
+} while (0)
+*/
+//
+// The call is:
+//    PDEBUG( MEMMGR_MEM, ...);
+//
+// The limitation is that one can define only 6 sub-modules with a 32-bit debug variable ...
+//
+//=============================================================================
+// Another thing -- sometimes want multi-line output, e.g. some information with
+//    all the goodies like function name and module, etc., but then a bunch of
+//    lines that are not so long. Could enable it with a special flag added
+//    specifically, e.g.:
+//    PDEBUG( MEMMGR_MOD, < regular stuff > )
+//    for () PDEBUG( MEMMGR_MOD+PCLEAN, < no header needed stuff >
+//
+//  The "no header needed stuff" still needs to go through the same checking, but it doesn't need all
+//    the acouterments. Possible implementation is extra bit flag removed before check. Something like:
+//    #define PCLEAN 1<<31
+/*
+#define PDEBUG(module_flag, fmt, args...) do { \
+   if ( (debug & ( (module_flag) << PDEBUG_SHIFT)) ) { \
+      char *pstr; \
+      if ( module_flag & PCLEAR) pstr=KERN_DEBUG; \
+      else pstr=KERN_DEBUG "d:" DRV_NAME ":%s[%d] " fmt; \
+      printk( pstr, __AAL_FUNC__, current->tgid, ##args); \
+   } \
+} while (0)
+*/
+//=============================================================================
+//=============================================================================
+
+
+//
+// Error Codes & Misc.
+//
+#if   defined( __AAL_LINUX__ )
+# include <linux/version.h> // LINUX_VERSION_CODE
+# include <linux/stddef.h>
+# define kosal_offsetof(_type, _memb) offsetof(_type, _memb)
+# define kosal_container_of(_ptr, _type, _memb) container_of(_ptr, _type, _memb)
+# include <linux/errno.h>
+# include <linux/compiler.h>  // likely(), unlikely(), etc.
+# include <linux/sched.h>
+# define kosal_get_pid() (KOSAL_PID)( current->tgid )
+# define kosal_get_tid() (KOSAL_TID)( current->pid  )
+
+typedef struct bus_type kosal_bus_type, *pkosal_bus_type;
+
+#elif defined( __AAL_WINDOWS__ )
+# include <stddef.h>
+# define kosal_offsetof(_type, _memb) offsetof(_type, _memb)
+# define kosal_container_of(_ptr, _type, _memb) ( (_type *)( (KOSAL_BYTEARRAY)(_ptr) - kosal_offsetof(_type, _memb) ) )
+# include <crt/errno.h>
+# ifndef likely
+#    define likely(x) x
+# endif // likely
+# ifndef unlikely
+#    define unlikely(x) x
+# endif // unlikely
+# include <ntddk.h>
+# define kosal_get_pid() (KOSAL_PID)PsGetCurrentProcessId()
+# define kosal_get_tid() (KOSAL_TID)PsGetCurrentThreadId()
+
+typedef KOSAL_ANY           kosal_bus_type, *pkosal_bus_type;
+
+#endif // OS
+
+#define kosal_get_object_containing(_ptr, _type, _memb) kosal_container_of(_ptr, _type, _memb)
+
+KOSAL_INT _kosal_mdelay(__ASSERT_HERE_PROTO KOSAL_TIME );
+#ifdef kosal_mdelay
+# undef kosal_mdelay
+#endif // kosal_mdelay
+#define kosal_mdelay(__delay) _kosal_mdelay(__ASSERT_HERE_ARGS __delay)
+
+KOSAL_INT _kosal_udelay(__ASSERT_HERE_PROTO KOSAL_TIME );
+#ifdef kosal_udelay
+# undef kosal_udelay
+#endif // kosal_udelay
+#define kosal_udelay(__delay) _kosal_udelay(__ASSERT_HERE_ARGS __delay)
+
+//
+// PCI Device
+//
+#if   defined( __AAL_LINUX__ )
+# include <linux/pci.h>
+  typedef struct pci_dev         kosal_pci_dev, *pkosal_pci_dev;
+  typedef struct device          kosal_os_dev,  *pkosal_os_dev;
+#elif defined( __AAL_WINDOWS__ )
+# include <wdm.h>
+  typedef BUS_INTERFACE_STANDARD kosal_pci_dev, *pkosal_pci_dev;
+  typedef KOSAL_ANY              kosal_os_dev,  *pkosal_os_dev;
+#endif // OS
+
+KOSAL_INT _kosal_pci_read_config_dword(__ASSERT_HERE_PROTO pkosal_pci_dev , KOSAL_U32 , KOSAL_U32 * );
+#ifdef kosal_pci_read_config_dword
+# undef kosal_pci_read_config_dword
+#endif // kosal_pci_read_config_dword
+#define kosal_pci_read_config_dword(__pdev, __offset, __pval) _kosal_pci_read_config_dword(__ASSERT_HERE_ARGS __pdev, __offset, __pval)
+
+//
+// Semaphore
+//
+#if   defined( __AAL_LINUX__ )
+# if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,27)
+#    include <asm/semaphore.h>
+# else
+#    include <linux/semaphore.h>
+# endif // < KERNEL_VERSION(2,6,27)
+
+  typedef struct semaphore kosal_semaphore, *pkosal_semaphore;
+// Count (c) cannot be negative.
+# define kosal_sem_init(sptr, c)  do{ ASSERT(c >= 0); sema_init(sptr, c); }while(0)
+
+// Non-alertable, infinite wait. When thread is servicing a user process and running in the user process context.
+# define kosal_sem_get_user(sptr) down(sptr)
+
+// Alertable wait. When thread is servicing a user process and running in the user process context.
+// returns true if interrupted.
+# define kosal_sem_get_user_alertable(sptr) (KOSAL_BOOL)down_interruptible(sptr)
+
+// Non-alertable, infinite wait. When thread is not servicing a user process.
+# define kosal_sem_get_krnl(sptr) down(sptr)
+
+// Alertable wait. When thread is not servicing a user process.
+// returns true if interrupted.
+# define kosal_sem_get_krnl_alertable(sptr) (KOSAL_BOOL)down_interruptible(sptr)
+
+// Release one count of the semaphore.
+# define kosal_sem_put(sptr)      up(sptr)
+
+#elif defined( __AAL_WINDOWS__ )
+  #include <ntdef.h>
+  typedef KSEMAPHORE       kosal_semaphore, *pkosal_semaphore;
+
+// Count (c) cannot be negative.
+// Last parameter is number of threads to resume when sem is put.
+# define kosal_sem_init(sptr, c)  do{ ASSERT(c >= 0); KeInitializeSemaphore(sptr, c, 1); }while(0)
+
+// Non-alertable, infinite wait. When thread is servicing a user process and running in the user process context.
+static inline
+void kosal_sem_get_user(pkosal_semaphore sptr) {                                                                          
+   NTSTATUS __s;                                                           
+   do                                                                         
+   {                                                                          
+     __s = KeWaitForSingleObject(sptr, UserRequest, KernelMode, FALSE, NULL); 
+   } while( STATUS_SUCCESS != __s && STATUS_ABANDONED_WAIT_0 != __s ); 
+}
+
+// Alertable wait. When thread is servicing a user process and running in the user process context.
+// returns true if alerted/abandoned.
+static inline
+KOSAL_BOOL kosal_sem_get_user_alertable(pkosal_semaphore sptr) {
+   NTSTATUS __s;
+   do
+   {
+      __s = KeWaitForSingleObject(sptr, UserRequest, KernelMode, TRUE, NULL);
+   } while( STATUS_SUCCESS != __s && STATUS_ALERTED != __s && STATUS_ABANDONED_WAIT_0 != __s );
+   return STATUS_SUCCESS != __s;
+}
+
+// Non-alertable, infinite wait. When thread is not servicing a user process.
+static inline 
+void kosal_sem_get_krnl(pkosal_semaphore sptr) {                                                                          
+   NTSTATUS __s;                                                           
+   do                                                                         
+   {                                                                          
+     __s = KeWaitForSingleObject(sptr, Executive,   KernelMode, FALSE, NULL); 
+   } while( STATUS_SUCCESS != __s && STATUS_ABANDONED_WAIT_0 != __s ); 
+}
+
+// Alertable wait. When thread is not servicing a user process.
+// returns true if alerted/abandoned.
+static inline
+KOSAL_BOOL kosal_sem_get_krnl_alertable(pkosal_semaphore sptr) {
+   NTSTATUS __s;
+   do
+   {
+      __s = KeWaitForSingleObject(sptr, Executive, KernelMode, TRUE, NULL);
+   } while( STATUS_SUCCESS != __s && STATUS_ALERTED != __s && STATUS_ABANDONED_WAIT_0 != __s );
+   return STATUS_SUCCESS != __s;
+}
+
+// Release one count of the semaphore. Count must not be negative.
+# define kosal_sem_put(sptr)      KeReleaseSemaphore(sptr, 0, 1, FALSE)
+
+#endif // OS
+
+//
+// Mutex
+//
+typedef kosal_semaphore kosal_mutex, *pkosal_mutex;
+#define kosal_mutex_init(mptr) kosal_sem_init(mptr, 1)
+
+//
+// List
+//
+#if   defined( __AAL_LINUX__ )
+# include <linux/list.h>
+  typedef struct list_head kosal_list_head, *pkosal_list_head;
+# define kosal_list_prev(_h)                 (_h)->prev
+# define kosal_list_next(_h)                 (_h)->next
+
+# define kosal_list_init(_h)                 INIT_LIST_HEAD(_h)
+# define kosal_list_is_empty(_h)             list_empty(_h)
+
+# define kosal_list_add_head(_new, _h)       list_add(_new, _h)
+# define kosal_list_add_tail(_new, _h)       list_add_tail(_new, _h)
+
+# define kosal_list_del_init(_h)             list_del_init(_h)
+# define kosal_list_del(_h)                  list_del(_h)
+
+# define kosal_list_replace(_old, _new)      list_replace(_old, _new)
+
+# if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,16)
+#    define kosal_list_replace_init(_old, _new) list_replace_init(_old, _new)
+# else
+#    define kosal_list_replace_init(_old, _new) do{ list_replace_rcu(_old, _new); INIT_LIST_HEAD(_old); }while(0)
+# endif // > KERNEL_VERSION(2,6,16)
+
+# define kosal_list_move(_new, _h)           list_move(_new, _h)
+
+# define kosal_list_for_each(_pos, _h)                                list_for_each(_pos, _h)
+# define kosal_list_for_each_safe(_pos, _n, _h)                       list_for_each_safe(_pos, _n, _h)
+# define kosal_list_for_each_entry(_pos, _h, _memb, _cont_t)          list_for_each_entry(_pos, _h, _memb)
+# define kosal_list_for_each_entry_safe(_pos, _n, _h, _memb, _cont_t) list_for_each_entry_safe(_pos, _n, _h, _memb)
+
+
+#elif defined( __AAL_WINDOWS__ )
+# include <ntdef.h>
+  typedef LIST_ENTRY       kosal_list_head, *pkosal_list_head;
+# define kosal_list_prev(_h)                 (_h)->Blink
+# define kosal_list_next(_h)                 (_h)->Flink
+
+# define kosal_list_init(_h)                 InitializeListHead(_h)
+# define kosal_list_is_empty(_h)             IsListEmpty(_h)
+
+# define kosal_list_add_head(_new, _h)       InsertHeadList(_h, _new)
+# define kosal_list_add_tail(_new, _h)       InsertTailList(_h, _new)
+
+# define kosal_list_del_init(_h)             do{ RemoveEntryList(_h); InitializeListHead(_h); }while(0)
+# define kosal_list_del(_h)                  RemoveEntryList(_h)
+
+# define kosal_list_replace(_old, _new)           \
+do                                                \
+{                                                 \
+   kosal_list_prev(_new) = kosal_list_prev(_old); \
+   kosal_list_next(kosal_list_prev(_new)) = _new; \
+   kosal_list_next(_new) = kosal_list_next(_old); \
+   kosal_list_prev(kosal_list_next(_new)) = _new; \
+}while(0)
+
+# define kosal_list_replace_init(_old, _new) do{ kosal_list_replace(_old, _new); kosal_list_init(_old); }while(0)
+
+# define kosal_list_move(_new, _h)           do{ RemoveEntryList(_new); InsertHeadList(_h, _new); }while(0)
+
+# define kosal_list_for_each(_pos, _h) \
+   for ( (_pos) = kosal_list_next(_h) ; (_pos) != (_h) ; (_pos) = kosal_list_next(_pos) )
+
+# define kosal_list_for_each_safe(_pos, _n, _h)                       \
+   for ( (_pos) = kosal_list_next(_h), (_n) = kosal_list_next(_pos) ; \
+            (_pos) != (_h) ;                                          \
+               (_pos) = (_n), (_n) = kosal_list_next(_pos) )
+
+# define kosal_list_for_each_entry(_pos, _h, _memb, _cont_t)                   \
+      for ( (_pos) = kosal_container_of(kosal_list_next(_h), _cont_t, _memb) ; \
+               &(_pos)->_memb != (_h) ;                                        \
+                  (_pos) = kosal_container_of(kosal_list_next(&(_pos)->_memb), _cont_t, _memb) )
+
+# define kosal_list_for_each_entry_safe(_pos, _n, _h, _memb, _cont_t)                   \
+   for ( (_pos) = kosal_container_of(kosal_list_next(_h),   _cont_t, _memb),            \
+         (_n)   = kosal_container_of(kosal_list_next(&(_pos)->_memb), _cont_t, _memb) ; \
+            &(_pos)->_memb != (_h) ;                                                    \
+               (_pos) = (_n),                                                           \
+               (_n)   = kosal_container_of(kosal_list_next(&(_pos)->_memb), _cont_t, _memb) )
+
+#endif // OS
+
+#define kosal_list_add(_new, _h)                  kosal_list_add_head(_new, _h)
+
+#define kosal_list_entry(_ptr, _type, _memb)      kosal_container_of(_ptr, _type, _memb)
+#define kosal_list_get_object(_ptr, _type, _memb) kosal_container_of(_ptr, _type, _memb)
+
+
+//
+// Memory
+//
+#if   defined( __AAL_LINUX__ )
+# include <linux/slab.h>
+#define kosal_map_handle   btAny
+#elif defined( __AAL_WINDOWS__ )
+# include <ntddk.h>
+#define kosal_map_handle   PMDL
+#endif // OS
+
+KOSAL_VIRT _kosal_kmalloc(__ASSERT_HERE_PROTO KOSAL_WSSIZE );
+#ifdef kosal_kmalloc
+# undef kosal_kmalloc
+#endif // kosal_kmalloc
+#define kosal_kmalloc(__size) _kosal_kmalloc(__ASSERT_HERE_ARGS __size)
+
+KOSAL_VIRT _kosal_kzmalloc(__ASSERT_HERE_PROTO KOSAL_WSSIZE );
+#ifdef kosal_kzmalloc
+# undef kosal_kzmalloc
+#endif // kosal_kmalloc
+#define kosal_kzmalloc(__size) _kosal_kzmalloc(__ASSERT_HERE_ARGS __size)
+
+void _kosal_kfree(__ASSERT_HERE_PROTO KOSAL_ANY , KOSAL_WSSIZE );
+#ifdef kosal_kfree
+# undef kosal_kfree
+#endif // kosal_kfree
+#define kosal_kfree(__ptr, __size) _kosal_kfree(__ASSERT_HERE_ARGS __ptr, __size)
+
+KOSAL_PHYS kosal_virt_to_phys(KOSAL_ANY );
+
+KOSAL_VIRT _kosal_alloc_contiguous_mem_nocache(__ASSERT_HERE_PROTO KOSAL_WSSIZE );
+#ifdef kosal_alloc_contiguous_mem_nocache
+# undef kosal_alloc_contiguous_mem_nocache
+#endif // kosal_alloc_contiguous_mem_nocache
+#define kosal_alloc_contiguous_mem_nocache(__size) _kosal_alloc_contiguous_mem_nocache(__ASSERT_HERE_ARGS __size)
+
+void _kosal_free_contiguous_mem(__ASSERT_HERE_PROTO KOSAL_ANY , KOSAL_WSSIZE );
+# ifdef kosal_free_contiguous_mem
+#    undef kosal_free_contiguous_mem
+# endif // kosal_free_contiguous_mem
+# define kosal_free_contiguous_mem(__ptr, __size) _kosal_free_contiguous_mem(__ASSERT_HERE_ARGS __ptr, __size)
+
+static inline
+KOSAL_WSSIZE kosal_round_up_to_page_size(KOSAL_WSSIZE s) {
+   KOSAL_WSSIZE m = ((KOSAL_WSSIZE)1 << PAGE_SHIFT) - 1;
+   KOSAL_WSSIZE r = s & m;
+   return (s & ~m) + (((KOSAL_WSSIZE)0 == r) ? 0 : PAGE_SIZE);
+}
+
+KOSAL_VIRT _kosal_alloc_dma_coherent(__ASSERT_HERE_PROTO KOSAL_HANDLE ,  KOSAL_WSSIZE , KOSAL_HANDLE *);
+#ifdef kosal_alloc_dma_coherent
+# undef kosal_alloc_dma_coherent
+#endif // _kosal_alloc_dma_coherent
+#define kosal_alloc_dma_coherent(__devhandle, __size, __pdmahandle) _kosal_alloc_dma_coherent(__ASSERT_HERE_ARGS __devhandle, __size, __pdmahandle)
+
+void _kosal_free_dma_coherent(__ASSERT_HERE_PROTO  KOSAL_HANDLE , KOSAL_VIRT , KOSAL_WSSIZE , KOSAL_HANDLE );
+# ifdef _kosal_free_dma_coherent
+#    undef _kosal_free_dma_coherent
+# endif // _kosal_free_dma_coherent
+# define kosal_free_dma_coherent(__devhandle, __ptr , __size, __dmahandle) _kosal_free_dma_coherent(__ASSERT_HERE_ARGS __devhandle, __ptr, __size, __dmahandle)
+//
+// Work queue
+//
+#if   defined( __AAL_LINUX__ )
+# include <linux/workqueue.h>
+   // Dev must be the an aal_device pointer but is not currently used here
+   #define kosal_create_workqueue(name, dev)  create_workqueue(name)
+   #define kosal_destroy_workqueue(wq)        destroy_workqueue(wq)
+   #define kosal_cancel_workqueue(wq)         cancel_delayed_work(wq)
+    // Worker thread items
+
+   #if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,19)
+      typedef struct workqueue_struct *kosal_work_queue;
+   #else
+   # error Linux version < 2.6.19 not supported
+   #endif
+
+   typedef void (*osfunc)(struct work_struct *work);
+
+
+   // typedef struct work_object *pwork_object;
+   struct kosal_work_object;
+
+   typedef void (*kosal_work_handler)(struct kosal_work_object * );
+
+   struct kosal_work_object{
+      struct delayed_work  workobj;
+      void *               context;
+      osfunc               callback;
+      kosal_work_handler   fnct;
+   };
+
+
+
+   void task_poller(struct work_struct *work);
+
+
+#define KOSAL_INIT_WORK(w,f)        do {((w)->fnct) = f; \
+                                         ((w)->context)=(w); \
+                                         ((w)->callback)=task_poller; \
+                                         INIT_DELAYED_WORK(&((w)->workobj),task_poller); \
+                                    }while(0)
+
+
+#define kosal_init_waitqueue_head(q) init_waitqueue_head(q)
+
+void kosal_queue_delayed_work(kosal_work_queue wq, struct kosal_work_object* pwo, KOSAL_TIME msec);
+
+char* kosal_gettimestamp(void) ;
+
+#elif defined( __AAL_WINDOWS__ )
+   typedef PIO_WORKITEM    kosal_work_queue;
+
+#define kosal_init_waitqueue_head(q)
+
+// Name not currently used
+#define kosal_create_workqueue(name, pd)     IoAllocateWorkItem(aaldev_to_basedev(pd))
+
+#define kosal_destroy_workqueue(wq)          IoFreeWorkItem(wq)
+
+#define kosal_cancel_workqueue(wq)           IoFreeWorkItem(wq)
+//kosal_create_workqueue
+
+typedef void (*osfunc)(PDEVICE_OBJECT,PVOID);
+
+typedef void(*kosal_work_handler)(pkosal_work_object);
+
+struct kosal_work_object{
+   void *               context;
+   osfunc               callback;
+   KOSAL_TIME           msec_delay;
+   kosal_work_handler   fnct;
+};
+
+#define KOSAL_INIT_WORK(w,f)      do {((w)->fnct) = f; \
+                                      ((w)->context)=(w); \
+                                      ((w)->callback)=WorkItemCallback; \
+                                     }while(0)
+
+
+void WorkItemCallback(IN PDEVICE_OBJECT pdevObject, IN PVOID Context);
+void kosal_queue_delayed_work(kosal_work_queue wq, struct kosal_work_object* pwo, KOSAL_TIME msec);
+#if 0
+static void
+   kosal_queue_delayed_work(kosal_work_queue wq, pwork_object pwo, KOSAL_TIME msec)
+{
+   pwo->msec_delay = msec;
+   IoQueueWorkItem(wq, WorkItemCallback, DelayedWorkQueue, pwo);
+}
+#endif
+#endif // OS Work queue
+
+//
+// Polling/Events
+//
+#if   defined( __AAL_LINUX__ )
+// struct __wait_queue_head {
+// ...
+// };
+// typedef struct __wait_queue_head wait_queue_head_t;
+# include <linux/wait.h>
+typedef wait_queue_head_t kosal_poll_object;
+
+# define kosal_poll_object_is_valid(__kpo_ptr) ( !list_empty(&(__kpo_ptr)->task_list) )
+
+# define kosal_poll_object_consume(__kpo_ptr) \
+do                                            \
+{  wait_queue_t __junk;                       \
+   remove_wait_queue(__kpo_ptr, &__junk);     \
+}while(0)
+
+# define kosal_wake_up_interruptible(__kpo_ptr) wake_up_interruptible(__kpo_ptr)
+
+#elif defined( __AAL_WINDOWS__ )
+//
+// typedef WDFREQUEST__ *WDFREQUEST;
+//
+# include <wdf.h>
+# include <wdftypes.h>
+typedef WDFREQUEST        kosal_poll_object; 
+
+// Macro to hide relationship of Request to Poll Object
+#define AAL_WDFREQUEST_TO_POLLOBJ(po) (kosal_poll_object)(po)
+
+# define kosal_poll_object_is_valid(__kpo_ptr) ( (NULL != (__kpo_ptr)) && (NULL != *(__kpo_ptr)) )
+
+# define kosal_poll_object_consume(__kpo_ptr)  ( *(__kpo_ptr) = NULL )
+
+void kosal_wake_up_interruptible(kosal_poll_object * );
+
+# define kosal_poll_wait(q)             //IoMarkIrpPending(WdfRequestWdmGetIrp(q))
+#endif // Polling
+
+//
+// Accessing User mode buffers
+//
+KOSAL_VIRT _kosal_get_user_buffer(__ASSERT_HERE_PROTO KOSAL_VIRT user_prt, KOSAL_WSSIZE size_in_bytes);
+#ifdef kosal_get_user_buffer
+# undef kosal_get_user_buffer
+#endif // kosal_get_user_buffer
+#define kosal_get_user_buffer(__user_prt, __size_in_bytes) _kosal_get_user_buffer(__ASSERT_HERE_ARGS __user_prt, __size_in_bytes)
+
+
+void _kosal_free_user_buffer(__ASSERT_HERE_PROTO KOSAL_VIRT user_prt,  KOSAL_WSSIZE size_in_bytes);
+#ifdef kosal_free_user_buffer
+# undef kosal_free_user_buffer
+#endif // kosal_get_user_buffer
+#define kosal_free_user_buffer(__user_prt, __size_in_bytes) _kosal_free_user_buffer(__ASSERT_HERE_ARGS __user_prt, __size_in_bytes)
+
+//
+// Timers
+//
+#if   defined( __AAL_LINUX__ )
+// ktime_get(), ktime_compare() and related.
+# include <linux/hrtimer.h>
+# include <linux/ktime.h>
+
+#endif // __AAL_LINUX__
+
+#endif // __AALSDK_KERNEL_KOSAL_H__
+#endif // __AAL_KERNEL__
+
diff --git a/drivers/fpga/aal/include/aalsdk/kernel/spl2defs.h b/drivers/fpga/aal/include/aalsdk/kernel/spl2defs.h
new file mode 100644
index 000000000000..00970f2beaf0
--- /dev/null
+++ b/drivers/fpga/aal/include/aalsdk/kernel/spl2defs.h
@@ -0,0 +1,303 @@
+//******************************************************************************
+// This  file  is  provided  under  a  dual BSD/GPLv2  license.  When using or
+//         redistributing this file, you may do so under either license.
+//
+//                            GPL LICENSE SUMMARY
+//
+//  Copyright(c) 2011-2017, Intel Corporation.
+//
+//  This program  is  free software;  you  can redistribute it  and/or  modify
+//  it  under  the  terms of  version 2 of  the GNU General Public License  as
+//  published by the Free Software Foundation.
+//
+//  This  program  is distributed  in the  hope that it  will  be useful,  but
+//  WITHOUT   ANY   WARRANTY;   without   even  the   implied   warranty    of
+//  MERCHANTABILITY  or  FITNESS  FOR  A  PARTICULAR  PURPOSE.  See  the   GNU
+//  General Public License for more details.
+//
+//  The  full  GNU  General Public License is  included in  this  distribution
+//  in the file called README.GPLV2-LICENSE.TXT.
+//
+//  Contact Information:
+//  Henry Mitchel, henry.mitchel at intel.com
+//  77 Reed Rd., Hudson, MA  01749
+//
+//                                BSD LICENSE
+//
+//  Copyright(c) 2011-2017, Intel Corporation.
+//
+//  Redistribution and  use  in source  and  binary  forms,  with  or  without
+//  modification,  are   permitted  provided  that  the  following  conditions
+//  are met:
+//
+//    * Redistributions  of  source  code  must  retain  the  above  copyright
+//      notice, this list of conditions and the following disclaimer.
+//    * Redistributions in  binary form  must  reproduce  the  above copyright
+//      notice,  this  list of  conditions  and  the  following disclaimer  in
+//      the   documentation   and/or   other   materials   provided  with  the
+//      distribution.
+//    * Neither   the  name   of  Intel  Corporation  nor  the  names  of  its
+//      contributors  may  be  used  to  endorse  or promote  products derived
+//      from this software without specific prior written permission.
+//
+//  THIS  SOFTWARE  IS  PROVIDED  BY  THE  COPYRIGHT HOLDERS  AND CONTRIBUTORS
+//  "AS IS"  AND  ANY  EXPRESS  OR  IMPLIED  WARRANTIES,  INCLUDING,  BUT  NOT
+//  LIMITED  TO, THE  IMPLIED WARRANTIES OF  MERCHANTABILITY  AND FITNESS  FOR
+//  A  PARTICULAR  PURPOSE  ARE  DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT
+//  OWNER OR CONTRIBUTORS BE LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,
+//  SPECIAL,  EXEMPLARY,  OR  CONSEQUENTIAL   DAMAGES  (INCLUDING,   BUT   NOT
+//  LIMITED  TO,  PROCUREMENT  OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF USE,
+//  DATA,  OR PROFITS;  OR BUSINESS INTERRUPTION)  HOWEVER  CAUSED  AND ON ANY
+//  THEORY  OF  LIABILITY,  WHETHER  IN  CONTRACT,  STRICT LIABILITY,  OR TORT
+//  (INCLUDING  NEGLIGENCE  OR OTHERWISE) ARISING  IN ANY WAY  OUT  OF THE USE
+//  OF  THIS  SOFTWARE, EVEN IF ADVISED  OF  THE  POSSIBILITY  OF SUCH DAMAGE.
+//******************************************************************************
+//****************************************************************************
+//        FILE: spl2defs.h
+//     CREATED: 12/05/2011
+//      AUTHOR: Henry Mitchel
+//
+// PURPOSE:  This file contains external definitions for the
+//           Accelerator Abstraction Layer (AAL)
+//           SPL 2 HW interface.
+//
+//           SPL 2 User Mode fundamental definitions file
+//
+// HISTORY:
+// COMMENTS:
+// WHEN:          WHO:     WHAT:
+// 12/05/2011     HM       Initial version started
+// 02/06/2012     JG       AAL integration
+// 04/05/2012     TSW      Add CASSERT's for struct sizes
+// 07/30/2014     JG       CCI 3 support
+//****************************************************************************
+#ifndef __AALSDK_KERNEL_SPL2DEFS_H__
+#define __AALSDK_KERNEL_SPL2DEFS_H__
+#include <aalsdk/kernel/aaltypes.h>
+#include <aalsdk/kernel/ccidefs.h> // struct CCIAFU_DSM
+
+BEGIN_NAMESPACE(AAL)
+
+/*
+ * CCI-specific constants based on QLP2 implementation
+ *
+ * DSM == Device Status Memory, i.e. a place for the device to communicate to the host
+ *
+ * All 64-bit CSR's are written in 32-bit halves, upper half first. HW takes writing
+ *    of lower 32-bit half as signal that both are written and the entire value is valid.
+ *    Note that because these CSRs are in the PCIe configuration space, they are serialized,
+ *    so that the above assumption is accurate.
+ */
+
+/*****************************************************************************
+ *****************************************************************************
+ * 32-bit CSR that controls CCI
+ *****************************************************************************
+ *****************************************************************************/
+#define byte_offset_CCI_CH_CTRL  0x280      // CIPUCTL
+
+struct CCI_CH_CTRL {
+   union {
+      btUnsigned32bitInt csr;           // the entire csr as a 32-bit entity
+      struct {
+         btUnsigned32bitInt Reset:   1; // writing 0 has no effect, writing 1 causes SPL channel & AFU reset
+         btUnsigned32bitInt Enable:  1; // writing 0 disables SPL channel and AFU,
+                              //    writing 1 re-enables them to pick up where they left off
+         btUnsigned32bitInt rsvd:   30;
+      };
+   };
+}; // struct CCI_CH_CTRL
+CASSERT(sizeof(struct CCI_CH_CTRL) == 4);
+
+#define byte_offset_CCI_CH_STAT0  0x284      // CIPUSTAT0
+
+#define byte_offset_CCI_CH_STAT1  0x288      // CIPUSTAT1
+
+
+#define byte_offset_CSR_AFU_DSM_BASE 0x1a00
+
+
+/*
+ * SPL 2-specific constants based on QLP2 implementation
+ *
+ * DSM == Device Status Memory, i.e. a place for the device to communicate to the host
+ *
+ * All 64-bit CSR's are written in 32-bit halves, upper half first. HW takes writing
+ *    of lower 32-bit half as signal that both are written and the entire value is valid.
+ *    Note that because these CSRs are in the PCIe configuration space, they are serialized,
+ *    so that the above assumption is accurate.
+ */
+
+/*****************************************************************************
+ *****************************************************************************
+ * SPL 2's CONTEXT STRUCTURE, which defines an SPL 2 task
+ *****************************************************************************
+ *****************************************************************************/
+/*
+ * Written with the 64-bit physical address of SPL 2's context structure
+ */
+#define byte_offset_SPL2_CNTXT_BASE  0x1008
+
+/*
+ * The structure that goes there is the SPL2_CNTXT structure
+ */
+struct SPL2_CNTXT {
+   btUnsigned64bitInt phys_addr_page_table;      // physical byte address, low 6 bits 0
+   btUnsigned64bitInt virt_addr_afu_context;     // user virtual address of AFU's
+                                       //    workspace, low 6 bits 0
+                                       // same value that is written to the
+                                       //    byte_offset_AFU_CNTXT_BASE csr
+   // 3rd qword, low 32-bits
+   union {
+      btUnsigned32bitInt page_table_flags;
+      struct {
+         btUnsigned32bitInt page_size: 1;        // 1 = 2 MB, 0 = 4 KB. ONLY 2MB is valid.
+         btUnsigned32bitInt rsvd1:    31;
+      };
+   };
+   // 3rd qword, high 32-bits
+   btUnsigned32bitInt num_valid_ptes;            // number of valid pte's in page-table
+
+   // 4th qword
+   union {
+      btUnsigned64bitInt control_flags;
+      struct {
+         btUnsigned64bitInt mode:      1;        // 0 = physical, 1 = virtual.
+                                                 //    Only virtual allowed
+         btUnsigned64bitInt rsvd2:    63;
+      };
+   };
+
+   // 5th qword
+   btUnsigned64bitInt sw_handle;                 // for SW use, un-touched by HW
+
+   // 6th qword
+   btUnsigned64bitInt afu_dsm_phys;              // Physical address of AFU DSM
+
+   // rest of the cacheline
+   btUnsigned64bitInt rsvd3[2];                  // qwords 7-8
+}; // struct SPL2_CNTXT
+CASSERT(sizeof(struct SPL2_CNTXT) == 64);
+
+/*****************************************************************************
+ *****************************************************************************
+ * 32-bit CSR that controls SPL2
+ *****************************************************************************
+ *****************************************************************************/
+#define byte_offset_SPL2_CH_CTRL 0x1010
+struct SPL2_CH_CTRL {
+   union {
+      btUnsigned32bitInt csr;           // the entire csr as a 32-bit entity
+      struct {
+         btUnsigned32bitInt Reset:   1; // writing 0 has no effect, writing 1 causes SPL channel & AFU reset
+         btUnsigned32bitInt Enable:  1; // writing 0 disables SPL channel and AFU,
+                              //    writing 1 re-enables them to pick up where they left off
+         btUnsigned32bitInt rsvd:   30;
+      };
+   };
+}; // struct SPL2_CH_CTRL
+CASSERT(sizeof(struct SPL2_CH_CTRL) == 4);
+
+/*****************************************************************************
+ *****************************************************************************
+ * SPL2_DSM data structure, needs to be aligned on 4K boundary
+ *****************************************************************************
+ *****************************************************************************/
+
+/*
+ * This is what resides at the address defined in ccidefs.h, as
+ *    static const int byte_offset_CCIAFU_DSM_BASE   =  0x910;
+ */
+
+// SPL 2 id
+#define SPL2_ID 0x11100101
+
+// If there is an error, what type of error was it?
+enum e_SPL_Status_Error {
+   PTE_Load_Error = 1,
+   PT_Access_Violation,
+};
+
+// If there is a fault, what type of request caused it?
+enum e_SPL_Error_Request_Type {
+   Read = 1,
+   Write,
+};
+
+// Actual structure of SPL 2 Device Status Memory area is two cache-lines long
+struct SPL2_DSM {
+   // first cache-line
+   struct CCIAFU_DSM cci;                 // SPL_ID, first cache-line
+                                          //    cci.cci_afu_id == SPL2_ID ?
+   // second cache-line
+   union {                                // SPL_Status
+      btUnsigned64bitInt CL_1[8];                   //    second cache-line
+      struct {
+         // first qword
+         btUnsigned64bitInt Valid:               1; // true if the task has terminated
+         btUnsigned64bitInt Error:               1; // true if this termination is in error
+         btUnsigned64bitInt rsvd1:               6;
+         enum e_SPL_Status_Error
+                  Error_Status:       24; // Valid if Error is true
+         enum e_SPL_Error_Request_Type
+                  Fault_Request_Type: 32; // Valid if Error is true
+
+         // second qword
+         btUnsigned64bitInt Error_Address;          // access to this 64-bit virtual
+                                          //    address caused the error
+      };
+   };
+}; // struct SPL2_DSM
+CASSERT(sizeof(struct SPL2_DSM) == (2 * 64));
+
+/*****************************************************************************
+ *****************************************************************************
+ * SPL2 expects its AFU to follow certain conventions, defined here
+ *****************************************************************************
+ *****************************************************************************/
+
+/*****************************************************************************
+ * Written with 64-bit physical address of SPL's AFU's DSM (Device Status Memory)
+ *****************************************************************************/
+#define byte_offset_AFU_DSM_BASE    0x8A00
+
+/*****************************************************************************
+ * SPL 2 expects the AFU's DSM to contain one cache-line, reserved by SPL 2,
+ *    for the AFU's AFU_ID
+ *****************************************************************************/
+struct SPL2AFU_DSM{
+   btUnsigned64bitInt AFU_ID[2];        // 128 bit GUID. Current implementation only
+                              //    uses lowest 64-bits, i.e. AFU_ID[0]
+   btUnsigned64bitInt rsvd[6];
+};
+CASSERT(sizeof(struct SPL2AFU_DSM) == 64);
+
+/*****************************************************************************
+ * Written with 64-bit virtual address into which the AFU's CNTXT (Page Table)
+ *    member PTE's have been mmap()'d. This is the same value written into
+ *    the SPL2_CNTXT structure member virt_addr_afu_context.
+ * The mechanism of writing the same value twice allows the SPL not to have
+ *    to send the value to the AFU -- instead the SW does.
+ *****************************************************************************/
+#define byte_offset_AFU_CNTXT_BASE   0x8A08
+
+/*****************************************************************************
+ * CCI CSR Offsets from system config space based on AFU number
+ *****************************************************************************/
+static const int CCI3_AFU0_CSR_OFFSET=0x1000;
+
+
+/*****************************************************************************
+ * SPL3 CSR Offsets from system config space based on AFU number
+ *****************************************************************************/
+static const int SPL3_AFU0_CSR_OFFSET=0x8000;
+static const int SPL3_AFU1_CSR_OFFSET=0x9000;
+static const int SPL3_AFU2_CSR_OFFSET=0xA000;
+static const int SPL3_AFU3_CSR_OFFSET=0xB000;
+
+static const int SPL3_CSR_SPACE_SIZE=0x1000;
+
+END_NAMESPACE(AAL)
+
+#endif // __AALSDK_KERNEL_SPL2DEFS_H__
+
diff --git a/drivers/fpga/aal/include/aalsdk/kernel/vafu2defs.h b/drivers/fpga/aal/include/aalsdk/kernel/vafu2defs.h
new file mode 100644
index 000000000000..77037c23d189
--- /dev/null
+++ b/drivers/fpga/aal/include/aalsdk/kernel/vafu2defs.h
@@ -0,0 +1,180 @@
+//******************************************************************************
+// This  file  is  provided  under  a  dual BSD/GPLv2  license.  When using or
+//         redistributing this file, you may do so under either license.
+//
+//                            GPL LICENSE SUMMARY
+//
+//  Copyright(c) 2011-2017, Intel Corporation.
+//
+//  This program  is  free software;  you  can redistribute it  and/or  modify
+//  it  under  the  terms of  version 2 of  the GNU General Public License  as
+//  published by the Free Software Foundation.
+//
+//  This  program  is distributed  in the  hope that it  will  be useful,  but
+//  WITHOUT   ANY   WARRANTY;   without   even  the   implied   warranty    of
+//  MERCHANTABILITY  or  FITNESS  FOR  A  PARTICULAR  PURPOSE.  See  the   GNU
+//  General Public License for more details.
+//
+//  The  full  GNU  General Public License is  included in  this  distribution
+//  in the file called README.GPLV2-LICENSE.TXT.
+//
+//  Contact Information:
+//  Henry Mitchel, henry.mitchel at intel.com
+//  77 Reed Rd., Hudson, MA  01749
+//
+//                                BSD LICENSE
+//
+//  Copyright(c) 2011-2017, Intel Corporation.
+//
+//  Redistribution and  use  in source  and  binary  forms,  with  or  without
+//  modification,  are   permitted  provided  that  the  following  conditions
+//  are met:
+//
+//    * Redistributions  of  source  code  must  retain  the  above  copyright
+//      notice, this list of conditions and the following disclaimer.
+//    * Redistributions in  binary form  must  reproduce  the  above copyright
+//      notice,  this  list of  conditions  and  the  following disclaimer  in
+//      the   documentation   and/or   other   materials   provided  with  the
+//      distribution.
+//    * Neither   the  name   of  Intel  Corporation  nor  the  names  of  its
+//      contributors  may  be  used  to  endorse  or promote  products derived
+//      from this software without specific prior written permission.
+//
+//  THIS  SOFTWARE  IS  PROVIDED  BY  THE  COPYRIGHT HOLDERS  AND CONTRIBUTORS
+//  "AS IS"  AND  ANY  EXPRESS  OR  IMPLIED  WARRANTIES,  INCLUDING,  BUT  NOT
+//  LIMITED  TO, THE  IMPLIED WARRANTIES OF  MERCHANTABILITY  AND FITNESS  FOR
+//  A  PARTICULAR  PURPOSE  ARE  DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT
+//  OWNER OR CONTRIBUTORS BE LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,
+//  SPECIAL,  EXEMPLARY,  OR  CONSEQUENTIAL   DAMAGES  (INCLUDING,   BUT   NOT
+//  LIMITED  TO,  PROCUREMENT  OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF USE,
+//  DATA,  OR PROFITS;  OR BUSINESS INTERRUPTION)  HOWEVER  CAUSED  AND ON ANY
+//  THEORY  OF  LIABILITY,  WHETHER  IN  CONTRACT,  STRICT LIABILITY,  OR TORT
+//  (INCLUDING  NEGLIGENCE  OR OTHERWISE) ARISING  IN ANY WAY  OUT  OF THE USE
+//  OF  THIS  SOFTWARE, EVEN IF ADVISED  OF  THE  POSSIBILITY  OF SUCH DAMAGE.
+//******************************************************************************
+//****************************************************************************
+/// @file vafu2defs.h
+/// @brief External definitions for the SPL2 hardware interface.
+/// @ingroup AALCore
+/// @verbatim
+/// Accelerator Abstraction Layer
+///
+/// AUTHOR: Henry Mitchel, Intel Corporation
+///
+/// HISTORY:
+/// COMMENTS:
+/// WHEN:          WHO:     WHAT:
+/// 12/05/2011     HM       Initial version started
+/// 02/13/2012     JG       AAL integration
+/// 04/26/2012     TSW      Add CASSERTs for struct sizes.@endverbatim
+//****************************************************************************
+#ifndef __AALSDK_KERNEL_VAFU2DEFS_H__
+#define __AALSDK_KERNEL_VAFU2DEFS_H__
+#include <aalsdk/kernel/aaltypes.h>
+#include <aalsdk/kernel/spl2defs.h> // SPL2AFU_DSM
+
+BEGIN_NAMESPACE(AAL)
+
+/// @addtogroup AALCore
+/// @{
+
+/*
+ * VAFU 2-specific constants based on QLP2 implementation
+ *
+ * DSM == Device Status Memory, i.e. a place for the device to communicate to the host
+ *
+ * All 64-bit CSR's are written in 32-bit halves, upper half first. HW takes writing
+ *    of lower 32-bit half as signal that both are written and the entire value is valid.
+ *    Note that because these CSRs are in the PCIe configuration space, they are serialized,
+ *    so that the above assumption is accurate.
+ */
+
+/*****************************************************************************
+ * CSRs inherited from SPL2 are:
+ *    static const int byte_offset_AFU_DSM_BASE     =  0xA00;
+ *    static const int byte_offset_AFU_CNTXT_BASE   =  0xA08;
+ *****************************************************************************/
+
+/*****************************************************************************
+ * 32-bit value provided as a check write/read mechanism
+ *****************************************************************************/
+static const int byte_offset_AFU_CSR_SCRATCH = 0xAFC;
+
+/*
+ * VAFU2_DSM data structure, needs to be aligned on 4K boundary
+ */
+
+// VAFU 2 id (fake GUID)
+static const btUnsigned64bitInt VAFU2_ID_LO = 0x11100181;
+static const btUnsigned64bitInt VAFU2_ID_HI = 0;
+
+/*****************************************************************************
+ *****************************************************************************
+ * Structure of VAFU 2 Device Status Memory area
+ *****************************************************************************
+ *****************************************************************************/
+struct VAFU2_DSM {
+   // cache-line 0                        // AKA AFU_DSM_ID
+   struct SPL2AFU_DSM vafu2;              // Inherited from SPL, the AFU_ID definition
+                                          // If vafu2.AFU_ID[0] == VAFU2_ID_LO &&
+                                          //    vafu2.AFU_ID[1] == VAFU2_ID_HI, then this is VAFU2
+   // cache-lines 1-3
+   btUnsigned64bitInt           rsvd0[8][3];        // Don't use these
+
+   // cache-line 4
+   union {                                // Latency counter
+      btUnsigned64bitInt        rsvd1[8];           // Make it a cache-line
+      btUnsigned64bitInt        AFU_DSM_LATENCY;    // Clocks?
+   };
+
+   // cache-line 5
+   union {                                // Performance counter
+      btUnsigned64bitInt        rsvd2[8];           // Make it a cache-line
+      btUnsigned64bitInt        AFU_DSM_PERFORMANCE;// Number of cycles elapsed between start and end of task
+   };
+
+   // cache-lines 6-62
+   btUnsigned64bitInt           rsvd3[8][62-6+1];   // Don't use these
+
+   // cache-line 63
+   union {                                // Performance counter
+      btUnsigned64bitInt        rsvd4[8];           // Make it a cache-line
+      btUnsigned32bitInt        AFU_DSM_SCRATCH;    // Value written to byte_offset_AFU_CSR_SCRATCH
+   };
+}; // struct VAFU2_DSM
+CASSERT(sizeof(struct VAFU2_DSM) == (64 * 64));
+
+/// Structure of Validation AFU Context for SPL2
+/// @todo Doxygen cannot handle nested anonymous structs/unions.
+struct VAFU2_CNTXT {
+   union {
+      btUnsigned64bitInt          qword0[8];       // make it a whole cacheline
+      struct {
+         union {                                   // first qword
+            btUnsigned64bitInt    dword0;
+            struct {
+               btUnsigned64bitInt rsvd0:   32;
+               btUnsigned64bitInt delay:   16;     // undefined, but in the structure definition, set to 0
+            };
+         };
+         void          *pSource;                   ///< Source user-mode virtual address, cache-line aligned.
+         void          *pDest;                     ///< Destination user-mode virtual address, cache-line aligned.
+         btUnsigned32bitInt       num_cl;          ///< Number of cache lines to copy.
+      };
+   };
+   union {
+      btUnsigned64bitInt          qword1[8];       // make it a whole cacheline
+      struct {
+         btUnsigned32bitInt       Status;          ///< Bit0 true if done
+#define  VAFU2_CNTXT_STATUS_DONE   0x00000001      ///< Bit0 selector
+      };
+   };
+}; // struct VAFU2_CNTXT
+//CASSERT(sizeof(struct VAFU2_CNTXT) == 64);       // no longer true
+
+/// @}
+
+END_NAMESPACE(AAL)
+
+#endif // __AALSDK_KERNEL_VAFU2DEFS_H__
+
diff --git a/drivers/fpga/aal/rmc/Makefile b/drivers/fpga/aal/rmc/Makefile
new file mode 100644
index 000000000000..dc0b5f866ec6
--- /dev/null
+++ b/drivers/fpga/aal/rmc/Makefile
@@ -0,0 +1,22 @@
+ccflags-y := -I$(src)/../include -D__KERNEL__=1
+ccflags-y += -DDRV_NAME=\"aalrmc\"
+ccflags-y += -DDRV_VERSION=\"6.3.1\"
+
+ifdef CONFIG_AAL_DEBUG
+	ccflags-y += -DENABLE_DEBUG=1
+else
+	ccflags-y += -DENABLE_DEBUG=0
+endif
+
+ifdef CONFIG_AAL_ASSERT
+	ccflags-y += -DENABLE_ASSERT=1
+else
+	ccflags-y += -DENABLE_ASSERT=0
+endif
+
+obj-$(CONFIG_AAL_RMC)	+= aalrmc.o
+
+aalrmc-y	:=	aalrm-file.o  \
+			aalrm-ioctl.o \
+			aalrm-main.o  \
+			kOSAL.o
diff --git a/drivers/fpga/aal/rmc/aalrm-events-int.h b/drivers/fpga/aal/rmc/aalrm-events-int.h
new file mode 100644
index 000000000000..45c15e216de3
--- /dev/null
+++ b/drivers/fpga/aal/rmc/aalrm-events-int.h
@@ -0,0 +1,241 @@
+//******************************************************************************
+// This  file  is  provided  under  a  dual BSD/GPLv2  license.  When using or
+//         redistributing this file, you may do so under either license.
+//
+//                            GPL LICENSE SUMMARY
+//
+//  Copyright(c) 2009-2017, Intel Corporation.
+//
+//  This program  is  free software;  you  can redistribute it  and/or  modify
+//  it  under  the  terms of  version 2 of  the GNU General Public License  as
+//  published by the Free Software Foundation.
+//
+//  This  program  is distributed  in the  hope that it  will  be useful,  but
+//  WITHOUT   ANY   WARRANTY;   without   even  the   implied   warranty    of
+//  MERCHANTABILITY  or  FITNESS  FOR  A  PARTICULAR  PURPOSE.  See  the   GNU
+//  General Public License for more details.
+//
+//  The  full  GNU  General Public License is  included in  this  distribution
+//  in the file called README.GPLV2-LICENSE.TXT.
+//
+//  Contact Information:
+//  Henry Mitchel, henry.mitchel at intel.com
+//  77 Reed Rd., Hudson, MA  01749
+//
+//                                BSD LICENSE
+//
+//  Copyright(c) 2009-2017, Intel Corporation.
+//
+//  Redistribution and  use  in source  and  binary  forms,  with  or  without
+//  modification,  are   permitted  provided  that  the  following  conditions
+//  are met:
+//
+//    * Redistributions  of  source  code  must  retain  the  above  copyright
+//      notice, this list of conditions and the following disclaimer.
+//    * Redistributions in  binary form  must  reproduce  the  above copyright
+//      notice,  this  list of  conditions  and  the  following disclaimer  in
+//      the   documentation   and/or   other   materials   provided  with  the
+//      distribution.
+//    * Neither   the  name   of  Intel  Corporation  nor  the  names  of  its
+//      contributors  may  be  used  to  endorse  or promote  products derived
+//      from this software without specific prior written permission.
+//
+//  THIS  SOFTWARE  IS  PROVIDED  BY  THE  COPYRIGHT HOLDERS  AND CONTRIBUTORS
+//  "AS IS"  AND  ANY  EXPRESS  OR  IMPLIED  WARRANTIES,  INCLUDING,  BUT  NOT
+//  LIMITED  TO, THE  IMPLIED WARRANTIES OF  MERCHANTABILITY  AND FITNESS  FOR
+//  A  PARTICULAR  PURPOSE  ARE  DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT
+//  OWNER OR CONTRIBUTORS BE LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,
+//  SPECIAL,  EXEMPLARY,  OR  CONSEQUENTIAL   DAMAGES  (INCLUDING,   BUT   NOT
+//  LIMITED  TO,  PROCUREMENT  OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF USE,
+//  DATA,  OR PROFITS;  OR BUSINESS INTERRUPTION)  HOWEVER  CAUSED  AND ON ANY
+//  THEORY  OF  LIABILITY,  WHETHER  IN  CONTRACT,  STRICT LIABILITY,  OR TORT
+//  (INCLUDING  NEGLIGENCE  OR OTHERWISE) ARISING  IN ANY WAY  OUT  OF THE USE
+//  OF  THIS  SOFTWARE, EVEN IF ADVISED  OF  THE  POSSIBILITY  OF SUCH DAMAGE.
+//******************************************************************************
+//****************************************************************************
+//        FILE: aalrm-events-int.h
+//     CREATED: 01/08/2009
+//      AUTHOR: Joseph Grecco - Intel
+//
+// PURPOSE: This file contains internal event definitions for the
+//          AAL Resource Manager Client Service Module.
+// HISTORY:
+// COMMENTS:
+// WHEN:          WHO:     WHAT:
+// 01/08/09       JG       Initial version created
+// 05/14/10       JG       Moved event methods into here
+//****************************************************************************
+#ifndef __AALKERNEL_AALRESOURCEMGR_CLIENT_AALRM_EVENTS_INT_H__
+#define __AALKERNEL_AALRESOURCEMGR_CLIENT_AALRM_EVENTS_INT_H__
+#include "aalsdk/kernel/kosal.h"
+#include "aalsdk/kernel/aalbus.h"
+#include "aalsdk/kernel/aalrm_client.h"
+
+///////////////////////////////////////////////////////////////////////////////
+///////////////////////////////////////////////////////////////////////////////
+////////////////////                                     //////////////////////
+/////////////////       RESOURCE MANAGER CLIENT EVENTS     ////////////////////
+////////////////////                                     //////////////////////
+///////////////////////////////////////////////////////////////////////////////
+///////////////////////////////////////////////////////////////////////////////
+//=============================================================================
+//=============================================================================
+// Name: reqdev_cmplt
+// Description: Request Device Complete
+//=============================================================================
+struct reqdev_cmplt {
+#define qi_to_reqdev_cmplt(pqi) (container_of( pqi, struct reqdev_cmplt, m_qitem ) )
+   //-------------------------------------------
+   // Including the macro effectively causes
+   // this object to be derived from aal_q_item
+   //-------------------------------------------
+   _DECLARE_AALQ_TYPE;
+
+   stTransactionID_t        tranID;    // transaction ID to identify result [IN]
+   btAny 					context;   // optional token [IN]
+   struct rsp_device        retdev;    // Return information [IN]
+
+};
+
+//=============================================================================
+// Name: registrarreq_cmplt
+// Description: Registrar Request Complete
+//=============================================================================
+struct registrarreq_cmplt {
+#define qi_to_registrarreq_cmplt(pqi) (container_of( pqi, struct registrarreq_cmplt, m_qitem ) )
+   //-------------------------------------------
+   // Including the macro effectively causes
+   // this object to be derived from aal_q_item
+   //-------------------------------------------
+   _DECLARE_AALQ_TYPE;
+   btInt                     errno;    // Error code
+   struct req_registrar     *resp;     // Return information
+};
+
+
+//=============================================================================
+// Name: shutdownreq_cmplt
+// Description: Shutdown Request Complete
+//=============================================================================
+struct shutdownreq_cmplt {
+#define qi_to_shutdownreq_cmplt(pqi) (container_of( pqi, struct shutdownreq_cmplt, m_qitem ) )
+   //-------------------------------------------
+   // Including the macro effectively causes
+   // this object to be derived from aal_q_item
+   //-------------------------------------------
+   _DECLARE_AALQ_TYPE;
+   int                      errno;      // Error code
+};
+
+
+
+//=============================================================================
+// Name: reqdev_cmplt_create
+// Description: Request Device Event Constructor
+//=============================================================================
+static inline struct reqdev_cmplt *
+reqdev_cmplt_create( struct rsp_device   *pretdev,
+                     struct req_allocdev *origreq)
+{
+   // Allocate event with room for payload.
+   struct reqdev_cmplt * This = (struct reqdev_cmplt *)kosal_kmalloc( sizeof(struct reqdev_cmplt) +
+                                         	 	 	 	 	 	 	  pretdev->size);
+   if(This == NULL){
+      return NULL;
+   }
+
+   // Copy the rsp_device payload
+   memcpy(&This->retdev, pretdev, pretdev->size + sizeof(struct rsp_device));
+
+   // Carry forward request data
+   This->tranID = origreq->tranID;
+   This->context = origreq->context;
+
+   AALQ_QID(This) = rspid_URMS_RequestDevice;
+   AALQ_QLEN(This) = pretdev->size;    // Length of payload
+
+   // Initialize the queue item
+   kosal_list_init(&AALQ_QUEUE(This));
+   return This;
+}
+
+//=============================================================================
+// Name: reqdev_cmplt_destroy
+// Description: Destructor
+//=============================================================================
+static inline void reqdev_cmplt_destroy(struct reqdev_cmplt *This)
+{
+   kosal_kfree(This, sizeof(struct reqdev_cmplt));
+}
+
+
+//=============================================================================
+// Name: registrar_cmplt_create
+// Description: Constructor
+//=============================================================================
+static inline struct registrarreq_cmplt *
+                          registrar_cmplt_create(int errno,
+                                                 struct req_registrar *resp)
+{
+   struct registrarreq_cmplt * This = (struct registrarreq_cmplt *)kosal_kmalloc(sizeof(struct registrarreq_cmplt));
+   if(This == NULL){
+      return NULL;
+   }
+
+   This->errno = errno;
+   This->resp = resp;
+
+   AALQ_QID(This) = rspid_RS_Registrar;
+   AALQ_QLEN(This) = resp->size;
+
+   // Initialize the queue item
+   kosal_list_init(&AALQ_QUEUE(This));
+   return This;
+}
+
+
+//=============================================================================
+// Name: registrar_cmplt_destroy
+// Description: Destructor
+//=============================================================================
+static inline void registrar_cmplt_destroy(struct registrarreq_cmplt *This)
+{
+
+   kosal_kfree(This, sizeof(struct registrarreq_cmplt));
+}
+
+
+//=============================================================================
+// Name: shutdown_cmplt_create
+// Description: Constructor
+//=============================================================================
+static inline struct shutdownreq_cmplt *
+                          shutdown_cmplt_create(int errno)
+{
+   struct shutdownreq_cmplt * This = (struct shutdownreq_cmplt * )kosal_kmalloc(sizeof(struct shutdownreq_cmplt));
+   if(This == NULL){
+      return NULL;
+   }
+
+   This->errno = errno;
+
+   AALQ_QID(This) = rspid_Shutdown;
+   AALQ_QLEN(This) = 0;
+
+   // Initialize the queue item
+   kosal_list_init(&AALQ_QUEUE(This));
+   return This;
+}
+
+
+//=============================================================================
+// Name: shutdown_cmplt_destroy
+// Description: Destructor
+//=============================================================================
+static inline void shutdown_cmplt_destroy(struct shutdownreq_cmplt *This)
+{
+   kosal_kfree(This, sizeof(struct shutdownreq_cmplt));
+}
+
+
+#endif // __AALKERNEL_AALRESOURCEMGR_CLIENT_AALRM_EVENTS_INT_H__
diff --git a/drivers/fpga/aal/rmc/aalrm-file.c b/drivers/fpga/aal/rmc/aalrm-file.c
new file mode 100644
index 000000000000..9f4a4529c725
--- /dev/null
+++ b/drivers/fpga/aal/rmc/aalrm-file.c
@@ -0,0 +1,241 @@
+//******************************************************************************
+// This  file  is  provided  under  a  dual BSD/GPLv2  license.  When using or
+//         redistributing this file, you may do so under either license.
+//
+//                            GPL LICENSE SUMMARY
+//
+//  Copyright(c) 2008-2017, Intel Corporation.
+//
+//  This program  is  free software;  you  can redistribute it  and/or  modify
+//  it  under  the  terms of  version 2 of  the GNU General Public License  as
+//  published by the Free Software Foundation.
+//
+//  This  program  is distributed  in the  hope that it  will  be useful,  but
+//  WITHOUT   ANY   WARRANTY;   without   even  the   implied   warranty    of
+//  MERCHANTABILITY  or  FITNESS  FOR  A  PARTICULAR  PURPOSE.  See  the   GNU
+//  General Public License for more details.
+//
+//  The  full  GNU  General Public License is  included in  this  distribution
+//  in the file called README.GPLV2-LICENSE.TXT.
+//
+//  Contact Information:
+//  Henry Mitchel, henry.mitchel at intel.com
+//  77 Reed Rd., Hudson, MA  01749
+//
+//                                BSD LICENSE
+//
+//  Copyright(c) 2008-2017, Intel Corporation.
+//
+//  Redistribution and  use  in source  and  binary  forms,  with  or  without
+//  modification,  are   permitted  provided  that  the  following  conditions
+//  are met:
+//
+//    * Redistributions  of  source  code  must  retain  the  above  copyright
+//      notice, this list of conditions and the following disclaimer.
+//    * Redistributions in  binary form  must  reproduce  the  above copyright
+//      notice,  this  list of  conditions  and  the  following disclaimer  in
+//      the   documentation   and/or   other   materials   provided  with  the
+//      distribution.
+//    * Neither   the  name   of  Intel  Corporation  nor  the  names  of  its
+//      contributors  may  be  used  to  endorse  or promote  products derived
+//      from this software without specific prior written permission.
+//
+//  THIS  SOFTWARE  IS  PROVIDED  BY  THE  COPYRIGHT HOLDERS  AND CONTRIBUTORS
+//  "AS IS"  AND  ANY  EXPRESS  OR  IMPLIED  WARRANTIES,  INCLUDING,  BUT  NOT
+//  LIMITED  TO, THE  IMPLIED WARRANTIES OF  MERCHANTABILITY  AND FITNESS  FOR
+//  A  PARTICULAR  PURPOSE  ARE  DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT
+//  OWNER OR CONTRIBUTORS BE LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,
+//  SPECIAL,  EXEMPLARY,  OR  CONSEQUENTIAL   DAMAGES  (INCLUDING,   BUT   NOT
+//  LIMITED  TO,  PROCUREMENT  OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF USE,
+//  DATA,  OR PROFITS;  OR BUSINESS INTERRUPTION)  HOWEVER  CAUSED  AND ON ANY
+//  THEORY  OF  LIABILITY,  WHETHER  IN  CONTRACT,  STRICT LIABILITY,  OR TORT
+//  (INCLUDING  NEGLIGENCE  OR OTHERWISE) ARISING  IN ANY WAY  OUT  OF THE USE
+//  OF  THIS  SOFTWARE, EVEN IF ADVISED  OF  THE  POSSIBILITY  OF SUCH DAMAGE.
+//******************************************************************************
+//****************************************************************************
+//        FILE: aalrm-file.c
+//     CREATED: 02/13/2008
+//      AUTHOR: Joseph Grecco - Intel
+//
+// PURPOSE:  Implements the file character driver API for the AAL Resource
+//           Manager Client Service.
+// HISTORY:
+// COMMENTS:
+// WHEN:          WHO:     WHAT:
+// 02-13-08       JG       Initial version started
+// 11/11/2008     JG       Added legal header
+// 01/04/2009     HM       Updated Copyright
+// 01/08/2009     JG       Cleanup and refactoring
+// 02/09/2009     JG       Added support for RMSS cancel transaction   TODO - Make trancnt set atomic
+// 05/13/2010     JG       Fixed bug in close where transactions were canceled
+//                            after devices were freed.
+// 05/18/2010     HM       Labeled kosal_sem_get_krnl_alertable() with FIXME. Need a
+//                            global fix for these. Getting it to compile.
+// 11/09/2010     HM       Removed extraneous kernel include asm/uaccess.h
+// 08/28/2013     JG       Added suport for kOSAL
+//****************************************************************************
+#define MODULE_FLAGS AALRMC_DBG_FILE
+
+#include "aalsdk/kernel/kosal.h"
+#include "aalrm-int.h"
+#include "aalsdk/kernel/aalrm_server-services.h"
+
+//=============================================================================
+// Name: aalrm_open
+// Description: Implements the open system call
+// Interface: public
+// Inputs: inode - pointer to inode for device node
+//         file - pointer to file instance for this open
+// Outputs: none.
+// Comments: Creates a session instance with the RMC service. The session
+//           is the state and context between an application process and the
+//           RMC service.
+//=============================================================================
+btInt aalrm_open(struct inode *inode, struct file *file)
+{
+   btInt minor, ret = 0;
+   struct aalresmgr_session *session = NULL;
+
+   DPRINTF (AALRMC_DBG_FILE, ":RM-Opened by pid = %d tgid = %d\n",current->pid, current->tgid );
+
+   // minor number must be zero
+   minor = iminor (inode);
+   if (minor != 0){
+      return -ENODEV;
+   }
+
+   //-------------------
+   // Create the session
+   //-------------------
+   session = (struct aalresmgr_session *)kosal_kmalloc(sizeof(struct aalresmgr_session));
+   if(session == NULL){
+      DPRINTF (AALRMC_DBG_FILE, ": open failed to malloc\n");
+      return -ENOMEM;
+   }
+
+   // Initialize session's lists, queues and sync objects
+   kosal_list_init(&session->m_devlist);
+   kosal_list_init(&session->m_sessq);
+   kosal_init_waitqueue_head(&session->m_waitq);
+   kosal_mutex_init(&session->m_sem);
+
+   // Transaction count
+   session->m_transcnt=0;
+
+   // Initialize the event queue
+   aal_queue_init(&session->m_eventq);
+
+   // Get a pointer to the resource manager client service singleton
+   session->m_resmgr = &resmgr;
+
+   // Record the owning process
+   //   This is used to identify a process as owning a resource
+   session->m_tgpid = current->tgid;
+
+
+   // Add this session to the session queue of the resource manager
+   rmssess_to_rmcsrv(session).register_sess(&session->m_sessq);
+
+   // Save this session on the file instance
+   file->private_data = session;
+
+   DPRINTF(AALRMC_DBG_FILE, ": RM-AAL Session created\n");
+
+   return ret;
+}
+
+
+//=============================================================================
+// Name: aalrm_close
+// Description: Implements the close system call
+// Interface: public
+// Inputs: .
+// Outputs: none.
+// Comments: Close pulls the plug on any outstanding transactions. This implies
+//           that notifications for completion may not be sent to the
+//           application. Ideally the app is in a quiescent state before
+//           calling.
+//=============================================================================
+btInt aalrm_close (struct inode *inode, struct file *file)
+{
+   btInt ret = 0, loopcnt=0;
+   struct aaldev_owner *itr, *tmp;
+   struct aalresmgr_session *psess = file->private_data;
+
+   // Set the transaction ID to cancel requests
+   struct aalrms_req_tranID tranID =
+   {
+     .m_context = psess
+   };
+
+   DPRINTF(AALRMC_DBG_FILE, ": RM-CLOSE Entered\n");
+
+   // Cancel all outstanding transactions
+   if(psess->m_transcnt != 0){
+     //-----------------------------------
+     // Wait no more that 1 second per
+     // outstanding transaction to cancel
+     //-----------------------------------
+     loopcnt = psess->m_transcnt * 10;
+
+     // Cancel all outstanding requests for this session
+     i_rmserver(rmssess_to_rmssrv(psess)).cancel_all_requests(  &tranID  );
+
+     while((psess->m_transcnt != 0) && loopcnt--){
+        DPRINTF(AALRMC_DBG_FILE, ": Waiting up to %d seconds on %d transactions to cancel.\n",loopcnt/10,psess->m_transcnt);
+        kosal_mdelay(100);
+     }
+   }
+
+   // Free all devices that have not bound
+   if (kosal_sem_get_krnl_alertable(&psess->m_sem)) { /* FIXME */ }
+
+   // Walk the owner list and delete each entry
+   kosal_list_for_each_entry_safe(itr, tmp, &psess->m_devlist, m_devicelist, struct aaldev_owner){
+     DPRINTF(AALRMC_DBG_FILE, ": Removing ownership from unbound devices\n");
+     dev_removeOwner(itr->m_device, psess->m_tgpid);
+   }
+
+   kosal_sem_put(&psess->m_sem);
+
+   // flush the event queue
+   aalrm_flush_eventqueue( psess );
+
+   // remove the session from the RMC queue
+   rmssess_to_rmcsrv(psess).unregister_sess(&psess->m_sessq);
+   kosal_kfree(psess, sizeof(struct aalresmgr_session));
+   DPRINTF(AALRMC_DBG_FILE, ": RM-CLOSE Exited\n");
+   return ret;
+}
+
+
+//=============================================================================
+// Name: aalrm_poll
+// Description: Called from select, poll or epoll call.
+// Interface: public
+// Inputs: .
+// Returns: Mask indicating if there are any events available
+// Comments:
+//=============================================================================
+btUnsignedInt aalrm_poll( struct file *file, poll_table *wait )
+{
+   btUnsignedInt mask = 0;
+
+   // Get the user session
+   struct aalresmgr_session *psess = (struct aalresmgr_session *) file->private_data;
+
+   // Put session's waitq in the poll table
+   poll_wait( file, &psess->m_waitq, wait );
+
+   // Check for any resource request completions
+   if (kosal_sem_get_krnl_alertable( &psess->m_sem )) { /* FIXME */ }
+   if( !_aal_q_empty( &psess->m_eventq ) ){
+      mask |= POLLPRI;  // Device request completion
+   }
+   up( &psess->m_sem );
+
+   // Return the event mask
+   return mask;
+}
+
+
diff --git a/drivers/fpga/aal/rmc/aalrm-int.h b/drivers/fpga/aal/rmc/aalrm-int.h
new file mode 100644
index 000000000000..156666502567
--- /dev/null
+++ b/drivers/fpga/aal/rmc/aalrm-int.h
@@ -0,0 +1,211 @@
+//******************************************************************************
+// This  file  is  provided  under  a  dual BSD/GPLv2  license.  When using or
+//         redistributing this file, you may do so under either license.
+//
+//                            GPL LICENSE SUMMARY
+//
+//  Copyright(c) 2008-2017, Intel Corporation.
+//
+//  This program  is  free software;  you  can redistribute it  and/or  modify
+//  it  under  the  terms of  version 2 of  the GNU General Public License  as
+//  published by the Free Software Foundation.
+//
+//  This  program  is distributed  in the  hope that it  will  be useful,  but
+//  WITHOUT   ANY   WARRANTY;   without   even  the   implied   warranty    of
+//  MERCHANTABILITY  or  FITNESS  FOR  A  PARTICULAR  PURPOSE.  See  the   GNU
+//  General Public License for more details.
+//
+//  The  full  GNU  General Public License is  included in  this  distribution
+//  in the file called README.GPLV2-LICENSE.TXT.
+//
+//  Contact Information:
+//  Henry Mitchel, henry.mitchel at intel.com
+//  77 Reed Rd., Hudson, MA  01749
+//
+//                                BSD LICENSE
+//
+//  Copyright(c) 2008-2017, Intel Corporation.
+//
+//  Redistribution and  use  in source  and  binary  forms,  with  or  without
+//  modification,  are   permitted  provided  that  the  following  conditions
+//  are met:
+//
+//    * Redistributions  of  source  code  must  retain  the  above  copyright
+//      notice, this list of conditions and the following disclaimer.
+//    * Redistributions in  binary form  must  reproduce  the  above copyright
+//      notice,  this  list of  conditions  and  the  following disclaimer  in
+//      the   documentation   and/or   other   materials   provided  with  the
+//      distribution.
+//    * Neither   the  name   of  Intel  Corporation  nor  the  names  of  its
+//      contributors  may  be  used  to  endorse  or promote  products derived
+//      from this software without specific prior written permission.
+//
+//  THIS  SOFTWARE  IS  PROVIDED  BY  THE  COPYRIGHT HOLDERS  AND CONTRIBUTORS
+//  "AS IS"  AND  ANY  EXPRESS  OR  IMPLIED  WARRANTIES,  INCLUDING,  BUT  NOT
+//  LIMITED  TO, THE  IMPLIED WARRANTIES OF  MERCHANTABILITY  AND FITNESS  FOR
+//  A  PARTICULAR  PURPOSE  ARE  DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT
+//  OWNER OR CONTRIBUTORS BE LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,
+//  SPECIAL,  EXEMPLARY,  OR  CONSEQUENTIAL   DAMAGES  (INCLUDING,   BUT   NOT
+//  LIMITED  TO,  PROCUREMENT  OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF USE,
+//  DATA,  OR PROFITS;  OR BUSINESS INTERRUPTION)  HOWEVER  CAUSED  AND ON ANY
+//  THEORY  OF  LIABILITY,  WHETHER  IN  CONTRACT,  STRICT LIABILITY,  OR TORT
+//  (INCLUDING  NEGLIGENCE  OR OTHERWISE) ARISING  IN ANY WAY  OUT  OF THE USE
+//  OF  THIS  SOFTWARE, EVEN IF ADVISED  OF  THE  POSSIBILITY  OF SUCH DAMAGE.
+//******************************************************************************
+//****************************************************************************
+//        FILE: aalrm-int.h
+//     CREATED: 02/20/2008
+//      AUTHOR: Joseph Grecco - Intel
+//
+// PURPOSE: This file containe internal definitions for the
+//          AAL Resource Manager Kernel Module.
+// HISTORY:
+// COMMENTS:
+// WHEN:          WHO:     WHAT:
+// 02/20/08       JG       Initial version created
+// 11/11/2008     JG       Added legal header
+// 01/04/2009     HM       Updated Copyright
+// 01/08/2009     JG       Cleanup and refactoring
+// 02/09/2009     JG       Added support for RMSS cancel transaction
+// 04/19/2012     TSW      Deprecate __func__ in favor of platform-agnostic
+//                          __AAL_FUNC__.
+//****************************************************************************
+#ifndef __AALKERNEL_AALRESOURCEMGR_CLIENT_AALRM_INT_H__
+#define __AALKERNEL_AALRESOURCEMGR_CLIENT_AALRM_INT_H__
+#include "aalsdk/kernel/kosal.h"
+#include "aalsdk/kernel/aalbus.h"
+#include "aalsdk/kernel/aalrm_client.h"
+
+
+#ifndef DRV_VERSION
+# define DRV_VERSION      "EXPERIMENTAL VERSION"
+#endif
+
+#define DRV_DESCRIPTION   "Resource Manager Client Service Kernel Module"
+#define DRV_AUTHOR        "Joseph Grecco <joe.grecco@intel.com>"
+#define DRV_LICENSE       "GPL"
+#define DRV_COPYRIGHT     "Copyright(c) 2008-2016, Intel Corporation"
+
+extern btUnsignedInt debug;
+
+#define AALRMC_DBG_ALL        AALRMC_DBG_MOD | AALRMC_DBG_FILE | AALRMC_DBG_MMAP | AALRMC_DBG_IOCTL
+#define AALRMC_DBG_INVLID    ~(AALRMC_DBG_ALL)
+#define AALRMC_DBG_DEFAULT    AALRMC_DBG_ALL
+
+
+///////////////////////////////////////////////////////////////////////////////
+///////////////////////////////////////////////////////////////////////////////
+////////////////////                                     //////////////////////
+/////////////////      RESOURCE MANAGER CLIENT SERVICE     ////////////////////
+////////////////////                                     //////////////////////
+///////////////////////////////////////////////////////////////////////////////
+///////////////////////////////////////////////////////////////////////////////
+//=============================================================================
+//=============================================================================
+struct aalresmgr;
+
+
+//=============================================================================
+// Name: aalresmgr_session
+// Description: Session structure holds state and other context for a user
+//              session with the resource manager.
+//=============================================================================
+struct aalresmgr_session{
+   // The resource manager client service
+   struct aalresmgr     *m_resmgr;
+
+   // Process ID of the process owning this session
+   btPID                 m_tgpid;
+
+   // List of devices owned by this session
+   kosal_list_head       m_devlist;
+
+   // Queue of sessions this session is on (RMC)
+   kosal_list_head       m_sessq;
+
+   // Queue of events to be sent to user space
+   aal_queue_t           m_eventq;
+
+   // Wait queue used for poll
+   kosal_poll_object     m_waitq;
+
+   // Private semaphore
+   kosal_semaphore	    m_sem;
+
+   // Counts transactions pending
+   btUnsignedInt         m_transcnt;
+
+};
+
+//=============================================================================
+// Name: aalresmgr
+// Description: Resource manager class. This is the class definition for the
+//              Resource Manager kernel service.
+//              Holds resource manager client specific information.
+//=============================================================================
+struct aalresmgr{
+
+   // Public Methods
+   void (*register_sess)(kosal_list_head *psession);
+   void (*unregister_sess)(kosal_list_head *psession);
+
+   // Resource manager driver
+   struct aal_driver       *m_driver;
+
+   // Resource manager class device
+   struct aal_classdevice  *m_class;
+
+   // List of current sessions
+   kosal_list_head         m_sessq;
+
+    // RMS service interface
+   struct aal_interface    *m_rmssrvs;
+
+   // Private semaphore
+   kosal_semaphore          m_sem;
+
+};
+
+///////////////////////////////////////////////////////////////////////////////
+///////////////////////////////////////////////////////////////////////////////
+////////////////////                                     //////////////////////
+/////////////////                  MACROS                  ////////////////////
+////////////////////                                     //////////////////////
+///////////////////////////////////////////////////////////////////////////////
+///////////////////////////////////////////////////////////////////////////////
+//=============================================================================
+//=============================================================================
+
+//RMC Driver object to AALBus
+#define rmcdrv_to_aalbus(drv)       (*(drv)->m_bus)
+
+//RMC Session to RMC
+#define rmssess_to_rmcsrv(sess)     (*(sess)->m_resmgr)
+
+//RMC Session to RMS
+#define rmssess_to_rmssrv(sess)     ((sess)->m_resmgr->m_rmssrvs)
+
+
+//--------
+// Externs
+//--------
+
+// Singleton resource manager
+extern struct aalresmgr resmgr;
+
+
+extern btInt aalrm_open(struct inode *, struct file *);
+extern btInt aalrm_close(struct inode *, struct file *);
+#if HAVE_UNLOCKED_IOCTL
+extern long aalrm_ioctl(struct file * , unsigned int , unsigned long );
+#else
+extern int aalrm_ioctl(struct inode * , struct file * ,
+                       unsigned int , unsigned long );
+#endif
+
+extern btUnsignedInt aalrm_poll(struct file *, poll_table *);
+extern btInt aalrm_flush_eventqueue(struct aalresmgr_session *);
+
+
+#endif // __AALKERNEL_AALRESOURCEMGR_CLIENT_AALRM_INT_H__
+
diff --git a/drivers/fpga/aal/rmc/aalrm-ioctl.c b/drivers/fpga/aal/rmc/aalrm-ioctl.c
new file mode 100644
index 000000000000..8601704501d3
--- /dev/null
+++ b/drivers/fpga/aal/rmc/aalrm-ioctl.c
@@ -0,0 +1,769 @@
+//******************************************************************************
+// This  file  is  provided  under  a  dual BSD/GPLv2  license.  When using or
+//         redistributing this file, you may do so under either license.
+//
+//                            GPL LICENSE SUMMARY
+//
+//  Copyright(c) 2008-2017, Intel Corporation.
+//
+//  This program  is  free software;  you  can redistribute it  and/or  modify
+//  it  under  the  terms of  version 2 of  the GNU General Public License  as
+//  published by the Free Software Foundation.
+//
+//  This  program  is distributed  in the  hope that it  will  be useful,  but
+//  WITHOUT   ANY   WARRANTY;   without   even  the   implied   warranty    of
+//  MERCHANTABILITY  or  FITNESS  FOR  A  PARTICULAR  PURPOSE.  See  the   GNU
+//  General Public License for more details.
+//
+//  The  full  GNU  General Public License is  included in  this  distribution
+//  in the file called README.GPLV2-LICENSE.TXT.
+//
+//  Contact Information:
+//  Henry Mitchel, henry.mitchel at intel.com
+//  77 Reed Rd., Hudson, MA  01749
+//
+//                                BSD LICENSE
+//
+//  Copyright(c) 2008-2017, Intel Corporation.
+//
+//  Redistribution and  use  in source  and  binary  forms,  with  or  without
+//  modification,  are   permitted  provided  that  the  following  conditions
+//  are met:
+//
+//    * Redistributions  of  source  code  must  retain  the  above  copyright
+//      notice, this list of conditions and the following disclaimer.
+//    * Redistributions in  binary form  must  reproduce  the  above copyright
+//      notice,  this  list of  conditions  and  the  following disclaimer  in
+//      the   documentation   and/or   other   materials   provided  with  the
+//      distribution.
+//    * Neither   the  name   of  Intel  Corporation  nor  the  names  of  its
+//      contributors  may  be  used  to  endorse  or promote  products derived
+//      from this software without specific prior written permission.
+//
+//  THIS  SOFTWARE  IS  PROVIDED  BY  THE  COPYRIGHT HOLDERS  AND CONTRIBUTORS
+//  "AS IS"  AND  ANY  EXPRESS  OR  IMPLIED  WARRANTIES,  INCLUDING,  BUT  NOT
+//  LIMITED  TO, THE  IMPLIED WARRANTIES OF  MERCHANTABILITY  AND FITNESS  FOR
+//  A  PARTICULAR  PURPOSE  ARE  DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT
+//  OWNER OR CONTRIBUTORS BE LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,
+//  SPECIAL,  EXEMPLARY,  OR  CONSEQUENTIAL   DAMAGES  (INCLUDING,   BUT   NOT
+//  LIMITED  TO,  PROCUREMENT  OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF USE,
+//  DATA,  OR PROFITS;  OR BUSINESS INTERRUPTION)  HOWEVER  CAUSED  AND ON ANY
+//  THEORY  OF  LIABILITY,  WHETHER  IN  CONTRACT,  STRICT LIABILITY,  OR TORT
+//  (INCLUDING  NEGLIGENCE  OR OTHERWISE) ARISING  IN ANY WAY  OUT  OF THE USE
+//  OF  THIS  SOFTWARE, EVEN IF ADVISED  OF  THE  POSSIBILITY  OF SUCH DAMAGE.
+//******************************************************************************
+//****************************************************************************
+//        FILE: aalrm-ioctl.c
+//     CREATED: 02/21/2008
+//      AUTHOR: Joseph Grecco - Intel
+//
+// PURPOSE:  IOCTL operations
+// HISTORY:
+// COMMENTS:
+// WHEN:          WHO:     WHAT:
+// 02-21-08       JG       Initial version created
+// 11/11/2008     JG       Added legal header
+// 01/04/2009     HM       Updated Copyright
+// 01/08/2009     JG       Cleanup and refactoring
+// 02/09/2009     JG       Added support for RMSS cancel transaction
+// 11/09/2010     HM       Removed extraneous kernel include asm/uaccess.h
+//****************************************************************************
+#include "aalsdk/kernel/kosal.h"
+
+#define MODULE_FLAGS AALRMC_DBG_IOCTL
+
+#include "aalsdk/kernel/aalbus.h"
+#include "aalsdk/kernel/aalinterface.h"
+#include "aalrm-int.h"
+#include "aalsdk/kernel/aalrm_server-services.h"
+#include "aalsdk/kernel/aalbus-device.h"
+#include "aalrm-events-int.h"
+
+
+//----------
+// Protoypes
+//----------
+static inline btInt aalrm_process_event(btUnsigned64bitInt arg,
+                                        struct aalrm_ioctlreq *,
+                                        struct aal_q_item *);
+
+static inline btInt aalrm_RequestDevEvent(btUnsigned64bitInt arg,
+                                          struct aalrm_ioctlreq *,
+                                          struct reqdev_cmplt *);
+
+static inline btInt aalrm_RegistrarEvent(btUnsigned64bitInt arg,
+                                         struct aalrm_ioctlreq *preq,
+                                         struct registrarreq_cmplt *pqitem);
+
+static inline btInt aalrm_ShutdownEvent(btUnsigned64bitInt arg,
+                                        struct aalrm_ioctlreq *preq,
+                                        struct shutdownreq_cmplt *pqitem);
+
+
+
+///////////////////////////////////////////////////////////////////////////////
+///////////////////////////////////////////////////////////////////////////////
+////////////////                                              /////////////////
+/////////////         RESOURCE MANAGER CLIENT CALLBACKS         ///////////////
+////////////////                                              /////////////////
+///////////////////////////////////////////////////////////////////////////////
+///////////////////////////////////////////////////////////////////////////////
+//=============================================================================
+//=============================================================================
+
+//=============================================================================
+// Name: aalrm_reqdev_cmplt
+// Description: Called by the Resource Manager Server Service when the device
+//              request completes
+// Interface: public
+// Inputs:  pretdev - response data
+//          origreq - original request
+//          context - pointer to the session this request belongs to
+// Outputs: none.
+// Comments:
+//=============================================================================
+void aalrm_reqdev_cmplt( btInt errno,
+                         struct rsp_device   *pretdev,
+                         struct req_allocdev *origreq,
+                         struct aalrms_req_tranID tranID )
+{
+   struct reqdev_cmplt *preqdev_cmplt = NULL;
+   struct aal_device *devp = NULL;
+   struct aalresmgr_session *psess = (struct aalresmgr_session *)tranID.m_context;
+
+   // Pending transactions
+   psess->m_transcnt--;
+   DPRINTF (AALRMC_DBG_IOCTL, ": Outstanding transactions %d\n",psess->m_transcnt);
+
+   // Was it cancelled?
+   if(errno == rms_resultCancelled){
+      // Nothing to do but delete
+      DPRINTF (AALRMC_DBG_IOCTL, ": Request device Cancelled.\n");
+
+      // No longer need the original request
+      kosal_kfree(origreq, sizeof(struct req_allocdev));
+      return;
+   }
+
+   //  Add the session to the owner list
+   if( likely(pretdev->result == rms_resultOK) ){
+      // Get the device from the handle and claim the device
+      devp = aaldev_handle_to_devp(pretdev->devHandle);
+      if(likely(devp) ){
+         aaldev_AddOwner_e ret;
+         kosal_sem_get_user_alertable( &psess->m_sem );
+         if( unlikely( (ret=dev_addOwner( devp,
+                                          psess->m_tgpid,
+                                          NULL, // TODO MANIFEST ON OWNER NOT SUPPORTED YET
+                                          NULL, // No owner context yet
+                                          &psess->m_devlist)) != aaldev_addowner_OK)  ) {
+
+            DPRINTF (AALRMC_DBG_IOCTL, ": failed to claim the device\n");
+
+            // Change the result to failed
+            pretdev->result = ret;
+            pretdev->devHandle = NULL;
+         }
+         kosal_sem_put( &psess->m_sem );
+      } // if(likely(devp) ) 
+      else{
+         DPRINTF (AALRMC_DBG_IOCTL, ": Software AFU returned\n");
+
+         // Must be SW AFU
+         pretdev->devHandle = NULL;
+
+      }
+   }// if( likely(pretdev->result == rms_resultOK) )
+   else{
+      DPRINTF (AALRMC_DBG_IOCTL, ": Received failed rsp_device\n");
+   }
+
+   // Create the completion event
+   preqdev_cmplt = reqdev_cmplt_create(pretdev,origreq);
+
+   // Queue the device result
+   _aal_q_enqueue(&AALQI(preqdev_cmplt), &psess->m_eventq);
+
+   // Wake any sleeping clients
+   wake_up_interruptible (&psess->m_waitq);
+
+   // No longer need the original request
+   kosal_kfree(origreq, sizeof(struct req_allocdev));
+}
+
+
+//=============================================================================
+// Name: aalrm_registar_cmplt
+// Description: Called by the RMS when the Registrar request completes
+// Interface: public
+// Inputs: errno - error code
+//         resp - response packet
+//         origreq - original request
+//         context - pointer to the session this request belongs to
+// Outputs: none.
+// Comments:
+//=============================================================================
+void aalrm_registar_cmplt(btInt errno,
+                          struct req_registrar *resp,
+                          struct req_registrar *origreq,
+                          struct aalrms_req_tranID tranID)
+{
+   struct aalresmgr_session *psess = (struct aalresmgr_session *)tranID.m_context;
+   struct registrarreq_cmplt *preq_cmplt;
+   // Pending transactions
+   psess->m_transcnt--;
+   DPRINTF (AALRMC_DBG_IOCTL, ": Outstanding transactions %d\n",psess->m_transcnt);
+
+   // Was it cancelled?
+   if(errno == rms_resultCancelled){
+      // decrement the reference and ignore
+      DPRINTF (AALRMC_DBG_IOCTL, ": Request device Cancelled.\n");
+
+      // No longer need the original request
+      kosal_kfree(origreq, sizeof(struct req_registrar));
+      return;
+   }
+
+   // Create the completion event
+   preq_cmplt = registrar_cmplt_create(errno,resp);
+
+   // Queue the device result
+   _aal_q_enqueue(&AALQI(preq_cmplt), &psess->m_eventq);
+
+   // Wake any sleeping clients
+   wake_up_interruptible (&psess->m_waitq);
+
+   // No longer need the original request
+   kosal_kfree(origreq, sizeof(struct req_registrar));
+}
+
+
+//=============================================================================
+// Name: aalrm_shutdown_cmplt
+// Description: Called by the ioctl message reqid_Shutdown
+// Interface: public
+// Inputs: errno - error code
+//         resp - response packet
+//         origreq - original request
+//         context - pointer to the session this request belongs to
+// Outputs: none.
+// Comments:
+//=============================================================================
+void aalrm_shutdown_cmplt(btInt errno, void * context)
+{
+   struct aalresmgr_session *psess = context;
+
+   // Create the completion event
+   struct shutdownreq_cmplt *pshutdownreq_cmplt = shutdown_cmplt_create(errno);
+
+   // Queue the device result
+   _aal_q_enqueue(&AALQI(pshutdownreq_cmplt), &psess->m_eventq);
+
+   // Wake any sleeping clients
+   wake_up_interruptible (&psess->m_waitq);
+
+}
+
+///////////////////////////////////////////////////////////////////////////////
+///////////////////////////////////////////////////////////////////////////////
+////////////////                                              /////////////////
+/////////////             EVENT HANDLING FUNCTIONS              ///////////////
+////////////////                                              /////////////////
+///////////////////////////////////////////////////////////////////////////////
+///////////////////////////////////////////////////////////////////////////////
+//=============================================================================
+//=============================================================================
+
+//=============================================================================
+// Name: aalrm_process_event
+// Description: Process the event. An event is defined as a message from
+//              the RMS e.g., a response.
+// Interface: private
+// Inputs: pqitem - AAL Qitem object
+// Outputs: none.
+// Comments:
+//=============================================================================
+static btInt aalrm_process_event(btUnsigned64bitInt arg,
+                                 struct aalrm_ioctlreq    *preq,
+                                 struct aal_q_item *pqitem)
+{
+   // Switch on message type
+   switch(pqitem->m_id) {
+      // Request response message
+      case rspid_URMS_RequestDevice:
+         return aalrm_RequestDevEvent(arg, preq, qi_to_reqdev_cmplt(pqitem));
+         break;
+
+      case rspid_RS_Registrar:
+         return aalrm_RegistrarEvent(arg, preq, qi_to_registrarreq_cmplt(pqitem));
+         break;
+
+      case rspid_Shutdown:
+         return aalrm_ShutdownEvent(arg, preq, qi_to_shutdownreq_cmplt(pqitem));
+         break;
+      default:
+         return -EINVAL;
+   }
+   return 0;
+}
+
+//=============================================================================
+// Name: aalrm_RequestDevEvent
+// Description: Process the RequestDev resposne event
+// Interface: private
+// Inputs: pitem - Request object
+// Outputs: none.
+// Comments:
+//=============================================================================
+static inline btInt aalrm_RequestDevEvent(btUnsigned64bitInt arg,
+                                          struct aalrm_ioctlreq *preq,
+                                          struct reqdev_cmplt *pqitem)
+{
+   preq->id = rspid_URMS_RequestDevice;
+   preq->res_handle = pqitem->retdev.devHandle;
+   preq->result_code = pqitem->retdev.result;
+   preq->context = pqitem->context;
+   preq->tranID = pqitem->tranID;
+
+   if(preq->result_code != rms_resultOK){
+      DPRINTF(AALRMC_DBG_IOCTL, ": About to return failure %d\n",preq->result_code);
+   }
+
+   // Copy the header portion of the request back
+   if(copy_to_user ((struct aalrm_ioctlreq *) arg, preq, sizeof(struct aalrm_ioctlreq))){
+      DPRINTF(AALRMC_DBG_IOCTL, ": Failed get Message \n");
+      reqdev_cmplt_destroy(pqitem);
+      return -EFAULT;
+   }
+
+   DPRINTF( AALRMC_DBG_IOCTL,
+            ": About to copy payload[%d] to buf[%d]\n %s",
+            (int)QI_LEN(AALQIP(pqitem)),
+            (int)preq->size,&pqitem->retdev.buf);
+
+   if(preq->size >= QI_LEN(AALQIP(pqitem))){
+      preq->size  = QI_LEN(AALQIP(pqitem));
+
+      //-----------------------------------------------------------------------
+      // Copy the payload portion of the request back
+      // Note that the preq holds the user request and thus the payload pointer
+      //-----------------------------------------------------------------------
+      if(copy_to_user ((struct aalrm_ioctlreq *)preq->payload, &pqitem->retdev.buf, preq->size)){
+         DPRINTF(AALRMC_DBG_IOCTL, ": Failed get Message \n");
+         reqdev_cmplt_destroy(pqitem);
+         return -EFAULT;
+      }
+   }// if(preq->size >= QI_LEN(AALQIP(pqitem)))
+   else{
+      // Invalid size for the return payload
+      reqdev_cmplt_destroy(pqitem);
+      return -EINVAL;
+   }
+
+   //Destroy the request
+   reqdev_cmplt_destroy(pqitem);
+   return 0;
+}
+
+//=============================================================================
+// Name: aalrm_RegistrarEvent
+// Description: Process the Registrar response event
+// Interface: private
+// Inputs: pitem - Request object
+// Outputs: none.
+// Comments:
+//=============================================================================
+static inline btInt aalrm_RegistrarEvent(btUnsigned64bitInt arg,
+                                         struct aalrm_ioctlreq *preq,
+                                         struct registrarreq_cmplt *pqitem)
+{
+   preq->size  = QI_LEN(AALQIP(pqitem));
+   preq->id = rspid_URMS_RequestDevice;
+
+   // Copy the header portion of the request back
+   if(copy_to_user ((struct aalrm_ioctlreq *)arg, preq, sizeof(struct aalrm_ioctlreq))){
+      DPRINTF(AALRMC_DBG_IOCTL, ": Failed get Message \n");
+      return -EFAULT;
+   }
+
+   //-----------------------------------------------------------------------
+   // Copy the payload portion of the request back
+   // Note that the preq holds the user request and thus the payload pointer
+   //-----------------------------------------------------------------------
+   if(copy_to_user ((struct aalrm_ioctlreq *)preq->payload, &pqitem->resp->buf, preq->size)){
+      DPRINTF(AALRMC_DBG_IOCTL, ": Failed get Message \n");
+      return -EFAULT;
+   }
+
+   //Destroy the request
+   registrar_cmplt_destroy(pqitem);
+   return 0;
+}
+
+//=============================================================================
+// Name: aalrm_ShutdownEvent
+// Description: Process the shutdown event
+// Interface: private
+// Inputs: pitem - Request object
+// Outputs: none.
+// Comments:
+//=============================================================================
+static inline btInt aalrm_ShutdownEvent(btUnsigned64bitInt arg,
+                                        struct aalrm_ioctlreq *preq,
+                                        struct shutdownreq_cmplt *pqitem)
+{
+   preq->size = AALQ_QLEN(pqitem);
+   preq->id = rspid_Shutdown;
+
+   DPRINTF(AALRMC_DBG_IOCTL, ": Shutdown Event\n");
+
+   // Copy the header portion of the request back
+   if(copy_to_user ((struct aalrm_ioctlreq *)arg, preq, sizeof(struct aalrm_ioctlreq))){
+      DPRINTF(AALRMC_DBG_IOCTL, ": Failed get Message \n");
+      return -EFAULT;
+   }
+
+   //Destroy the request
+   shutdown_cmplt_destroy(pqitem);
+   return 0;
+}
+
+///////////////////////////////////////////////////////////////////////////////
+///////////////////////////////////////////////////////////////////////////////
+////////////////                                              /////////////////
+/////////////             MESSAGE HANDLING FUNCTIONS            ///////////////
+////////////////                                              /////////////////
+///////////////////////////////////////////////////////////////////////////////
+///////////////////////////////////////////////////////////////////////////////
+//=============================================================================
+//=============================================================================
+
+//=============================================================================
+// Name: aalrm_processmsg
+// Description: Processes request messages from the user
+// Interface: private
+// Inputs: preq - pointer to generic request header
+//         psess - session
+// Outputs: none.
+// Comments:
+//=============================================================================
+btInt aalrm_processmsg(struct aalrm_ioctlreq    *preq,
+                       struct aalresmgr_session *psess )
+{
+   // Various variables that will be used exclusively
+   union {
+      struct req_allocdev  *pallocreq;
+      struct req_registrar *preqreg;
+   }req;
+
+   struct aalrms_req_tranID tranID;
+
+   struct req_allocdev  *pallocmsg;
+   btInt                 ret = 0;
+   struct aal_device    *pdev = NULL;
+   struct aaldev_ownerSession * ownerSessp = NULL;
+
+   switch(preq->id) {
+      // Registrar request
+      case reqid_RS_Registrar:{
+         // Allocate the message -
+         // Note the message will be freed when the completion event is returned
+         req.preqreg = (struct req_registrar *)kosal_kmalloc((preq->size + REGISTRAR_REQ_HDRSZ));
+         if(req.preqreg == NULL){
+            DPRINTF (AALRMC_DBG_IOCTL, ": CMD - reqid_Registrar failed kmalloc\n");
+            return -ENOMEM;
+         }
+         // Copy in the request and payload
+         req.preqreg->tranID = preq->tranID;
+         req.preqreg->context = preq->context;
+         req.preqreg->size = preq->size;
+
+         if(copy_from_user (&req.preqreg->buf, preq->payload, preq->size)){
+            DPRINTF (AALRMC_DBG_IOCTL, ": CMD - Copy failed\n");
+            kosal_kfree(req.preqreg, (preq->size + REGISTRAR_REQ_HDRSZ));
+            return -EFAULT;
+         }
+         //--------------------------------------------------------------
+         // Call the RMS service Registrar Request method
+         // NOTE: i_rmserver() returns the aalrms_service interface from
+         //       an aal_interface to a RMS service pointer
+         //--------------------------------------------------------------
+
+         // TODO MUST HAVE A METHOD OF FLUSHING OUTSTANDING REQUESTS IN THE CASE OF A CLOSE OR ABORT
+         DPRINTF (AALRMC_DBG_IOCTL, ": CMD - Calling RMS reqid_Registrar\n");
+
+         // Pending transactions
+         psess->m_transcnt++;
+         tranID.m_context = psess;
+         ret = i_rmserver(rmssess_to_rmssrv(psess)).registrar_request( req.preqreg,
+                                                                       aalrm_registar_cmplt,
+                                                                       tranID);
+         DPRINTF (AALRMC_DBG_IOCTL, ": Outstanding transactions %d\n",psess->m_transcnt);
+         DPRINTF (AALRMC_DBG_IOCTL, ": CMD - Done Calling reqid_Registrar\n");
+         break;
+      }// case reqid_RS_Registrar
+
+
+      // Request a device be allocated
+      case reqid_URMS_RequestDevice:  {
+         // Allocate the message -
+         // Note the message will be freed when the compeletion event is returned
+         pallocmsg = (struct req_allocdev  *)kosal_kmalloc((preq->size + ALLOC_DEVHDRSZ));
+         if(pallocmsg == NULL){
+            DPRINTF (AALRMC_DBG_IOCTL, ": CMD - AALRM_IOCTL_REQDEV failed kmalloc\n");
+            return -ENOMEM;
+         }
+         // Copy in the request and payload
+         pallocmsg->tranID = preq->tranID;
+         pallocmsg->context = preq->context;
+         pallocmsg->size = preq->size;
+         if( preq->size != 0 ){
+            if(copy_from_user (&pallocmsg->buf, preq->payload, preq->size)){
+               DPRINTF (AALRMC_DBG_IOCTL, ": CMD - Copy failed\n");
+               kosal_kfree(pallocmsg, (preq->size + ALLOC_DEVHDRSZ));
+               return -EFAULT;
+            }
+         }
+
+         DPRINTF(AALRMC_DBG_IOCTL, ": About to Get %d  \n %s\n",(int)pallocmsg->size,(char*)&pallocmsg->buf);
+
+         //--------------------------------------------------------------
+         // Call the RMS service request Device method
+         // Note: first psess is used by PM to assign ownership to device
+         //       the second is the context used in the callback
+         // NOTE: i_rmserver() returns the aalrms_service interface from
+         //       an aal_interface to a RMS service pointer
+         //---------------------------------------------------------------
+         DPRINTF (AALRMC_DBG_IOCTL, ": CMD - Calling RMS request_device\n");
+
+         // Pending transactions
+         tranID.m_context = psess;
+         psess->m_transcnt++;
+         ret = i_rmserver(rmssess_to_rmssrv(psess)).request_device( pallocmsg,
+                                                                    aalrm_reqdev_cmplt,
+                                                                    tranID);
+
+         DPRINTF (AALRMC_DBG_IOCTL, ": Outstanding transactions %d\n",psess->m_transcnt);
+         DPRINTF (AALRMC_DBG_IOCTL, ": CMD - Done Calling RMS request_device\n");
+         break;
+      }// case reqid_URMS_RequestDevice
+
+      case reqid_URMS_ReleaseDevice: {
+          DPRINTF (AALRMC_DBG_IOCTL, ": reqid_URMS_ReleaseDevice - UI\n");
+
+          // Get the device from the handle and validate
+          pdev = aaldev_handle_to_devp(preq->res_handle);
+          if( unlikely(pdev == NULL) ){
+             DPRINTF (AALRMC_DBG_IOCTL, ": Invalid device handle %p\n", preq->res_handle);
+             return -EINVAL;
+          }
+
+          // Get the device session for this device
+          ownerSessp = dev_OwnerSession(pdev,psess->m_tgpid);
+
+          // Get the default message interface
+          if(ownerSessp == NULL){
+                DPRINTF (AALRMC_DBG_IOCTL, ": Not owner or no message handler during Release Device.\n");
+                return -EACCES;
+          }
+
+          // Update the owner's list
+          if(unlikely(!dev_removeOwner( pdev,
+                                        psess->m_tgpid))){
+             DPRINTF (AALRMC_DBG_IOCTL, ": Failed to update owner\n");
+             ret = -EINVAL;
+           }
+           break;
+      }// case reqid_URMS_ReleaseDevice
+      case reqid_Shutdown:{
+         DPRINTF (AALRMC_DBG_IOCTL, ": CMD - Shutdown\n");
+         // For now nothing much to do so complete
+         aalrm_shutdown_cmplt(0, psess);
+         ret = 0;
+         break;
+      }
+
+      default: {
+         DPRINTF (AALRMC_DBG_IOCTL, ": CMD - Unexpected\n");
+         ret = -EINVAL;
+         break;
+      }
+   } // switch(preq->id) 
+   return ret;
+}
+
+///////////////////////////////////////////////////////////////////////////////
+///////////////////////////////////////////////////////////////////////////////
+////////////////                                              /////////////////
+/////////////             IOCTL HANDLING FUNCTION                //////////////
+////////////////                                              /////////////////
+///////////////////////////////////////////////////////////////////////////////
+///////////////////////////////////////////////////////////////////////////////
+//=============================================================================
+//=============================================================================
+
+//=============================================================================
+// Name: aalrm_ioctl
+// Description: Implements the ioctl system call
+// Interface: public
+// Inputs: inode - pointer to inode of special device file
+//         file - open file instance
+//         cmd - from command argument of ioctl
+//         arg - arg argument of ioctl
+// Outputs: none.
+// Comments:
+//=============================================================================
+#if HAVE_UNLOCKED_IOCTL
+long aalrm_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
+#else
+int aalrm_ioctl(struct inode *inode, struct file *file,
+                unsigned int cmd, unsigned long arg)
+#endif
+{
+   btInt ret=0;
+   struct aalrm_ioctlreq    req;              // Holds user request
+   struct aal_q_item       *pqitem = NULL;    // Generic request queue item
+
+   // Get the user session
+   struct aalresmgr_session *psess = (struct aalresmgr_session *) file->private_data;
+
+   // Get the request header first
+   if (copy_from_user (&req, (void *) arg, sizeof(req))){
+    return -EFAULT;
+   }
+
+   if ( ( req.size + REGISTRAR_REQ_HDRSZ ) > KMALLOC_MAX_SIZE ) {
+      PERR("Request size too large: %" PRIu64 "\n", req.size + REGISTRAR_REQ_HDRSZ);
+      return -EINVAL;
+   }
+
+   ret = -EINVAL;  //Assume failure
+
+   // Inv Process IOCTL CMD
+   switch (cmd){
+      // Send message
+      case AALRM_IOCTL_SENDMSG:{
+         return aalrm_processmsg(&req, psess);
+         break;
+      }
+
+      //---------------------------------------
+      // Get next queued RMS message descriptor
+      // This will contain things like its
+      // size and type
+      //---------------------------------------
+      case AALRM_IOCTL_GETMSG_DESC: {
+         // Make sure there is a message to be had
+         if( _aal_q_empty( &psess->m_eventq ) ){
+            DPRINTF( AALRMC_DBG_IOCTL, ": No Message available\n" );
+            return -EAGAIN;
+         }
+
+         // Peek the head of the RMS message queue
+         pqitem = _aal_q_peek( &psess->m_eventq );
+         if(pqitem == NULL){
+            DPRINTF( AALRMC_DBG_IOCTL, ": AALRM_IOCTL_GETMSG_DESC Invalid or corrupted request\n" );
+            return -EFAULT;
+         }
+
+         // Return the type and total size of the message that will be returned including header
+         req.id    = QI_QID(pqitem);
+         req.size  = QI_LEN(pqitem);
+
+         DPRINTF(AALRMC_DBG_MOD, ": Getting Message Descriptor - size = %d\n",(int)req.size );
+         if(copy_to_user ((struct aalrm_ioctlreq *) arg, &req, sizeof(struct aalrm_ioctlreq))){
+            DPRINTF(AALRMC_DBG_IOCTL, ": Failed get Message Decriptor \n");
+            return -EFAULT;
+         }
+         ret = 0;
+        break;
+      } // case AALRM_IOCTL_GETMSG_DESC
+
+      //----------------------------------------------------
+      // Get the next message off of the RMS message queue
+      //----------------------------------------------------
+      case AALRM_IOCTL_GETMSG:{
+         DPRINTF( AALRMC_DBG_IOCTL, ": Getting Message\n" );
+
+         // Make sure there is a message to be had
+         if(  _aal_q_empty( &psess->m_eventq ) ){
+            DPRINTF( AALRMC_DBG_IOCTL, ": No Message available\n" );
+            req.size = 0;
+            if(copy_to_user ((struct aalrm_ioctlreq *) arg, &req, sizeof(struct aalrm_ioctlreq))){
+               DPRINTF(AALRMC_DBG_IOCTL, ": Failed copy Message\n");
+               return -EFAULT;
+            }
+            return -EAGAIN;
+         }
+
+         //------------------------
+         // Get the request message
+         //------------------------
+         pqitem = _aal_q_dequeue(&psess->m_eventq);
+         if(pqitem == NULL){
+            DPRINTF( AALRMC_DBG_IOCTL, ": AALRM_IOCTL_GETMSG Invalid or corrupted request\n" );
+            return -EFAULT;
+         }
+
+         ret = aalrm_process_event(arg,
+                                   &req,
+                                   pqitem);
+      break;
+      } // case AALRM_IOCTL_GETMSG
+
+      default:
+         DPRINTF (AALRMC_DBG_IOCTL, ": Invalid IOCTL=%x\n", cmd);
+         ret = -EINVAL;
+         break;
+
+   } // switch (cmd)
+   return ret;
+}
+
+
+//=============================================================================
+// Name: aalrm_flush_eventqueue
+// Description: flush the event queue
+// Interface: private
+// Inputs: psess - session pointer
+// Outputs: none.
+// Comments:
+//=============================================================================
+btInt aalrm_flush_eventqueue(  struct aalresmgr_session *psess)
+{
+   btInt ret = 0;
+   struct aal_q_item *pqitem;
+   DPRINTF( AALRMC_DBG_FILE, ": Flushing event queue\n" );
+   while(!_aal_q_empty(&psess->m_eventq) ) {
+      //------------------------
+      // Get the request message
+      //------------------------
+      pqitem = _aal_q_dequeue(&psess->m_eventq);
+      if(pqitem == NULL) {
+         DPRINTF( AALRMC_DBG_FILE, ": Invalid or corrupted request on flush\n" );
+         continue;
+      }
+      // Switch on message type
+      switch(pqitem->m_id){
+         // Request response message
+         case rspid_URMS_RequestDevice:
+            DPRINTF( AALRMC_DBG_FILE, ": rspid_URMS_RequestDevice\n" );
+            reqdev_cmplt_destroy(qi_to_reqdev_cmplt(pqitem));
+            break;
+
+         case rspid_RS_Registrar:
+            DPRINTF( AALRMC_DBG_FILE, ": rspid_RS_Registrar\n" );
+            registrar_cmplt_destroy(qi_to_registrarreq_cmplt(pqitem));
+            break;
+
+         case rspid_Shutdown:
+            DPRINTF( AALRMC_DBG_FILE, ": rspid_Shutdown\n" );
+            shutdown_cmplt_destroy(qi_to_shutdownreq_cmplt(pqitem));
+            break;
+
+         default:
+            DPRINTF( AALRMC_DBG_FILE, ": Encountered unknown event while flushing - leak\n" );
+      }
+   }
+   return ret;
+}
diff --git a/drivers/fpga/aal/rmc/aalrm-main.c b/drivers/fpga/aal/rmc/aalrm-main.c
new file mode 100644
index 000000000000..2d630a828531
--- /dev/null
+++ b/drivers/fpga/aal/rmc/aalrm-main.c
@@ -0,0 +1,611 @@
+//******************************************************************************
+// This  file  is  provided  under  a  dual BSD/GPLv2  license.  When using or
+//         redistributing this file, you may do so under either license.
+//
+//                            GPL LICENSE SUMMARY
+//
+//  Copyright(c) 2008-2017, Intel Corporation.
+//
+//  This program  is  free software;  you  can redistribute it  and/or  modify
+//  it  under  the  terms of  version 2 of  the GNU General Public License  as
+//  published by the Free Software Foundation.
+//
+//  This  program  is distributed  in the  hope that it  will  be useful,  but
+//  WITHOUT   ANY   WARRANTY;   without   even  the   implied   warranty    of
+//  MERCHANTABILITY  or  FITNESS  FOR  A  PARTICULAR  PURPOSE.  See  the   GNU
+//  General Public License for more details.
+//
+//  The  full  GNU  General Public License is  included in  this  distribution
+//  in the file called README.GPLV2-LICENSE.TXT.
+//
+//  Contact Information:
+//  Henry Mitchel, henry.mitchel at intel.com
+//  77 Reed Rd., Hudson, MA  01749
+//
+//                                BSD LICENSE
+//
+//  Copyright(c) 2008-2017, Intel Corporation.
+//
+//  Redistribution and  use  in source  and  binary  forms,  with  or  without
+//  modification,  are   permitted  provided  that  the  following  conditions
+//  are met:
+//
+//    * Redistributions  of  source  code  must  retain  the  above  copyright
+//      notice, this list of conditions and the following disclaimer.
+//    * Redistributions in  binary form  must  reproduce  the  above copyright
+//      notice,  this  list of  conditions  and  the  following disclaimer  in
+//      the   documentation   and/or   other   materials   provided  with  the
+//      distribution.
+//    * Neither   the  name   of  Intel  Corporation  nor  the  names  of  its
+//      contributors  may  be  used  to  endorse  or promote  products derived
+//      from this software without specific prior written permission.
+//
+//  THIS  SOFTWARE  IS  PROVIDED  BY  THE  COPYRIGHT HOLDERS  AND CONTRIBUTORS
+//  "AS IS"  AND  ANY  EXPRESS  OR  IMPLIED  WARRANTIES,  INCLUDING,  BUT  NOT
+//  LIMITED  TO, THE  IMPLIED WARRANTIES OF  MERCHANTABILITY  AND FITNESS  FOR
+//  A  PARTICULAR  PURPOSE  ARE  DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT
+//  OWNER OR CONTRIBUTORS BE LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,
+//  SPECIAL,  EXEMPLARY,  OR  CONSEQUENTIAL   DAMAGES  (INCLUDING,   BUT   NOT
+//  LIMITED  TO,  PROCUREMENT  OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF USE,
+//  DATA,  OR PROFITS;  OR BUSINESS INTERRUPTION)  HOWEVER  CAUSED  AND ON ANY
+//  THEORY  OF  LIABILITY,  WHETHER  IN  CONTRACT,  STRICT LIABILITY,  OR TORT
+//  (INCLUDING  NEGLIGENCE  OR OTHERWISE) ARISING  IN ANY WAY  OUT  OF THE USE
+//  OF  THIS  SOFTWARE, EVEN IF ADVISED  OF  THE  POSSIBILITY  OF SUCH DAMAGE.
+//******************************************************************************
+//****************************************************************************
+//        FILE: aalrm-main.c
+//     CREATED: 02/20/2008
+//      AUTHOR: Joseph Grecco - Intel
+//
+// PURPOSE: This file implements the initialization and cleanup code for the
+//          AAL Resource Manager Client Service Module.
+// HISTORY:
+// COMMENTS: This module implements the resource manager client.
+// WHEN:          WHO:     WHAT:
+// 02/20/08       JG       Initial version created
+// 06/17/08       JG       Separated Policy manager (a.k.a. RMS)
+// 11/11/2008     JG       Added legal header
+// 01/04/2009     HM       Updated Copyright
+// 01/08/2009     JG       Cleanup and refactoring
+// 02/26/2009     JG       Nulled unused match()
+// 05/18/2010     HM       Labeled kosal_sem_get_krnl_alertable() with FIXME. Need a
+//                            global fix for these. Getting it to compile.
+// 11/09/2010     HM       Removed extraneous kernel include asm/uaccess.h
+//****************************************************************************
+#include "aalsdk/kernel/kosal.h"
+
+#define MODULE_FLAGS AALRMC_DBG_MOD
+
+#include "aalrm-int.h"
+#include "aalsdk/kernel/aalrm-services.h"
+#include "aalsdk/kernel/aalrm_server-services.h"
+#include "aalsdk/kernel/aalbus.h"
+#include "aalsdk/kernel/aalinterface.h"
+
+
+MODULE_VERSION    (DRV_VERSION);
+MODULE_DESCRIPTION(DRV_DESCRIPTION);
+MODULE_AUTHOR     (DRV_AUTHOR);
+MODULE_LICENSE    (DRV_LICENSE);
+
+//=============================================================================
+// Driver Parameters
+//=============================================================================
+
+// debug flags with default values
+btUnsignedInt debug = 0
+#if 0
+   | AALRMC_DBG_DEFAULT
+#endif
+;
+
+// Major device number to use for the device nodes
+btInt majornum = 0;
+
+
+//
+//  Declarations for module parameters - Enables parameter value passing from
+//                                       insmod and permissions as seen from /sys
+//
+MODULE_PARM_DESC(debug, "debug level");
+module_param    (debug, int, 0644);
+
+MODULE_PARM_DESC(majornum, "major device number");
+module_param    (majornum, int, 0444);
+
+
+//=============================================================================
+// Name: aalbus_attrib_show_debug
+//=============================================================================
+static ssize_t ahmpip_attrib_show_debug(struct device_driver *drv, char *buf)
+{
+   return (snprintf(buf,PAGE_SIZE,"%d\n",debug));
+}
+
+//=============================================================================
+// Name: aalbus_attrib_store_debug
+//=============================================================================
+static ssize_t ahmpip_attrib_store_debug(struct device_driver *drv,
+                                         const char *buf,
+                                         size_t size)
+{
+   int temp = 0;
+   sscanf(buf,"%d", &temp);
+
+   debug = temp;
+
+   DPRINTF(AALRMC_DBG_MOD,": Attribute change - debug = %d\n", temp);
+   return size;
+}
+
+// Attribute accessors for debug
+DRIVER_ATTR(debug,S_IRUGO|S_IWUSR|S_IWGRP, ahmpip_attrib_show_debug,ahmpip_attrib_store_debug);
+
+
+// Declare standard entry points
+static btInt  aalrm_init(void);
+static void aalrm_exit(void);
+
+module_init(aalrm_init);
+module_exit(aalrm_exit);
+
+static btInt resourcemgr_init(void);
+static void aalrm_register_sess(kosal_list_head *);
+static void aalrm_unregister_sess(kosal_list_head *);
+
+#if 0
+static btInt aalrm_initialize_driver(const char *,
+                                     int,
+                                     struct aal_driver *,
+                                     struct aal_classdevice *);
+static void aalrm_removedriver(struct aal_driver*,
+                               struct aal_classdevice *);
+#endif
+
+static struct aal_interface *aalrm_get_interface(struct aal_driver*,
+                                                 btID );
+static btInt aalrm_has_interface(struct aal_driver*,
+                                 btID);
+static btInt aalrm_supports_interface(struct aal_driver*,
+                                      btID);
+
+
+///////////////////////////////////////////////////////////////////////////////
+///////////////////////////////////////////////////////////////////////////////
+////////////////////                                     //////////////////////
+/////////////////      RESOURCE MANAGER CLIENT OBJECTS     ////////////////////
+////////////////////                                     //////////////////////
+///////////////////////////////////////////////////////////////////////////////
+///////////////////////////////////////////////////////////////////////////////
+//=============================================================================
+//=============================================================================
+
+//=============================================================================
+// Name: devIID_tbl
+// Description: Lists the IDs of the interfaces this service exports to the
+//              AALBus interface broker
+//=============================================================================
+static btID  devIID_tbl[] = {
+   AAL_RMAPI_IID_01,
+   0
+};
+
+//=============================================================================
+// Name: id_table
+// Description: This driver supports the following devices
+//=============================================================================
+static struct aal_device_id id_table[] = {
+   aal_device_id_terminator // None
+};
+
+// Used for hotplug system
+MODULE_DEVICE_TABLE( aal, id_table );
+
+//=============================================================================
+// Name: aalrm_class
+// Description: Class device. Wrapper object that contains both the Linux
+//              DD Model class information but also AAL specific class
+//              information. The modules "class" defines its unique interface
+//              attributes.
+//=============================================================================
+struct aal_classdevice  rm_class = {
+   .m_classid = {
+      .m_majorversion   = AALRM_API_MAJVERSION,
+      .m_minorversion   = AALRM_API_MINVERSION,
+      .m_releaseversion = AALRM_API_RELEASE,
+      .m_classGUID      = AALRM_API_INTC,
+   },
+   .m_devIIDlist = devIID_tbl,        // List of supported APIs
+};
+
+
+//=============================================================================
+//=============================================================================
+// Name: rm_driver
+// Description: This is the Resource Manager Driver Object singleton. This is
+//              object that gets registered with AALBus.  It is a device driver
+//              in name only. It does not actually control any device HW.
+//              As a device driver module it is allowed to expose a user mode
+//              interface.
+//=============================================================================
+//=============================================================================
+static struct aal_driver rm_driver = {
+
+   // File operations (User Space control interface)
+   .m_fops = {
+      .owner    = THIS_MODULE,
+      .open     = aalrm_open,
+      .release  = aalrm_close,
+
+#if HAVE_UNLOCKED_IOCTL
+      .unlocked_ioctl = aalrm_ioctl,
+#else
+      .ioctl          = aalrm_ioctl,  // Deprecated in 2.6.36
+#endif
+
+      .poll     = aalrm_poll,
+   },
+
+   // Return an interface pointer based on the iid. Used to dynamically
+   // bind to a custom interface the driver may export. Typically used to
+   // export the internal control interface used by a user space interface
+   // driver.
+   .get_interface          = aalrm_get_interface,
+
+   // Return 1 if interface supported
+   .has_interface          = aalrm_has_interface,
+
+   // Returns 1 if the interface specified in iid can be used. Typically
+   // used to find out if a user space interface driver can "speak" particular
+   // interface.
+   .supports_interface     = aalrm_supports_interface,
+
+   // List of implemented dynamic interfaces
+   .m_iids                 = 0,
+
+   // ID list of supported devices if this is a device driver
+   .m_idtable              = id_table,
+
+   // Called to determine if this driver supports a device
+   //.m_match                = aalrm_drv_match,
+   .m_match                = NULL,
+
+   // Called when a device matches
+   .m_probe                = NULL,
+
+   // Base structure
+   .m_driver = {
+      .owner   = THIS_MODULE,
+      .name    = RESMGR_DEV_NAME,
+   },
+};
+
+
+//=============================================================================
+// Name: resmgr
+// Description: Resource manager service object instance.
+//=============================================================================
+struct aalresmgr resmgr = {
+   // Public Methods
+   .register_sess    = aalrm_register_sess,
+   .unregister_sess  = aalrm_unregister_sess,
+
+   // Driver and class
+   .m_driver   =  &rm_driver,
+   .m_class    =  &rm_class,
+};
+
+///////////////////////////////////////////////////////////////////////////////
+///////////////////////////////////////////////////////////////////////////////
+////////////////////                                     //////////////////////
+/////////////////         RESOURCE MANAGER METHODS         ////////////////////
+////////////////////                                     //////////////////////
+///////////////////////////////////////////////////////////////////////////////
+///////////////////////////////////////////////////////////////////////////////
+//=============================================================================
+//=============================================================================
+
+//=============================================================================
+// Name: aalrm_register_sess
+// Description: Registers a session with the resource manager
+// Interface: public
+// Inputs: psession - session pointer
+// Outputs: none.
+// Comments:
+//=============================================================================
+void aalrm_register_sess(kosal_list_head *psession)
+{
+   if (kosal_sem_get_krnl_alertable(&resmgr.m_sem)) { /* FIXME */ }
+   kosal_list_add_head( psession, &resmgr.m_sessq);
+   kosal_sem_put(&resmgr.m_sem);
+}
+
+//=============================================================================
+// Name: aalrm_unregister_sess
+// Description: Unregisters a session with the resource manager
+// Interface: public
+// Inputs: psession - session pointer
+// Outputs: none.
+// Comments:
+//=============================================================================
+void aalrm_unregister_sess(kosal_list_head *psession)
+{
+   if (kosal_sem_get_krnl_alertable(&resmgr.m_sem)) { /* FIXME */ }
+   kosal_list_del_init(psession);
+   kosal_sem_put(&resmgr.m_sem);
+}
+
+//=============================================================================
+// Name: aalrm_init
+// Description: Initialization routine for the module.  This is the module
+//              entry point.
+// Interface: public
+// Inputs: none.
+// Outputs: none.
+// Comments:
+//=============================================================================
+btInt aalrm_init(void)
+{
+   btInt ret = 0;
+
+   //-------------------
+   // Display the signon
+   //-------------------
+   kosal_printk_level(KERN_INFO, "Accelerator Abstraction Layer\n");
+   kosal_printk_level(KERN_INFO, "-> %s\n", DRV_DESCRIPTION);
+   kosal_printk_level(KERN_INFO, "-> Version %s\n",DRV_VERSION);
+   kosal_printk_level(KERN_INFO, "-> %s\n", DRV_COPYRIGHT);
+
+   //--------------------------------
+   // Initialize the Resource Manager
+   //--------------------------------
+   ret = resourcemgr_init();
+
+   return ret;
+}
+
+
+//=============================================================================
+// Name: resourcemgr_init
+// Description: Initialization the resource manager object
+// Interface: public
+// Inputs: none.
+// Outputs: none.
+// Comments:
+//=============================================================================
+btInt resourcemgr_init()
+{
+   btInt ret = 0;
+
+   // Initialize user space interface driver
+   //    Causes the module to be registered with AALBus
+   //    and instantiates the user mode device interface
+
+   aalbus_get_bus()->init_driver((kosal_ownermodule *)THIS_MODULE,
+                                &rm_driver,
+                                &rm_class,
+                                RESMGR_DEV_NAME,
+                                majornum);
+
+   if(ret < 0) {
+      DPRINTF(AALRMC_DBG_MOD, ": failed to register driver %s\n", RESMGR_DEV_NAME);
+      return ret;
+   }
+
+   if(driver_create_file(&rm_driver.m_driver,&driver_attr_debug)){
+       DPRINTF (AALRMC_DBG_MOD, ": Failed to create debug attribute - Unloading module\n");
+       // Unregister the driver with the bus
+       aalbus_get_bus()->unregister_driver( &rm_driver );
+       return -EIO;
+   }
+
+
+   // Initialize structures
+   kosal_list_init(&resmgr.m_sessq);    // Queue of sessions
+   kosal_mutex_init(&resmgr.m_sem);          // Private semaphore
+
+   // Get the Resource Manager Server Service Interface from AALBus interface broker
+   resmgr.m_rmssrvs = aalbus_get_bus()->get_service_interface(AAL_RMSAPI_IID_01);
+
+   //TODO - MAKE THIS SHOULD/COULD USE NOTIFY interface service once it is implemented
+   if(resmgr.m_rmssrvs == NULL){
+      DPRINTF(AALRMC_DBG_MOD, ": failed to get RMS service interface [%x]\n", AAL_RMSAPI_IID_01);
+      //aalrm_removedriver(&rm_driver, &rm_class);
+      aalbus_get_bus()->release_driver(&rm_driver, &rm_class);
+      return -ENODEV;
+   }
+   return 0;
+}
+
+#if 0
+//=============================================================================
+// Name: aalrm_initialize_driver
+// Description: Initialization routine for the  driver. Registers with the bus
+//              driver
+// Interface: private
+// Inputs: name - driver/class name
+//         majornum - major device node number to assign
+//         pdriver - driver to register
+//         pclassdev - class device to register
+// Outputs: none.
+// Comments:
+//=============================================================================
+btInt aalrm_initialize_driver( const char * name,
+                             btInt majornum,
+                             struct aal_driver *pdriver,
+                             struct aal_classdevice *pclassdev)
+{
+   btInt ret = 0;
+   dev_t dev;
+
+   // Get a major device number
+   if (majornum != 0) {
+      // major number provided in command line
+      DPRINTF(AALRMC_DBG_MOD, ": Registering static major number %d\n", majornum);
+      dev = MKDEV(majornum, 0);
+      ret = register_chrdev_region(dev, 1, name);
+   }
+   else {
+      // Dynamically allocate the major number
+      ret = alloc_chrdev_region(&dev, 0, 1, name);
+      pdriver->m_major = MAJOR(dev);
+      DPRINTF(AALRMC_DBG_MOD, ": Allocating dynamic major number %d for %s\n", pdriver->m_major, name);
+   }
+   if(ret < 0) {
+      DPRINTF(AALRMC_DBG_MOD, ": Failed to assign major device number %d for %s\n", pdriver->m_major, name);
+      return ret;
+   }
+
+   // Register the driver with the bus
+   ret = aalbus_get_bus()->register_driver( pdriver );
+   if( ret < 0 ) {
+      DPRINTF(AALRMC_DBG_MOD, ": Failed to register ret = %d\n", ret);
+      unregister_chrdev_region(dev, 1);
+      return ret;
+   }
+
+   //---------------------------------------------------------------------------
+   // Register the UI character device with the kernel.
+   // Uses the cdev structure embedded in the aal_driver.
+   // This simply hooks our entry points. The device node is created
+   // with the class device below.
+   //---------------------------------------------------------------------------
+   cdev_init(aaldrv_cdevp(pdriver), &pdriver->m_fops);
+   aaldrv_cdevp(pdriver)->owner = THIS_MODULE;
+   aaldrv_cdevp(pdriver)->ops   = &pdriver->m_fops;
+
+   ret = cdev_add(aaldrv_cdevp(pdriver), dev, 1);
+   if ( ret ) {
+      DPRINTF(AALRMC_DBG_MOD, ": Failed to register charcter device - ret = %d\n", ret);
+      rmcdrv_to_aalbus(pdriver).unregister_driver( pdriver );
+      unregister_chrdev_region(dev, 1);
+      return ret;
+   }
+
+   //-----------------------------------------------
+   // Initialize and create the class device.
+   // This is where the actual device node will be
+   // created in user space
+   //-----------------------------------------------
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,26)
+   dev_set_name(&pclassdev->m_classdev,name);
+#else
+   strncpy(AALCLASSNAME(pclassdev),name, BUS_ID_SIZE);
+#endif
+   aal_classdev_devtype(pclassdev) = dev;
+
+   DPRINTF(AALRMC_DBG_MOD, ": Registering class \"%s\"\n", aal_classdev_get_name(pclassdev));
+   ret = aaldrv_aalbus(pdriver).register_class_device(pclassdev);
+   if(ret < 0) {
+      DPRINTF(AALRMC_DBG_MOD, ": Failed to register class\n");
+      rmcdrv_to_aalbus(pdriver).unregister_driver(pdriver);
+      unregister_chrdev_region(dev, 1);
+      cdev_del(aaldrv_cdevp(pdriver));
+      return ret;
+   }
+
+   return ret;
+}
+#endif
+
+
+//=============================================================================
+// Name: aalrm_exit
+// Description: Removes device from filesystem and unregisters
+// Interface: public
+// Inputs: none.
+// Outputs: none.
+// Comments:
+//=============================================================================
+void aalrm_exit(void)
+{
+   // Get the RMS interface
+   aalbus_get_bus()->release_service_interface(resmgr.m_rmssrvs);
+
+   // Unregister drivers
+   aalbus_get_bus()->release_driver(&rm_driver, &rm_class);
+   //aalrm_removedriver(&rm_driver, &rm_class);
+
+   kosal_printk_level(KERN_INFO, "<- %s removed\n", DRV_DESCRIPTION);
+   return;
+}
+
+#if 0
+//=============================================================================
+// Name: aalrm_removedriver
+// Description: Removes device from filesystem and registration
+// Interface: public
+// Inputs: pdriver - driver to remove,
+//         pclassdev - class device
+// Outputs: none.
+// Comments:
+//=============================================================================
+void aalrm_removedriver(struct aal_driver* pdriver,
+                        struct aal_classdevice *pclassdev)
+{
+   dev_t dev;
+   btInt majornum = pdriver->m_major;
+
+   DPRINTF(AALRMC_DBG_MOD, ": Removing driver\n");
+
+   // Remove the class device
+   rmcdrv_to_aalbus(pdriver).unregister_class_device(pclassdev);
+
+   // Unregister the character driver
+   cdev_del(aaldrv_cdevp(pdriver));
+
+   // Unregister the driver
+   rmcdrv_to_aalbus(pdriver).unregister_driver( pdriver );
+
+   dev = MKDEV(majornum, 0);
+   unregister_chrdev_region(dev, 1);
+   return;
+}
+#endif
+
+//=============================================================================
+// Name:  aalrm_get_interface
+// Description: Returns the requested interface if supported
+// Interface: public
+// Inputs:  drv - base pointer to this driver
+//.         iid - interface ID
+// Outputs: interface pointer.
+// Comments: This driver does not publish any dynamic interfaces
+//=============================================================================
+struct aal_interface  *aalrm_get_interface(struct aal_driver* drv,
+                                           btID iid)
+{
+   return NULL;
+}
+
+
+//=============================================================================
+// Name:  aalrm_has_interface
+// Description: Reports if this driver implements a specifc interface
+// Interface: public
+// Inputs:  drv - base pointer to this driver
+//.         iid - interface ID
+// Outputs: 1 - if interface implemented.
+// Comments: This driver does not publish any dynamic interfaces
+//=============================================================================
+btInt aalrm_has_interface(struct aal_driver* drv, btID iid)
+{
+   return 0;
+}
+
+//=============================================================================
+// Name:  aalrm_supports_interface
+// Description: Report whether this driver can use a specific interface
+// Interface: public
+// Inputs:  drv - base pointer to this driver
+//.         iid - interface ID
+// Outputs: 1 - if supported.
+// Comments:
+//=============================================================================
+btInt aalrm_supports_interface(struct aal_driver* drv, btID iid)
+{
+   if(iid != AAL_DDAPI_IID_07){
+      return 0;
+   }
+   return 1;
+}
diff --git a/drivers/fpga/aal/rmc/kOSAL.c b/drivers/fpga/aal/rmc/kOSAL.c
new file mode 100644
index 000000000000..6335f93fba8a
--- /dev/null
+++ b/drivers/fpga/aal/rmc/kOSAL.c
@@ -0,0 +1,692 @@
+//******************************************************************************
+// This  file  is  provided  under  a  dual BSD/GPLv2  license.  When using or
+//         redistributing this file, you may do so under either license.
+//
+//                            GPL LICENSE SUMMARY
+//
+//  Copyright(c) 2012-2017, Intel Corporation.
+//
+//  This program  is  free software;  you  can redistribute it  and/or  modify
+//  it  under  the  terms of  version 2 of  the GNU General Public License  as
+//  published by the Free Software Foundation.
+//
+//  This  program  is distributed  in the  hope that it  will  be useful,  but
+//  WITHOUT   ANY   WARRANTY;   without   even  the   implied   warranty    of
+//  MERCHANTABILITY  or  FITNESS  FOR  A  PARTICULAR  PURPOSE.  See  the   GNU
+//  General Public License for more details.
+//
+//  The  full  GNU  General Public License is  included in  this  distribution
+//  in the file called README.GPLV2-LICENSE.TXT.
+//
+//  Contact Information:
+//  Henry Mitchel, henry.mitchel at intel.com
+//  77 Reed Rd., Hudson, MA  01749
+//
+//                                BSD LICENSE
+//
+//  Copyright(c) 2012-2017, Intel Corporation.
+//
+//  Redistribution and  use  in source  and  binary  forms,  with  or  without
+//  modification,  are   permitted  provided  that  the  following  conditions
+//  are met:
+//
+//    * Redistributions  of  source  code  must  retain  the  above  copyright
+//      notice, this list of conditions and the following disclaimer.
+//    * Redistributions in  binary form  must  reproduce  the  above copyright
+//      notice,  this  list of  conditions  and  the  following disclaimer  in
+//      the   documentation   and/or   other   materials   provided  with  the
+//      distribution.
+//    * Neither   the  name   of  Intel  Corporation  nor  the  names  of  its
+//      contributors  may  be  used  to  endorse  or promote  products derived
+//      from this software without specific prior written permission.
+//
+//  THIS  SOFTWARE  IS  PROVIDED  BY  THE  COPYRIGHT HOLDERS  AND CONTRIBUTORS
+//  "AS IS"  AND  ANY  EXPRESS  OR  IMPLIED  WARRANTIES,  INCLUDING,  BUT  NOT
+//  LIMITED  TO, THE  IMPLIED WARRANTIES OF  MERCHANTABILITY  AND FITNESS  FOR
+//  A  PARTICULAR  PURPOSE  ARE  DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT
+//  OWNER OR CONTRIBUTORS BE LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,
+//  SPECIAL,  EXEMPLARY,  OR  CONSEQUENTIAL   DAMAGES  (INCLUDING,   BUT   NOT
+//  LIMITED  TO,  PROCUREMENT  OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF USE,
+//  DATA,  OR PROFITS;  OR BUSINESS INTERRUPTION)  HOWEVER  CAUSED  AND ON ANY
+//  THEORY  OF  LIABILITY,  WHETHER  IN  CONTRACT,  STRICT LIABILITY,  OR TORT
+//  (INCLUDING  NEGLIGENCE  OR OTHERWISE) ARISING  IN ANY WAY  OUT  OF THE USE
+//  OF  THIS  SOFTWARE, EVEN IF ADVISED  OF  THE  POSSIBILITY  OF SUCH DAMAGE.
+//******************************************************************************
+//****************************************************************************
+/// @file kOSAL.c
+/// @brief Implementation of the Kernel abstraction functions.
+/// @ingroup kOSAL
+/// @verbatim
+/// Accelerator Abstraction Layer
+///
+/// AUTHORS:  Joseph Grecco, Intel Corporation
+///           Tim Whisonant, Intel Corporation
+///
+/// HISTORY:
+/// WHEN:          WHO:     WHAT:
+/// 12/27/2012     JG       Initial version
+//****************************************************************************
+#include "aalsdk/kernel/kosal.h"
+#define MODULE_FLAGS KOSAL_DBG_MOD
+
+#if defined( __AAL_LINUX__ )
+#include <linux/vmalloc.h>
+# include <linux/delay.h>
+#include <linux/dma-mapping.h>
+#include <linux/rtc.h>
+#endif // __AAL_LINUX__
+
+#if defined( __AAL_UNKNOWN_OS__ )
+# error Implement kOSAL for unknown OS.
+#endif // __AAL_UNKNOWN_OS__
+
+//=============================================================================
+/// kosal_pci_read_config_dword
+/// @brief     Read a dword from PCIe device Config space
+/// @param[in] dev - PCI device handle
+///            offset - offset into Config space starting from beginning of 
+//                      header.
+//             
+/// @return    0 failed
+///
+/// @note   Windows intrinsic numbers bits 0 to 63, ffsll numbers
+///         them 1 to 64. Using ffsll variation.
+/// @note   Windows intrinsic must be set outside function
+//
+//=============================================================================
+btInt _kosal_pci_read_config_dword(__ASSERT_HERE_PROTO
+                                   pkosal_pci_dev      pdev,
+                                   btUnsigned32bitInt  offset,
+                                   btUnsigned32bitInt *pval)
+{
+   btInt res;
+#if   defined( __AAL_WINDOWS__ )
+   ULONG bytesRead = 0;
+#endif // __AAL_WINDOWS__
+
+   __ASSERT_HERE_IN_FN(NULL != pdev);
+   __ASSERT_HERE_IN_FN(NULL != pval);
+   if((NULL ==  pdev) || (NULL == pval)) {
+      res = -EINVAL;
+      return res ;
+   }
+
+#if   defined( __AAL_LINUX__ )
+
+   res = ( pci_read_config_dword(pdev, offset, pval) ? 0 : 1 );
+
+#elif defined( __AAL_WINDOWS__ )
+
+   bytesRead = pdev->GetBusData(pdev->Context,             // Context of bus interface
+                                PCI_WHICHSPACE_CONFIG,     // Config space
+                                pval,                      // Where to return it
+                                offset,                    // From the beginning
+                                sizeof(btUnsigned32bitInt));
+
+   res = ( sizeof(btUnsigned32bitInt) == bytesRead ? 1 : 0 );
+
+#endif // OS
+
+   PPCI_HERE("kosal_pci_read_config_dword(pdev=0x%" PRIxUINTPTR_T ", offset=%u [0x%x], pval=0x%" PRIxUINTPTR_T ") : *pval=0x%x [%u]\n",
+                __UINTPTR_T_CAST(pdev),
+                offset, offset,
+                __UINTPTR_T_CAST(pval),
+                *pval, *pval);
+
+   return res;
+}
+
+//=============================================================================
+/// kosal_virt_to_phys
+/// @brief     Convert a kernel virtual address to physical
+/// @param[in] vaddr - kernel virtual
+/// @return    physica address or NULLif  failed
+//=============================================================================
+btPhysAddr
+kosal_virt_to_phys(btAny vaddr)
+{
+#if   defined( __AAL_LINUX__ )
+
+   return (btPhysAddr)virt_to_phys(vaddr);
+
+#elif defined( __AAL_WINDOWS__ )
+
+   PHYSICAL_ADDRESS physaddr = { 0 };
+     
+   physaddr = MmGetPhysicalAddress(vaddr);
+
+   return (btPhysAddr)physaddr.QuadPart;
+
+#endif // OS
+}
+
+//=============================================================================
+/// kosal_mdelay
+/// @brief     Delay in milliseconds
+/// @param[in] time in millisecs
+/// @return    1 if success
+/// @note      This function may only be called when IRQL <= APC_LEVEL
+//=============================================================================
+btInt _kosal_mdelay(__ASSERT_HERE_PROTO btTime delay)
+{
+   btInt res;
+#if   defined( __AAL_WINDOWS__ )
+   NTSTATUS      status;
+   LARGE_INTEGER rel_timout_in_100ns;
+# if ENABLE_ASSERT
+   UNREFERENCED_PARAMETER(__file);
+   UNREFERENCED_PARAMETER(__line);
+   UNREFERENCED_PARAMETER(__fn);
+# endif // ENABLE_ASSERT
+#endif // __AAL_WINDOWS__
+
+   PPOLLING_HERE("kosal_mdelay(delay=%llu [0x%llx]) sleeping\n", delay, delay);
+
+#if   defined( __AAL_LINUX__ )
+
+   mdelay(delay);
+   res = 1;
+
+#elif defined( __AAL_WINDOWS__ )
+
+   // Relative time is specified as a negative value.
+   // Timeout is specified in 100 ns.
+   rel_timout_in_100ns.QuadPart = -((LONGLONG)delay * 10000);
+
+   status = KeDelayExecutionThread(KernelMode, FALSE, &rel_timout_in_100ns);
+
+   res = ( NT_SUCCESS(status) ? 1 : 0 );
+
+#endif // OS
+
+   PPOLLING_HERE("kosal_mdelay(delay=%llu [0x%llx]) waking\n", delay, delay);
+   return res;
+}
+
+//=============================================================================
+/// kosal_udelay
+/// @brief     Delay in microseconds
+/// @param[in] time in micro seconds
+/// @return    1 if success
+/// @note      This function may only be called when IRQL <= APC_LEVEL
+//=============================================================================
+btInt _kosal_udelay(__ASSERT_HERE_PROTO btTime delay)
+{
+   btInt res;
+#if   defined( __AAL_WINDOWS__ )
+   NTSTATUS      status;
+   LARGE_INTEGER rel_timout_in_100ns;
+# if ENABLE_ASSERT
+   UNREFERENCED_PARAMETER(__file);
+   UNREFERENCED_PARAMETER(__line);
+   UNREFERENCED_PARAMETER(__fn);
+# endif // ENABLE_ASSERT
+#endif // __AAL_WINDOWS__
+
+   PPOLLING_HERE("kosal_udelay(delay=%llu [0x%llx]) sleeping\n", delay, delay);
+
+#if   defined( __AAL_LINUX__ )
+
+   udelay(delay);
+   res = 1;
+
+#elif defined( __AAL_WINDOWS__ )
+   
+   // Relative time is specified as a negative value.
+   // Timeout is specified in 100 ns.
+   rel_timout_in_100ns.QuadPart = -((LONGLONG)delay * 10);
+
+   status = KeDelayExecutionThread(KernelMode, FALSE, &rel_timout_in_100ns);
+   res = ( NT_SUCCESS(status) ? 1 : 0 );
+
+#endif // OS
+
+   PPOLLING_HERE("kosal_udelay(delay=%llu [0x%llx]) waking\n", delay, delay);
+   return res;
+}
+
+btVirtAddr _kosal_kmalloc(__ASSERT_HERE_PROTO btWSSize size_in_bytes)
+{
+   btVirtAddr krnl_virt = NULL;
+
+   __ASSERT_HERE_IN_FN(size_in_bytes > 0);
+
+#if   defined( __AAL_LINUX__ )
+# ifdef __i386__
+   krnl_virt = __get_free_pages(GFP_KERNEL, get_order(kosal_round_up_to_page_size(size_in_bytes)));
+# else
+   krnl_virt = kmalloc((size_t)size_in_bytes, GFP_KERNEL);
+# endif // __i386__
+#elif defined( __AAL_WINDOWS__ )
+
+   krnl_virt = (btVirtAddr)MmAllocateNonCachedMemory((SIZE_T)size_in_bytes);
+
+#endif // OS
+
+   __ASSERT_HERE_IN_FN(NULL != krnl_virt);
+
+   PMEMORY_HERE("kosal_kmalloc(size=%llu [0x%llx]) = 0x%" PRIxUINTPTR_T " [phys=0x%" PRIxPHYS_ADDR "]\n",
+                   size_in_bytes, size_in_bytes,
+                   __UINTPTR_T_CAST(krnl_virt),
+                   kosal_virt_to_phys(krnl_virt));
+
+   return krnl_virt;
+}
+
+btVirtAddr _kosal_kzmalloc(__ASSERT_HERE_PROTO btWSSize size_in_bytes)
+{
+   btVirtAddr krnl_virt = NULL;
+
+   __ASSERT_HERE_IN_FN(size_in_bytes > 0);
+
+#if   defined( __AAL_LINUX__ )
+# ifdef __i386__
+   krnl_virt = __get_free_pages(GFP_KERNEL, get_order(kosal_round_up_to_page_size(size_in_bytes)));
+   if(krnl_virt){
+      memset(krnl_virt, 0 , (size_t)size_in_bytes);
+   }
+# else
+   krnl_virt = kmalloc((size_t)size_in_bytes, GFP_KERNEL);
+   if(krnl_virt){
+      memset(krnl_virt, 0 , (size_t)size_in_bytes);
+   }
+# endif // __i386__
+#elif defined( __AAL_WINDOWS__ )
+
+   krnl_virt = (btVirtAddr)MmAllocateNonCachedMemory((SIZE_T)size_in_bytes);
+   if(krnl_virt){
+      RtlZeroMemory(krnl_virt, (SIZE_T)size_in_bytes);
+   }
+#endif // OS
+
+   __ASSERT_HERE_IN_FN(NULL != krnl_virt);
+
+   PMEMORY_HERE("kosal_kzmalloc(size=%llu [0x%llx]) = 0x%" PRIxUINTPTR_T " [phys=0x%" PRIxPHYS_ADDR "]\n",
+                   size_in_bytes, size_in_bytes,
+                   __UINTPTR_T_CAST(krnl_virt),
+                   kosal_virt_to_phys(krnl_virt));
+
+   return krnl_virt;
+}
+
+void _kosal_kfree(__ASSERT_HERE_PROTO btAny krnl_virt, btWSSize size_in_bytes)
+{
+   __ASSERT_HERE_IN_FN(NULL != krnl_virt);
+   __ASSERT_HERE_IN_FN(size_in_bytes > 0);
+
+   PMEMORY_HERE("kosal_kfree(0x%" PRIxUINTPTR_T " [phys=0x%" PRIxPHYS_ADDR "], size=%llu [0x%llx])\n",
+                   __UINTPTR_T_CAST(krnl_virt),
+                   kosal_virt_to_phys(krnl_virt),
+                   size_in_bytes, size_in_bytes);
+
+   if ( NULL != krnl_virt ) {
+
+#if   defined( __AAL_LINUX__ )
+# ifdef __i386__
+      free_pages(krnl_virt, get_order(kosal_round_up_to_page_size(size_in_bytes)));
+# else
+      UNREFERENCED_PARAMETER(size_in_bytes);
+      kfree(krnl_virt);
+# endif // __i386__
+#elif defined( __AAL_WINDOWS__ )
+
+      MmFreeNonCachedMemory(krnl_virt, (SIZE_T)size_in_bytes);
+
+#endif // OS
+
+   }
+
+}
+
+//=============================================================================
+/// kosal_alloc_contiguous_mem_nocache
+/// @brief     Allocate a buffer of contiguous physical pages
+/// @param[in] size in bytes
+/// @return    pointer to memory. NULL if failure.
+/// @note      
+//=============================================================================
+btVirtAddr _kosal_alloc_contiguous_mem_nocache(__ASSERT_HERE_PROTO btWSSize size_in_bytes)
+{
+#if   defined( __AAL_LINUX__ )
+   btVirtAddr pg;
+   btVirtAddr buffer_end;
+#elif defined( __AAL_WINDOWS__ )
+   PHYSICAL_ADDRESS minaddr = { 0ULL };
+   PHYSICAL_ADDRESS maxaddr = { 0xFFFFFFFFFFFFFFFFULL };
+   PHYSICAL_ADDRESS alignment;
+   maxaddr.LowPart= 0xffffffff;
+   maxaddr.HighPart= 0xffffffff;
+#endif // __AAL_WINDOWS__
+
+   btVirtAddr krnl_virt = NULL;
+
+   __ASSERT_HERE_IN_FN(size_in_bytes > 0);
+   
+
+
+#if   defined( __AAL_LINUX__ )
+
+   krnl_virt = (btVirtAddr)__get_free_pages(GFP_KERNEL, get_order(size_in_bytes));
+   __ASSERT_HERE_IN_FN(NULL != krnl_virt);
+   if ( NULL == krnl_virt ) {
+      return NULL;
+   }
+   
+   // Set each page as reserved so that the swapper will not page them out.
+   buffer_end = krnl_virt + size_in_bytes;
+   for ( pg = krnl_virt ; pg < buffer_end ; pg += PAGE_SIZE ) {
+      SetPageReserved( virt_to_page((unsigned long)pg) );
+   }
+
+#elif defined( __AAL_WINDOWS__ )
+   // MmAllocateContiguousMemorySpecifyCache allocates a block of nonpaged memory that is contiguous
+   //  in physical address space. The routine maps this block to a contiguous block of virtual memory
+   //  in the system address space and returns the virtual address of the base of this block.
+   //  The routine aligns the starting address of a contiguous memory allocation to a memory page boundary.
+   
+   alignment.QuadPart = kosal_round_up_to_page_size(size_in_bytes);
+   krnl_virt = (btVirtAddr)MmAllocateContiguousMemorySpecifyCache((SIZE_T)size_in_bytes,
+                                                                  minaddr,
+                                                                  maxaddr,
+                                                                  alignment,
+                                                                  MmNonCached);
+   __ASSERT_HERE_IN_FN(NULL != krnl_virt);
+   if ( NULL == krnl_virt ) {
+      return NULL;
+   }
+
+#endif // OS
+
+   // Recommended security practice..
+   memset(krnl_virt, 0, (size_t)size_in_bytes);
+
+   PMEMORY_HERE("kosal_alloc_contiguous_mem_nocache(size=%llu [0x%llx]) = 0x%" PRIxUINTPTR_T " [phys=0x%" PRIxPHYS_ADDR "]\n",
+                   size_in_bytes, size_in_bytes,
+                   __UINTPTR_T_CAST(krnl_virt),
+                   kosal_virt_to_phys(krnl_virt));
+
+   return krnl_virt;
+}
+
+//=============================================================================
+/// kosal_free_contiguous_mem
+/// @brief     Free buffer of contiguous physical pages allocated through
+///            kosal_alloc_contiguous_mem_nocache
+/// @param[in] size in bytes
+/// @return    pointer to memory. NULL if failure.
+/// @note      
+//=============================================================================
+void _kosal_free_contiguous_mem(__ASSERT_HERE_PROTO btAny krnl_virt, btWSSize size_in_bytes)
+{
+#if   defined( __AAL_WINDOWS__ )
+   UNREFERENCED_PARAMETER(size_in_bytes);
+#endif // __AAL_WINDOWS__
+
+   __ASSERT_HERE_IN_FN(NULL != krnl_virt);
+   __ASSERT_HERE_IN_FN(size_in_bytes > 0);
+
+   PMEMORY_HERE("kosal_free_contiguous_mem(ptr=0x%" PRIxUINTPTR_T " [phys=0x%" PRIxPHYS_ADDR "], bytes=%llu [0x%llx])\n",
+                   __UINTPTR_T_CAST(krnl_virt),
+                   kosal_virt_to_phys(krnl_virt),
+                   size_in_bytes, size_in_bytes);
+
+   // Recommended security practice..
+   if ( NULL != krnl_virt ) {
+      memset(krnl_virt, 0, (size_t)size_in_bytes);
+   }
+
+#if   defined( __AAL_LINUX__ )
+
+   if ( NULL != krnl_virt ) {
+      // Clear the reserved bit.
+      btVirtAddr pg;
+      btVirtAddr buffer_end = krnl_virt + size_in_bytes;
+
+      for ( pg = krnl_virt ; pg < buffer_end ; pg += PAGE_SIZE ) {
+         ClearPageReserved( virt_to_page((unsigned long)pg) );
+      }
+
+      free_pages((unsigned long)krnl_virt, get_order(size_in_bytes));
+   }
+
+#elif defined( __AAL_WINDOWS__ )
+
+   if ( NULL != krnl_virt ) {
+      MmFreeContiguousMemory(krnl_virt);
+   }
+
+#endif // OS
+}
+
+//=============================================================================
+/// _kosal_alloc_dma_coherent
+/// @brief     Allocate a buffer of DMA-able coherent contiguous memory
+/// @param[in] devhandle OS specific
+///            size in bytes
+///            pdma_handle Address to return DMA address for device
+/// @return    pointer to memory. NULL if failure.
+/// @note
+//=============================================================================
+btVirtAddr _kosal_alloc_dma_coherent( __ASSERT_HERE_PROTO btHANDLE devhandle,
+                                       btWSSize size_in_bytes,
+                                      btHANDLE *pdma_handle)
+{
+#if defined( __AAL_WINDOWS__ )
+   PHYSICAL_ADDRESS minaddr = { 0ULL };
+   PHYSICAL_ADDRESS maxaddr = { 0xFFFFFFFFFFFFFFFFULL };
+   PHYSICAL_ADDRESS alignment;
+   maxaddr.LowPart= 0xffffffff;
+   maxaddr.HighPart= 0xffffffff;
+#endif // __AAL_WINDOWS__
+
+   btVirtAddr krnl_virt = NULL;
+
+   __ASSERT_HERE_IN_FN(size_in_bytes > 0);
+
+
+
+#if   defined( __AAL_LINUX__ )
+
+   krnl_virt = (btVirtAddr)dma_alloc_coherent(&((struct pci_dev*)devhandle)->dev, size_in_bytes, (dma_addr_t*)pdma_handle, GFP_KERNEL);
+   __ASSERT_HERE_IN_FN(NULL != krnl_virt);
+   if ( NULL == krnl_virt ) {
+      return NULL;
+   }
+
+
+#elif defined( __AAL_WINDOWS__ )
+   // MmAllocateContiguousMemorySpecifyCache allocates a block of nonpaged memory that is contiguous
+   //  in physical address space. The routine maps this block to a contiguous block of virtual memory
+   //  in the system address space and returns the virtual address of the base of this block.
+   //  The routine aligns the starting address of a contiguous memory allocation to a memory page boundary.
+
+   alignment.QuadPart = kosal_round_up_to_page_size(size_in_bytes);
+   krnl_virt = (btVirtAddr)MmAllocateContiguousMemorySpecifyCache((SIZE_T)size_in_bytes,
+                                                                  minaddr,
+                                                                  maxaddr,
+                                                                  alignment,
+                                                                  MmNonCached);
+   __ASSERT_HERE_IN_FN(NULL != krnl_virt);
+   if ( NULL == krnl_virt ) {
+      return NULL;
+   }
+
+#endif // OS
+
+   // Recommended security practice..
+   memset(krnl_virt, 0, (size_t)size_in_bytes);
+
+   PMEMORY_HERE("_kosal_alloc_dma_coherent(size=%llu [0x%llx]) = 0x%" PRIxUINTPTR_T " [phys=0x%" PRIxPHYS_ADDR "]\n",
+                   size_in_bytes, size_in_bytes,
+                   __UINTPTR_T_CAST(krnl_virt),
+                 (long unsigned int)*pdma_handle);
+
+   return krnl_virt;
+}
+
+//=============================================================================
+/// kosal_free_contiguous_mem
+/// @brief     Free buffer of contiguous physical pages allocated through
+///            kosal_alloc_contiguous_mem_nocache
+/// @param[in] size in bytes
+/// @return    pointer to memory. NULL if failure.
+/// @note
+//=============================================================================
+void _kosal_free_dma_coherent( __ASSERT_HERE_PROTO btHANDLE devhandle,
+                               btVirtAddr krnl_virt,
+                               btWSSize size_in_bytes,
+                               btHANDLE dma_handle)
+{
+#if   defined( __AAL_WINDOWS__ )
+   UNREFERENCED_PARAMETER(size_in_bytes);
+#endif // __AAL_WINDOWS__
+
+   __ASSERT_HERE_IN_FN(NULL != krnl_virt);
+   __ASSERT_HERE_IN_FN(size_in_bytes > 0);
+
+   PMEMORY_HERE("_kosal_free_dma_coherent(ptr=0x%" PRIxUINTPTR_T " [phys=0x%" PRIxPHYS_ADDR "], bytes=%llu [0x%llx])\n",
+                   __UINTPTR_T_CAST(krnl_virt),
+                   kosal_virt_to_phys(krnl_virt),
+                   size_in_bytes, size_in_bytes);
+
+   // Recommended security practice..
+   if ( NULL != krnl_virt ) {
+      memset(krnl_virt, 0, (size_t)size_in_bytes);
+   }
+
+#if   defined( __AAL_LINUX__ )
+
+
+      dma_free_coherent(&((struct pci_dev*)devhandle)->dev, size_in_bytes, krnl_virt, (dma_addr_t)dma_handle);
+
+#elif defined( __AAL_WINDOWS__ )
+
+   if ( NULL != krnl_virt ) {
+      MmFreeContiguousMemory(krnl_virt);
+   }
+
+#endif // OS
+}
+
+#if   defined( __AAL_LINUX__ )
+
+void task_poller(struct work_struct *work)
+{
+   struct delayed_work *delayedWork = container_of(work, struct delayed_work, work);
+   struct kosal_work_object *pwork  = container_of(delayedWork, struct kosal_work_object, workobj);
+
+   pwork->fnct(pwork->context);
+
+}
+void kosal_queue_delayed_work(kosal_work_queue wq, struct kosal_work_object *pwo, KOSAL_TIME msec) {
+
+   queue_delayed_work(wq,&(pwo->workobj),msecs_to_jiffies(msec));
+}
+
+
+#elif defined( __AAL_WINDOWS__ )
+
+void WorkItemCallback(IN PDEVICE_OBJECT pdevObject, IN PVOID Context) {
+   struct kosal_work_object *pwork = ( struct kosal_work_object * )Context;
+   UNREFERENCED_PARAMETER(pdevObject);
+   kosal_mdelay(pwork->msec_delay);
+   pwork->fnct(pwork->context);
+   return;
+}
+
+void kosal_queue_delayed_work(kosal_work_queue wq, struct kosal_work_object *pwo, btTime msec)
+{
+   pwo->msec_delay = msec;
+   IoQueueWorkItem(wq, WorkItemCallback, DelayedWorkQueue, pwo);
+}
+
+void kosal_wake_up_interruptible(kosal_poll_object *pwaitq)
+{
+   NTSTATUS Status;
+   if ( NULL != *pwaitq ) {
+      // Check to see if the IRP was canceled already   
+      Status = WdfRequestUnmarkCancelable(*pwaitq);
+      if ( Status != STATUS_CANCELLED ) {
+         // Complete normally
+         WdfRequestComplete(*pwaitq, STATUS_SUCCESS);
+      }
+   }
+   kosal_poll_object_consume(pwaitq);
+}
+
+#endif // __AAL_WINDOWS__
+
+btVirtAddr _kosal_get_user_buffer( __ASSERT_HERE_PROTO btVirtAddr user_prt, btWSSize size_in_bytes)
+{
+
+
+#if   defined( __AAL_LINUX__ )
+   unsigned long ret;
+   btVirtAddr pkbuffer = vmalloc(size_in_bytes);
+   if(NULL== pkbuffer){
+      return NULL;
+   }
+
+   memset(pkbuffer,0,size_in_bytes);
+   ret = copy_from_user(pkbuffer, user_prt, size_in_bytes);
+   if(ret != 0){
+      vfree(pkbuffer);
+      return NULL;
+   }
+   return pkbuffer;
+#elif defined( __AAL_WINDOWS__ )  //TODO
+   UNREFERENCED_PARAMETER(user_prt);
+   UNREFERENCED_PARAMETER(size_in_bytes);
+
+   __ASSERT_HERE_IN_FN( NULL != user_prt );
+   __ASSERT_HERE_IN_FN( 0 != size_in_bytes );
+   return NULL;
+#endif
+}
+
+void _kosal_free_user_buffer(__ASSERT_HERE_PROTO btVirtAddr user_prt,  btWSSize size_in_bytes)
+{
+
+#if   defined( __AAL_LINUX__ )
+   vfree(user_prt);
+#elif defined( __AAL_WINDOWS__ )  // TODO
+   UNREFERENCED_PARAMETER( user_prt );
+   UNREFERENCED_PARAMETER( size_in_bytes );
+
+   __ASSERT_HERE_IN_FN( NULL != user_prt );
+   __ASSERT_HERE_IN_FN( 0 != size_in_bytes );
+
+#endif
+}
+
+
+char* kosal_gettimestamp(void) 
+{
+
+#if defined( __AAL_LINUX__ )
+
+   static char timestamp[200];
+   struct rtc_time tm;
+   struct timeval time;
+   unsigned long local_time;
+
+   do_gettimeofday(&time);
+   local_time = (u32)(time.tv_sec - (sys_tz.tz_minuteswest * 60));
+   rtc_time_to_tm(local_time, &tm);
+
+   sprintf(timestamp," Time Stamp: %04d-%02d-%02d %02d:%02d:%02d ",
+                                                                   tm.tm_year + 1900,
+                                                                   tm.tm_mon + 1,
+                                                                   tm.tm_mday,
+                                                                   tm.tm_hour,
+                                                                   tm.tm_min,
+                                                                   tm.tm_sec);
+
+   return timestamp;
+#elif defined( __AAL_WINDOWS__ )
+
+#endif
+}
+
+
+
diff --git a/drivers/fpga/aal/rms/Makefile b/drivers/fpga/aal/rms/Makefile
new file mode 100644
index 000000000000..f885c65a6366
--- /dev/null
+++ b/drivers/fpga/aal/rms/Makefile
@@ -0,0 +1,23 @@
+ccflags-y := -I$(src)/../include -D__KERNEL__=1
+ccflags-y += -DDRV_NAME=\"aalrms\"
+ccflags-y += -DDRV_VERSION=\"6.3.1\"
+
+ifdef CONFIG_AAL_DEBUG
+	ccflags-y += -DENABLE_DEBUG=1
+else
+	ccflags-y += -DENABLE_DEBUG=0
+endif
+
+ifdef CONFIG_AAL_ASSERT
+	ccflags-y += -DENABLE_ASSERT=1
+else
+	ccflags-y += -DENABLE_ASSERT=0
+endif
+
+obj-$(CONFIG_AAL_RMC)	+= aalrms.o
+
+aalrms-y	:=	aalrm_server-file.o  \
+			aalrm_server-ioctl.o \
+			aalrm_server-main.o  \
+			aalrm_server-services.o  \
+			kOSAL.o
diff --git a/drivers/fpga/aal/rms/aalrm_server-file.c b/drivers/fpga/aal/rms/aalrm_server-file.c
new file mode 100644
index 000000000000..933343a5f841
--- /dev/null
+++ b/drivers/fpga/aal/rms/aalrm_server-file.c
@@ -0,0 +1,212 @@
+//******************************************************************************
+// This  file  is  provided  under  a  dual BSD/GPLv2  license.  When using or
+//         redistributing this file, you may do so under either license.
+//
+//                            GPL LICENSE SUMMARY
+//
+//  Copyright(c) 2008-2017, Intel Corporation.
+//
+//  This program  is  free software;  you  can redistribute it  and/or  modify
+//  it  under  the  terms of  version 2 of  the GNU General Public License  as
+//  published by the Free Software Foundation.
+//
+//  This  program  is distributed  in the  hope that it  will  be useful,  but
+//  WITHOUT   ANY   WARRANTY;   without   even  the   implied   warranty    of
+//  MERCHANTABILITY  or  FITNESS  FOR  A  PARTICULAR  PURPOSE.  See  the   GNU
+//  General Public License for more details.
+//
+//  The  full  GNU  General Public License is  included in  this  distribution
+//  in the file called README.GPLV2-LICENSE.TXT.
+//
+//  Contact Information:
+//  Henry Mitchel, henry.mitchel at intel.com
+//  77 Reed Rd., Hudson, MA  01749
+//
+//                                BSD LICENSE
+//
+//  Copyright(c) 2008-2017, Intel Corporation.
+//
+//  Redistribution and  use  in source  and  binary  forms,  with  or  without
+//  modification,  are   permitted  provided  that  the  following  conditions
+//  are met:
+//
+//    * Redistributions  of  source  code  must  retain  the  above  copyright
+//      notice, this list of conditions and the following disclaimer.
+//    * Redistributions in  binary form  must  reproduce  the  above copyright
+//      notice,  this  list of  conditions  and  the  following disclaimer  in
+//      the   documentation   and/or   other   materials   provided  with  the
+//      distribution.
+//    * Neither   the  name   of  Intel  Corporation  nor  the  names  of  its
+//      contributors  may  be  used  to  endorse  or promote  products derived
+//      from this software without specific prior written permission.
+//
+//  THIS  SOFTWARE  IS  PROVIDED  BY  THE  COPYRIGHT HOLDERS  AND CONTRIBUTORS
+//  "AS IS"  AND  ANY  EXPRESS  OR  IMPLIED  WARRANTIES,  INCLUDING,  BUT  NOT
+//  LIMITED  TO, THE  IMPLIED WARRANTIES OF  MERCHANTABILITY  AND FITNESS  FOR
+//  A  PARTICULAR  PURPOSE  ARE  DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT
+//  OWNER OR CONTRIBUTORS BE LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,
+//  SPECIAL,  EXEMPLARY,  OR  CONSEQUENTIAL   DAMAGES  (INCLUDING,   BUT   NOT
+//  LIMITED  TO,  PROCUREMENT  OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF USE,
+//  DATA,  OR PROFITS;  OR BUSINESS INTERRUPTION)  HOWEVER  CAUSED  AND ON ANY
+//  THEORY  OF  LIABILITY,  WHETHER  IN  CONTRACT,  STRICT LIABILITY,  OR TORT
+//  (INCLUDING  NEGLIGENCE  OR OTHERWISE) ARISING  IN ANY WAY  OUT  OF THE USE
+//  OF  THIS  SOFTWARE, EVEN IF ADVISED  OF  THE  POSSIBILITY  OF SUCH DAMAGE.
+//******************************************************************************
+//****************************************************************************
+//        FILE: aalrm_server-file.c
+//     CREATED: 02/20/2008
+//      AUTHOR: Joseph Grecco - Intel
+//
+// PURPOSE:  Implements the file character driver for the plolicy manager
+//           interface service interface
+// HISTORY:
+// COMMENTS:
+// WHEN:          WHO:     WHAT:
+// 02-20-08       JG       Initial version started
+// 11/11/2008     JG       Added legal header
+// 01/04/2009     HM       Updated Copyright
+// 01/23/2009     JG       Initial code cleanup
+// 02/09/2009     JG       Added support for RMSS cancel transaction
+// 05/18/2010     HM       Labeled kosal_sem_get_krnl_alertable() with FIXME. Need a
+//                            global fix for these. Getting it to compile.
+// 11/09/2010     HM       Removed extraneous kernel include asm/uaccess.h
+//****************************************************************************
+#include "aalsdk/kernel/kosal.h"
+
+#define MODULE_FLAGS AALRMS_DBG_FILE
+
+#include "aalrm_server-int.h"
+
+
+//=============================================================================
+// Name: aalrm_server_open
+// Description: Implements the open system call
+// Interface: public
+// Inputs: inode - inode structure of the special device file
+//         file - per open file structure
+// Outputs: none.
+// Comments: Creates a session instance with the HW subsystem
+//=============================================================================
+int aalrm_server_open(struct inode *inode, struct file *file)
+{
+   int minor, ret = 0;
+   struct aalrm_server_session *session = NULL;
+
+   // minor number must be zero
+   minor = iminor (inode);
+   if (minor != 0){
+      return -ENODEV;
+   }
+
+   //-------------------
+   // Create the session
+   //-------------------
+   if (kosal_sem_get_krnl_alertable(&rmserver.m_sem)) { /* FIXME */ }
+
+   // For now we are only allowing one session enforcing single RM user service
+   if(!kosal_list_is_empty(&rmserver.m_sessq)){
+      DPRINTF (AALRMS_DBG_FILE, ": open failed because device already opened\n");
+      kosal_sem_put(&rmserver.m_sem);
+      return -EBUSY;
+   }
+
+   kosal_sem_put(&rmserver.m_sem);
+
+   // Create the session
+   session = (struct aalrm_server_session *)kosal_kmalloc(sizeof(struct aalrm_server_session));
+   if(session == NULL){
+      DPRINTF (AALRMS_DBG_FILE, ": open failed to malloc\n");
+      return -ENOMEM;
+   }
+
+   // Initialize session's lists, queues and sync objects
+   kosal_list_init(&session->m_sessq);
+   kosal_init_waitqueue_head(&session->m_waitq);
+   kosal_mutex_init(&session->m_sem);
+
+
+   // Save the bus pointer
+   session->m_aalbus = aalbus_get_bus();
+
+   // Get a pointer to the RMSS singleton
+   session->m_rmserver = &rmserver;
+
+   // Default events
+   //  used for selectively enabling events
+   session->m_eventflgs = KRMS_DEFAULT_EVENTS;
+
+   // Add this session to the session queue of the RMSS
+   rms_sess_to_rms_server(session).register_sess(&session->m_sessq);
+
+   // Save this session on the file instance
+   file->private_data = session;
+
+   DPRINTF(AALRMS_DBG_FILE, ": AAL Resourse Manager Server Session created\n");
+
+   return ret;
+}
+
+//=============================================================================
+// Name: aalrm_server_close
+// Description: Implements the close system call
+// Interface: public
+// Inputs: inode - inode structure of the special device file
+//         file - per open file structure
+// Outputs: none.
+// Comments: Close pulls the plug on any outstanding transactions. This implies
+//           that notifcations for completion may not be sent to the
+//           application. Ideally the app is in a quiescent state before
+//           calling.
+//=============================================================================
+int
+aalrm_server_close (struct inode *inode, struct file *file)
+{
+   int ret = 0;
+   struct aalrm_server_session *session = file->private_data;
+   DPRINTF(AALRMS_DBG_FILE, ": CLOSE Entered\n");
+
+   // Disable config updates
+   session->m_aalbus->register_config_update_handler(NULL,NULL);
+
+   //TODO make sure all messages are flushed
+   // aalrm_flush_queues(session);
+
+   // Unregister the interface with the AALBus Service Interface Broker
+   rms_sess_to_rms_server(session).unregister_sess(&session->m_sessq);
+   kosal_kfree(session, sizeof(struct aalrm_server_session));
+   DPRINTF(AALRMS_DBG_FILE, ": CLOSE Exited\n");
+   return ret;
+}
+
+
+//=============================================================================
+// Name: aalrm_server_poll
+// Description: Called from select, poll or epoll call.
+// Interface: public
+// Inputs: file - pointer to file instance
+//         wait - pointer to the process poll_table
+// Outputs: none.
+// Comments:
+//=============================================================================
+unsigned int aalrm_server_poll ( struct file *file, poll_table *wait )
+{
+   unsigned int mask = 0;
+
+   // Get the user session
+   struct aalrm_server_session *psess = (struct aalrm_server_session *) file->private_data;
+
+   // Put RMSS's request queue in the poll table
+   poll_wait( file, &rmserver.m_reqq_wq, wait );
+
+   if (kosal_sem_get_krnl_alertable( &psess->m_sem )) { /* FIXME */ }
+
+   // If there is a request on the queue so wake up sleeper
+   if( !aalrms_reqq_empty() ){
+      DPRINTF( AALRMS_DBG_FILE, ": Message available. Waking sleepers\n" );
+      mask |= POLLPRI;  // Device request completion
+   }
+   up( &psess->m_sem );
+
+   // Return the event mask
+   return mask;
+}
diff --git a/drivers/fpga/aal/rms/aalrm_server-int.h b/drivers/fpga/aal/rms/aalrm_server-int.h
new file mode 100644
index 000000000000..8e6f68e03ca4
--- /dev/null
+++ b/drivers/fpga/aal/rms/aalrm_server-int.h
@@ -0,0 +1,753 @@
+//******************************************************************************
+// This  file  is  provided  under  a  dual BSD/GPLv2  license.  When using or
+//         redistributing this file, you may do so under either license.
+//
+//                            GPL LICENSE SUMMARY
+//
+//  Copyright(c) 2008-2017, Intel Corporation.
+//
+//  This program  is  free software;  you  can redistribute it  and/or  modify
+//  it  under  the  terms of  version 2 of  the GNU General Public License  as
+//  published by the Free Software Foundation.
+//
+//  This  program  is distributed  in the  hope that it  will  be useful,  but
+//  WITHOUT   ANY   WARRANTY;   without   even  the   implied   warranty    of
+//  MERCHANTABILITY  or  FITNESS  FOR  A  PARTICULAR  PURPOSE.  See  the   GNU
+//  General Public License for more details.
+//
+//  The  full  GNU  General Public License is  included in  this  distribution
+//  in the file called README.GPLV2-LICENSE.TXT.
+//
+//  Contact Information:
+//  Henry Mitchel, henry.mitchel at intel.com
+//  77 Reed Rd., Hudson, MA  01749
+//
+//                                BSD LICENSE
+//
+//  Copyright(c) 2008-2017, Intel Corporation.
+//
+//  Redistribution and  use  in source  and  binary  forms,  with  or  without
+//  modification,  are   permitted  provided  that  the  following  conditions
+//  are met:
+//
+//    * Redistributions  of  source  code  must  retain  the  above  copyright
+//      notice, this list of conditions and the following disclaimer.
+//    * Redistributions in  binary form  must  reproduce  the  above copyright
+//      notice,  this  list of  conditions  and  the  following disclaimer  in
+//      the   documentation   and/or   other   materials   provided  with  the
+//      distribution.
+//    * Neither   the  name   of  Intel  Corporation  nor  the  names  of  its
+//      contributors  may  be  used  to  endorse  or promote  products derived
+//      from this software without specific prior written permission.
+//
+//  THIS  SOFTWARE  IS  PROVIDED  BY  THE  COPYRIGHT HOLDERS  AND CONTRIBUTORS
+//  "AS IS"  AND  ANY  EXPRESS  OR  IMPLIED  WARRANTIES,  INCLUDING,  BUT  NOT
+//  LIMITED  TO, THE  IMPLIED WARRANTIES OF  MERCHANTABILITY  AND FITNESS  FOR
+//  A  PARTICULAR  PURPOSE  ARE  DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT
+//  OWNER OR CONTRIBUTORS BE LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,
+//  SPECIAL,  EXEMPLARY,  OR  CONSEQUENTIAL   DAMAGES  (INCLUDING,   BUT   NOT
+//  LIMITED  TO,  PROCUREMENT  OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF USE,
+//  DATA,  OR PROFITS;  OR BUSINESS INTERRUPTION)  HOWEVER  CAUSED  AND ON ANY
+//  THEORY  OF  LIABILITY,  WHETHER  IN  CONTRACT,  STRICT LIABILITY,  OR TORT
+//  (INCLUDING  NEGLIGENCE  OR OTHERWISE) ARISING  IN ANY WAY  OUT  OF THE USE
+//  OF  THIS  SOFTWARE, EVEN IF ADVISED  OF  THE  POSSIBILITY  OF SUCH DAMAGE.
+//******************************************************************************
+//****************************************************************************
+//        FILE: aalrm_server-int.h
+//     CREATED: 02/13/2008
+//      AUTHOR: Joseph Grecco - Intel
+//
+// PURPOSE: This file containe internal definetions for the
+//          Accelerator Hardware Module Emulator (AHME) driver module.
+// HISTORY:
+// COMMENTS:
+// WHEN:          WHO:     WHAT:
+// 02/13/08       JG       Initial version created
+// 11/11/2008     JG       Added legal header
+// 01/04/2009     HM       Updated Copyright
+// 01/23/2009     JG       Initial code cleanup
+// 02/09/2009     JG       Added support for RMSS cancel transaction
+// 04/28/2010     HM       Added return value checks to kosal_sem_get_krnl_alertable()
+// 04/19/2012     TSW      Deprecate __func__ in favor of platform-agnostic
+//                          __AAL_FUNC__.
+//****************************************************************************
+#ifndef __AALKERNEL_AALRESOURCEMGR_SERVER_AALRM_SERVER_INT_H__
+#define __AALKERNEL_AALRESOURCEMGR_SERVER_AALRM_SERVER_INT_H__
+#include "aalsdk/kernel/kosal.h"
+#include "aalsdk/kernel/aalrm_server-services.h"
+#include "aalsdk/kernel/aalrm_server.h"
+
+
+#ifndef DRV_VERSION
+# define DRV_VERSION      "EXPERIMENTAL VERSION"
+#endif
+
+#define DRV_DESCRIPTION   "Resource Manager Server Kernel Module"
+#define DRV_AUTHOR        "Joseph Grecco <joe.grecco@intel.com>"
+#define DRV_LICENSE       "GPL"
+#define DRV_COPYRIGHT     "Copyright(c) 2008-2016, Intel Corporation"
+
+extern btUnsignedInt debug;
+
+#define AALRMS_DBG_ALL        AALRMS_DBG_MOD | AALRMS_DBG_FILE | AALRMS_DBG_MMAP | AALRMS_DBG_IOCTL
+#define AALRMS_DBG_INVLID    ~(AALRMS_DBG_ALL)
+#define AALRMS_DBG_DEFAULT    AALRMS_DBG_ALL
+
+///////////////////////////////////////////////////////////////////////////////
+///////////////////////////////////////////////////////////////////////////////
+////////////////////                                     //////////////////////
+/////////////////      RESOURCE MANAGER SERVER SERVICE     ////////////////////
+////////////////////                                     //////////////////////
+///////////////////////////////////////////////////////////////////////////////
+///////////////////////////////////////////////////////////////////////////////
+//=============================================================================
+//=============================================================================
+
+//=============================================================================
+// Typedefs and constants
+//=============================================================================
+#define  KRMS_DEFAULT_EVENTS   0
+
+
+extern struct aalrm_server rmserver;
+
+//=============================================================================
+// Name: aalrm_server_session
+// Description: Session structure holds state and other context for a user
+//              session with the RMS.
+//=============================================================================
+struct aalrm_server_session {
+   // Event flags
+   unsigned int          m_eventflgs;
+
+   // AAL Bus
+   struct aal_bus       *m_aalbus;
+
+   // The resource manager
+   struct aalrm_server  *m_rmserver;
+
+   // Queue of sessions
+   kosal_list_head       m_sessq;
+
+  // Wait queue used for poll
+   kosal_poll_object     m_waitq;
+
+   // Private semaphore
+   kosal_semaphore       m_sem;
+};
+
+//=============================================================================
+// Name: aalrm_server
+// Description: RMS Service class. This is the class definition for the
+//              RMS kernel service.
+//=============================================================================
+struct aalrm_server {
+   // Public Methods
+   void (*register_sess)(kosal_list_head *psession);
+   void (*unregister_sess)(kosal_list_head *psession);
+
+   // RMS driver
+   struct aal_driver       *m_driver;
+
+   // RMS class device
+   struct aal_classdevice  *m_class;
+
+   // List of current sessions
+   kosal_list_head          m_sessq;
+
+   // Private semaphore
+   kosal_semaphore          m_sem;
+
+   // Request queue
+   aal_queue_t              m_reqq;
+
+   // Pending queue
+   aal_queue_t              m_pendq;
+
+   // Wait queue used to unblock poll
+   kosal_poll_object        m_reqq_wq;
+};
+
+
+///////////////////////////////////////////////////////////////////////////////
+///////////////////////////////////////////////////////////////////////////////
+////////////////////                                     //////////////////////
+/////////////////          RMSS MESSAGE CLASSES            ////////////////////
+////////////////////                                     //////////////////////
+///////////////////////////////////////////////////////////////////////////////
+///////////////////////////////////////////////////////////////////////////////
+//=============================================================================
+//=============================================================================
+//----------------------------------------------------------------------------
+// The following classes are used to wrap Resource Manager Service INterface
+// calls into messages that can be queued for the handling by the RMSS.
+// The RMSS presents a Proxy interface to clients (e.g., RMCS) via the AALBus
+// Service Interface Broker.  The RMSS API is asynchronous. Method calls into
+// the RMSS service interface are converted into request messages that are
+// queued for scheduled processing
+//----------------------------------------------------------------------------
+//----------------------------------------------------------------------------
+
+//--------------------------------------------
+// Base class for all RMSS request queue items
+//--------------------------------------------
+struct rms_reqq_item {
+   struct aal_q_item              m_qitem;
+   struct aalrms_req_tranID       m_tranid;
+};
+#define _DECLARE_RMSSQ_TYPE  struct rms_reqq_item m_rmsqitem
+
+//----------------------------
+// Casting and accessor macros
+//----------------------------
+#define qi_to_rmsqi(pqi)   (container_of( pqi, struct rms_reqq_item, m_qitem ))
+#define RMSSQI(p)       (p->m_rmsqitem.m_qitem)
+#define RMSSQIP(p)      (&(p->m_rmsqitem.m_qitem))
+#define RMSSQ_QID(p)    ( AALQ_QID( &(p->m_rmsqitem )) )
+#define RMSSQ_QLEN(p)   (AALQ_QLEN(&(p->m_rmsqitem )))
+#define RMSSQ_QUEUE(p)  (AALQ_QUEUE(&(p->m_rmsqitem )))
+#define RMSSQ_TRANID(p) (p->m_rmsqitem.m_tranid)
+
+//=============================================================================
+// Name: rms_reqq_reqdev
+// Description: Requests a Device allocation from the Resource Manager Service
+//=============================================================================
+struct rms_reqq_reqdev{
+#define qi_to_reqdev(pqi) (container_of( pqi, struct rms_reqq_reqdev, m_rmsqitem.m_qitem ))
+
+   //-----------------------------------------------------------------------
+   // Including this macro effectively causes this object to be derived from
+   // rms_reqq_item
+   //-----------------------------------------------------------------------
+   _DECLARE_RMSSQ_TYPE;
+
+   // Request specific
+   struct req_allocdev           *m_reqdev;
+   void                          *m_powner;
+   aalrms_reqdev_cmplt_t          m_completionfcn;
+   void                          *m_context;
+};
+
+//=============================================================================
+// Name: rms_reqq_reqdev_create
+// Description: Constructor
+//=============================================================================
+static inline struct rms_reqq_reqdev *
+      rms_reqq_reqdev_create( struct req_allocdev       *req,
+                              aalrms_reqdev_cmplt_t      completionfcn,
+                              struct aalrms_req_tranID   tranid)
+{
+   struct rms_reqq_reqdev * This = (struct rms_reqq_reqdev * )kosal_kmalloc(sizeof(struct rms_reqq_reqdev));
+   if(This == NULL){
+      return NULL;
+   }
+
+   This->m_reqdev = req;
+   This->m_completionfcn = completionfcn;
+   RMSSQ_QID(This) = reqid_URMS_RequestDevice;
+   RMSSQ_QLEN(This) = req->size;
+   RMSSQ_TRANID(This) = tranid;
+
+   // Initialize the queue item
+   kosal_list_init(&RMSSQ_QUEUE(This));
+   return This;
+}
+
+//----------
+// Accessors
+//----------
+#define REQDEV_ALLOCDEV(preqdev)    (*(preqdev->m_reqdev))
+#define REQDEV_ALLOCDEVP(preqdev)   (preqdev->m_reqdev)
+
+
+//=============================================================================
+// Name: rms_reqq_reqdev_create
+// Description: Destructor
+//=============================================================================
+static inline void rms_reqq_reqdev_destroy(struct rms_reqq_reqdev *This)
+{
+   kosal_kfree(This, sizeof(struct rms_reqq_reqdev));
+}
+
+
+
+//------------------------------------------------------------------------------
+//------------------------------------------------------------------------------
+
+//=============================================================================
+// Name: rms_reqq_registrar
+// Description: Registrar request message
+//=============================================================================
+struct rms_reqq_registrar {
+#define qi_to_regreq(pqi) (container_of( pqi, struct rms_reqq_registrar, m_rmsqitem.m_qitem ) )
+   //-----------------------------------------------------------------------
+   // Including this macro effectively causes this object to be derived from
+   // aal_q_item
+   //-----------------------------------------------------------------------
+   _DECLARE_RMSSQ_TYPE;
+
+   // Request specific
+   struct req_registrar          *m_regreq;
+   aalrms_registrarreq_cmplt_t    m_completionfcn;
+};
+
+//----------
+// Accessors
+//----------
+#define REGREQ_REGREQ(p)    (*(p->m_regreq))
+#define REGREQ_REGREQP(p)   (p->m_regreq)
+
+
+#define CALL_COMPLETION(p)    (p->m_completionfcn)
+
+//=============================================================================
+// Name: rms_reqq_registrar_create
+// Description: Constructor
+//=============================================================================
+static inline struct rms_reqq_registrar *
+         rms_reqq_registrar_create( struct req_registrar          *req,
+                                    aalrms_registrarreq_cmplt_t   completionfcn,
+                                    struct aalrms_req_tranID      tranid)
+{
+   struct rms_reqq_registrar * This = (struct rms_reqq_registrar *)kosal_kmalloc(sizeof(struct rms_reqq_registrar));
+   if(This == NULL){
+      return NULL;
+   }
+
+   This->m_regreq = req;
+   This->m_completionfcn = completionfcn;
+
+   RMSSQ_QID(This) = reqid_RS_Registrar;
+   RMSSQ_QLEN(This) = req->size;
+   RMSSQ_TRANID(This) = tranid;
+
+   // Initialize the queue item
+   kosal_list_init(&RMSSQ_QUEUE(This));
+   return This;
+}
+
+//=============================================================================
+// Name: rms_reqq_regreq_destroy
+// Description: Destructor
+//=============================================================================
+static inline void rms_reqq_regreq_destroy(struct rms_reqq_registrar *This)
+{
+   kosal_kfree(This, sizeof(struct rms_reqq_registrar));
+}
+
+//------------------------------------------------------------------------------
+//------------------------------------------------------------------------------
+
+//=============================================================================
+// Name: rms_reqq_config_update_event
+// Description: Config update event
+//=============================================================================
+struct rms_reqq_config_update_event
+{
+#define qi_to_updateevent(pqi) (container_of( pqi, struct rms_reqq_config_update_event, m_rmsqitem.m_qitem ) )
+#define CONF_EVTP_EVENT(p) (*(p->m_pupdateEvt))
+
+   //-----------------------------------------------------------------------
+   // Including this macro effectively causes this object to be derived from
+   // aal_q_item
+   //-----------------------------------------------------------------------
+   _DECLARE_RMSSQ_TYPE;
+
+   // Request specific
+   struct aalrms_configUpDateEvent          *m_pupdateEvt;
+};
+
+//----------
+// Accessors
+//----------
+
+
+//=============================================================================
+// Name: rms_reqq_config_update_event_create
+// Description: Constructor
+//=============================================================================
+static inline struct rms_reqq_config_update_event *
+     rms_reqq_config_update_event_create(struct aalrms_configUpDateEvent  *pupdateEvt)
+{
+   struct rms_reqq_config_update_event * This
+                        = (struct rms_reqq_config_update_event * )kosal_kmalloc(sizeof(struct rms_reqq_config_update_event));
+   if(This == NULL){
+      return NULL;
+   }
+   This->m_pupdateEvt = pupdateEvt;
+
+   DPRINTF(AALRMS_DBG_IOCTL,"ID %d and %d\n",  This->m_pupdateEvt->id ,pupdateEvt->id );
+
+   RMSSQ_QID(This) = evtid_KRMS_ConfigUpdate;
+   RMSSQ_QLEN(This) = offsetof(struct aalrms_configUpDateEvent,devattrs.ownerlist) + (pupdateEvt->devattrs.numOwners * sizeof(btPID));
+   RMSSQ_TRANID(This).m_context = NULL;
+
+
+   // Initialize the queue item
+   kosal_list_init(&RMSSQ_QUEUE(This));
+   return This;
+}
+
+//=============================================================================
+// Name: rms_reqq_config_update_event_destroy
+// Description: Destructor
+//=============================================================================
+static inline void rms_reqq_config_update_event_destroy(struct rms_reqq_config_update_event *This)
+{
+   kosal_kfree(This->m_pupdateEvt, sizeof(struct aalrms_configUpDateEvent));
+   kosal_kfree(This, sizeof(struct rms_reqq_config_update_event));
+}
+
+
+//------------------------------------------------------------------------------
+//------------------------------------------------------------------------------
+
+//=============================================================================
+// Name: rms_reqq_Shutdown
+// Description: Shutdown request
+//=============================================================================
+struct rms_reqq_Shutdown {
+#define qi_to_shutdownreq(pqi) (container_of( pqi, struct rms_reqq_Shutdown, m_rmsqitem.m_qitem ) )
+#define SHUTDOWNREQ_REASON(p) ((p->m_reason))
+
+   //-----------------------------------------------------------------------
+   // Including this macro effectively causes this object to be derived from
+   // aal_q_item
+   //-----------------------------------------------------------------------
+   _DECLARE_RMSSQ_TYPE;
+
+   // Reason
+   rms_shutdownreason_e  m_reason;
+};
+
+
+//=============================================================================
+// Name: rms_reqq_Shutdown
+// Description: Constructor
+//=============================================================================
+static inline struct rms_reqq_Shutdown *
+     rms_reqq_Shutdown_create(rms_shutdownreason_e reason)
+{
+#define qi_to_shutdownevent(pqi) (container_of( pqi, struct rms_reqq_Shutdown, m_rmsqitem.m_qitem ) )
+
+   struct rms_reqq_Shutdown * This
+                        = (struct rms_reqq_Shutdown * )kosal_kmalloc(sizeof(struct rms_reqq_Shutdown));
+   if(This == NULL){
+      return NULL;
+   }
+   This->m_reason = reason;
+
+   RMSSQ_QID(This)    = reqid_Shutdown;
+   RMSSQ_QLEN(This)   = 0;
+   RMSSQ_TRANID(This).m_context = NULL;
+
+   // Initialize the queue item
+   kosal_list_init(&RMSSQ_QUEUE(This));
+   return This;
+}
+
+//=============================================================================
+// Name: rms_reqq_Shutdown_destroy
+// Description: Destructor
+//=============================================================================
+static inline void rms_reqq_Shutdown_destroy(struct rms_reqq_Shutdown *This)
+{
+   kosal_kfree(This, sizeof(struct rms_reqq_Shutdown));
+}
+
+
+//=============================================================================
+//=============================================================================
+//                            Resource Manager Server
+//=============================================================================
+//=============================================================================
+extern int aalrm_server_open(struct inode *, struct file *);
+extern int aalrm_server_close(struct inode *, struct file *);
+
+#if HAVE_UNLOCKED_IOCTL
+extern long aalrm_server_ioctl(struct file *,
+                               unsigned int,
+                               unsigned long);
+#else
+extern int aalrm_server_ioctl(struct inode *,
+                              struct file *,
+                              unsigned int,
+                              unsigned long);
+#endif
+
+extern unsigned int aalrm_server_poll(struct file *, poll_table *);
+
+
+///////////////////////////////////////////////////////////////////////////////
+///////////////////////////////////////////////////////////////////////////////
+////////////////////                                     //////////////////////
+/////////////////          RMSS QUEUE MANAGEMENT           ////////////////////
+////////////////////                                     //////////////////////
+///////////////////////////////////////////////////////////////////////////////
+///////////////////////////////////////////////////////////////////////////////
+//=============================================================================
+//=============================================================================
+//----------------------------------------------------------------------------
+// The following functions are used to interact with the RMSS queues
+// They are here primarily for legacy reasons and for the most part simply
+// wrap the AAL generic functions.
+//----------------------------------------------------------------------------
+//----------------------------------------------------------------------------
+
+//=============================================================================
+// Name: aalrms_queue_req
+// Description: Queues a request onto the request queue
+// Interface: private
+// Inputs: pqitem - item
+// Outputs: none.
+// Comments: Causes any threads waiting on this event to wake up
+//=============================================================================
+static inline void aalrms_queue_req(struct aal_q_item * pqitem)
+{
+   _aal_q_enqueue( pqitem, &rmserver.m_reqq);
+
+   // Unblock select() calls.
+   wake_up_interruptible (&rmserver.m_reqq_wq);
+}
+
+//=============================================================================
+// Name: aalrms_queue_push_req
+// Description: Queues a request onto the request queue head
+// Interface: private
+// Inputs: pqitem - item
+// Outputs: none.
+// Comments: Causes any threads waiting on this event to wake up
+//=============================================================================
+static inline void aalrms_queue_push__req(struct aal_q_item * pqitem)
+{
+   _aal_q_pushqueue( pqitem, &rmserver.m_reqq);
+
+   // Unblock select() calls.
+   wake_up_interruptible (&rmserver.m_reqq_wq);
+}
+
+//=============================================================================
+// Name: aalrms_dequeue_req
+// Description: Get the next item from the request queue
+// Interface: private
+// Inputs: None
+// Returns: next item; NULL - empty.
+// Comments:
+//=============================================================================
+static inline struct aal_q_item * aalrms_dequeue_req(void)
+{
+   return _aal_q_dequeue(&rmserver.m_reqq);
+}
+
+//=============================================================================
+// Name: aalrms_peek_req
+// Description: Get the next item from the request queue without dequeuing
+// Interface: private
+// Inputs: None
+// Returns: next item; NULL - empty.
+// Comments:
+//=============================================================================
+static inline struct aal_q_item * aalrms_peek_req(void)
+{
+   return _aal_q_peek(&rmserver.m_reqq);
+}
+
+
+//=============================================================================
+// Name: aalrms_reqq_empty
+// Description: return status of request queue
+// Interface: private
+// Inputs: None
+// Returns: >0 - empty
+// Comments:
+//=============================================================================
+static inline int aalrms_reqq_empty(void)
+{
+   return _aal_q_empty(&rmserver.m_reqq);
+}
+
+
+//=============================================================================
+// Name: aalrms_reqq_find
+// Description: if the item is found
+// Interface: private
+// Inputs: pqitem - item to find
+// Returns: NULL = Not foind
+// Comments:
+//=============================================================================
+static inline int aalrms_reqq_find(struct aal_q_item * pqitem)
+{
+   return (_aal_q_find(&QI_QUEUE(pqitem), &rmserver.m_reqq) != NULL);
+}
+
+//=============================================================================
+// Name: aalrms_queue_move_to_pend
+// Description: Moves a request to the pending queue atomically
+// Interface: private
+// Inputs: pqitem - item
+// Outputs: none.
+// Comments:
+//=============================================================================
+static inline void aalrms_queue_move_to_pend(struct aal_q_item * pqitem)
+{
+   _aal_q_swapqueue( pqitem, &rmserver.m_reqq, &rmserver.m_pendq);
+}
+
+//=============================================================================
+// Name: aalrms_dequeue_pend
+// Description: Get the next item from the pending queue
+// Interface: private
+// Inputs: None
+// Returns: next item; NULL - empty.
+// Comments:
+//=============================================================================
+static inline struct aal_q_item * aalrms_dequeue_pend(void)
+{
+   return _aal_q_dequeue(&rmserver.m_pendq);
+}
+
+//=============================================================================
+// Name: aalrms_peek_pend
+// Description: Get the next item from the pending queue without dequeuing
+// Interface: private
+// Inputs: None
+// Returns: next item; NULL - empty.
+// Comments:
+//=============================================================================
+static inline struct aal_q_item * aalrms_peek_pend(void)
+{
+   return _aal_q_peek(&rmserver.m_pendq);
+}
+
+
+//=============================================================================
+// Name: aalrms_pendq_empty
+// Description: return status of pending queue
+// Interface: private
+// Inputs: None
+// Returns: >0 - empty
+// Comments:
+//=============================================================================
+static inline int aalrms_pendq_empty(void)
+{
+   return _aal_q_empty(&rmserver.m_pendq);
+}
+
+//=============================================================================
+// Name: aalrms_pendq_find
+// Description: if the item is found
+// Interface: private
+// Inputs: pqitem - item to find
+// Returns: NULL = Not found
+// Comments:
+//=============================================================================
+static inline int aalrms_pendq_find(struct aal_q_item * pqitem)
+{
+   return (_aal_q_find(&QI_QUEUE(pqitem), &rmserver.m_pendq) != NULL);
+}
+
+//=============================================================================
+// Name: aalrms_pendq_remove
+// Description: if the item is found
+// Interface: private
+// Inputs: pqitem - item to find
+// Returns: NULL = Not found
+// Comments: TODO these should use qitems not list_head entries
+//=============================================================================
+static inline int aalrms_pendq_remove(struct aal_q_item * pqitem)
+{
+   kosal_list_head *entry = NULL;
+
+   entry = _aal_q_find(&QI_QUEUE(pqitem),
+                      &rmserver.m_pendq);
+   if(entry != NULL){
+      // NOTE: It is possible for this to fail due to not being able to lock the queue.
+      //       If something other than ignoring needs to be done, test the result code here
+      _aal_q_remove(entry, &rmserver.m_pendq );
+      return 1;
+   }
+   return 0;
+}
+
+
+//=============================================================================
+// Name: aalrms_queue_remove
+// Description: remove from any queue
+// Interface: private
+// Inputs: pqitem - item to find
+// Returns: NULL = Not found
+// Comments:
+//=============================================================================
+static inline int aalrms_queue_remove(aal_queue_t *pqueue,
+                                      struct aal_q_item * pqitem)
+{
+   kosal_list_head *entry = NULL;
+
+   entry = _aal_q_find(&QI_QUEUE(pqitem),
+                      pqueue);
+   if(entry != NULL){
+      // NOTE: It is possible for this to fail due to not being able to lock the queue.
+      //       If something other than ignoring needs to be done, test the result code here
+      _aal_q_remove(entry, pqueue);
+      return 1;
+   }
+   return 0;
+}
+
+//=============================================================================
+// Name: aalrms_queue_doForAllQueuedItems
+// Description: For each item on the Request queue and pending queue call the
+//              function passing the context and queue  info.
+// Interface: private
+// Inputs: pqitem - item to find
+// Returns: NULL = Not found
+// Comments:
+//=============================================================================
+static inline void aalrms_queue_doForAllQueuedItems( aal_q_ProcessItem_t fcn,
+                                                     void *context)
+{
+   // Request queue first
+   _aal_q_doForEachItem( &rmserver.m_reqq,
+                         fcn,
+                         context);
+   // Now pending queue
+   _aal_q_doForEachItem( &rmserver.m_pendq,
+                         fcn,
+                         context);
+}
+
+
+///////////////////////////////////////////////////////////////////////////////
+///////////////////////////////////////////////////////////////////////////////
+////////////////////                                     //////////////////////
+/////////////////                  MACROS                  ////////////////////
+////////////////////                                     //////////////////////
+///////////////////////////////////////////////////////////////////////////////
+///////////////////////////////////////////////////////////////////////////////
+//=============================================================================
+//=============================================================================
+
+// Macros to help with deep fields. Act like casts
+#define rms_sess_to_rms_server(sess)         (*(sess)->m_rmserver)
+
+#define rms_drv_to_ibus(drv)                 (*(drv)->m_bus)
+#define rms_sess_to_ibus(s)                  (*((s)->m_rmserver->m_driver->m_bus))
+
+
+// Singleton RMS
+extern struct aalrm_server rmserver;
+
+
+// External implementations
+extern int aalrms_request_device( struct req_allocdev* preqdev,
+                                  aalrms_reqdev_cmplt_t completionfcn,
+                                  struct aalrms_req_tranID tranID);
+
+extern int aalrms_registrar_request( struct req_registrar* preqdev,
+                                     aalrms_registrarreq_cmplt_t completionfcn,
+                                     struct aalrms_req_tranID tranID);
+
+extern void aalrms_cancel_all_requests(  struct aalrms_req_tranID *);
+
+#endif // __AALKERNEL_AALRESOURCEMGR_SERVER_AALRM_SERVER_INT_H__
+
diff --git a/drivers/fpga/aal/rms/aalrm_server-ioctl.c b/drivers/fpga/aal/rms/aalrm_server-ioctl.c
new file mode 100644
index 000000000000..65c82dbbb4bb
--- /dev/null
+++ b/drivers/fpga/aal/rms/aalrm_server-ioctl.c
@@ -0,0 +1,900 @@
+//******************************************************************************
+// This  file  is  provided  under  a  dual BSD/GPLv2  license.  When using or
+//         redistributing this file, you may do so under either license.
+//
+//                            GPL LICENSE SUMMARY
+//
+//  Copyright(c) 2008-2017, Intel Corporation.
+//
+//  This program  is  free software;  you  can redistribute it  and/or  modify
+//  it  under  the  terms of  version 2 of  the GNU General Public License  as
+//  published by the Free Software Foundation.
+//
+//  This  program  is distributed  in the  hope that it  will  be useful,  but
+//  WITHOUT   ANY   WARRANTY;   without   even  the   implied   warranty    of
+//  MERCHANTABILITY  or  FITNESS  FOR  A  PARTICULAR  PURPOSE.  See  the   GNU
+//  General Public License for more details.
+//
+//  The  full  GNU  General Public License is  included in  this  distribution
+//  in the file called README.GPLV2-LICENSE.TXT.
+//
+//  Contact Information:
+//  Henry Mitchel, henry.mitchel at intel.com
+//  77 Reed Rd., Hudson, MA  01749
+//
+//                                BSD LICENSE
+//
+//  Copyright(c) 2008-2017, Intel Corporation.
+//
+//  Redistribution and  use  in source  and  binary  forms,  with  or  without
+//  modification,  are   permitted  provided  that  the  following  conditions
+//  are met:
+//
+//    * Redistributions  of  source  code  must  retain  the  above  copyright
+//      notice, this list of conditions and the following disclaimer.
+//    * Redistributions in  binary form  must  reproduce  the  above copyright
+//      notice,  this  list of  conditions  and  the  following disclaimer  in
+//      the   documentation   and/or   other   materials   provided  with  the
+//      distribution.
+//    * Neither   the  name   of  Intel  Corporation  nor  the  names  of  its
+//      contributors  may  be  used  to  endorse  or promote  products derived
+//      from this software without specific prior written permission.
+//
+//  THIS  SOFTWARE  IS  PROVIDED  BY  THE  COPYRIGHT HOLDERS  AND CONTRIBUTORS
+//  "AS IS"  AND  ANY  EXPRESS  OR  IMPLIED  WARRANTIES,  INCLUDING,  BUT  NOT
+//  LIMITED  TO, THE  IMPLIED WARRANTIES OF  MERCHANTABILITY  AND FITNESS  FOR
+//  A  PARTICULAR  PURPOSE  ARE  DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT
+//  OWNER OR CONTRIBUTORS BE LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,
+//  SPECIAL,  EXEMPLARY,  OR  CONSEQUENTIAL   DAMAGES  (INCLUDING,   BUT   NOT
+//  LIMITED  TO,  PROCUREMENT  OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF USE,
+//  DATA,  OR PROFITS;  OR BUSINESS INTERRUPTION)  HOWEVER  CAUSED  AND ON ANY
+//  THEORY  OF  LIABILITY,  WHETHER  IN  CONTRACT,  STRICT LIABILITY,  OR TORT
+//  (INCLUDING  NEGLIGENCE  OR OTHERWISE) ARISING  IN ANY WAY  OUT  OF THE USE
+//  OF  THIS  SOFTWARE, EVEN IF ADVISED  OF  THE  POSSIBILITY  OF SUCH DAMAGE.
+//******************************************************************************
+//****************************************************************************
+//        FILE: aalrm_server-ioctl.c
+//     CREATED: 02/21/2008
+//      AUTHOR: Joseph Grecco 	- Intel
+//      		Alvin Chen		- Intel
+//
+// PURPOSE:  IOCTL operations
+// HISTORY:
+// COMMENTS:
+// WHEN:          WHO:     WHAT:
+// 02-21-08       JG       Initial version created
+// 11/11/2008     JG       Added legal header
+// 01/04/2009     HM       Updated Copyright
+// 01/23/2009     JG       Initial code clean up
+// 02/09/2009     JG       Added support for RMSS cancel transaction
+// 06/30/2009     AC       Copy all user space memory to local instead of using
+//                            user space pointer directly
+// 10/12/2009     JG       Major changes to processDeviceRequest began
+// 11/09/2010     HM       Removed extraneous kernel include asm/uaccess.h
+//****************************************************************************
+#include "aalsdk/kernel/kosal.h"
+
+#define MODULE_FLAGS AALRMS_DBG_IOCTL
+
+#include "aalsdk/kernel/aalbus.h"
+#include "aalsdk/kernel/aalinterface.h"
+#include "aalrm_server-int.h"
+#include "aalsdk/kernel/aalrm_server-services.h"
+#include "aalsdk/kernel/aaldevice.h"
+#include "aalrms-events-int.h"
+
+
+
+///////////////////////////////////////////////////////////////////////////////
+///////////////////////////////////////////////////////////////////////////////
+////////////////                                              /////////////////
+/////////////      RESOURCE MANAGER SERVER CALLBACK METHODS       /////////////
+////////////////                                              /////////////////
+///////////////////////////////////////////////////////////////////////////////
+///////////////////////////////////////////////////////////////////////////////
+//=============================================================================
+//=============================================================================
+
+//=============================================================================
+// Name: aalrms_event_config_update
+// Description: Process a config update event
+// Interface: private
+// Inputs:   pdev - AAL device
+//           updateType - Type of update to the device state
+//           pid - Process ID if applicable
+//           context - User context
+// Outputs: none.
+// Comments:
+//=============================================================================
+void aalrms_event_config_update(struct aal_device *pdev,
+                                krms_cfgUpDate_e   updateType,
+                                btPID              pid,
+                                void              *context)
+{
+   struct rms_reqq_config_update_event* newreq;
+   struct aaldev_owner *itr, *tmp;
+   btPID *nextowner;
+
+   //-------------------------------------------------------------
+   // Create queue request object -
+   //  Includes size of constant structure and array of owner pids
+   //-------------------------------------------------------------
+   struct aalrms_configUpDateEvent * pcfgUpdate = (struct aalrms_configUpDateEvent *)
+		   kosal_kmalloc(( sizeof(struct aalrms_configUpDateEvent) + (pdev->m_numowners * sizeof(btPID)) ));
+
+   DPRINTF (AALRMS_DBG_IOCTL, ": Update Event\n");
+
+   //--------------------------------------
+   // Set the constant portion of the event
+   //--------------------------------------
+   pcfgUpdate->id  = updateType;
+   pcfgUpdate->pid = pid;
+
+   pcfgUpdate->devattrs.state       = pdev->m_devstate;     // Device state
+   pcfgUpdate->devattrs.Handle      = pdev;                 // Device Handle
+   pcfgUpdate->devattrs.devid       = pdev->m_devid;        // Copy over the device ID
+   pcfgUpdate->devattrs.maxOwners   = pdev->m_maxowners;    // Max mumber of owners
+
+   //---------------------------------------------
+   // Set the variable length portion of the event
+   //   this consists  of an array of PIDs
+   //---------------------------------------------
+   pcfgUpdate->devattrs.numOwners   = pdev->m_numowners;    // Number of owners
+
+
+   nextowner = pcfgUpdate->devattrs.ownerlist;  // The start of the variable length portion
+   DPRINTF (AALRMS_DBG_IOCTL, ": Walkinglist %p, NumOwners %d, Head %p, Next %p\n", nextowner, pdev->m_numowners, &pdev->m_ownerlist, pdev->m_ownerlist.next);
+
+   if(0 != pdev->m_numowners){
+      // Fill in the owner list - Walk the ownerlist and copy the pid for each
+      kosal_list_for_each_entry_safe(itr, tmp, &pdev->m_ownerlist, m_ownerlist, struct aaldev_owner) {
+         DPRINTF(AALRMS_DBG_IOCTL, "About to look at itr %p, nextowner %p\n", itr, nextowner);
+         if (itr) {
+            *nextowner++ = itr->m_pid; // The owner is identified by pid. Save in increment the pointer
+         }
+         else {
+            DPRINTF(AALRMS_DBG_IOCTL, "ITR IS NULL\n");
+            break;   // GET OUT, otherwise maybe infinite
+         }
+      }
+   }
+
+   //---------------
+   // Debug log info
+   //---------------
+   DPRINTF(AALRMS_DBG_IOCTL,"ID %d and %d\n",  updateType,pcfgUpdate->id );
+
+   DPRINTF(AALRMS_DBG_IOCTL,"Handle: %p\n", pcfgUpdate->devattrs.Handle);                    // Device Handle
+   DPRINTF(AALRMS_DBG_IOCTL,"vendor: %x\n", pcfgUpdate->devattrs.devid.m_vendor);            // Vendor code
+   DPRINTF(AALRMS_DBG_IOCTL,"devicetype: %x\n", pcfgUpdate->devattrs.devid.m_devicetype);    // Device type
+
+   DPRINTF(AALRMS_DBG_IOCTL,"\nADDRESS:\n");
+   DPRINTF(AALRMS_DBG_IOCTL,"bustype: %x\n", pcfgUpdate->devattrs.devid.m_devaddr.m_bustype);
+   DPRINTF(AALRMS_DBG_IOCTL,"busnum: %x\n", pcfgUpdate->devattrs.devid.m_devaddr.m_busnum);
+   DPRINTF(AALRMS_DBG_IOCTL,"devicenum: %x\n", pcfgUpdate->devattrs.devid.m_devaddr.m_devicenum);
+   DPRINTF(AALRMS_DBG_IOCTL,"funcnum: %x\n", pcfgUpdate->devattrs.devid.m_devaddr.m_functnum);
+   DPRINTF(AALRMS_DBG_IOCTL,"subdevnum: %x\n\n", pcfgUpdate->devattrs.devid.m_devaddr.m_subdevnum);
+   DPRINTF(AALRMS_DBG_IOCTL,"instancenum: %x\n\n", pcfgUpdate->devattrs.devid.m_devaddr.m_instanceNum);
+   DPRINTF(AALRMS_DBG_IOCTL,"socketnum: %x\n\n", pcfgUpdate->devattrs.devid.m_devaddr.m_socketnum);
+
+   DPRINTF(AALRMS_DBG_IOCTL,"pipGUID: %llx\n", pcfgUpdate->devattrs.devid.m_pipGUID); // PIP GUID
+   DPRINTF(AALRMS_DBG_IOCTL,"ahmGUID: %llx\n", pcfgUpdate->devattrs.devid.m_ahmGUID); // AHM GUID
+   DPRINTF(AALRMS_DBG_IOCTL,"afuGUIDH: %llx\n", pcfgUpdate->devattrs.devid.m_afuGUIDh); // AFU GUID
+   DPRINTF(AALRMS_DBG_IOCTL,"afuGUIDL: %llx\n", pcfgUpdate->devattrs.devid.m_afuGUIDl); // AFU GUID
+
+   DPRINTF(AALRMS_DBG_IOCTL,"Owners: %d\n", pcfgUpdate->devattrs.numOwners);
+   DPRINTF(AALRMS_DBG_IOCTL,"MaxOwners: %d\n",pcfgUpdate->devattrs.maxOwners);
+
+
+   // Create the event object
+   newreq = rms_reqq_config_update_event_create(pcfgUpdate);
+   if(newreq == NULL){
+      DPRINTF (AALRMS_DBG_IOCTL, ": Failed to create queue object\n");
+      return;
+   }
+
+   // Queue the item  - TODO Need a separate queue to make a priority queuing scheme
+   aalrms_queue_req(RMSSQIP(newreq));
+   return;
+
+}
+
+///////////////////////////////////////////////////////////////////////////////
+///////////////////////////////////////////////////////////////////////////////
+////////////////                                              /////////////////
+/////////////         RESOURCE MANAGER SERVER  METHODS            /////////////
+////////////////                                              /////////////////
+///////////////////////////////////////////////////////////////////////////////
+///////////////////////////////////////////////////////////////////////////////
+//=============================================================================
+//=============================================================================
+
+//=============================================================================
+// Name: aalrms_process_message
+// Description: Process a request message
+// Interface: private
+// Inputs:struct psess - session
+//               arg - user args from ioctl
+//               preq - aalrm_ioctlreq header
+// Outputs: Message copied back to user sapce.
+// Comments: This function processes requests that typically originate from the
+//           Resource Manager Client Service (RMCS). These requests are
+//           in messages derived from the aal_q_item type.
+//           Some/most messages are directed toward user space services but
+//           not all.
+//           NOTE: Requests are moved from the request queue to the pending
+//                 queue. This must be done atomically so that requests are
+//                 always in a trackable state so that it can be canceled.
+
+// TODO BUG occurs if max owners exceeded and device removed
+//=============================================================================
+int aalrms_process_message( struct aalrm_server_session *psess,
+                            unsigned long arg,
+                            struct aalrm_ioctlreq  *preq)
+{
+   union {
+      struct rms_reqq_reqdev     *preqdev;   // "Request Device" message which is of type qitem
+      struct rms_reqq_registrar  *pregreq;   // "Registrar Request" message which is of type qitem
+      struct rms_reqq_config_update_event *pupdate;
+   }u;
+
+   struct aal_q_item    *pqitem = NULL;
+   int ret = 0;
+
+   DPRINTF(AALRMS_DBG_IOCTL, ": Processing message\n");
+
+   // Lock-out cancels. Do not make this interruptible - TODO perhaps shold be changed to down_killable
+   kosal_sem_get_user(&rmserver.m_sem);
+
+   //--------------------------------------------------------
+   // Check the request message
+   // Must use peek() so that it remains on a trackable queue
+   //--------------------------------------------------------
+   pqitem = aalrms_peek_req();
+   if(pqitem == NULL) {
+      DPRINTF( AALRMS_DBG_IOCTL, ": Invalid or corrupted request\n" );
+      ret =  -EFAULT;
+      goto done;
+   }
+
+   //-----------------------------------------------------------------------------
+   // Update the ioctl header
+   //  Since most RMSS requests are forwarded to the user mode service application
+   //  the user request header is prepared up front
+   //-----------------------------------------------------------------------------
+   preq->id = QI_QID(pqitem);
+   preq->req_handle = pqitem;
+
+   //----------------------------------------------------------------
+   // Process the request message
+   // - Note the ID has already been copied into the preq structure
+   //   but originally comes from the queued request message in qitem
+   //----------------------------------------------------------------
+   switch(preq->id) {
+      //------------------
+      // Registrar Request
+      //------------------
+      case reqid_RS_Registrar: {
+         DPRINTF (AALRMS_DBG_IOCTL, ": MSG - reqid_Registrar  reqhandle %p\n",preq->req_handle);
+
+         // Get the request from the queue item
+         u.pregreq = qi_to_regreq(pqitem);
+
+         // User should have passed the payload buffer size.  Do not exceed buffer
+         if(preq->size < QI_LEN(pqitem)){
+            // TODO the message should be pushed back on the request queue or at least an error response sent to the requestor
+            rms_reqq_regreq_destroy(u.pregreq);
+            DPRINTF(AALRMS_DBG_IOCTL, ": Buffer not large enough to accept command\n");
+            ret = -EINVAL;
+            goto done;
+         }
+
+         //------------------------------------------------------
+         // Place the item on the pending queue
+         //  Requests that have a response must be
+         //  saved so that the response can be routed back to the
+         //  originator. This is an atomic operation.
+         //------------------------------------------------------
+         aalrms_queue_move_to_pend(pqitem);
+
+         // Copy the header portion of the request back
+         if(copy_to_user ((struct aalrm_ioctlreq *)arg, preq, sizeof(struct aalrm_ioctlreq))){
+            DPRINTF(AALRMS_DBG_IOCTL, ": Failed copy Message \n");
+            ret = -EFAULT;
+            goto done;
+         }
+
+         // Copy the payload portion of the request back
+         if(QI_LEN(pqitem) !=0){
+            if(copy_to_user(preq->payload,
+                              &REGREQ_REGREQP(u.pregreq)->buf,
+                              REGREQ_REGREQP(u.pregreq)->size) ){
+               DPRINTF(AALRMS_DBG_IOCTL, ": Failed get Message \n");
+               ret = -EFAULT;
+               goto done;
+            }
+         }
+         preq->size  = QI_LEN(pqitem);
+         break;
+      } // case reqid_RS_Registrar
+
+
+      //------------------------------
+      // Request a device be allocated
+      //------------------------------
+      case reqid_URMS_RequestDevice: {
+         DPRINTF (AALRMS_DBG_IOCTL, ": MSG - reqid_URMS_RequestDevice reqhandle %p\n",preq->req_handle);
+
+         // Get the request
+         u.preqdev = qi_to_reqdev(pqitem);
+
+         // User should have passed the payload buffer size.  Do not exceed buffer
+         if(preq->size < QI_LEN(pqitem)){
+            // TODO SHOULD SEND A FAILURE RESOPONSE TO REQUESTOR NOT DELETE MYSELF AND REMOVE FROM PENDING
+            kosal_kfree(u.preqdev->m_reqdev, sizeof(struct req_allocdev)); rms_reqq_reqdev_destroy(u.preqdev);
+            DPRINTF(AALRMS_DBG_IOCTL, ": DEBUG FREEING THE QITEM AND ITEM ITSELF\n");
+            ret = -EINVAL;
+            goto done;
+         }
+
+         // Place the item on the pending queue atomically
+         aalrms_queue_move_to_pend(pqitem);
+
+         // Copy the header portion of the request back
+         if(copy_to_user((struct aalrm_ioctlreq *) arg, preq, sizeof(struct aalrm_ioctlreq))){
+              DPRINTF(AALRMS_DBG_IOCTL, ": Failed get Message \n");
+              ret = -EFAULT;
+              goto done;
+         }
+
+         // Copy the payload section if there is one
+         if(QI_LEN(pqitem) != 0){
+            if( copy_to_user( preq->payload, &REQDEV_ALLOCDEV(u.preqdev).buf, QI_LEN(pqitem)  )    ){
+               DPRINTF(AALRMS_DBG_IOCTL, ": Failed copy Message\n");
+               ret = -EFAULT;
+               goto done;
+            }
+         }
+         preq->size  = QI_LEN(pqitem);
+         break;
+      } // case reqid_URMS_RequestDevice
+
+      //---------------------------
+      // Configuration Update event
+      //---------------------------
+      case evtid_KRMS_ConfigUpdate: {
+         pqitem = aalrms_dequeue_req();
+
+         u.pupdate = qi_to_updateevent(pqitem);
+         DPRINTF (AALRMS_DBG_IOCTL, ": CMD - rspid_KRMS_ConfigUpdate ID = %d\n",CONF_EVTP_EVENT(u.pupdate).id);
+         // User should have passed the payload buffer size.  Do not exceed buffer
+         if(preq->size < QI_LEN(pqitem)){
+             rms_reqq_config_update_event_destroy(u.pupdate);
+             DPRINTF(AALRMS_DBG_IOCTL, ": No room to return the event\n");
+             ret = -EINVAL;
+             goto done;
+         }
+
+         // Copy the payload section
+         if(copy_to_user(  preq->payload, &CONF_EVTP_EVENT(u.pupdate), QI_LEN(pqitem)) ){
+            DPRINTF(AALRMS_DBG_IOCTL, ": Failed copy Message\n");
+            rms_reqq_config_update_event_destroy(u.pupdate);
+            ret = -EFAULT;
+            goto done;
+         }
+         DPRINTF (AALRMS_DBG_IOCTL, ": CMD - rspid_KRMS_ConfigUpdate - Event Destroyed\n");
+         rms_reqq_config_update_event_destroy(u.pupdate);
+         preq->size  = QI_LEN(pqitem);
+         break;
+      } // case evtid_KRMS_ConfigUpdate
+
+      //-----------------
+      // Shutdown request
+      //-----------------
+      case reqid_Shutdown: {
+         // Copy the header portion of the request back
+         DPRINTF (AALRMS_DBG_IOCTL, ": CMD - reqid_Shutdown\n");
+
+         pqitem = aalrms_dequeue_req();
+
+         // User should have passed the payload buffer size.  Do not exceed buffer
+         if(preq->size < QI_LEN(pqitem)){
+            rms_reqq_Shutdown_destroy(qi_to_shutdownevent(pqitem));
+             DPRINTF(AALRMS_DBG_IOCTL, ": No room to return the event\n");
+             ret = -EINVAL;
+             goto done;
+         }
+
+         if(copy_to_user ((struct aalrm_ioctlreq *)arg, preq, sizeof(struct aalrm_ioctlreq))){
+            DPRINTF(AALRMS_DBG_IOCTL, ": Failed copy Message \n");
+            rms_reqq_Shutdown_destroy(qi_to_shutdownevent(pqitem));
+            ret = -EFAULT;
+            goto done;
+         }
+         rms_reqq_Shutdown_destroy(qi_to_shutdownevent(pqitem));
+         preq->size  = QI_LEN(pqitem);
+         break;
+      } // case reqid_Shutdown
+
+
+      default: {
+         DPRINTF (AALRMS_DBG_IOCTL, ": CMD - Unexpected\n");
+         pqitem = aalrms_dequeue_req();
+         ret = -EINVAL;
+         goto done;
+         break;
+      }
+
+   } // switch(preq->id)
+
+   done:
+      kosal_sem_put(&rmserver.m_sem);
+      return ret;
+}
+
+//=============================================================================
+// Name: aalrms_processDeviceRequest
+// Description: Process a request to be forwarded to a device such as activate
+//              and deactivate
+// Interface: public
+// Inputs:  psess- pointer to session
+//          preq - pointer to user request block
+// Outputs: none.
+// Comments:
+//=============================================================================
+int aalrms_processDeviceRequest(struct aalrm_server_session *psess,
+                                struct aalrm_ioctlreq       *preq)
+{
+   struct aaldev_ownerSession     ownerSess;
+   struct aal_pipmessage          pipMessage;
+   struct rms_event_devreq_cmplt *eventp = NULL;
+   struct aal_device             *pdev   = NULL;
+   int                            ret    = -EINVAL;
+
+   // Get the handle and validate
+   DPRINTF(AALRMS_DBG_IOCTL, ": Getting handle %p %p\n",preq,preq->res_handle );
+
+   pdev = aaldev_handle_to_devp(preq->res_handle);
+   if ( unlikely( NULL == pdev ) ) {
+      DPRINTF(AALRMS_DBG_IOCTL, ": Invalid device handle %p\n", preq->res_handle);
+
+      eventp = rms_event_devreq_cmplt_create(rms_resultInvalidDevice,
+                                             preq->tranID,
+                                             preq->context);
+      goto DONE;
+   }
+
+   // ------------------------------------
+   // Get the default PIP message handler
+   // interface and bind it to our session
+   // ------------------------------------
+   DPRINTF(AALRMS_DBG_IOCTL, ": Checking Interface\n");
+   if ( unlikely( NULL == aaldev_pipp(pdev) ) ) {
+      DPRINTF(AALRMS_DBG_IOCTL, ": rms_resultDeviceHasNoPIPAssigned\n");
+
+      eventp = rms_event_devreq_cmplt_create(rms_resultDeviceHasNoPIPAssigned,
+                                             preq->tranID,
+                                             preq->context);
+      goto DONE;
+   }
+
+   //--------------------------------------------
+   // Initialize the UI side of the owner session
+   //--------------------------------------------
+   ownerSess.m_device = pdev;                                   // Device
+
+   // Wrap the message and transaction identification
+   //  pipMessage is a generic message wrapper for all
+   //  PIP message handlers
+   pipMessage.m_message = preq->payload;
+   pipMessage.m_tranID  = preq->tranID;
+   pipMessage.m_context = preq->context;
+
+   DPRINTF(AALRMS_DBG_IOCTL, ": Sending message\n");
+
+   // Send the message on its way.
+
+   ret = aalsess_pipSendMessage(&ownerSess)(&ownerSess,
+                                            &pipMessage);
+   if ( 0 == ret ) {
+      ASSERT(NULL == eventp); // memory leak otherwise.
+      goto DONE;
+   }
+
+   eventp = rms_event_devreq_cmplt_create(rms_resultOK,
+                                          preq->tranID,
+                                          preq->context);
+
+DONE:
+   if ( NULL != eventp ) {
+      aalrms_queue_req(AALQIP(eventp));
+   }
+
+   return ret;
+}
+
+//=============================================================================
+// Name: aalrms_process_sendmessage
+// Description: Process a send message command
+// Interface: public
+// Inputs:  psess- pointer to session
+//          preq - pointer to user request block
+// Outputs: none.
+// Comments:
+//=============================================================================
+int aalrms_process_sendmessage(struct aalrm_server_session *psess,
+                               struct aalrm_ioctlreq  *preq)
+{
+   struct rms_reqq_Shutdown*  newreq;
+
+   // Process an RMSS message
+   switch (preq->id) {
+      //---------------------------------------
+      // Enable or disable config update events
+      //---------------------------------------
+      case reqid_KRMS_SetConfigUpdates: {
+         DPRINTF(AALRMS_DBG_IOCTL, ": Enabling Update Events\n");
+         return psess->m_aalbus->register_config_update_handler(
+                                             aalrms_event_config_update, NULL);
+      }
+      break;
+
+      //-------------------------
+      // Issue a shutdown request
+      //-------------------------
+      case reqid_Shutdown: {
+         //-------------------------------
+         // Create shutdown  request object
+         //-------------------------------
+         DPRINTF(AALRMS_DBG_IOCTL, ": Received a shutdown ioctl\n");
+         newreq = rms_reqq_Shutdown_create((rms_shutdownreason_e)preq->data);
+         if ( NULL == newreq ) {
+            return -ENOMEM;
+         }
+
+         // Queue the item
+         aalrms_queue_req(RMSSQIP(newreq));
+         break;
+      }
+
+      //----------------
+      // Device request
+      //---------------
+      case reqid_RM_DeviceRequest:
+      {
+         DPRINTF(AALRMS_DBG_IOCTL, ": Received a device request ioctl\n");
+         return aalrms_processDeviceRequest(psess,
+                                            preq);
+      }
+
+      default:
+      {
+         DPRINTF(AALRMS_DBG_IOCTL, ": Unknown message\n");
+         return -EINVAL;
+         break;
+      }
+   } // switch (preq->id)
+   return 0;
+}
+
+//=============================================================================
+// Name: aalrms_process_sendresponse
+// Description: Process a response message
+// Interface: public
+// Inputs:  psess- pointer to session
+//          preq - pointer to user request block
+//          pqitem - Pointer to the qitem holding original request
+// Outputs: Response copied to user space..
+// Comments:
+//=============================================================================
+int aalrms_process_sendresponse(struct aalrm_server_session *psess,
+                                struct aalrm_ioctlreq  *preq,
+                                struct aal_q_item    *pqitem)
+{
+   struct req_registrar    *pregresp;        // Response from registrar
+   struct rsp_device       *presresp;        // Response from RMS
+   union {
+      struct rms_reqq_reqdev     *preqdev;   // "Request Device" message which is of type qitem
+      struct rms_reqq_registrar  *pregreq;   // "Registrar Request" message which is of type qitem
+   }u;
+
+   int ret = 0;
+
+   // Lock-out cancels. Do not make this interruptible
+   kosal_sem_get_user(&rmserver.m_sem);
+
+   // Make sure the qitem is valid
+   if(likely(aalrms_pendq_find(pqitem))){
+      //Remove it from the pending queue
+      aalrms_pendq_remove(pqitem);
+
+   }
+   else{
+      DPRINTF (AALRMS_DBG_IOCTL, ": Invalid qitem  %p\n",pqitem);
+
+      ret = -EINVAL;
+      goto done;
+   }
+
+   //-----------------
+   // Process response
+   //-----------------
+   switch (preq->id) {
+      //------------------
+      // Registar response  //TODO make sure the response is correct for the request
+      //------------------
+      case rspid_RS_Registrar: {
+         DPRINTF(AALRMS_DBG_IOCTL, ": rspid_RS_Registrar - Payload len = %d\n",(int)preq->size);
+
+         u.pregreq = qi_to_regreq(pqitem);
+
+         //--------------------------------
+         // Make a copy of the user message
+         //  so that it can be sent in a
+         //  response event back to RMCS
+         //--------------------------------
+
+         // Allocates space for the message + payload
+         pregresp = (struct req_registrar    *)kosal_kmalloc((preq->size + REGISTRAR_REQ_HDRSZ));
+         if (pregresp == NULL) {
+            DPRINTF(AALRMS_DBG_IOCTL,
+                  ": CMD - Registrar response failed kmalloc\n");
+            ret = -ENOMEM;
+            goto done;
+         }
+
+         //---------------------------------------------------
+         // Copy the header from original request. It includes
+         //   the TranID and Context from original request.
+         //   These need to be returned in the response.
+         //---------------------------------------------------
+         *pregresp = REGREQ_REGREQ(u.pregreq);
+
+         //Update the Payload information with Registrar response data
+         pregresp->size = preq->size;
+
+         DPRINTF(AALRMS_DBG_IOCTL,
+               ": CMD - Queuing Registrar response size = %d\n",
+               (int) pregresp->size);
+
+         // Copy in the response payload
+         if((pregresp->size != 0) && preq->payload ){
+            //Copy the payload
+            if (copy_from_user(&pregresp->buf, preq->payload, preq->size)) {
+               DPRINTF(AALRMS_DBG_IOCTL, ": CMD - Copy failed\n");
+               kosal_kfree(pregresp, (preq->size + REGISTRAR_REQ_HDRSZ));
+               ret = -EFAULT;
+               goto done;
+            }
+         }
+
+         // Call the RMC completion callback
+         CALL_COMPLETION(u.pregreq)(preq->result_code,
+                                    pregresp,
+                                    REGREQ_REGREQP(u.pregreq),
+                                    RMSSQ_TRANID(u.pregreq));
+
+         // Free the copy of the response
+         kosal_kfree(pregresp, (preq->size + REGISTRAR_REQ_HDRSZ));
+
+         //Destroy original request message
+         rms_reqq_regreq_destroy(u.pregreq);
+         
+         break;
+      } // case rspid_RS_Registrar
+
+      //-----------------------
+      // RequestDevice response
+      //-----------------------
+      case rspid_URMS_RequestDevice: {
+         DPRINTF(AALRMS_DBG_IOCTL, ": rspid_URMS_RequestDevice - Payload len = %d\n",(int)preq->size);
+
+         // Get the original request from queue item
+         u.preqdev = qi_to_reqdev(pqitem);
+
+         //--------------------------------
+         // Make a copy of the user message
+         //  so that it can be sent in a
+         //  response event back to RMCS
+         //--------------------------------
+
+         // Allocates space for the message + payload
+         presresp = (struct rsp_device *)kosal_kmalloc((preq->size + REQDEVICE_RSP_HDRSZ));
+         if (presresp == NULL) {
+            DPRINTF(AALRMS_DBG_IOCTL,
+                  ": CMD - Registrar response failed kmalloc\n");
+            ret = -ENOMEM;
+            goto done;
+         }
+
+         presresp->devHandle = preq->res_handle;
+         presresp->result = preq->result_code;
+         if(unlikely(presresp->result != 0 ) ){
+            DPRINTF(AALRMS_DBG_IOCTL, ": Failure response sent from uRMS\n");
+         }
+
+         //Update the Payload information with response data
+         presresp->size = preq->size;
+
+         if((presresp->size != 0) && preq->payload ){
+            //Copy the payload
+            DPRINTF(AALRMS_DBG_IOCTL, ": Copying payload %p[%d]\n",preq->payload,(int)presresp->size);
+            if (copy_from_user(&presresp->buf, preq->payload, preq->size)) {
+               DPRINTF(AALRMS_DBG_IOCTL, ": CMD - Copy failed\n");
+               kosal_kfree(presresp, (preq->size + REQDEVICE_RSP_HDRSZ));
+               ret = -EFAULT;
+               goto done;
+            }
+         }
+
+         // Send the response event back
+         CALL_COMPLETION( u.preqdev)(presresp->result,
+                                     presresp,
+                                     REQDEV_ALLOCDEVP(u.preqdev),
+                                     RMSSQ_TRANID(u.preqdev));
+
+         // Done so destroy the request
+         rms_reqq_reqdev_destroy(u.preqdev);
+
+         // Destroy the response
+         kosal_kfree(presresp, (preq->size + REQDEVICE_RSP_HDRSZ));
+         
+         break;
+      } // rspid_URMS_RequestDevice
+
+      default:  {
+         DPRINTF(AALRMS_DBG_IOCTL, ": CMD - Unknown response\n");
+         ret = -EINVAL;
+         goto done;
+         break;
+      }
+   } // switch (preq->id)
+
+done:
+   kosal_sem_put(&rmserver.m_sem);
+   return ret;
+}
+
+
+//=============================================================================
+// Name: aalrm_server_ioctl
+// Description: Implements the ioctl system call
+// Interface: public
+// Inputs: inode - pointer to inode of special device file
+//         file - open file instance
+//         cmd - from command argument of ioctl
+//         arg - arg argument of ioctl
+// Outputs: none.
+// Comments:
+//=============================================================================
+#if HAVE_UNLOCKED_IOCTL
+long aalrm_server_ioctl(struct file *file,
+                        unsigned int cmd,
+                        unsigned long arg)
+#else
+int aalrm_server_ioctl(struct inode *inode,
+                       struct file *file,
+                       unsigned int cmd,
+                       unsigned long arg)
+#endif
+
+{
+   // Get the session pointer from file instance
+   struct aalrm_server_session *psess =
+                           (struct aalrm_server_session *) file->private_data;
+
+   // Generic variables
+   int                           ret=0;
+   struct aalrm_ioctlreq         req;              // User IOCTL request structure
+
+   // Variables used in the Device Allocate Messages
+   struct aal_q_item             *pqitem = NULL;   // Generic request queue item
+
+   //---------------------
+   // Get the user request
+   //---------------------
+   if(copy_from_user (&req, (void *) arg, sizeof(req))){
+      return -EFAULT;
+   }
+
+   if ( ( req.size + REGISTRAR_REQ_HDRSZ ) > KMALLOC_MAX_SIZE ) {
+      PERR("Request size too large: %" PRIu64 "\n", req.size + REGISTRAR_REQ_HDRSZ);
+      return -EINVAL;
+   }
+
+   //------------------
+   // Process the IOCTL
+   //------------------
+   DPRINTF (AALRMS_DBG_IOCTL, "cmd=%x\n", cmd);
+   ret = -EINVAL;  //Assume failure
+
+   switch (cmd) {
+   //-----------------------------------
+   // Get next queued message descriptor
+   // This will contain things like its
+   // size and type
+   //---------------------------------
+      case AALRM_IOCTL_GETMSG_DESC: {
+         // Make sure there is a message to be had
+         if( aalrms_reqq_empty() ) {
+            DPRINTF( AALRMS_DBG_IOCTL, ": No Message available\n" );
+            return -EAGAIN;
+         }
+
+         // Peek the head of the message queue
+         pqitem = aalrms_peek_req();
+         if(pqitem == NULL) {
+            DPRINTF( AALRMS_DBG_IOCTL, ": Invalid or corrupted request\n" );
+            return -EFAULT;
+         }
+
+         // Return the type and total size of the message that will be returned
+         req.id   = QI_QID(pqitem);
+         req.size = QI_LEN(pqitem);
+
+         DPRINTF(AALRMS_DBG_MOD, ": Getting Message Decriptor - size = %d\n",(int)req.size );
+
+         // Return the message header
+         if(copy_to_user ((struct aalrm_ioctlreq *) arg, &req, sizeof(struct aalrm_ioctlreq))) {
+            DPRINTF(AALRMS_DBG_IOCTL, ": Failed get Message Decriptor \n");
+            return -EFAULT;
+         }
+         return 0;
+      } // case AALRM_IOCTL_GETMSG_DESC: 
+
+   //-----------------------------------------------
+   // Get the next message off of the request queue
+   // and process it.  The message is processed and
+   // may be forwarded to a user mode service
+   //-----------------------------------------------
+      case  AALRM_IOCTL_GETMSG: {
+         // Make sure there is a message to be had
+         if( aalrms_reqq_empty() ) {
+            DPRINTF( AALRMS_DBG_IOCTL, ": No Message available\n" );
+            return -EAGAIN;
+         }
+
+
+         // Process the request
+         return aalrms_process_message(psess, arg, &req);
+      }
+
+      //-----------------------------------------
+      // Send a message
+      //  This may be a response to a request or
+      //  simply a message
+      //-----------------------------------------
+      case  AALRM_IOCTL_SENDMSG: {
+         if(req.req_handle == NULL) {
+            DPRINTF(AALRMS_DBG_IOCTL, ": Sending message\n");
+            return aalrms_process_sendmessage(psess, &req);
+         }else {
+            DPRINTF(AALRMS_DBG_IOCTL, ": Sending response\n");
+
+            /* a straight cast from (void *) is performed here.  the pointer
+             * value is validated before use in aalrms_process_sendresponse(),
+             * so it is not checked here.  */
+            pqitem = req.req_handle;
+
+            return aalrms_process_sendresponse(psess, &req, pqitem);
+         }
+         break;
+      }
+      default:
+      {
+         DPRINTF(AALRMS_DBG_IOCTL, ": Invalid IOCTL=%x\n", cmd);
+         break;
+      }
+   } // switch (cmd)
+   return ret;
+}
+
+///////////////////////////////////////////////////////////////////////////////
+///////////////////////////////////////////////////////////////////////////////
+////////////////                                              /////////////////
+/////////////      RESOURCE MANAGER SERVER UTILITY METHODS       /////////////
+////////////////                                              /////////////////
+///////////////////////////////////////////////////////////////////////////////
+///////////////////////////////////////////////////////////////////////////////
+//=============================================================================
+//=============================================================================
diff --git a/drivers/fpga/aal/rms/aalrm_server-main.c b/drivers/fpga/aal/rms/aalrm_server-main.c
new file mode 100644
index 000000000000..4bdf59d17d58
--- /dev/null
+++ b/drivers/fpga/aal/rms/aalrm_server-main.c
@@ -0,0 +1,709 @@
+//******************************************************************************
+// This  file  is  provided  under  a  dual BSD/GPLv2  license.  When using or
+//         redistributing this file, you may do so under either license.
+//
+//                            GPL LICENSE SUMMARY
+//
+//  Copyright(c) 2008-2017, Intel Corporation.
+//
+//  This program  is  free software;  you  can redistribute it  and/or  modify
+//  it  under  the  terms of  version 2 of  the GNU General Public License  as
+//  published by the Free Software Foundation.
+//
+//  This  program  is distributed  in the  hope that it  will  be useful,  but
+//  WITHOUT   ANY   WARRANTY;   without   even  the   implied   warranty    of
+//  MERCHANTABILITY  or  FITNESS  FOR  A  PARTICULAR  PURPOSE.  See  the   GNU
+//  General Public License for more details.
+//
+//  The  full  GNU  General Public License is  included in  this  distribution
+//  in the file called README.GPLV2-LICENSE.TXT.
+//
+//  Contact Information:
+//  Henry Mitchel, henry.mitchel at intel.com
+//  77 Reed Rd., Hudson, MA  01749
+//
+//                                BSD LICENSE
+//
+//  Copyright(c) 2008-2017, Intel Corporation.
+//
+//  Redistribution and  use  in source  and  binary  forms,  with  or  without
+//  modification,  are   permitted  provided  that  the  following  conditions
+//  are met:
+//
+//    * Redistributions  of  source  code  must  retain  the  above  copyright
+//      notice, this list of conditions and the following disclaimer.
+//    * Redistributions in  binary form  must  reproduce  the  above copyright
+//      notice,  this  list of  conditions  and  the  following disclaimer  in
+//      the   documentation   and/or   other   materials   provided  with  the
+//      distribution.
+//    * Neither   the  name   of  Intel  Corporation  nor  the  names  of  its
+//      contributors  may  be  used  to  endorse  or promote  products derived
+//      from this software without specific prior written permission.
+//
+//  THIS  SOFTWARE  IS  PROVIDED  BY  THE  COPYRIGHT HOLDERS  AND CONTRIBUTORS
+//  "AS IS"  AND  ANY  EXPRESS  OR  IMPLIED  WARRANTIES,  INCLUDING,  BUT  NOT
+//  LIMITED  TO, THE  IMPLIED WARRANTIES OF  MERCHANTABILITY  AND FITNESS  FOR
+//  A  PARTICULAR  PURPOSE  ARE  DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT
+//  OWNER OR CONTRIBUTORS BE LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,
+//  SPECIAL,  EXEMPLARY,  OR  CONSEQUENTIAL   DAMAGES  (INCLUDING,   BUT   NOT
+//  LIMITED  TO,  PROCUREMENT  OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF USE,
+//  DATA,  OR PROFITS;  OR BUSINESS INTERRUPTION)  HOWEVER  CAUSED  AND ON ANY
+//  THEORY  OF  LIABILITY,  WHETHER  IN  CONTRACT,  STRICT LIABILITY,  OR TORT
+//  (INCLUDING  NEGLIGENCE  OR OTHERWISE) ARISING  IN ANY WAY  OUT  OF THE USE
+//  OF  THIS  SOFTWARE, EVEN IF ADVISED  OF  THE  POSSIBILITY  OF SUCH DAMAGE.
+//******************************************************************************
+//****************************************************************************
+//        FILE: aalrm_server-main.c
+//     CREATED: 02/20/2008
+//      AUTHOR: Joseph Grecco - Intel
+//
+// PURPOSE: This file implements the initialization and cleanup code for the
+//          AAL Resouce Manager Server Kernel Module.
+// HISTORY:
+// COMMENTS: This module implemeents RMS. The Resource
+//           manager server is an service interface device used by the resource
+//           management user space service daemon responsible for all of the
+//           policy decisions of the resource manager.
+// WHEN:          WHO:     WHAT:
+// 02/20/08       JG       Initial version created
+// 11/11/2008     JG       Added legal header
+// 01/04/2009     HM       Updated Copyright
+// 01/21/2009     JG       Initial code cleanup
+// 02/09/2009     JG       Added support for RMSS cancel transaction
+// 02/26/2009     JG       Nulled unused match()
+// 04/13/2009     JG       Added support for version kernel 2.6.27
+// 05/18/2010     HM       Labeled kosal_sem_get_krnl_alertable() with FIXME. Need a
+//                            global fix for these. Getting it to compile.
+// 11/09/2010     HM       Removed extraneous kernel include asm/uaccess.h
+//****************************************************************************
+#include "aalsdk/kernel/kosal.h"
+
+#define MODULE_FLAGS AALRMS_DBG_MOD
+
+#include "aalrm_server-int.h"
+#include "aalsdk/kernel/aalrm-services.h"
+#include "aalsdk/kernel/aalrm_server-services.h"
+#include "aalsdk/kernel/aalbus.h"
+#include "aalsdk/kernel/aalinterface.h"
+
+MODULE_VERSION    (DRV_VERSION);
+MODULE_DESCRIPTION(DRV_DESCRIPTION);
+MODULE_AUTHOR     (DRV_AUTHOR);
+MODULE_LICENSE    (DRV_LICENSE);
+
+//=============================================================================
+// Driver Parameters
+//=============================================================================
+
+// debug flags with default values
+btUnsignedInt debug = 0; //AALRMS_DBG_DEFAULT;
+
+// Major device number to use for the device nodes
+btInt majornum = 0;
+#if defined( __AAL_LINUX__ )
+
+//
+//  Declarations for module parameters - Enables parameter value passing from
+//                                       insmod and permissions as seen from /sys
+//
+MODULE_PARM_DESC(debug, "debug level");
+module_param    (debug, int, 0644);
+
+MODULE_PARM_DESC(majornum, "major device number");
+module_param    (majornum, int, 0444);
+
+//=============================================================================
+// Name: aalbus_attrib_show_debug
+//=============================================================================
+static ssize_t ahmpip_attrib_show_debug(struct device_driver *drv, char *buf)
+{
+   return (snprintf(buf,PAGE_SIZE,"%d\n",debug));
+}
+
+//=============================================================================
+// Name: aalbus_attrib_store_debug
+//=============================================================================
+static ssize_t ahmpip_attrib_store_debug(struct device_driver *drv,
+                                         const char *buf,
+                                         size_t size)
+{
+   int temp = 0;
+   sscanf(buf,"%d", &temp);
+
+   debug = temp;
+
+   DPRINTF(AALRMS_DBG_MOD, ": Attribute change - debug = %d\n", temp);
+   return size;
+}
+
+// Attribute accessors for debug
+DRIVER_ATTR(debug,S_IRUGO|S_IWUSR|S_IWGRP, ahmpip_attrib_show_debug,ahmpip_attrib_store_debug);
+
+
+
+#endif // __AAL_LINUX__
+
+// Declare standard entry points
+static int
+aalrm_server_init(void);
+static void
+aalrm_server_exit(void);
+
+module_init(aalrm_server_init);
+module_exit(aalrm_server_exit);
+
+
+// Prototypes
+void
+aalrm_server_register_sess(kosal_list_head *psession);
+void
+aalrm_server_unregister_sess(kosal_list_head *psession);
+
+/*
+int
+aalrm_server_initialize_driver(const char             *name,
+                               int                     majornum,
+                               struct aal_driver      *pdriver,
+                               struct aal_classdevice *pclassdev);
+void
+aalrm_server_removedriver(struct aal_driver      *pdriver,
+                          struct aal_classdevice *pclassdev);
+*/
+
+int
+aalrm_server_drv_match(struct aal_driver *drv, struct aal_device *dev);
+
+struct aal_interface *
+aalrm_server_get_interface(struct aal_driver *drv, btID iid);
+int
+aalrm_server_has_interface(struct aal_driver *drv, btID iid);
+int
+aalrm_server_supports_interface(struct aal_driver *drv, btID iid);
+int
+rm_server_init(void);
+int
+rm_server_destroy(void);
+
+//=============================================================================
+// Name: devIID_tbl
+// Description: Lists the IDs of the interfaces this service exports to the
+//              AALBus interface broker
+//=============================================================================
+static btID devIID_tbl[] = {
+   AAL_RMSAPI_IID_01,
+   0
+};
+
+//=============================================================================
+// Name: id_table
+// Description: This driver supports the following devices
+//=============================================================================
+static struct aal_device_id id_table[] = {
+   aal_device_id_terminator // none
+};
+MODULE_DEVICE_TABLE(aal, id_table);
+
+///////////////////////////////////////////////////////////////////////////////
+///////////////////////////////////////////////////////////////////////////////
+////////////////////                                     //////////////////////
+/////////////////      RESOURCE MANAGER SERVER OBJECTS     ////////////////////
+////////////////////                                     //////////////////////
+///////////////////////////////////////////////////////////////////////////////
+///////////////////////////////////////////////////////////////////////////////
+//=============================================================================
+//=============================================================================
+
+
+//=============================================================================
+// Name: rm_server_service
+// Description: RMS service interface declaration. This interface exposes
+//              the services provided to the Resource Manager Client Service.
+//              This interface is registered with the AALBus Service Interface
+//              broker.
+//=============================================================================
+static struct aalrm_server_service rm_server_service = {
+   .request_device      = aalrms_request_device,
+   .registrar_request   = aalrms_registrar_request,
+   .cancel_all_requests = aalrms_cancel_all_requests
+};
+
+// AAL interface used when registering service interfaces with AALBus
+static struct aal_interface rm_server_intfc;
+
+//=============================================================================
+// Name: aalrm_server_class
+// Description Class device. Wrapper object that contains both the Linux
+//             DD Model class information but also AAL specific class
+//             information. The modules "class" defines its unique interface
+//             attributes.
+//=============================================================================
+static struct aal_classdevice rms_class = {
+   .m_classid = {
+      .m_majorversion   = AALRMS_API_MAJVERSION,
+      .m_minorversion   = AALRMS_API_MINVERSION,
+      .m_releaseversion = AALRMS_API_RELEASE,
+      .m_classGUID      = AALRMS_API_INTC,
+   },
+   .m_devIIDlist = devIID_tbl,        // List of supported device module APIs
+};
+
+
+//=============================================================================
+// Name: rms_driver
+// Description: This is the Resource Manager Driver Object singleton. This is
+//              object that gets registered with AALBus.  It is a device driver
+//              in name only. It does not actually control any device HW.
+//              As a device driver module it is allowed to expose a user mode
+//              interface.
+//=============================================================================
+static struct aal_driver rms_driver = {
+
+   // File operations (User Space control interface)
+   // Exposes methods invoked by the user space device driver interface
+   .m_fops = {
+      .owner           = THIS_MODULE,
+      .open            = aalrm_server_open,
+      .release         = aalrm_server_close,
+#if HAVE_UNLOCKED_IOCTL
+      .unlocked_ioctl  = aalrm_server_ioctl,
+#else
+      .ioctl           = aalrm_server_ioctl,  // Deprecated in 2.6.36
+#endif
+      .poll            = aalrm_server_poll,
+   },
+
+   // Return an interface pointer based on the iid. Used to dynamically
+   // bind to a custom interface the driver may export. Typically used to
+   // export the internal control interface used by a user space interface
+   // driver.
+   .get_interface      = aalrm_server_get_interface,
+
+   // Return 1 if interface zupported
+   .has_interface      = aalrm_server_has_interface,
+
+   // Returns 1 if the interface specified in iid can be used. Typically
+   // used to find out if a user space interface driver can "speak" particular
+   // interface.
+   .supports_interface = aalrm_server_supports_interface,
+
+   // List of implemented dynamic interfaces
+   .m_iids             = 0,
+
+   // ID list of supported devices if this is a device driver
+   .m_idtable          = id_table,
+
+   // Called to determine if this driver supports a device
+   //.m_match                = aalrm_server_drv_match,
+   .m_match            = NULL,
+
+   // Called when a device matches
+   .m_probe            = NULL,
+
+   // Base structure
+   .m_driver =  {
+      .owner = THIS_MODULE,
+      .name  = RMS_DEV_NAME,
+   },
+};
+
+//=============================================================================
+// Name: rmserver
+// Description: RMS object instance.
+//=============================================================================
+struct aalrm_server rmserver = {
+   // Public Methods
+   .register_sess   = aalrm_server_register_sess,
+   .unregister_sess = aalrm_server_unregister_sess,
+
+   // Driver and class
+   .m_driver = &rms_driver,
+   .m_class  = &rms_class,
+};
+
+///////////////////////////////////////////////////////////////////////////////
+///////////////////////////////////////////////////////////////////////////////
+////////////////////                                     //////////////////////
+/////////////////         RESOURCE MANAGER METHODS         ////////////////////
+////////////////////                                     //////////////////////
+///////////////////////////////////////////////////////////////////////////////
+///////////////////////////////////////////////////////////////////////////////
+//=============================================================================
+//=============================================================================
+
+
+//=============================================================================
+// Name: aalrm_server_register_sess
+// Description: Registers a session with the RMS
+// Interface: public
+// Inputs: psession - session pointer
+// Outputs: none.
+// Comments:
+//=============================================================================
+void aalrm_server_register_sess(kosal_list_head *psession)
+{
+   if (kosal_sem_get_krnl_alertable(&rmserver.m_sem)) { /* FIXME */ }
+   list_add( psession, &rmserver.m_sessq);
+   kosal_sem_put(&rmserver.m_sem);
+}
+
+//=============================================================================
+// Name: aalrm_server_unregister_sess
+// Description: Unregisters a session with the resource manager
+// Interface: public
+// Inputs: psession - session pointer
+// Outputs: none.
+// Comments:
+//=============================================================================
+void aalrm_server_unregister_sess(kosal_list_head *psession)
+{
+   if (kosal_sem_get_krnl_alertable(&rmserver.m_sem)) { /* FIXME */ }
+   list_del_init(psession);
+   kosal_sem_put(&rmserver.m_sem);
+}
+
+//=============================================================================
+// Name: aalrm_server_init
+// Description: Initialization routine for the module. Registers with the bus
+//              driver
+// Interface: public
+// Inputs: none.
+// Outputs: none.
+// Comments:
+//=============================================================================
+static int
+aalrm_server_init(void)
+{
+   int ret = 0;
+
+   //-------------------
+   // Display the signon
+   //-------------------
+   kosal_printk_level(KERN_INFO, "Accelerator Abstraction Layer\n");
+   kosal_printk_level(KERN_INFO, "-> %s\n", DRV_DESCRIPTION);
+   kosal_printk_level(KERN_INFO, "-> Version %s\n",DRV_VERSION);
+   kosal_printk_level(KERN_INFO, "-> %s\n", DRV_COPYRIGHT);
+
+   //---------------------------------------
+   // Initialize the Resource Manager Server
+   //---------------------------------------
+   ret = rm_server_init();
+   return ret;
+}
+
+//=============================================================================
+// Name: rm_server_init
+// Description: Initialization the resource manager server object
+// Interface: public
+// Inputs: none.
+// Outputs: none.
+// Comments:
+//=============================================================================
+int rm_server_init(void)
+{
+   int ret = 0;
+
+   //---------------------------------------
+   // Initialize the device driver subsystem
+   //  registers the driver with AALBus and
+   //  registers class device, creating user
+   //  mode device node.
+   //---------------------------------------
+
+   ret = aalbus_get_bus()->init_driver((kosal_ownermodule *)THIS_MODULE,
+                                      &rms_driver,
+                                      &rms_class,
+                                      RMS_DEV_NAME,
+                                      majornum);
+
+/*
+   ret = aalrm_server_initialize_driver(RMS_DEV_NAME,
+                                        majornum,
+                                       &rms_driver,
+                                       &rms_class);
+*/
+
+   if ( ret < 0 ) {
+      DPRINTF(AALRMS_DBG_MOD, ": failed to register driver %s\n", RMS_DEV_NAME);
+      return ret;
+   }
+
+
+   if(driver_create_file(&rms_driver.m_driver,&driver_attr_debug)){
+       DPRINTF (AALRMS_DBG_MOD, ": Failed to create debug attribute - Unloading module\n");
+       // Unregister the driver with the bus
+       aalbus_get_bus()->unregister_driver( &rms_driver );
+       return -EIO;
+   }
+
+
+
+   // Initialize structures
+   kosal_list_init(&rmserver.m_sessq);          // Session queue
+   aal_queue_init(&rmserver.m_reqq);           // Request queue m_pendq
+   aal_queue_init(&rmserver.m_pendq);          // Pending queue
+   kosal_mutex_init(&rmserver.m_sem);                // Private semaphore
+   kosal_init_waitqueue_head(&rmserver.m_reqq_wq);   // Wait queue for requests
+
+   //------------------------------------------
+   // Create and register the service interface
+   //  with AALBus Service Interface Broker.
+   //  Allows this service to be discovered and
+   //  linked to at runtime.
+   //------------------------------------------
+
+   // Initialize the aal_interface
+   aal_interface_init(rm_server_intfc,       // aal_interface wrapper
+                      &rm_server_service,    // service interface
+                      AAL_RMSAPI_IID_01);    // service interface ID
+
+   // Register with the service interface with the AAL Bus Service INterface Broker
+   DPRINTF(AALRMS_DBG_MOD, "Registering service interface 0x%Lx\n", (long long)AAL_RMSAPI_IID_01);
+   ret = aalbus_get_bus()->register_service_interface(&rm_server_intfc);
+   if(ret < 0){
+	   DPRINTF(AALRMS_DBG_MOD, "Failed registeer service interface\n");
+      //aalrm_server_removedriver(&rms_driver, &rms_class);
+      aalbus_get_bus()->release_driver(&rms_driver, &rms_class);
+      return ret;
+   }
+   return 0;
+}
+
+//=============================================================================
+// Name: aalrm_server_exit
+// Description: Removes device from filesystem and deregisters
+// Interface: public
+// Inputs: none.
+// Outputs: none.
+// Comments:
+//=============================================================================
+void aalrm_server_exit(void)
+{
+   //TODO FLUSH ALL Messages on Resource manager queues
+
+   // Unregister service interface with AALBus Interface Broker
+   // TODO - This needs to be more sophisticated.  Must notify current interface
+   //        holders that it is going.  Holders must release and then the interface
+   //        can be revoked.  Perhaps the interface should be disabled so that
+   //        using it always fails. The interface must not be allocatable while
+   //        it is being revoked.
+   //aalbus_get_bus()->unregister_service_interface(&rm_server_intfc);
+
+   // Unregister drivers
+   rm_server_destroy();
+
+  DPRINTF(AALRMS_DBG_MOD,  "<- %s removed\n", DRV_DESCRIPTION);
+   return;
+}
+
+//=============================================================================
+// Name: rm_server_destroy
+// Description: Destroys the RMS object
+// Interface: public
+// Inputs: none.
+// Outputs: none.
+// Comments:
+//=============================================================================
+int rm_server_destroy()
+{
+   //TODO HIGH PRIORITY FLUSH ALL Messages on queues
+
+   // Unregister service interface
+   aalbus_get_bus()->unregister_service_interface(&rm_server_intfc);
+
+   aalbus_get_bus()->release_driver(&rms_driver, &rms_class);
+   //aalrm_server_removedriver(&rms_driver, &rms_class);
+   return 0;
+}
+
+
+#if 0
+//=============================================================================
+// Name: aalrm_server_initialize_driver
+// Description: Initialization routine for the  driver. Registers with the bus
+//              driver
+// Interface: private
+// Inputs: name - driver/class name
+//         majornum - major device node number to assign
+//         pdriver - driver to register
+//         pclassdev - class device to register
+// Outputs: none.
+// Comments:
+//=============================================================================
+int
+aalrm_server_initialize_driver(const char             *name,
+                               int                     majornum,
+                               struct aal_driver      *pdriver,
+                               struct aal_classdevice *pclassdev)
+{
+   int ret = 0;
+   dev_t dev;
+
+   // Get a major device number
+   if ( 0 != majornum ) {
+      // major number provided in command line
+      DPRINTF(AALRMS_DBG_MOD, ": Registering static major number %d\n", majornum);
+      dev = MKDEV(majornum, 0);
+
+      ret = register_chrdev_region(dev, 1, name);
+
+      if ( ret < 0 ) {
+         DPRINTF(AALRMS_DBG_MOD, ": Failed to register major device number %d for %s\n",
+                    majornum, name);
+         return ret;
+      }
+   } else {
+      // Dynamically allocate the major number
+      ret = alloc_chrdev_region(&dev, 0, 1, name);
+      pdriver->m_major = MAJOR(dev);
+      DPRINTF(AALRMS_DBG_MOD, ": Allocating dynamic major number %d for %s\n", pdriver->m_major, name);
+   }
+
+
+   if(ret < 0) {
+      DPRINTF(AALRMS_DBG_MOD, ": Failed to assign major device number %d for %s\n", pdriver->m_major, name);
+      return ret;
+   }
+
+   // Register the driver with the bus
+   ret = aalbus_get_bus()->register_driver( pdriver );
+   if( ret < 0 ){
+      DPRINTF(AALRMS_DBG_MOD, ": Failed to register ret = %d\n", ret);
+      unregister_chrdev_region(dev, 1);
+      return ret;
+   }
+
+   // Register the UI character device with the kernel. Uses the cdev structure
+   // embedded in the aal_driver.
+   // This simply hooks our entry points. The device node is created
+   // with the class device below
+   cdev_init(aaldrv_cdevp(pdriver), &pdriver->m_fops);
+   aaldrv_cdevp(pdriver)->owner = THIS_MODULE;
+   aaldrv_cdevp(pdriver)->ops   = &pdriver->m_fops;
+
+   ret = cdev_add(aaldrv_cdevp(pdriver), dev, 1);
+   if ( ret ) {
+      DPRINTF(AALRMS_DBG_MOD, ": Failed to register charcter device - ret = %d\n", ret);
+      rms_drv_to_ibus(pdriver).unregister_driver( pdriver );
+      unregister_chrdev_region(dev, 1);
+      return ret;
+   }
+
+   // Initialize and create the class device.
+   // This is where the actual device node will be
+   // created in user land
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,26)
+   dev_set_name(&pclassdev->m_classdev,name);
+#else
+   strncpy(AALCLASSNAME(pclassdev),name, BUS_ID_SIZE);
+#endif
+
+   aal_classdev_devtype(pclassdev) = dev;
+
+   DPRINTF(AALRMS_DBG_MOD, ": Registering class %s\n", aal_classdev_get_name(pclassdev));
+   ret = aaldrv_aalbus(pdriver).register_class_device(pclassdev);
+   if(ret < 0) {
+      DPRINTF(AALRMS_DBG_MOD, ": Failed to register class\n");
+      rms_drv_to_ibus(pdriver).unregister_driver(pdriver);
+      unregister_chrdev_region(dev, 1);
+      cdev_del(aaldrv_cdevp(pdriver));
+      return ret;
+   }
+
+   return ret;
+}
+#endif
+
+#if 0
+//=============================================================================
+// Name: aalrm_server_removedriver
+// Description: Removes device from filesystem and registration
+// Interface: public
+// Inputs: pdriver - driver to remove,
+//         pclassdev - class device
+// Outputs: none.
+// Comments:
+//=============================================================================
+void aalrm_server_removedriver(struct aal_driver* pdriver,
+                        struct aal_classdevice *pclassdev)
+{
+   dev_t dev;
+   int majornum = pdriver->m_major;
+
+   DPRINTF(AALRMS_DBG_MOD, ": Removing driver\n");
+
+   // Remove the class device
+   rms_drv_to_ibus(pdriver).unregister_class_device(pclassdev);
+
+   // Unregister the character driver
+   cdev_del(aaldrv_cdevp(pdriver));
+
+   // Unregister the driver
+   rms_drv_to_ibus(pdriver).unregister_driver( pdriver );
+
+   dev = MKDEV(majornum, 0);
+   unregister_chrdev_region(dev, 1);
+   return;
+}
+#endif
+
+//=============================================================================
+// Name:  aalrm_server_drv_match
+// Description: Driver specific function for matching a suported device
+// Interface: public
+// Inputs: drv - this driver
+//         dev - device to check
+// Outputs: none.
+// Comments:
+//=============================================================================
+int aalrm_server_drv_match(struct aal_driver* drv, struct aal_device* dev)
+{
+   DPRINTF(AALRMS_DBG_MOD, ": Device not supported by this driver.\n");
+   return 0;
+}
+
+//=============================================================================
+// Name:  aalrm_server_get_interface
+// Description: Returns the requested interface if supported
+// Interface: public
+// Inputs:  drv - base pointer to this driver
+//.         iid - interface ID
+// Outputs: interface pointer.
+// Comments: This driver does not publish any dynamic interfaces
+//=============================================================================
+struct aal_interface  *aalrm_server_get_interface(struct aal_driver* drv,
+                                                  btID iid)
+{
+   return NULL;
+}
+
+
+//=============================================================================
+// Name:  aalrm_server_has_interface
+// Description: Reports if this driver implements a specifc interface
+// Interface: public
+// Inputs:  drv - base pointer to this driver
+//.         iid - interface ID
+// Outputs: 1 - if interface implemented.
+// Comments: This driver does not publish any dynamic interfaces
+//=============================================================================
+int aalrm_server_has_interface(struct aal_driver* drv, btID iid)
+{
+   return 0;
+}
+
+//=============================================================================
+// Name:  aalrm_server_supports_interface
+// Description: Report whether this driver can use a specific interface
+// Interface: public
+// Inputs:  drv - base pointer to this driver
+//.         iid - interface ID
+// Outputs: 1 - if supported.
+// Comments:
+//=============================================================================
+int aalrm_server_supports_interface(struct aal_driver* drv, btID iid)
+{
+   if(iid != AAL_DDAPI_IID_07){  //TODO this needs to be properly defined
+      return 0;
+   }
+   return 1;
+}
diff --git a/drivers/fpga/aal/rms/aalrm_server-services.c b/drivers/fpga/aal/rms/aalrm_server-services.c
new file mode 100644
index 000000000000..e65703af9348
--- /dev/null
+++ b/drivers/fpga/aal/rms/aalrm_server-services.c
@@ -0,0 +1,254 @@
+//******************************************************************************
+// This  file  is  provided  under  a  dual BSD/GPLv2  license.  When using or
+//         redistributing this file, you may do so under either license.
+//
+//                            GPL LICENSE SUMMARY
+//
+//  Copyright(c) 2008-2017, Intel Corporation.
+//
+//  This program  is  free software;  you  can redistribute it  and/or  modify
+//  it  under  the  terms of  version 2 of  the GNU General Public License  as
+//  published by the Free Software Foundation.
+//
+//  This  program  is distributed  in the  hope that it  will  be useful,  but
+//  WITHOUT   ANY   WARRANTY;   without   even  the   implied   warranty    of
+//  MERCHANTABILITY  or  FITNESS  FOR  A  PARTICULAR  PURPOSE.  See  the   GNU
+//  General Public License for more details.
+//
+//  The  full  GNU  General Public License is  included in  this  distribution
+//  in the file called README.GPLV2-LICENSE.TXT.
+//
+//  Contact Information:
+//  Henry Mitchel, henry.mitchel at intel.com
+//  77 Reed Rd., Hudson, MA  01749
+//
+//                                BSD LICENSE
+//
+//  Copyright(c) 2008-2017, Intel Corporation.
+//
+//  Redistribution and  use  in source  and  binary  forms,  with  or  without
+//  modification,  are   permitted  provided  that  the  following  conditions
+//  are met:
+//
+//    * Redistributions  of  source  code  must  retain  the  above  copyright
+//      notice, this list of conditions and the following disclaimer.
+//    * Redistributions in  binary form  must  reproduce  the  above copyright
+//      notice,  this  list of  conditions  and  the  following disclaimer  in
+//      the   documentation   and/or   other   materials   provided  with  the
+//      distribution.
+//    * Neither   the  name   of  Intel  Corporation  nor  the  names  of  its
+//      contributors  may  be  used  to  endorse  or promote  products derived
+//      from this software without specific prior written permission.
+//
+//  THIS  SOFTWARE  IS  PROVIDED  BY  THE  COPYRIGHT HOLDERS  AND CONTRIBUTORS
+//  "AS IS"  AND  ANY  EXPRESS  OR  IMPLIED  WARRANTIES,  INCLUDING,  BUT  NOT
+//  LIMITED  TO, THE  IMPLIED WARRANTIES OF  MERCHANTABILITY  AND FITNESS  FOR
+//  A  PARTICULAR  PURPOSE  ARE  DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT
+//  OWNER OR CONTRIBUTORS BE LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,
+//  SPECIAL,  EXEMPLARY,  OR  CONSEQUENTIAL   DAMAGES  (INCLUDING,   BUT   NOT
+//  LIMITED  TO,  PROCUREMENT  OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF USE,
+//  DATA,  OR PROFITS;  OR BUSINESS INTERRUPTION)  HOWEVER  CAUSED  AND ON ANY
+//  THEORY  OF  LIABILITY,  WHETHER  IN  CONTRACT,  STRICT LIABILITY,  OR TORT
+//  (INCLUDING  NEGLIGENCE  OR OTHERWISE) ARISING  IN ANY WAY  OUT  OF THE USE
+//  OF  THIS  SOFTWARE, EVEN IF ADVISED  OF  THE  POSSIBILITY  OF SUCH DAMAGE.
+//******************************************************************************
+//****************************************************************************
+//        FILE: aalrm_server-services.c
+//     CREATED: 02/29/2008
+//      AUTHOR: Joseph Grecco - Intel
+//
+// PURPOSE:  Implementation of RMS kernel services
+// HISTORY:
+// COMMENTS:
+// WHEN:          WHO:     WHAT:
+// 02-29-08       JG       Initial version created
+// 11/11/2008     JG       Added legal header
+// 01/04/2009     HM       Updated Copyright
+// 01/23/2009     JG       Initial code cleanup
+// 02/09/2009     JG       Added support for RMSS cancel transaction
+// 05/18/2010     HM       Labeled kosal_sem_get_krnl_alertable() with FIXME. Need a
+//                            global fix for these. Getting it to compile.
+//****************************************************************************
+#include "aalsdk/kernel/kosal.h"
+
+#define MODULE_FLAGS AALRMS_DBG_MOD
+
+#include "aalsdk/kernel/aalrm_server.h"
+#include "aalsdk/kernel/aalrm_server-services.h"
+#include "aalrm_server-int.h"
+
+//
+// Protoypes
+void aalrms_queue_req(struct aal_q_item * pqitem);
+struct aal_q_item * aalrms_dequeue_req(void);
+
+
+///////////////////////////////////////////////////////////////////////////////
+///////////////////////////////////////////////////////////////////////////////
+////////////////////                                     //////////////////////
+/////////////////       RESOURCE MANAGER CLIENT EVENTS     ////////////////////
+////////////////////                                     //////////////////////
+///////////////////////////////////////////////////////////////////////////////
+///////////////////////////////////////////////////////////////////////////////
+//=============================================================================
+//=============================================================================
+//-----------------------------------------------------------------------------
+//-----------------------------------------------------------------------------
+// The following methods implement the RMS Service interface. These functions
+// are not called directly but rather through the the virtual RMSS interface
+// that is registered with the AALBus Service Interface Broker
+//-----------------------------------------------------------------------------
+//-----------------------------------------------------------------------------
+
+//=============================================================================
+// Name: aalrms_request_device
+// Description: builds and queues an allocate request
+// Interface: public
+// Inputs: preqdev - pointer to request object
+//         tranID - transaction ID
+// Outputs: none.
+// Comments:
+//=============================================================================
+int aalrms_request_device(struct req_allocdev     *preqdev,
+                          aalrms_reqdev_cmplt_t    completionfcn,
+                          struct aalrms_req_tranID tranID )
+{
+   //----------------------------
+   // Create queue request object
+   //----------------------------
+   struct rms_reqq_reqdev *newreq = rms_reqq_reqdev_create(preqdev,
+                                                           completionfcn,
+                                                           tranID);
+   if ( NULL == newreq ) {
+      return -ENOMEM;
+   }
+
+   // Queue the item
+   aalrms_queue_req(&RMSSQI(newreq));
+   return 0;
+}
+
+//=============================================================================
+// Name: aalrms_registrar_request
+// Description: Created and queues a request for the Registrar
+// Interface: public
+// Inputs: preqdev - pointer to request object
+//         tranID - Transaction ID for the request
+// Outputs: none.
+// Comments:
+//=============================================================================
+int aalrms_registrar_request(struct req_registrar       *preqdev,
+                             aalrms_registrarreq_cmplt_t completionfcn,
+                             struct aalrms_req_tranID    tranID)
+{
+
+   //----------------------------
+   // Create queue request object
+   //----------------------------
+   struct rms_reqq_registrar *newreq = rms_reqq_registrar_create(preqdev,
+                                                                 completionfcn,
+                                                                 tranID);
+   if ( NULL == newreq ) {
+      return -ENOMEM;
+   }
+
+   // Queue the item
+   aalrms_queue_req(&RMSSQI(newreq));
+   return 0;
+}
+
+//=============================================================================
+// Name: cancel_all_requests
+// Description: Cancel all requests that match transaction ID context
+// Inputs: tranID - Transaction ID for the request(s) to cancel
+// Outputs: none.
+// Comments:
+//=============================================================================
+//-----------------------------------------------------------------------------
+int aalrms_process_cancel_request(struct aal_q_item *pqitem,
+                                  aal_queue_t *pqueue,
+                                  void *pcontext)
+{
+   struct rms_reqq_reqdev     *preqdev;   // "Request Device"
+   struct rms_reqq_registrar  *pregreq;   // "Registrar Request"
+
+   struct aalrms_req_tranID *tranID = (struct aalrms_req_tranID *)pcontext;
+
+
+
+   // Get the RMSS queue item from the AAL qitem (downcast)
+   struct rms_reqq_item *rms_qitem = qi_to_rmsqi(pqitem);
+   DPRINTF(AALRMS_DBG_IOCTL, ": TranID context  callback %p %p \n",tranID->m_context,rms_qitem->m_tranid.m_context );
+
+   // Is this a request to cancel?
+   if( tranID->m_context == rms_qitem->m_tranid.m_context ){
+      DPRINTF(AALRMS_DBG_IOCTL, ": Cancelling callback %p %p \n",pqitem,pqueue );
+
+      // Remove it
+      aalrms_queue_remove(pqueue,pqitem);
+
+      //---------------------------------------------
+      // Each message is processed differently
+      //  Call the completion
+      //---------------------------------------------
+      // TODO Would be nice to make this normalized like  AAL user mode
+      switch (pqitem->m_id){
+         case reqid_RS_Registrar:
+         case rspid_RS_Registrar: {
+            DPRINTF(AALRMS_DBG_IOCTL, ": rspid_RS_Registrar\n" );
+            // Get the original request from queue item
+            pregreq = qi_to_regreq(pqitem);
+            CALL_COMPLETION(pregreq)(rms_resultCancelled,
+                                     NULL,
+                                     REGREQ_REGREQP(pregreq),
+                                     RMSSQ_TRANID(pregreq));
+            //Destroy original request message
+            rms_reqq_regreq_destroy(pregreq);
+
+            break;
+         }
+
+         case reqid_URMS_RequestDevice:
+         case rspid_URMS_RequestDevice: {
+            DPRINTF(AALRMS_DBG_IOCTL, ": URMS_RequestDevice\n" );
+            // Get the original request from queue item
+            preqdev = qi_to_reqdev(pqitem);
+
+            // Send the response event back
+            CALL_COMPLETION( preqdev)(rms_resultCancelled,
+                                      NULL,
+                                      REQDEV_ALLOCDEVP(preqdev),
+                                      RMSSQ_TRANID(preqdev));
+            // Done so destroy the request
+            rms_reqq_reqdev_destroy(preqdev);
+         }
+         break;
+         default:
+            DPRINTF(AALRMS_DBG_IOCTL, ": Cancelling unknown type 0x%" PRIx64 "\n", pqitem->m_id);
+            break;
+      } // switch (pqitem->m_id)
+   } // if( tranID->m_context == rms_qitem->m_tranid.m_context )
+
+   return 0;
+}
+
+//=============================================================================
+// Name: cancel_all_requests
+// Description: Cancel all requests that match transaction ID context
+// Inputs: tranID - Transaction ID for the request(s) to cancel
+// Outputs: none.
+// Comments: For each entry in the queue the callback
+//           aalrms_process_cancel_request is called.
+//=============================================================================
+void aalrms_cancel_all_requests(  struct aalrms_req_tranID *tranID  )
+{
+
+   if (kosal_sem_get_krnl_alertable(&rmserver.m_sem)) { /* FIXME */ }
+   DPRINTF(AALRMS_DBG_IOCTL, ": Cancelling all\n");
+
+   aalrms_queue_doForAllQueuedItems( aalrms_process_cancel_request,
+                                     tranID);
+
+   kosal_sem_put(&rmserver.m_sem);
+}
+
diff --git a/drivers/fpga/aal/rms/aalrms-events-int.h b/drivers/fpga/aal/rms/aalrms-events-int.h
new file mode 100644
index 000000000000..533ab24c4730
--- /dev/null
+++ b/drivers/fpga/aal/rms/aalrms-events-int.h
@@ -0,0 +1,136 @@
+//******************************************************************************
+// This  file  is  provided  under  a  dual BSD/GPLv2  license.  When using or
+//         redistributing this file, you may do so under either license.
+//
+//                            GPL LICENSE SUMMARY
+//
+//  Copyright(c) 2009-2017, Intel Corporation.
+//
+//  This program  is  free software;  you  can redistribute it  and/or  modify
+//  it  under  the  terms of  version 2 of  the GNU General Public License  as
+//  published by the Free Software Foundation.
+//
+//  This  program  is distributed  in the  hope that it  will  be useful,  but
+//  WITHOUT   ANY   WARRANTY;   without   even  the   implied   warranty    of
+//  MERCHANTABILITY  or  FITNESS  FOR  A  PARTICULAR  PURPOSE.  See  the   GNU
+//  General Public License for more details.
+//
+//  The  full  GNU  General Public License is  included in  this  distribution
+//  in the file called README.GPLV2-LICENSE.TXT.
+//
+//  Contact Information:
+//  Henry Mitchel, henry.mitchel at intel.com
+//  77 Reed Rd., Hudson, MA  01749
+//
+//                                BSD LICENSE
+//
+//  Copyright(c) 2009-2017, Intel Corporation.
+//
+//  Redistribution and  use  in source  and  binary  forms,  with  or  without
+//  modification,  are   permitted  provided  that  the  following  conditions
+//  are met:
+//
+//    * Redistributions  of  source  code  must  retain  the  above  copyright
+//      notice, this list of conditions and the following disclaimer.
+//    * Redistributions in  binary form  must  reproduce  the  above copyright
+//      notice,  this  list of  conditions  and  the  following disclaimer  in
+//      the   documentation   and/or   other   materials   provided  with  the
+//      distribution.
+//    * Neither   the  name   of  Intel  Corporation  nor  the  names  of  its
+//      contributors  may  be  used  to  endorse  or promote  products derived
+//      from this software without specific prior written permission.
+//
+//  THIS  SOFTWARE  IS  PROVIDED  BY  THE  COPYRIGHT HOLDERS  AND CONTRIBUTORS
+//  "AS IS"  AND  ANY  EXPRESS  OR  IMPLIED  WARRANTIES,  INCLUDING,  BUT  NOT
+//  LIMITED  TO, THE  IMPLIED WARRANTIES OF  MERCHANTABILITY  AND FITNESS  FOR
+//  A  PARTICULAR  PURPOSE  ARE  DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT
+//  OWNER OR CONTRIBUTORS BE LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,
+//  SPECIAL,  EXEMPLARY,  OR  CONSEQUENTIAL   DAMAGES  (INCLUDING,   BUT   NOT
+//  LIMITED  TO,  PROCUREMENT  OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF USE,
+//  DATA,  OR PROFITS;  OR BUSINESS INTERRUPTION)  HOWEVER  CAUSED  AND ON ANY
+//  THEORY  OF  LIABILITY,  WHETHER  IN  CONTRACT,  STRICT LIABILITY,  OR TORT
+//  (INCLUDING  NEGLIGENCE  OR OTHERWISE) ARISING  IN ANY WAY  OUT  OF THE USE
+//  OF  THIS  SOFTWARE, EVEN IF ADVISED  OF  THE  POSSIBILITY  OF SUCH DAMAGE.
+//******************************************************************************
+//****************************************************************************
+//        FILE: aalrms-events-int.h
+//     CREATED: 03/04/2009
+//      AUTHOR: Joseph Grecco - Intel
+//
+// PURPOSE: This file contains internal event definitions for the
+//          AAL Resource Manager Server Service Module.
+// HISTORY:
+// COMMENTS:
+// WHEN:          WHO:     WHAT:
+// 03/04/09       JG       Initial version created
+//****************************************************************************
+#ifndef __AALKERNEL_AALRESOURCEMGR_SERVER_AALRMS_EVENTS_INT_H__
+#define __AALKERNEL_AALRESOURCEMGR_SERVER_AALRMS_EVENTS_INT_H__
+#include "aalsdk/kernel/aalbus.h"
+
+
+///////////////////////////////////////////////////////////////////////////////
+///////////////////////////////////////////////////////////////////////////////
+////////////////////                                     //////////////////////
+/////////////////      RESOURCE MANAGER SERVICE EVENTS     ////////////////////
+////////////////////                                     //////////////////////
+///////////////////////////////////////////////////////////////////////////////
+///////////////////////////////////////////////////////////////////////////////
+//=============================================================================
+//=============================================================================
+
+//=============================================================================
+// Name: devreq_cmplt
+// Description: Device Request Complete
+//=============================================================================
+struct rms_event_devreq_cmplt {
+#define qi_to_devreq_cmplt(pqi) (container_of( pqi, struct rms_event_devreq_cmplt, m_qitem ) )
+   //-------------------------------------------
+   // Including the macro effectively causes
+   // this object to be derived from aal_q_item
+   //-------------------------------------------
+   _DECLARE_AALQ_TYPE;
+   rms_result_e             result_code;  // Result code [IN/OUT]
+   stTransactionID_t        tranID;       // transaction ID to identify result [IN]
+   void                    *context;      // optional token [IN]
+};
+
+//=============================================================================
+// Name: rms_event_devreq_cmplt_create
+// Description: Constructor
+//=============================================================================
+static inline struct rms_event_devreq_cmplt *
+               rms_event_devreq_cmplt_create( rms_result_e           result_code,
+                                              stTransactionID_t      tranID,
+                                              void                  *context)
+{
+   struct rms_event_devreq_cmplt * This =
+                        ( struct rms_event_devreq_cmplt * )kosal_kmalloc(sizeof(struct rms_event_devreq_cmplt));
+   if(This == NULL){
+      return NULL;
+   }
+
+   This->result_code = result_code;
+   This->tranID = tranID;
+   This->context = context;
+
+   AALQ_QID(This) = rspid_RM_DeviceRequest;
+   AALQ_QLEN(This) = 0; // No payload
+
+   // Initialize the queue item
+   kosal_list_init(&AALQ_QUEUE(This));
+   return This;
+}
+
+
+//=============================================================================
+// Name: rms_event_devreq_cmplt_destroy
+// Description: Destructor
+//=============================================================================
+static inline void rms_event_devreq_cmplt_destroy(struct rms_event_devreq_cmplt *This)
+{
+   kosal_kfree(This, sizeof(struct rms_event_devreq_cmplt));
+}
+
+
+#endif // __AALKERNEL_AALRESOURCEMGR_SERVER_AALRMS_EVENTS_INT_H__
diff --git a/drivers/fpga/aal/rms/kOSAL.c b/drivers/fpga/aal/rms/kOSAL.c
new file mode 100644
index 000000000000..6335f93fba8a
--- /dev/null
+++ b/drivers/fpga/aal/rms/kOSAL.c
@@ -0,0 +1,692 @@
+//******************************************************************************
+// This  file  is  provided  under  a  dual BSD/GPLv2  license.  When using or
+//         redistributing this file, you may do so under either license.
+//
+//                            GPL LICENSE SUMMARY
+//
+//  Copyright(c) 2012-2017, Intel Corporation.
+//
+//  This program  is  free software;  you  can redistribute it  and/or  modify
+//  it  under  the  terms of  version 2 of  the GNU General Public License  as
+//  published by the Free Software Foundation.
+//
+//  This  program  is distributed  in the  hope that it  will  be useful,  but
+//  WITHOUT   ANY   WARRANTY;   without   even  the   implied   warranty    of
+//  MERCHANTABILITY  or  FITNESS  FOR  A  PARTICULAR  PURPOSE.  See  the   GNU
+//  General Public License for more details.
+//
+//  The  full  GNU  General Public License is  included in  this  distribution
+//  in the file called README.GPLV2-LICENSE.TXT.
+//
+//  Contact Information:
+//  Henry Mitchel, henry.mitchel at intel.com
+//  77 Reed Rd., Hudson, MA  01749
+//
+//                                BSD LICENSE
+//
+//  Copyright(c) 2012-2017, Intel Corporation.
+//
+//  Redistribution and  use  in source  and  binary  forms,  with  or  without
+//  modification,  are   permitted  provided  that  the  following  conditions
+//  are met:
+//
+//    * Redistributions  of  source  code  must  retain  the  above  copyright
+//      notice, this list of conditions and the following disclaimer.
+//    * Redistributions in  binary form  must  reproduce  the  above copyright
+//      notice,  this  list of  conditions  and  the  following disclaimer  in
+//      the   documentation   and/or   other   materials   provided  with  the
+//      distribution.
+//    * Neither   the  name   of  Intel  Corporation  nor  the  names  of  its
+//      contributors  may  be  used  to  endorse  or promote  products derived
+//      from this software without specific prior written permission.
+//
+//  THIS  SOFTWARE  IS  PROVIDED  BY  THE  COPYRIGHT HOLDERS  AND CONTRIBUTORS
+//  "AS IS"  AND  ANY  EXPRESS  OR  IMPLIED  WARRANTIES,  INCLUDING,  BUT  NOT
+//  LIMITED  TO, THE  IMPLIED WARRANTIES OF  MERCHANTABILITY  AND FITNESS  FOR
+//  A  PARTICULAR  PURPOSE  ARE  DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT
+//  OWNER OR CONTRIBUTORS BE LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,
+//  SPECIAL,  EXEMPLARY,  OR  CONSEQUENTIAL   DAMAGES  (INCLUDING,   BUT   NOT
+//  LIMITED  TO,  PROCUREMENT  OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF USE,
+//  DATA,  OR PROFITS;  OR BUSINESS INTERRUPTION)  HOWEVER  CAUSED  AND ON ANY
+//  THEORY  OF  LIABILITY,  WHETHER  IN  CONTRACT,  STRICT LIABILITY,  OR TORT
+//  (INCLUDING  NEGLIGENCE  OR OTHERWISE) ARISING  IN ANY WAY  OUT  OF THE USE
+//  OF  THIS  SOFTWARE, EVEN IF ADVISED  OF  THE  POSSIBILITY  OF SUCH DAMAGE.
+//******************************************************************************
+//****************************************************************************
+/// @file kOSAL.c
+/// @brief Implementation of the Kernel abstraction functions.
+/// @ingroup kOSAL
+/// @verbatim
+/// Accelerator Abstraction Layer
+///
+/// AUTHORS:  Joseph Grecco, Intel Corporation
+///           Tim Whisonant, Intel Corporation
+///
+/// HISTORY:
+/// WHEN:          WHO:     WHAT:
+/// 12/27/2012     JG       Initial version
+//****************************************************************************
+#include "aalsdk/kernel/kosal.h"
+#define MODULE_FLAGS KOSAL_DBG_MOD
+
+#if defined( __AAL_LINUX__ )
+#include <linux/vmalloc.h>
+# include <linux/delay.h>
+#include <linux/dma-mapping.h>
+#include <linux/rtc.h>
+#endif // __AAL_LINUX__
+
+#if defined( __AAL_UNKNOWN_OS__ )
+# error Implement kOSAL for unknown OS.
+#endif // __AAL_UNKNOWN_OS__
+
+//=============================================================================
+/// kosal_pci_read_config_dword
+/// @brief     Read a dword from PCIe device Config space
+/// @param[in] dev - PCI device handle
+///            offset - offset into Config space starting from beginning of 
+//                      header.
+//             
+/// @return    0 failed
+///
+/// @note   Windows intrinsic numbers bits 0 to 63, ffsll numbers
+///         them 1 to 64. Using ffsll variation.
+/// @note   Windows intrinsic must be set outside function
+//
+//=============================================================================
+btInt _kosal_pci_read_config_dword(__ASSERT_HERE_PROTO
+                                   pkosal_pci_dev      pdev,
+                                   btUnsigned32bitInt  offset,
+                                   btUnsigned32bitInt *pval)
+{
+   btInt res;
+#if   defined( __AAL_WINDOWS__ )
+   ULONG bytesRead = 0;
+#endif // __AAL_WINDOWS__
+
+   __ASSERT_HERE_IN_FN(NULL != pdev);
+   __ASSERT_HERE_IN_FN(NULL != pval);
+   if((NULL ==  pdev) || (NULL == pval)) {
+      res = -EINVAL;
+      return res ;
+   }
+
+#if   defined( __AAL_LINUX__ )
+
+   res = ( pci_read_config_dword(pdev, offset, pval) ? 0 : 1 );
+
+#elif defined( __AAL_WINDOWS__ )
+
+   bytesRead = pdev->GetBusData(pdev->Context,             // Context of bus interface
+                                PCI_WHICHSPACE_CONFIG,     // Config space
+                                pval,                      // Where to return it
+                                offset,                    // From the beginning
+                                sizeof(btUnsigned32bitInt));
+
+   res = ( sizeof(btUnsigned32bitInt) == bytesRead ? 1 : 0 );
+
+#endif // OS
+
+   PPCI_HERE("kosal_pci_read_config_dword(pdev=0x%" PRIxUINTPTR_T ", offset=%u [0x%x], pval=0x%" PRIxUINTPTR_T ") : *pval=0x%x [%u]\n",
+                __UINTPTR_T_CAST(pdev),
+                offset, offset,
+                __UINTPTR_T_CAST(pval),
+                *pval, *pval);
+
+   return res;
+}
+
+//=============================================================================
+/// kosal_virt_to_phys
+/// @brief     Convert a kernel virtual address to physical
+/// @param[in] vaddr - kernel virtual
+/// @return    physica address or NULLif  failed
+//=============================================================================
+btPhysAddr
+kosal_virt_to_phys(btAny vaddr)
+{
+#if   defined( __AAL_LINUX__ )
+
+   return (btPhysAddr)virt_to_phys(vaddr);
+
+#elif defined( __AAL_WINDOWS__ )
+
+   PHYSICAL_ADDRESS physaddr = { 0 };
+     
+   physaddr = MmGetPhysicalAddress(vaddr);
+
+   return (btPhysAddr)physaddr.QuadPart;
+
+#endif // OS
+}
+
+//=============================================================================
+/// kosal_mdelay
+/// @brief     Delay in milliseconds
+/// @param[in] time in millisecs
+/// @return    1 if success
+/// @note      This function may only be called when IRQL <= APC_LEVEL
+//=============================================================================
+btInt _kosal_mdelay(__ASSERT_HERE_PROTO btTime delay)
+{
+   btInt res;
+#if   defined( __AAL_WINDOWS__ )
+   NTSTATUS      status;
+   LARGE_INTEGER rel_timout_in_100ns;
+# if ENABLE_ASSERT
+   UNREFERENCED_PARAMETER(__file);
+   UNREFERENCED_PARAMETER(__line);
+   UNREFERENCED_PARAMETER(__fn);
+# endif // ENABLE_ASSERT
+#endif // __AAL_WINDOWS__
+
+   PPOLLING_HERE("kosal_mdelay(delay=%llu [0x%llx]) sleeping\n", delay, delay);
+
+#if   defined( __AAL_LINUX__ )
+
+   mdelay(delay);
+   res = 1;
+
+#elif defined( __AAL_WINDOWS__ )
+
+   // Relative time is specified as a negative value.
+   // Timeout is specified in 100 ns.
+   rel_timout_in_100ns.QuadPart = -((LONGLONG)delay * 10000);
+
+   status = KeDelayExecutionThread(KernelMode, FALSE, &rel_timout_in_100ns);
+
+   res = ( NT_SUCCESS(status) ? 1 : 0 );
+
+#endif // OS
+
+   PPOLLING_HERE("kosal_mdelay(delay=%llu [0x%llx]) waking\n", delay, delay);
+   return res;
+}
+
+//=============================================================================
+/// kosal_udelay
+/// @brief     Delay in microseconds
+/// @param[in] time in micro seconds
+/// @return    1 if success
+/// @note      This function may only be called when IRQL <= APC_LEVEL
+//=============================================================================
+btInt _kosal_udelay(__ASSERT_HERE_PROTO btTime delay)
+{
+   btInt res;
+#if   defined( __AAL_WINDOWS__ )
+   NTSTATUS      status;
+   LARGE_INTEGER rel_timout_in_100ns;
+# if ENABLE_ASSERT
+   UNREFERENCED_PARAMETER(__file);
+   UNREFERENCED_PARAMETER(__line);
+   UNREFERENCED_PARAMETER(__fn);
+# endif // ENABLE_ASSERT
+#endif // __AAL_WINDOWS__
+
+   PPOLLING_HERE("kosal_udelay(delay=%llu [0x%llx]) sleeping\n", delay, delay);
+
+#if   defined( __AAL_LINUX__ )
+
+   udelay(delay);
+   res = 1;
+
+#elif defined( __AAL_WINDOWS__ )
+   
+   // Relative time is specified as a negative value.
+   // Timeout is specified in 100 ns.
+   rel_timout_in_100ns.QuadPart = -((LONGLONG)delay * 10);
+
+   status = KeDelayExecutionThread(KernelMode, FALSE, &rel_timout_in_100ns);
+   res = ( NT_SUCCESS(status) ? 1 : 0 );
+
+#endif // OS
+
+   PPOLLING_HERE("kosal_udelay(delay=%llu [0x%llx]) waking\n", delay, delay);
+   return res;
+}
+
+btVirtAddr _kosal_kmalloc(__ASSERT_HERE_PROTO btWSSize size_in_bytes)
+{
+   btVirtAddr krnl_virt = NULL;
+
+   __ASSERT_HERE_IN_FN(size_in_bytes > 0);
+
+#if   defined( __AAL_LINUX__ )
+# ifdef __i386__
+   krnl_virt = __get_free_pages(GFP_KERNEL, get_order(kosal_round_up_to_page_size(size_in_bytes)));
+# else
+   krnl_virt = kmalloc((size_t)size_in_bytes, GFP_KERNEL);
+# endif // __i386__
+#elif defined( __AAL_WINDOWS__ )
+
+   krnl_virt = (btVirtAddr)MmAllocateNonCachedMemory((SIZE_T)size_in_bytes);
+
+#endif // OS
+
+   __ASSERT_HERE_IN_FN(NULL != krnl_virt);
+
+   PMEMORY_HERE("kosal_kmalloc(size=%llu [0x%llx]) = 0x%" PRIxUINTPTR_T " [phys=0x%" PRIxPHYS_ADDR "]\n",
+                   size_in_bytes, size_in_bytes,
+                   __UINTPTR_T_CAST(krnl_virt),
+                   kosal_virt_to_phys(krnl_virt));
+
+   return krnl_virt;
+}
+
+btVirtAddr _kosal_kzmalloc(__ASSERT_HERE_PROTO btWSSize size_in_bytes)
+{
+   btVirtAddr krnl_virt = NULL;
+
+   __ASSERT_HERE_IN_FN(size_in_bytes > 0);
+
+#if   defined( __AAL_LINUX__ )
+# ifdef __i386__
+   krnl_virt = __get_free_pages(GFP_KERNEL, get_order(kosal_round_up_to_page_size(size_in_bytes)));
+   if(krnl_virt){
+      memset(krnl_virt, 0 , (size_t)size_in_bytes);
+   }
+# else
+   krnl_virt = kmalloc((size_t)size_in_bytes, GFP_KERNEL);
+   if(krnl_virt){
+      memset(krnl_virt, 0 , (size_t)size_in_bytes);
+   }
+# endif // __i386__
+#elif defined( __AAL_WINDOWS__ )
+
+   krnl_virt = (btVirtAddr)MmAllocateNonCachedMemory((SIZE_T)size_in_bytes);
+   if(krnl_virt){
+      RtlZeroMemory(krnl_virt, (SIZE_T)size_in_bytes);
+   }
+#endif // OS
+
+   __ASSERT_HERE_IN_FN(NULL != krnl_virt);
+
+   PMEMORY_HERE("kosal_kzmalloc(size=%llu [0x%llx]) = 0x%" PRIxUINTPTR_T " [phys=0x%" PRIxPHYS_ADDR "]\n",
+                   size_in_bytes, size_in_bytes,
+                   __UINTPTR_T_CAST(krnl_virt),
+                   kosal_virt_to_phys(krnl_virt));
+
+   return krnl_virt;
+}
+
+void _kosal_kfree(__ASSERT_HERE_PROTO btAny krnl_virt, btWSSize size_in_bytes)
+{
+   __ASSERT_HERE_IN_FN(NULL != krnl_virt);
+   __ASSERT_HERE_IN_FN(size_in_bytes > 0);
+
+   PMEMORY_HERE("kosal_kfree(0x%" PRIxUINTPTR_T " [phys=0x%" PRIxPHYS_ADDR "], size=%llu [0x%llx])\n",
+                   __UINTPTR_T_CAST(krnl_virt),
+                   kosal_virt_to_phys(krnl_virt),
+                   size_in_bytes, size_in_bytes);
+
+   if ( NULL != krnl_virt ) {
+
+#if   defined( __AAL_LINUX__ )
+# ifdef __i386__
+      free_pages(krnl_virt, get_order(kosal_round_up_to_page_size(size_in_bytes)));
+# else
+      UNREFERENCED_PARAMETER(size_in_bytes);
+      kfree(krnl_virt);
+# endif // __i386__
+#elif defined( __AAL_WINDOWS__ )
+
+      MmFreeNonCachedMemory(krnl_virt, (SIZE_T)size_in_bytes);
+
+#endif // OS
+
+   }
+
+}
+
+//=============================================================================
+/// kosal_alloc_contiguous_mem_nocache
+/// @brief     Allocate a buffer of contiguous physical pages
+/// @param[in] size in bytes
+/// @return    pointer to memory. NULL if failure.
+/// @note      
+//=============================================================================
+btVirtAddr _kosal_alloc_contiguous_mem_nocache(__ASSERT_HERE_PROTO btWSSize size_in_bytes)
+{
+#if   defined( __AAL_LINUX__ )
+   btVirtAddr pg;
+   btVirtAddr buffer_end;
+#elif defined( __AAL_WINDOWS__ )
+   PHYSICAL_ADDRESS minaddr = { 0ULL };
+   PHYSICAL_ADDRESS maxaddr = { 0xFFFFFFFFFFFFFFFFULL };
+   PHYSICAL_ADDRESS alignment;
+   maxaddr.LowPart= 0xffffffff;
+   maxaddr.HighPart= 0xffffffff;
+#endif // __AAL_WINDOWS__
+
+   btVirtAddr krnl_virt = NULL;
+
+   __ASSERT_HERE_IN_FN(size_in_bytes > 0);
+   
+
+
+#if   defined( __AAL_LINUX__ )
+
+   krnl_virt = (btVirtAddr)__get_free_pages(GFP_KERNEL, get_order(size_in_bytes));
+   __ASSERT_HERE_IN_FN(NULL != krnl_virt);
+   if ( NULL == krnl_virt ) {
+      return NULL;
+   }
+   
+   // Set each page as reserved so that the swapper will not page them out.
+   buffer_end = krnl_virt + size_in_bytes;
+   for ( pg = krnl_virt ; pg < buffer_end ; pg += PAGE_SIZE ) {
+      SetPageReserved( virt_to_page((unsigned long)pg) );
+   }
+
+#elif defined( __AAL_WINDOWS__ )
+   // MmAllocateContiguousMemorySpecifyCache allocates a block of nonpaged memory that is contiguous
+   //  in physical address space. The routine maps this block to a contiguous block of virtual memory
+   //  in the system address space and returns the virtual address of the base of this block.
+   //  The routine aligns the starting address of a contiguous memory allocation to a memory page boundary.
+   
+   alignment.QuadPart = kosal_round_up_to_page_size(size_in_bytes);
+   krnl_virt = (btVirtAddr)MmAllocateContiguousMemorySpecifyCache((SIZE_T)size_in_bytes,
+                                                                  minaddr,
+                                                                  maxaddr,
+                                                                  alignment,
+                                                                  MmNonCached);
+   __ASSERT_HERE_IN_FN(NULL != krnl_virt);
+   if ( NULL == krnl_virt ) {
+      return NULL;
+   }
+
+#endif // OS
+
+   // Recommended security practice..
+   memset(krnl_virt, 0, (size_t)size_in_bytes);
+
+   PMEMORY_HERE("kosal_alloc_contiguous_mem_nocache(size=%llu [0x%llx]) = 0x%" PRIxUINTPTR_T " [phys=0x%" PRIxPHYS_ADDR "]\n",
+                   size_in_bytes, size_in_bytes,
+                   __UINTPTR_T_CAST(krnl_virt),
+                   kosal_virt_to_phys(krnl_virt));
+
+   return krnl_virt;
+}
+
+//=============================================================================
+/// kosal_free_contiguous_mem
+/// @brief     Free buffer of contiguous physical pages allocated through
+///            kosal_alloc_contiguous_mem_nocache
+/// @param[in] size in bytes
+/// @return    pointer to memory. NULL if failure.
+/// @note      
+//=============================================================================
+void _kosal_free_contiguous_mem(__ASSERT_HERE_PROTO btAny krnl_virt, btWSSize size_in_bytes)
+{
+#if   defined( __AAL_WINDOWS__ )
+   UNREFERENCED_PARAMETER(size_in_bytes);
+#endif // __AAL_WINDOWS__
+
+   __ASSERT_HERE_IN_FN(NULL != krnl_virt);
+   __ASSERT_HERE_IN_FN(size_in_bytes > 0);
+
+   PMEMORY_HERE("kosal_free_contiguous_mem(ptr=0x%" PRIxUINTPTR_T " [phys=0x%" PRIxPHYS_ADDR "], bytes=%llu [0x%llx])\n",
+                   __UINTPTR_T_CAST(krnl_virt),
+                   kosal_virt_to_phys(krnl_virt),
+                   size_in_bytes, size_in_bytes);
+
+   // Recommended security practice..
+   if ( NULL != krnl_virt ) {
+      memset(krnl_virt, 0, (size_t)size_in_bytes);
+   }
+
+#if   defined( __AAL_LINUX__ )
+
+   if ( NULL != krnl_virt ) {
+      // Clear the reserved bit.
+      btVirtAddr pg;
+      btVirtAddr buffer_end = krnl_virt + size_in_bytes;
+
+      for ( pg = krnl_virt ; pg < buffer_end ; pg += PAGE_SIZE ) {
+         ClearPageReserved( virt_to_page((unsigned long)pg) );
+      }
+
+      free_pages((unsigned long)krnl_virt, get_order(size_in_bytes));
+   }
+
+#elif defined( __AAL_WINDOWS__ )
+
+   if ( NULL != krnl_virt ) {
+      MmFreeContiguousMemory(krnl_virt);
+   }
+
+#endif // OS
+}
+
+//=============================================================================
+/// _kosal_alloc_dma_coherent
+/// @brief     Allocate a buffer of DMA-able coherent contiguous memory
+/// @param[in] devhandle OS specific
+///            size in bytes
+///            pdma_handle Address to return DMA address for device
+/// @return    pointer to memory. NULL if failure.
+/// @note
+//=============================================================================
+btVirtAddr _kosal_alloc_dma_coherent( __ASSERT_HERE_PROTO btHANDLE devhandle,
+                                       btWSSize size_in_bytes,
+                                      btHANDLE *pdma_handle)
+{
+#if defined( __AAL_WINDOWS__ )
+   PHYSICAL_ADDRESS minaddr = { 0ULL };
+   PHYSICAL_ADDRESS maxaddr = { 0xFFFFFFFFFFFFFFFFULL };
+   PHYSICAL_ADDRESS alignment;
+   maxaddr.LowPart= 0xffffffff;
+   maxaddr.HighPart= 0xffffffff;
+#endif // __AAL_WINDOWS__
+
+   btVirtAddr krnl_virt = NULL;
+
+   __ASSERT_HERE_IN_FN(size_in_bytes > 0);
+
+
+
+#if   defined( __AAL_LINUX__ )
+
+   krnl_virt = (btVirtAddr)dma_alloc_coherent(&((struct pci_dev*)devhandle)->dev, size_in_bytes, (dma_addr_t*)pdma_handle, GFP_KERNEL);
+   __ASSERT_HERE_IN_FN(NULL != krnl_virt);
+   if ( NULL == krnl_virt ) {
+      return NULL;
+   }
+
+
+#elif defined( __AAL_WINDOWS__ )
+   // MmAllocateContiguousMemorySpecifyCache allocates a block of nonpaged memory that is contiguous
+   //  in physical address space. The routine maps this block to a contiguous block of virtual memory
+   //  in the system address space and returns the virtual address of the base of this block.
+   //  The routine aligns the starting address of a contiguous memory allocation to a memory page boundary.
+
+   alignment.QuadPart = kosal_round_up_to_page_size(size_in_bytes);
+   krnl_virt = (btVirtAddr)MmAllocateContiguousMemorySpecifyCache((SIZE_T)size_in_bytes,
+                                                                  minaddr,
+                                                                  maxaddr,
+                                                                  alignment,
+                                                                  MmNonCached);
+   __ASSERT_HERE_IN_FN(NULL != krnl_virt);
+   if ( NULL == krnl_virt ) {
+      return NULL;
+   }
+
+#endif // OS
+
+   // Recommended security practice..
+   memset(krnl_virt, 0, (size_t)size_in_bytes);
+
+   PMEMORY_HERE("_kosal_alloc_dma_coherent(size=%llu [0x%llx]) = 0x%" PRIxUINTPTR_T " [phys=0x%" PRIxPHYS_ADDR "]\n",
+                   size_in_bytes, size_in_bytes,
+                   __UINTPTR_T_CAST(krnl_virt),
+                 (long unsigned int)*pdma_handle);
+
+   return krnl_virt;
+}
+
+//=============================================================================
+/// kosal_free_contiguous_mem
+/// @brief     Free buffer of contiguous physical pages allocated through
+///            kosal_alloc_contiguous_mem_nocache
+/// @param[in] size in bytes
+/// @return    pointer to memory. NULL if failure.
+/// @note
+//=============================================================================
+void _kosal_free_dma_coherent( __ASSERT_HERE_PROTO btHANDLE devhandle,
+                               btVirtAddr krnl_virt,
+                               btWSSize size_in_bytes,
+                               btHANDLE dma_handle)
+{
+#if   defined( __AAL_WINDOWS__ )
+   UNREFERENCED_PARAMETER(size_in_bytes);
+#endif // __AAL_WINDOWS__
+
+   __ASSERT_HERE_IN_FN(NULL != krnl_virt);
+   __ASSERT_HERE_IN_FN(size_in_bytes > 0);
+
+   PMEMORY_HERE("_kosal_free_dma_coherent(ptr=0x%" PRIxUINTPTR_T " [phys=0x%" PRIxPHYS_ADDR "], bytes=%llu [0x%llx])\n",
+                   __UINTPTR_T_CAST(krnl_virt),
+                   kosal_virt_to_phys(krnl_virt),
+                   size_in_bytes, size_in_bytes);
+
+   // Recommended security practice..
+   if ( NULL != krnl_virt ) {
+      memset(krnl_virt, 0, (size_t)size_in_bytes);
+   }
+
+#if   defined( __AAL_LINUX__ )
+
+
+      dma_free_coherent(&((struct pci_dev*)devhandle)->dev, size_in_bytes, krnl_virt, (dma_addr_t)dma_handle);
+
+#elif defined( __AAL_WINDOWS__ )
+
+   if ( NULL != krnl_virt ) {
+      MmFreeContiguousMemory(krnl_virt);
+   }
+
+#endif // OS
+}
+
+#if   defined( __AAL_LINUX__ )
+
+void task_poller(struct work_struct *work)
+{
+   struct delayed_work *delayedWork = container_of(work, struct delayed_work, work);
+   struct kosal_work_object *pwork  = container_of(delayedWork, struct kosal_work_object, workobj);
+
+   pwork->fnct(pwork->context);
+
+}
+void kosal_queue_delayed_work(kosal_work_queue wq, struct kosal_work_object *pwo, KOSAL_TIME msec) {
+
+   queue_delayed_work(wq,&(pwo->workobj),msecs_to_jiffies(msec));
+}
+
+
+#elif defined( __AAL_WINDOWS__ )
+
+void WorkItemCallback(IN PDEVICE_OBJECT pdevObject, IN PVOID Context) {
+   struct kosal_work_object *pwork = ( struct kosal_work_object * )Context;
+   UNREFERENCED_PARAMETER(pdevObject);
+   kosal_mdelay(pwork->msec_delay);
+   pwork->fnct(pwork->context);
+   return;
+}
+
+void kosal_queue_delayed_work(kosal_work_queue wq, struct kosal_work_object *pwo, btTime msec)
+{
+   pwo->msec_delay = msec;
+   IoQueueWorkItem(wq, WorkItemCallback, DelayedWorkQueue, pwo);
+}
+
+void kosal_wake_up_interruptible(kosal_poll_object *pwaitq)
+{
+   NTSTATUS Status;
+   if ( NULL != *pwaitq ) {
+      // Check to see if the IRP was canceled already   
+      Status = WdfRequestUnmarkCancelable(*pwaitq);
+      if ( Status != STATUS_CANCELLED ) {
+         // Complete normally
+         WdfRequestComplete(*pwaitq, STATUS_SUCCESS);
+      }
+   }
+   kosal_poll_object_consume(pwaitq);
+}
+
+#endif // __AAL_WINDOWS__
+
+btVirtAddr _kosal_get_user_buffer( __ASSERT_HERE_PROTO btVirtAddr user_prt, btWSSize size_in_bytes)
+{
+
+
+#if   defined( __AAL_LINUX__ )
+   unsigned long ret;
+   btVirtAddr pkbuffer = vmalloc(size_in_bytes);
+   if(NULL== pkbuffer){
+      return NULL;
+   }
+
+   memset(pkbuffer,0,size_in_bytes);
+   ret = copy_from_user(pkbuffer, user_prt, size_in_bytes);
+   if(ret != 0){
+      vfree(pkbuffer);
+      return NULL;
+   }
+   return pkbuffer;
+#elif defined( __AAL_WINDOWS__ )  //TODO
+   UNREFERENCED_PARAMETER(user_prt);
+   UNREFERENCED_PARAMETER(size_in_bytes);
+
+   __ASSERT_HERE_IN_FN( NULL != user_prt );
+   __ASSERT_HERE_IN_FN( 0 != size_in_bytes );
+   return NULL;
+#endif
+}
+
+void _kosal_free_user_buffer(__ASSERT_HERE_PROTO btVirtAddr user_prt,  btWSSize size_in_bytes)
+{
+
+#if   defined( __AAL_LINUX__ )
+   vfree(user_prt);
+#elif defined( __AAL_WINDOWS__ )  // TODO
+   UNREFERENCED_PARAMETER( user_prt );
+   UNREFERENCED_PARAMETER( size_in_bytes );
+
+   __ASSERT_HERE_IN_FN( NULL != user_prt );
+   __ASSERT_HERE_IN_FN( 0 != size_in_bytes );
+
+#endif
+}
+
+
+char* kosal_gettimestamp(void) 
+{
+
+#if defined( __AAL_LINUX__ )
+
+   static char timestamp[200];
+   struct rtc_time tm;
+   struct timeval time;
+   unsigned long local_time;
+
+   do_gettimeofday(&time);
+   local_time = (u32)(time.tv_sec - (sys_tz.tz_minuteswest * 60));
+   rtc_time_to_tm(local_time, &tm);
+
+   sprintf(timestamp," Time Stamp: %04d-%02d-%02d %02d:%02d:%02d ",
+                                                                   tm.tm_year + 1900,
+                                                                   tm.tm_mon + 1,
+                                                                   tm.tm_mday,
+                                                                   tm.tm_hour,
+                                                                   tm.tm_min,
+                                                                   tm.tm_sec);
+
+   return timestamp;
+#elif defined( __AAL_WINDOWS__ )
+
+#endif
+}
+
+
+
-- 
2.13.2

